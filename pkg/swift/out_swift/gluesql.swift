// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(gluesqlFFI)
import gluesqlFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_gluesql_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_gluesql_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureGluesqlInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
// Initial value and increment amount for handles. 
// These ensure that SWIFT handles always have the lowest bit set
fileprivate let UNIFFI_HANDLEMAP_INITIAL: UInt64 = 1
fileprivate let UNIFFI_HANDLEMAP_DELTA: UInt64 = 2

fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = UNIFFI_HANDLEMAP_INITIAL

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            return doInsert(obj)
        }
    }

    // Low-level insert function, this assumes `lock` is held.
    private func doInsert(_ obj: T) -> UInt64 {
        let handle = currentHandle
        currentHandle += UNIFFI_HANDLEMAP_DELTA
        map[handle] = obj
        return handle
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

     func clone(handle: UInt64) throws -> UInt64 {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return doInsert(obj)
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt16: FfiConverterPrimitive {
    typealias FfiType = Int16
    typealias SwiftType = Int16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int16, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol GlueProtocol: AnyObject, Sendable {
    
    func getKind() async  -> GlueStorageKind
    
    func query(query: [String]) async throws  -> [Payload]
    
}
open class Glue: GlueProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_gluesql_fn_clone_glue(self.handle, $0) }
    }
public convenience init(kind: GlueStorageKind)async  {
    let handle =
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_gluesql_fn_constructor_glue_new(FfiConverterTypeGlueStorageKind_lower(kind)
                )
            },
            pollFunc: ffi_gluesql_rust_future_poll_u64,
            completeFunc: ffi_gluesql_rust_future_complete_u64,
            freeFunc: ffi_gluesql_rust_future_free_u64,
            liftFunc: FfiConverterTypeGlue_lift,
            errorHandler: nil
            
        )
        
        .uniffiCloneHandle()
    self.init(unsafeFromHandle: handle)
}

    deinit {
        try! rustCall { uniffi_gluesql_fn_free_glue(handle, $0) }
    }

    

    
open func getKind()async  -> GlueStorageKind  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_gluesql_fn_method_glue_get_kind(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_gluesql_rust_future_poll_rust_buffer,
            completeFunc: ffi_gluesql_rust_future_complete_rust_buffer,
            freeFunc: ffi_gluesql_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGlueStorageKind_lift,
            errorHandler: nil
            
        )
}
    
open func query(query: [String])async throws  -> [Payload]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_gluesql_fn_method_glue_query(
                    self.uniffiCloneHandle(),
                    FfiConverterSequenceString.lower(query)
                )
            },
            pollFunc: ffi_gluesql_rust_future_poll_rust_buffer,
            completeFunc: ffi_gluesql_rust_future_complete_rust_buffer,
            freeFunc: ffi_gluesql_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePayload.lift,
            errorHandler: FfiConverterTypeGlueSwiftError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlue: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Glue

    public static func lift(_ handle: UInt64) throws -> Glue {
        return Glue(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Glue) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Glue {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Glue, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlue_lift(_ handle: UInt64) throws -> Glue {
    return try FfiConverterTypeGlue.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlue_lower(_ value: Glue) -> UInt64 {
    return FfiConverterTypeGlue.lower(value)
}




public struct ColumnMeta: Equatable, Hashable {
    public var field: String
    public var dataType: DataType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(field: String, dataType: DataType) {
        self.field = field
        self.dataType = dataType
    }

    
}

#if compiler(>=6)
extension ColumnMeta: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeColumnMeta: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ColumnMeta {
        return
            try ColumnMeta(
                field: FfiConverterString.read(from: &buf), 
                dataType: FfiConverterTypeDataType.read(from: &buf)
        )
    }

    public static func write(_ value: ColumnMeta, into buf: inout [UInt8]) {
        FfiConverterString.write(value.field, into: &buf)
        FfiConverterTypeDataType.write(value.dataType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColumnMeta_lift(_ buf: RustBuffer) throws -> ColumnMeta {
    return try FfiConverterTypeColumnMeta.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColumnMeta_lower(_ value: ColumnMeta) -> RustBuffer {
    return FfiConverterTypeColumnMeta.lower(value)
}


public struct I128: Equatable, Hashable {
    public var high: UInt64
    public var low: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(high: UInt64, low: UInt64) {
        self.high = high
        self.low = low
    }

    
}

#if compiler(>=6)
extension I128: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeI128: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> I128 {
        return
            try I128(
                high: FfiConverterUInt64.read(from: &buf), 
                low: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: I128, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.high, into: &buf)
        FfiConverterUInt64.write(value.low, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeI128_lift(_ buf: RustBuffer) throws -> I128 {
    return try FfiConverterTypeI128.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeI128_lower(_ value: I128) -> RustBuffer {
    return FfiConverterTypeI128.lower(value)
}


public struct Ipv4Addr: Equatable, Hashable {
    public var octets: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(octets: Data) {
        self.octets = octets
    }

    
}

#if compiler(>=6)
extension Ipv4Addr: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIpv4Addr: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ipv4Addr {
        return
            try Ipv4Addr(
                octets: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Ipv4Addr, into buf: inout [UInt8]) {
        FfiConverterData.write(value.octets, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIpv4Addr_lift(_ buf: RustBuffer) throws -> Ipv4Addr {
    return try FfiConverterTypeIpv4Addr.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIpv4Addr_lower(_ value: Ipv4Addr) -> RustBuffer {
    return FfiConverterTypeIpv4Addr.lower(value)
}


public struct Ipv6Addr: Equatable, Hashable {
    public var octets: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(octets: Data) {
        self.octets = octets
    }

    
}

#if compiler(>=6)
extension Ipv6Addr: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIpv6Addr: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ipv6Addr {
        return
            try Ipv6Addr(
                octets: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Ipv6Addr, into buf: inout [UInt8]) {
        FfiConverterData.write(value.octets, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIpv6Addr_lift(_ buf: RustBuffer) throws -> Ipv6Addr {
    return try FfiConverterTypeIpv6Addr.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIpv6Addr_lower(_ value: Ipv6Addr) -> RustBuffer {
    return FfiConverterTypeIpv6Addr.lower(value)
}


public struct Point: Equatable, Hashable {
    public var x: Double
    public var y: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(x: Double, y: Double) {
        self.x = x
        self.y = y
    }

    
}

#if compiler(>=6)
extension Point: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Point {
        return
            try Point(
                x: FfiConverterDouble.read(from: &buf), 
                y: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Point, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.x, into: &buf)
        FfiConverterDouble.write(value.y, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoint_lift(_ buf: RustBuffer) throws -> Point {
    return try FfiConverterTypePoint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoint_lower(_ value: Point) -> RustBuffer {
    return FfiConverterTypePoint.lower(value)
}


public struct U128: Equatable, Hashable {
    public var high: UInt64
    public var low: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(high: UInt64, low: UInt64) {
        self.high = high
        self.low = low
    }

    
}

#if compiler(>=6)
extension U128: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeU128: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U128 {
        return
            try U128(
                high: FfiConverterUInt64.read(from: &buf), 
                low: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: U128, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.high, into: &buf)
        FfiConverterUInt64.write(value.low, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU128_lift(_ buf: RustBuffer) throws -> U128 {
    return try FfiConverterTypeU128.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU128_lower(_ value: U128) -> RustBuffer {
    return FfiConverterTypeU128.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DataType: Equatable, Hashable {
    
    case boolean
    case int8
    case int16
    case int32
    case int
    case int128
    case uint8
    case uint16
    case uint32
    case uint64
    case uint128
    case float32
    case float
    case text
    case bytea
    case inet
    case date
    case timestamp
    case time
    case interval
    case uuid
    case map
    case list
    case decimal
    case point



}

#if compiler(>=6)
extension DataType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDataType: FfiConverterRustBuffer {
    typealias SwiftType = DataType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DataType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .boolean
        
        case 2: return .int8
        
        case 3: return .int16
        
        case 4: return .int32
        
        case 5: return .int
        
        case 6: return .int128
        
        case 7: return .uint8
        
        case 8: return .uint16
        
        case 9: return .uint32
        
        case 10: return .uint64
        
        case 11: return .uint128
        
        case 12: return .float32
        
        case 13: return .float
        
        case 14: return .text
        
        case 15: return .bytea
        
        case 16: return .inet
        
        case 17: return .date
        
        case 18: return .timestamp
        
        case 19: return .time
        
        case 20: return .interval
        
        case 21: return .uuid
        
        case 22: return .map
        
        case 23: return .list
        
        case 24: return .decimal
        
        case 25: return .point
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DataType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .boolean:
            writeInt(&buf, Int32(1))
        
        
        case .int8:
            writeInt(&buf, Int32(2))
        
        
        case .int16:
            writeInt(&buf, Int32(3))
        
        
        case .int32:
            writeInt(&buf, Int32(4))
        
        
        case .int:
            writeInt(&buf, Int32(5))
        
        
        case .int128:
            writeInt(&buf, Int32(6))
        
        
        case .uint8:
            writeInt(&buf, Int32(7))
        
        
        case .uint16:
            writeInt(&buf, Int32(8))
        
        
        case .uint32:
            writeInt(&buf, Int32(9))
        
        
        case .uint64:
            writeInt(&buf, Int32(10))
        
        
        case .uint128:
            writeInt(&buf, Int32(11))
        
        
        case .float32:
            writeInt(&buf, Int32(12))
        
        
        case .float:
            writeInt(&buf, Int32(13))
        
        
        case .text:
            writeInt(&buf, Int32(14))
        
        
        case .bytea:
            writeInt(&buf, Int32(15))
        
        
        case .inet:
            writeInt(&buf, Int32(16))
        
        
        case .date:
            writeInt(&buf, Int32(17))
        
        
        case .timestamp:
            writeInt(&buf, Int32(18))
        
        
        case .time:
            writeInt(&buf, Int32(19))
        
        
        case .interval:
            writeInt(&buf, Int32(20))
        
        
        case .uuid:
            writeInt(&buf, Int32(21))
        
        
        case .map:
            writeInt(&buf, Int32(22))
        
        
        case .list:
            writeInt(&buf, Int32(23))
        
        
        case .decimal:
            writeInt(&buf, Int32(24))
        
        
        case .point:
            writeInt(&buf, Int32(25))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataType_lift(_ buf: RustBuffer) throws -> DataType {
    return try FfiConverterTypeDataType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataType_lower(_ value: DataType) -> RustBuffer {
    return FfiConverterTypeDataType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GlueStorageKind: Equatable, Hashable {
    
    case memoryStorage
    case sharedMemoryStorage



}

#if compiler(>=6)
extension GlueStorageKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlueStorageKind: FfiConverterRustBuffer {
    typealias SwiftType = GlueStorageKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlueStorageKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .memoryStorage
        
        case 2: return .sharedMemoryStorage
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlueStorageKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .memoryStorage:
            writeInt(&buf, Int32(1))
        
        
        case .sharedMemoryStorage:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlueStorageKind_lift(_ buf: RustBuffer) throws -> GlueStorageKind {
    return try FfiConverterTypeGlueStorageKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlueStorageKind_lower(_ value: GlueStorageKind) -> RustBuffer {
    return FfiConverterTypeGlueStorageKind.lower(value)
}



public enum GlueSwiftError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Execute(message: String
    )

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension GlueSwiftError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlueSwiftError: FfiConverterRustBuffer {
    typealias SwiftType = GlueSwiftError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlueSwiftError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Execute(
            message: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlueSwiftError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Execute(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlueSwiftError_lift(_ buf: RustBuffer) throws -> GlueSwiftError {
    return try FfiConverterTypeGlueSwiftError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlueSwiftError_lower(_ value: GlueSwiftError) -> RustBuffer {
    return FfiConverterTypeGlueSwiftError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Interval: Equatable, Hashable {
    
    case month(Int32
    )
    case microsecond(Int64
    )



}

#if compiler(>=6)
extension Interval: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInterval: FfiConverterRustBuffer {
    typealias SwiftType = Interval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Interval {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .month(try FfiConverterInt32.read(from: &buf)
        )
        
        case 2: return .microsecond(try FfiConverterInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Interval, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .month(v1):
            writeInt(&buf, Int32(1))
            FfiConverterInt32.write(v1, into: &buf)
            
        
        case let .microsecond(v1):
            writeInt(&buf, Int32(2))
            FfiConverterInt64.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInterval_lift(_ buf: RustBuffer) throws -> Interval {
    return try FfiConverterTypeInterval.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInterval_lower(_ value: Interval) -> RustBuffer {
    return FfiConverterTypeInterval.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum IpAddr: Equatable, Hashable {
    
    case v4(Ipv4Addr
    )
    case v6(Ipv6Addr
    )



}

#if compiler(>=6)
extension IpAddr: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIpAddr: FfiConverterRustBuffer {
    typealias SwiftType = IpAddr

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IpAddr {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v4(try FfiConverterTypeIpv4Addr.read(from: &buf)
        )
        
        case 2: return .v6(try FfiConverterTypeIpv6Addr.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: IpAddr, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .v4(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeIpv4Addr.write(v1, into: &buf)
            
        
        case let .v6(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeIpv6Addr.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIpAddr_lift(_ buf: RustBuffer) throws -> IpAddr {
    return try FfiConverterTypeIpAddr.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIpAddr_lower(_ value: IpAddr) -> RustBuffer {
    return FfiConverterTypeIpAddr.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Payload: Equatable, Hashable {
    
    case showColumns([ColumnMeta]
    )
    case create
    case insert(UInt64
    )
    case select(labels: [String], rows: [[Value]]
    )
    case selectMap([[String: Value]]
    )
    case delete(UInt64
    )
    case update(UInt64
    )
    case dropTable(UInt64
    )
    case dropFunction
    case alterTable
    case createIndex
    case dropIndex
    case startTransaction
    case commit
    case rollback
    case showVariable(PayloadVariable
    )



}

#if compiler(>=6)
extension Payload: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayload: FfiConverterRustBuffer {
    typealias SwiftType = Payload

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Payload {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .showColumns(try FfiConverterSequenceTypeColumnMeta.read(from: &buf)
        )
        
        case 2: return .create
        
        case 3: return .insert(try FfiConverterUInt64.read(from: &buf)
        )
        
        case 4: return .select(labels: try FfiConverterSequenceString.read(from: &buf), rows: try FfiConverterSequenceSequenceTypeValue.read(from: &buf)
        )
        
        case 5: return .selectMap(try FfiConverterSequenceDictionaryStringTypeValue.read(from: &buf)
        )
        
        case 6: return .delete(try FfiConverterUInt64.read(from: &buf)
        )
        
        case 7: return .update(try FfiConverterUInt64.read(from: &buf)
        )
        
        case 8: return .dropTable(try FfiConverterUInt64.read(from: &buf)
        )
        
        case 9: return .dropFunction
        
        case 10: return .alterTable
        
        case 11: return .createIndex
        
        case 12: return .dropIndex
        
        case 13: return .startTransaction
        
        case 14: return .commit
        
        case 15: return .rollback
        
        case 16: return .showVariable(try FfiConverterTypePayloadVariable.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Payload, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .showColumns(v1):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeColumnMeta.write(v1, into: &buf)
            
        
        case .create:
            writeInt(&buf, Int32(2))
        
        
        case let .insert(v1):
            writeInt(&buf, Int32(3))
            FfiConverterUInt64.write(v1, into: &buf)
            
        
        case let .select(labels,rows):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceString.write(labels, into: &buf)
            FfiConverterSequenceSequenceTypeValue.write(rows, into: &buf)
            
        
        case let .selectMap(v1):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceDictionaryStringTypeValue.write(v1, into: &buf)
            
        
        case let .delete(v1):
            writeInt(&buf, Int32(6))
            FfiConverterUInt64.write(v1, into: &buf)
            
        
        case let .update(v1):
            writeInt(&buf, Int32(7))
            FfiConverterUInt64.write(v1, into: &buf)
            
        
        case let .dropTable(v1):
            writeInt(&buf, Int32(8))
            FfiConverterUInt64.write(v1, into: &buf)
            
        
        case .dropFunction:
            writeInt(&buf, Int32(9))
        
        
        case .alterTable:
            writeInt(&buf, Int32(10))
        
        
        case .createIndex:
            writeInt(&buf, Int32(11))
        
        
        case .dropIndex:
            writeInt(&buf, Int32(12))
        
        
        case .startTransaction:
            writeInt(&buf, Int32(13))
        
        
        case .commit:
            writeInt(&buf, Int32(14))
        
        
        case .rollback:
            writeInt(&buf, Int32(15))
        
        
        case let .showVariable(v1):
            writeInt(&buf, Int32(16))
            FfiConverterTypePayloadVariable.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayload_lift(_ buf: RustBuffer) throws -> Payload {
    return try FfiConverterTypePayload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayload_lower(_ value: Payload) -> RustBuffer {
    return FfiConverterTypePayload.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PayloadVariable: Equatable, Hashable {
    
    case tables([String]
    )
    case functions([String]
    )
    case version(String
    )



}

#if compiler(>=6)
extension PayloadVariable: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayloadVariable: FfiConverterRustBuffer {
    typealias SwiftType = PayloadVariable

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayloadVariable {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .tables(try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 2: return .functions(try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 3: return .version(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PayloadVariable, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .tables(v1):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceString.write(v1, into: &buf)
            
        
        case let .functions(v1):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceString.write(v1, into: &buf)
            
        
        case let .version(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayloadVariable_lift(_ buf: RustBuffer) throws -> PayloadVariable {
    return try FfiConverterTypePayloadVariable.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayloadVariable_lower(_ value: PayloadVariable) -> RustBuffer {
    return FfiConverterTypePayloadVariable.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Value: Equatable, Hashable {
    
    case bool(Bool
    )
    case i8(Int8
    )
    case i16(Int16
    )
    case i32(Int32
    )
    case i64(Int64
    )
    case i128(String
    )
    case u8(UInt8
    )
    case u16(UInt16
    )
    case u32(UInt32
    )
    case u64(UInt64
    )
    case u128(String
    )
    case f32(Float
    )
    case f64(Double
    )
    case decimal(String
    )
    case str(String
    )
    case bytea(Data
    )
    case inet(IpAddr
    )
    case date(String
    )
    case timestamp(String
    )
    case time(String
    )
    case interval(Interval
    )
    case uuid(String
    )
    case map([String: Value]
    )
    case list([Value]
    )
    case point(Point
    )
    case null



}

#if compiler(>=6)
extension Value: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeValue: FfiConverterRustBuffer {
    typealias SwiftType = Value

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Value {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bool(try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .i8(try FfiConverterInt8.read(from: &buf)
        )
        
        case 3: return .i16(try FfiConverterInt16.read(from: &buf)
        )
        
        case 4: return .i32(try FfiConverterInt32.read(from: &buf)
        )
        
        case 5: return .i64(try FfiConverterInt64.read(from: &buf)
        )
        
        case 6: return .i128(try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .u8(try FfiConverterUInt8.read(from: &buf)
        )
        
        case 8: return .u16(try FfiConverterUInt16.read(from: &buf)
        )
        
        case 9: return .u32(try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .u64(try FfiConverterUInt64.read(from: &buf)
        )
        
        case 11: return .u128(try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .f32(try FfiConverterFloat.read(from: &buf)
        )
        
        case 13: return .f64(try FfiConverterDouble.read(from: &buf)
        )
        
        case 14: return .decimal(try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .str(try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .bytea(try FfiConverterData.read(from: &buf)
        )
        
        case 17: return .inet(try FfiConverterTypeIpAddr.read(from: &buf)
        )
        
        case 18: return .date(try FfiConverterString.read(from: &buf)
        )
        
        case 19: return .timestamp(try FfiConverterString.read(from: &buf)
        )
        
        case 20: return .time(try FfiConverterString.read(from: &buf)
        )
        
        case 21: return .interval(try FfiConverterTypeInterval.read(from: &buf)
        )
        
        case 22: return .uuid(try FfiConverterString.read(from: &buf)
        )
        
        case 23: return .map(try FfiConverterDictionaryStringTypeValue.read(from: &buf)
        )
        
        case 24: return .list(try FfiConverterSequenceTypeValue.read(from: &buf)
        )
        
        case 25: return .point(try FfiConverterTypePoint.read(from: &buf)
        )
        
        case 26: return .null
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Value, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bool(v1):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(v1, into: &buf)
            
        
        case let .i8(v1):
            writeInt(&buf, Int32(2))
            FfiConverterInt8.write(v1, into: &buf)
            
        
        case let .i16(v1):
            writeInt(&buf, Int32(3))
            FfiConverterInt16.write(v1, into: &buf)
            
        
        case let .i32(v1):
            writeInt(&buf, Int32(4))
            FfiConverterInt32.write(v1, into: &buf)
            
        
        case let .i64(v1):
            writeInt(&buf, Int32(5))
            FfiConverterInt64.write(v1, into: &buf)
            
        
        case let .i128(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .u8(v1):
            writeInt(&buf, Int32(7))
            FfiConverterUInt8.write(v1, into: &buf)
            
        
        case let .u16(v1):
            writeInt(&buf, Int32(8))
            FfiConverterUInt16.write(v1, into: &buf)
            
        
        case let .u32(v1):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(v1, into: &buf)
            
        
        case let .u64(v1):
            writeInt(&buf, Int32(10))
            FfiConverterUInt64.write(v1, into: &buf)
            
        
        case let .u128(v1):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .f32(v1):
            writeInt(&buf, Int32(12))
            FfiConverterFloat.write(v1, into: &buf)
            
        
        case let .f64(v1):
            writeInt(&buf, Int32(13))
            FfiConverterDouble.write(v1, into: &buf)
            
        
        case let .decimal(v1):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .str(v1):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .bytea(v1):
            writeInt(&buf, Int32(16))
            FfiConverterData.write(v1, into: &buf)
            
        
        case let .inet(v1):
            writeInt(&buf, Int32(17))
            FfiConverterTypeIpAddr.write(v1, into: &buf)
            
        
        case let .date(v1):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .timestamp(v1):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .time(v1):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .interval(v1):
            writeInt(&buf, Int32(21))
            FfiConverterTypeInterval.write(v1, into: &buf)
            
        
        case let .uuid(v1):
            writeInt(&buf, Int32(22))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .map(v1):
            writeInt(&buf, Int32(23))
            FfiConverterDictionaryStringTypeValue.write(v1, into: &buf)
            
        
        case let .list(v1):
            writeInt(&buf, Int32(24))
            FfiConverterSequenceTypeValue.write(v1, into: &buf)
            
        
        case let .point(v1):
            writeInt(&buf, Int32(25))
            FfiConverterTypePoint.write(v1, into: &buf)
            
        
        case .null:
            writeInt(&buf, Int32(26))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValue_lift(_ buf: RustBuffer) throws -> Value {
    return try FfiConverterTypeValue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValue_lower(_ value: Value) -> RustBuffer {
    return FfiConverterTypeValue.lower(value)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeColumnMeta: FfiConverterRustBuffer {
    typealias SwiftType = [ColumnMeta]

    public static func write(_ value: [ColumnMeta], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeColumnMeta.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ColumnMeta] {
        let len: Int32 = try readInt(&buf)
        var seq = [ColumnMeta]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeColumnMeta.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePayload: FfiConverterRustBuffer {
    typealias SwiftType = [Payload]

    public static func write(_ value: [Payload], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayload.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Payload] {
        let len: Int32 = try readInt(&buf)
        var seq = [Payload]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayload.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeValue: FfiConverterRustBuffer {
    typealias SwiftType = [Value]

    public static func write(_ value: [Value], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Value] {
        let len: Int32 = try readInt(&buf)
        var seq = [Value]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeValue.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceTypeValue: FfiConverterRustBuffer {
    typealias SwiftType = [[Value]]

    public static func write(_ value: [[Value]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceTypeValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[Value]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[Value]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceTypeValue.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceDictionaryStringTypeValue: FfiConverterRustBuffer {
    typealias SwiftType = [[String: Value]]

    public static func write(_ value: [[String: Value]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterDictionaryStringTypeValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[String: Value]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[String: Value]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterDictionaryStringTypeValue.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: Value], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Value] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Value]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_WAKE: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureGluesqlInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                { handle, pollResult in
                    uniffiFutureContinuationCallback(handle: handle, pollResult: pollResult)
                },
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 30
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_gluesql_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_gluesql_checksum_method_glue_get_kind() != 20428) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gluesql_checksum_method_glue_query() != 797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gluesql_checksum_constructor_glue_new() != 47655) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureGluesqlInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all