// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'key.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Key {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KeyCopyWith<$Res> {
  factory $KeyCopyWith(Key value, $Res Function(Key) then) =
      _$KeyCopyWithImpl<$Res, Key>;
}

/// @nodoc
class _$KeyCopyWithImpl<$Res, $Val extends Key> implements $KeyCopyWith<$Res> {
  _$KeyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Key_I8ImplCopyWith<$Res> {
  factory _$$Key_I8ImplCopyWith(
          _$Key_I8Impl value, $Res Function(_$Key_I8Impl) then) =
      __$$Key_I8ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Key_I8ImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_I8Impl>
    implements _$$Key_I8ImplCopyWith<$Res> {
  __$$Key_I8ImplCopyWithImpl(
      _$Key_I8Impl _value, $Res Function(_$Key_I8Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_I8Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Key_I8Impl extends Key_I8 {
  const _$Key_I8Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Key.i8(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_I8Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_I8ImplCopyWith<_$Key_I8Impl> get copyWith =>
      __$$Key_I8ImplCopyWithImpl<_$Key_I8Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return i8(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return i8?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (i8 != null) {
      return i8(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return i8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return i8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (i8 != null) {
      return i8(this);
    }
    return orElse();
  }
}

abstract class Key_I8 extends Key {
  const factory Key_I8(final int field0) = _$Key_I8Impl;
  const Key_I8._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$Key_I8ImplCopyWith<_$Key_I8Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_I16ImplCopyWith<$Res> {
  factory _$$Key_I16ImplCopyWith(
          _$Key_I16Impl value, $Res Function(_$Key_I16Impl) then) =
      __$$Key_I16ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Key_I16ImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_I16Impl>
    implements _$$Key_I16ImplCopyWith<$Res> {
  __$$Key_I16ImplCopyWithImpl(
      _$Key_I16Impl _value, $Res Function(_$Key_I16Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_I16Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Key_I16Impl extends Key_I16 {
  const _$Key_I16Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Key.i16(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_I16Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_I16ImplCopyWith<_$Key_I16Impl> get copyWith =>
      __$$Key_I16ImplCopyWithImpl<_$Key_I16Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return i16(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return i16?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (i16 != null) {
      return i16(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return i16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return i16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (i16 != null) {
      return i16(this);
    }
    return orElse();
  }
}

abstract class Key_I16 extends Key {
  const factory Key_I16(final int field0) = _$Key_I16Impl;
  const Key_I16._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$Key_I16ImplCopyWith<_$Key_I16Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_I32ImplCopyWith<$Res> {
  factory _$$Key_I32ImplCopyWith(
          _$Key_I32Impl value, $Res Function(_$Key_I32Impl) then) =
      __$$Key_I32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Key_I32ImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_I32Impl>
    implements _$$Key_I32ImplCopyWith<$Res> {
  __$$Key_I32ImplCopyWithImpl(
      _$Key_I32Impl _value, $Res Function(_$Key_I32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_I32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Key_I32Impl extends Key_I32 {
  const _$Key_I32Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Key.i32(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_I32Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_I32ImplCopyWith<_$Key_I32Impl> get copyWith =>
      __$$Key_I32ImplCopyWithImpl<_$Key_I32Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return i32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return i32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (i32 != null) {
      return i32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return i32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return i32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (i32 != null) {
      return i32(this);
    }
    return orElse();
  }
}

abstract class Key_I32 extends Key {
  const factory Key_I32(final int field0) = _$Key_I32Impl;
  const Key_I32._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$Key_I32ImplCopyWith<_$Key_I32Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_I64ImplCopyWith<$Res> {
  factory _$$Key_I64ImplCopyWith(
          _$Key_I64Impl value, $Res Function(_$Key_I64Impl) then) =
      __$$Key_I64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Key_I64ImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_I64Impl>
    implements _$$Key_I64ImplCopyWith<$Res> {
  __$$Key_I64ImplCopyWithImpl(
      _$Key_I64Impl _value, $Res Function(_$Key_I64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_I64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Key_I64Impl extends Key_I64 {
  const _$Key_I64Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Key.i64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_I64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_I64ImplCopyWith<_$Key_I64Impl> get copyWith =>
      __$$Key_I64ImplCopyWithImpl<_$Key_I64Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return i64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return i64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (i64 != null) {
      return i64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return i64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return i64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (i64 != null) {
      return i64(this);
    }
    return orElse();
  }
}

abstract class Key_I64 extends Key {
  const factory Key_I64(final int field0) = _$Key_I64Impl;
  const Key_I64._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$Key_I64ImplCopyWith<_$Key_I64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_I128ImplCopyWith<$Res> {
  factory _$$Key_I128ImplCopyWith(
          _$Key_I128Impl value, $Res Function(_$Key_I128Impl) then) =
      __$$Key_I128ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt field0});
}

/// @nodoc
class __$$Key_I128ImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_I128Impl>
    implements _$$Key_I128ImplCopyWith<$Res> {
  __$$Key_I128ImplCopyWithImpl(
      _$Key_I128Impl _value, $Res Function(_$Key_I128Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_I128Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$Key_I128Impl extends Key_I128 {
  const _$Key_I128Impl(this.field0) : super._();

  @override
  final BigInt field0;

  @override
  String toString() {
    return 'Key.i128(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_I128Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_I128ImplCopyWith<_$Key_I128Impl> get copyWith =>
      __$$Key_I128ImplCopyWithImpl<_$Key_I128Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return i128(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return i128?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (i128 != null) {
      return i128(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return i128(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return i128?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (i128 != null) {
      return i128(this);
    }
    return orElse();
  }
}

abstract class Key_I128 extends Key {
  const factory Key_I128(final BigInt field0) = _$Key_I128Impl;
  const Key_I128._() : super._();

  BigInt get field0;
  @JsonKey(ignore: true)
  _$$Key_I128ImplCopyWith<_$Key_I128Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_U8ImplCopyWith<$Res> {
  factory _$$Key_U8ImplCopyWith(
          _$Key_U8Impl value, $Res Function(_$Key_U8Impl) then) =
      __$$Key_U8ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Key_U8ImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_U8Impl>
    implements _$$Key_U8ImplCopyWith<$Res> {
  __$$Key_U8ImplCopyWithImpl(
      _$Key_U8Impl _value, $Res Function(_$Key_U8Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_U8Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Key_U8Impl extends Key_U8 {
  const _$Key_U8Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Key.u8(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_U8Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_U8ImplCopyWith<_$Key_U8Impl> get copyWith =>
      __$$Key_U8ImplCopyWithImpl<_$Key_U8Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return u8(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return u8?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (u8 != null) {
      return u8(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return u8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return u8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (u8 != null) {
      return u8(this);
    }
    return orElse();
  }
}

abstract class Key_U8 extends Key {
  const factory Key_U8(final int field0) = _$Key_U8Impl;
  const Key_U8._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$Key_U8ImplCopyWith<_$Key_U8Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_U16ImplCopyWith<$Res> {
  factory _$$Key_U16ImplCopyWith(
          _$Key_U16Impl value, $Res Function(_$Key_U16Impl) then) =
      __$$Key_U16ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Key_U16ImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_U16Impl>
    implements _$$Key_U16ImplCopyWith<$Res> {
  __$$Key_U16ImplCopyWithImpl(
      _$Key_U16Impl _value, $Res Function(_$Key_U16Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_U16Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Key_U16Impl extends Key_U16 {
  const _$Key_U16Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Key.u16(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_U16Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_U16ImplCopyWith<_$Key_U16Impl> get copyWith =>
      __$$Key_U16ImplCopyWithImpl<_$Key_U16Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return u16(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return u16?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (u16 != null) {
      return u16(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return u16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return u16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (u16 != null) {
      return u16(this);
    }
    return orElse();
  }
}

abstract class Key_U16 extends Key {
  const factory Key_U16(final int field0) = _$Key_U16Impl;
  const Key_U16._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$Key_U16ImplCopyWith<_$Key_U16Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_U32ImplCopyWith<$Res> {
  factory _$$Key_U32ImplCopyWith(
          _$Key_U32Impl value, $Res Function(_$Key_U32Impl) then) =
      __$$Key_U32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Key_U32ImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_U32Impl>
    implements _$$Key_U32ImplCopyWith<$Res> {
  __$$Key_U32ImplCopyWithImpl(
      _$Key_U32Impl _value, $Res Function(_$Key_U32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_U32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Key_U32Impl extends Key_U32 {
  const _$Key_U32Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Key.u32(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_U32Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_U32ImplCopyWith<_$Key_U32Impl> get copyWith =>
      __$$Key_U32ImplCopyWithImpl<_$Key_U32Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return u32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return u32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (u32 != null) {
      return u32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return u32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return u32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (u32 != null) {
      return u32(this);
    }
    return orElse();
  }
}

abstract class Key_U32 extends Key {
  const factory Key_U32(final int field0) = _$Key_U32Impl;
  const Key_U32._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$Key_U32ImplCopyWith<_$Key_U32Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_U64ImplCopyWith<$Res> {
  factory _$$Key_U64ImplCopyWith(
          _$Key_U64Impl value, $Res Function(_$Key_U64Impl) then) =
      __$$Key_U64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt field0});
}

/// @nodoc
class __$$Key_U64ImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_U64Impl>
    implements _$$Key_U64ImplCopyWith<$Res> {
  __$$Key_U64ImplCopyWithImpl(
      _$Key_U64Impl _value, $Res Function(_$Key_U64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_U64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$Key_U64Impl extends Key_U64 {
  const _$Key_U64Impl(this.field0) : super._();

  @override
  final BigInt field0;

  @override
  String toString() {
    return 'Key.u64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_U64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_U64ImplCopyWith<_$Key_U64Impl> get copyWith =>
      __$$Key_U64ImplCopyWithImpl<_$Key_U64Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return u64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return u64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (u64 != null) {
      return u64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return u64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return u64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (u64 != null) {
      return u64(this);
    }
    return orElse();
  }
}

abstract class Key_U64 extends Key {
  const factory Key_U64(final BigInt field0) = _$Key_U64Impl;
  const Key_U64._() : super._();

  BigInt get field0;
  @JsonKey(ignore: true)
  _$$Key_U64ImplCopyWith<_$Key_U64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_U128ImplCopyWith<$Res> {
  factory _$$Key_U128ImplCopyWith(
          _$Key_U128Impl value, $Res Function(_$Key_U128Impl) then) =
      __$$Key_U128ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt field0});
}

/// @nodoc
class __$$Key_U128ImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_U128Impl>
    implements _$$Key_U128ImplCopyWith<$Res> {
  __$$Key_U128ImplCopyWithImpl(
      _$Key_U128Impl _value, $Res Function(_$Key_U128Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_U128Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$Key_U128Impl extends Key_U128 {
  const _$Key_U128Impl(this.field0) : super._();

  @override
  final BigInt field0;

  @override
  String toString() {
    return 'Key.u128(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_U128Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_U128ImplCopyWith<_$Key_U128Impl> get copyWith =>
      __$$Key_U128ImplCopyWithImpl<_$Key_U128Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return u128(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return u128?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (u128 != null) {
      return u128(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return u128(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return u128?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (u128 != null) {
      return u128(this);
    }
    return orElse();
  }
}

abstract class Key_U128 extends Key {
  const factory Key_U128(final BigInt field0) = _$Key_U128Impl;
  const Key_U128._() : super._();

  BigInt get field0;
  @JsonKey(ignore: true)
  _$$Key_U128ImplCopyWith<_$Key_U128Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_F32ImplCopyWith<$Res> {
  factory _$$Key_F32ImplCopyWith(
          _$Key_F32Impl value, $Res Function(_$Key_F32Impl) then) =
      __$$Key_F32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({OrderedFloatF32 field0});
}

/// @nodoc
class __$$Key_F32ImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_F32Impl>
    implements _$$Key_F32ImplCopyWith<$Res> {
  __$$Key_F32ImplCopyWithImpl(
      _$Key_F32Impl _value, $Res Function(_$Key_F32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_F32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as OrderedFloatF32,
    ));
  }
}

/// @nodoc

class _$Key_F32Impl extends Key_F32 {
  const _$Key_F32Impl(this.field0) : super._();

  @override
  final OrderedFloatF32 field0;

  @override
  String toString() {
    return 'Key.f32(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_F32Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_F32ImplCopyWith<_$Key_F32Impl> get copyWith =>
      __$$Key_F32ImplCopyWithImpl<_$Key_F32Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return f32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return f32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (f32 != null) {
      return f32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return f32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return f32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (f32 != null) {
      return f32(this);
    }
    return orElse();
  }
}

abstract class Key_F32 extends Key {
  const factory Key_F32(final OrderedFloatF32 field0) = _$Key_F32Impl;
  const Key_F32._() : super._();

  OrderedFloatF32 get field0;
  @JsonKey(ignore: true)
  _$$Key_F32ImplCopyWith<_$Key_F32Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_F64ImplCopyWith<$Res> {
  factory _$$Key_F64ImplCopyWith(
          _$Key_F64Impl value, $Res Function(_$Key_F64Impl) then) =
      __$$Key_F64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({OrderedFloatF64 field0});
}

/// @nodoc
class __$$Key_F64ImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_F64Impl>
    implements _$$Key_F64ImplCopyWith<$Res> {
  __$$Key_F64ImplCopyWithImpl(
      _$Key_F64Impl _value, $Res Function(_$Key_F64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_F64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as OrderedFloatF64,
    ));
  }
}

/// @nodoc

class _$Key_F64Impl extends Key_F64 {
  const _$Key_F64Impl(this.field0) : super._();

  @override
  final OrderedFloatF64 field0;

  @override
  String toString() {
    return 'Key.f64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_F64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_F64ImplCopyWith<_$Key_F64Impl> get copyWith =>
      __$$Key_F64ImplCopyWithImpl<_$Key_F64Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return f64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return f64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (f64 != null) {
      return f64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return f64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return f64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (f64 != null) {
      return f64(this);
    }
    return orElse();
  }
}

abstract class Key_F64 extends Key {
  const factory Key_F64(final OrderedFloatF64 field0) = _$Key_F64Impl;
  const Key_F64._() : super._();

  OrderedFloatF64 get field0;
  @JsonKey(ignore: true)
  _$$Key_F64ImplCopyWith<_$Key_F64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_DecimalImplCopyWith<$Res> {
  factory _$$Key_DecimalImplCopyWith(
          _$Key_DecimalImpl value, $Res Function(_$Key_DecimalImpl) then) =
      __$$Key_DecimalImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Decimal field0});
}

/// @nodoc
class __$$Key_DecimalImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_DecimalImpl>
    implements _$$Key_DecimalImplCopyWith<$Res> {
  __$$Key_DecimalImplCopyWithImpl(
      _$Key_DecimalImpl _value, $Res Function(_$Key_DecimalImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_DecimalImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Decimal,
    ));
  }
}

/// @nodoc

class _$Key_DecimalImpl extends Key_Decimal {
  const _$Key_DecimalImpl(this.field0) : super._();

  @override
  final Decimal field0;

  @override
  String toString() {
    return 'Key.decimal(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_DecimalImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_DecimalImplCopyWith<_$Key_DecimalImpl> get copyWith =>
      __$$Key_DecimalImplCopyWithImpl<_$Key_DecimalImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return decimal(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return decimal?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (decimal != null) {
      return decimal(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return decimal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return decimal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (decimal != null) {
      return decimal(this);
    }
    return orElse();
  }
}

abstract class Key_Decimal extends Key {
  const factory Key_Decimal(final Decimal field0) = _$Key_DecimalImpl;
  const Key_Decimal._() : super._();

  Decimal get field0;
  @JsonKey(ignore: true)
  _$$Key_DecimalImplCopyWith<_$Key_DecimalImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_BoolImplCopyWith<$Res> {
  factory _$$Key_BoolImplCopyWith(
          _$Key_BoolImpl value, $Res Function(_$Key_BoolImpl) then) =
      __$$Key_BoolImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool field0});
}

/// @nodoc
class __$$Key_BoolImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_BoolImpl>
    implements _$$Key_BoolImplCopyWith<$Res> {
  __$$Key_BoolImplCopyWithImpl(
      _$Key_BoolImpl _value, $Res Function(_$Key_BoolImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_BoolImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$Key_BoolImpl extends Key_Bool {
  const _$Key_BoolImpl(this.field0) : super._();

  @override
  final bool field0;

  @override
  String toString() {
    return 'Key.bool(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_BoolImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_BoolImplCopyWith<_$Key_BoolImpl> get copyWith =>
      __$$Key_BoolImplCopyWithImpl<_$Key_BoolImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return bool(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return bool?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (bool != null) {
      return bool(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return bool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return bool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (bool != null) {
      return bool(this);
    }
    return orElse();
  }
}

abstract class Key_Bool extends Key {
  const factory Key_Bool(final bool field0) = _$Key_BoolImpl;
  const Key_Bool._() : super._();

  bool get field0;
  @JsonKey(ignore: true)
  _$$Key_BoolImplCopyWith<_$Key_BoolImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_StrImplCopyWith<$Res> {
  factory _$$Key_StrImplCopyWith(
          _$Key_StrImpl value, $Res Function(_$Key_StrImpl) then) =
      __$$Key_StrImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$Key_StrImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_StrImpl>
    implements _$$Key_StrImplCopyWith<$Res> {
  __$$Key_StrImplCopyWithImpl(
      _$Key_StrImpl _value, $Res Function(_$Key_StrImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_StrImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Key_StrImpl extends Key_Str {
  const _$Key_StrImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'Key.str(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_StrImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_StrImplCopyWith<_$Key_StrImpl> get copyWith =>
      __$$Key_StrImplCopyWithImpl<_$Key_StrImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return str(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return str?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (str != null) {
      return str(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return str(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return str?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (str != null) {
      return str(this);
    }
    return orElse();
  }
}

abstract class Key_Str extends Key {
  const factory Key_Str(final String field0) = _$Key_StrImpl;
  const Key_Str._() : super._();

  String get field0;
  @JsonKey(ignore: true)
  _$$Key_StrImplCopyWith<_$Key_StrImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_ByteaImplCopyWith<$Res> {
  factory _$$Key_ByteaImplCopyWith(
          _$Key_ByteaImpl value, $Res Function(_$Key_ByteaImpl) then) =
      __$$Key_ByteaImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class __$$Key_ByteaImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_ByteaImpl>
    implements _$$Key_ByteaImplCopyWith<$Res> {
  __$$Key_ByteaImplCopyWithImpl(
      _$Key_ByteaImpl _value, $Res Function(_$Key_ByteaImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_ByteaImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$Key_ByteaImpl extends Key_Bytea {
  const _$Key_ByteaImpl(this.field0) : super._();

  @override
  final Uint8List field0;

  @override
  String toString() {
    return 'Key.bytea(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_ByteaImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_ByteaImplCopyWith<_$Key_ByteaImpl> get copyWith =>
      __$$Key_ByteaImplCopyWithImpl<_$Key_ByteaImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return bytea(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return bytea?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (bytea != null) {
      return bytea(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return bytea(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return bytea?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (bytea != null) {
      return bytea(this);
    }
    return orElse();
  }
}

abstract class Key_Bytea extends Key {
  const factory Key_Bytea(final Uint8List field0) = _$Key_ByteaImpl;
  const Key_Bytea._() : super._();

  Uint8List get field0;
  @JsonKey(ignore: true)
  _$$Key_ByteaImplCopyWith<_$Key_ByteaImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_DateImplCopyWith<$Res> {
  factory _$$Key_DateImplCopyWith(
          _$Key_DateImpl value, $Res Function(_$Key_DateImpl) then) =
      __$$Key_DateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({NaiveDate field0});
}

/// @nodoc
class __$$Key_DateImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_DateImpl>
    implements _$$Key_DateImplCopyWith<$Res> {
  __$$Key_DateImplCopyWithImpl(
      _$Key_DateImpl _value, $Res Function(_$Key_DateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_DateImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as NaiveDate,
    ));
  }
}

/// @nodoc

class _$Key_DateImpl extends Key_Date {
  const _$Key_DateImpl(this.field0) : super._();

  @override
  final NaiveDate field0;

  @override
  String toString() {
    return 'Key.date(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_DateImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_DateImplCopyWith<_$Key_DateImpl> get copyWith =>
      __$$Key_DateImplCopyWithImpl<_$Key_DateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return date(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return date?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (date != null) {
      return date(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return date(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return date?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (date != null) {
      return date(this);
    }
    return orElse();
  }
}

abstract class Key_Date extends Key {
  const factory Key_Date(final NaiveDate field0) = _$Key_DateImpl;
  const Key_Date._() : super._();

  NaiveDate get field0;
  @JsonKey(ignore: true)
  _$$Key_DateImplCopyWith<_$Key_DateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_TimestampImplCopyWith<$Res> {
  factory _$$Key_TimestampImplCopyWith(
          _$Key_TimestampImpl value, $Res Function(_$Key_TimestampImpl) then) =
      __$$Key_TimestampImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTime field0});
}

/// @nodoc
class __$$Key_TimestampImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_TimestampImpl>
    implements _$$Key_TimestampImplCopyWith<$Res> {
  __$$Key_TimestampImplCopyWithImpl(
      _$Key_TimestampImpl _value, $Res Function(_$Key_TimestampImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_TimestampImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$Key_TimestampImpl extends Key_Timestamp {
  const _$Key_TimestampImpl(this.field0) : super._();

  @override
  final DateTime field0;

  @override
  String toString() {
    return 'Key.timestamp(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_TimestampImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_TimestampImplCopyWith<_$Key_TimestampImpl> get copyWith =>
      __$$Key_TimestampImplCopyWithImpl<_$Key_TimestampImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return timestamp(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return timestamp?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (timestamp != null) {
      return timestamp(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return timestamp(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return timestamp?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (timestamp != null) {
      return timestamp(this);
    }
    return orElse();
  }
}

abstract class Key_Timestamp extends Key {
  const factory Key_Timestamp(final DateTime field0) = _$Key_TimestampImpl;
  const Key_Timestamp._() : super._();

  DateTime get field0;
  @JsonKey(ignore: true)
  _$$Key_TimestampImplCopyWith<_$Key_TimestampImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_TimeImplCopyWith<$Res> {
  factory _$$Key_TimeImplCopyWith(
          _$Key_TimeImpl value, $Res Function(_$Key_TimeImpl) then) =
      __$$Key_TimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({NaiveTime field0});
}

/// @nodoc
class __$$Key_TimeImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_TimeImpl>
    implements _$$Key_TimeImplCopyWith<$Res> {
  __$$Key_TimeImplCopyWithImpl(
      _$Key_TimeImpl _value, $Res Function(_$Key_TimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_TimeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as NaiveTime,
    ));
  }
}

/// @nodoc

class _$Key_TimeImpl extends Key_Time {
  const _$Key_TimeImpl(this.field0) : super._();

  @override
  final NaiveTime field0;

  @override
  String toString() {
    return 'Key.time(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_TimeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_TimeImplCopyWith<_$Key_TimeImpl> get copyWith =>
      __$$Key_TimeImplCopyWithImpl<_$Key_TimeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return time(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return time?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (time != null) {
      return time(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return time(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return time?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (time != null) {
      return time(this);
    }
    return orElse();
  }
}

abstract class Key_Time extends Key {
  const factory Key_Time(final NaiveTime field0) = _$Key_TimeImpl;
  const Key_Time._() : super._();

  NaiveTime get field0;
  @JsonKey(ignore: true)
  _$$Key_TimeImplCopyWith<_$Key_TimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_IntervalImplCopyWith<$Res> {
  factory _$$Key_IntervalImplCopyWith(
          _$Key_IntervalImpl value, $Res Function(_$Key_IntervalImpl) then) =
      __$$Key_IntervalImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Interval field0});
}

/// @nodoc
class __$$Key_IntervalImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_IntervalImpl>
    implements _$$Key_IntervalImplCopyWith<$Res> {
  __$$Key_IntervalImplCopyWithImpl(
      _$Key_IntervalImpl _value, $Res Function(_$Key_IntervalImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_IntervalImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Interval,
    ));
  }
}

/// @nodoc

class _$Key_IntervalImpl extends Key_Interval {
  const _$Key_IntervalImpl(this.field0) : super._();

  @override
  final Interval field0;

  @override
  String toString() {
    return 'Key.interval(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_IntervalImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_IntervalImplCopyWith<_$Key_IntervalImpl> get copyWith =>
      __$$Key_IntervalImplCopyWithImpl<_$Key_IntervalImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return interval(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return interval?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (interval != null) {
      return interval(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return interval(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return interval?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (interval != null) {
      return interval(this);
    }
    return orElse();
  }
}

abstract class Key_Interval extends Key {
  const factory Key_Interval(final Interval field0) = _$Key_IntervalImpl;
  const Key_Interval._() : super._();

  Interval get field0;
  @JsonKey(ignore: true)
  _$$Key_IntervalImplCopyWith<_$Key_IntervalImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_UuidImplCopyWith<$Res> {
  factory _$$Key_UuidImplCopyWith(
          _$Key_UuidImpl value, $Res Function(_$Key_UuidImpl) then) =
      __$$Key_UuidImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt field0});
}

/// @nodoc
class __$$Key_UuidImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_UuidImpl>
    implements _$$Key_UuidImplCopyWith<$Res> {
  __$$Key_UuidImplCopyWithImpl(
      _$Key_UuidImpl _value, $Res Function(_$Key_UuidImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_UuidImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$Key_UuidImpl extends Key_Uuid {
  const _$Key_UuidImpl(this.field0) : super._();

  @override
  final BigInt field0;

  @override
  String toString() {
    return 'Key.uuid(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_UuidImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_UuidImplCopyWith<_$Key_UuidImpl> get copyWith =>
      __$$Key_UuidImplCopyWithImpl<_$Key_UuidImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return uuid(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return uuid?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (uuid != null) {
      return uuid(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return uuid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return uuid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (uuid != null) {
      return uuid(this);
    }
    return orElse();
  }
}

abstract class Key_Uuid extends Key {
  const factory Key_Uuid(final BigInt field0) = _$Key_UuidImpl;
  const Key_Uuid._() : super._();

  BigInt get field0;
  @JsonKey(ignore: true)
  _$$Key_UuidImplCopyWith<_$Key_UuidImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_InetImplCopyWith<$Res> {
  factory _$$Key_InetImplCopyWith(
          _$Key_InetImpl value, $Res Function(_$Key_InetImpl) then) =
      __$$Key_InetImplCopyWithImpl<$Res>;
  @useResult
  $Res call({IpAddr field0});
}

/// @nodoc
class __$$Key_InetImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_InetImpl>
    implements _$$Key_InetImplCopyWith<$Res> {
  __$$Key_InetImplCopyWithImpl(
      _$Key_InetImpl _value, $Res Function(_$Key_InetImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Key_InetImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as IpAddr,
    ));
  }
}

/// @nodoc

class _$Key_InetImpl extends Key_Inet {
  const _$Key_InetImpl(this.field0) : super._();

  @override
  final IpAddr field0;

  @override
  String toString() {
    return 'Key.inet(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Key_InetImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Key_InetImplCopyWith<_$Key_InetImpl> get copyWith =>
      __$$Key_InetImplCopyWithImpl<_$Key_InetImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return inet(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return inet?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (inet != null) {
      return inet(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return inet(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return inet?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (inet != null) {
      return inet(this);
    }
    return orElse();
  }
}

abstract class Key_Inet extends Key {
  const factory Key_Inet(final IpAddr field0) = _$Key_InetImpl;
  const Key_Inet._() : super._();

  IpAddr get field0;
  @JsonKey(ignore: true)
  _$$Key_InetImplCopyWith<_$Key_InetImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Key_NoneImplCopyWith<$Res> {
  factory _$$Key_NoneImplCopyWith(
          _$Key_NoneImpl value, $Res Function(_$Key_NoneImpl) then) =
      __$$Key_NoneImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Key_NoneImplCopyWithImpl<$Res>
    extends _$KeyCopyWithImpl<$Res, _$Key_NoneImpl>
    implements _$$Key_NoneImplCopyWith<$Res> {
  __$$Key_NoneImplCopyWithImpl(
      _$Key_NoneImpl _value, $Res Function(_$Key_NoneImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Key_NoneImpl extends Key_None {
  const _$Key_NoneImpl() : super._();

  @override
  String toString() {
    return 'Key.none()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Key_NoneImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) i8,
    required TResult Function(int field0) i16,
    required TResult Function(int field0) i32,
    required TResult Function(int field0) i64,
    required TResult Function(BigInt field0) i128,
    required TResult Function(int field0) u8,
    required TResult Function(int field0) u16,
    required TResult Function(int field0) u32,
    required TResult Function(BigInt field0) u64,
    required TResult Function(BigInt field0) u128,
    required TResult Function(OrderedFloatF32 field0) f32,
    required TResult Function(OrderedFloatF64 field0) f64,
    required TResult Function(Decimal field0) decimal,
    required TResult Function(bool field0) bool,
    required TResult Function(String field0) str,
    required TResult Function(Uint8List field0) bytea,
    required TResult Function(NaiveDate field0) date,
    required TResult Function(DateTime field0) timestamp,
    required TResult Function(NaiveTime field0) time,
    required TResult Function(Interval field0) interval,
    required TResult Function(BigInt field0) uuid,
    required TResult Function(IpAddr field0) inet,
    required TResult Function() none,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? i8,
    TResult? Function(int field0)? i16,
    TResult? Function(int field0)? i32,
    TResult? Function(int field0)? i64,
    TResult? Function(BigInt field0)? i128,
    TResult? Function(int field0)? u8,
    TResult? Function(int field0)? u16,
    TResult? Function(int field0)? u32,
    TResult? Function(BigInt field0)? u64,
    TResult? Function(BigInt field0)? u128,
    TResult? Function(OrderedFloatF32 field0)? f32,
    TResult? Function(OrderedFloatF64 field0)? f64,
    TResult? Function(Decimal field0)? decimal,
    TResult? Function(bool field0)? bool,
    TResult? Function(String field0)? str,
    TResult? Function(Uint8List field0)? bytea,
    TResult? Function(NaiveDate field0)? date,
    TResult? Function(DateTime field0)? timestamp,
    TResult? Function(NaiveTime field0)? time,
    TResult? Function(Interval field0)? interval,
    TResult? Function(BigInt field0)? uuid,
    TResult? Function(IpAddr field0)? inet,
    TResult? Function()? none,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? i8,
    TResult Function(int field0)? i16,
    TResult Function(int field0)? i32,
    TResult Function(int field0)? i64,
    TResult Function(BigInt field0)? i128,
    TResult Function(int field0)? u8,
    TResult Function(int field0)? u16,
    TResult Function(int field0)? u32,
    TResult Function(BigInt field0)? u64,
    TResult Function(BigInt field0)? u128,
    TResult Function(OrderedFloatF32 field0)? f32,
    TResult Function(OrderedFloatF64 field0)? f64,
    TResult Function(Decimal field0)? decimal,
    TResult Function(bool field0)? bool,
    TResult Function(String field0)? str,
    TResult Function(Uint8List field0)? bytea,
    TResult Function(NaiveDate field0)? date,
    TResult Function(DateTime field0)? timestamp,
    TResult Function(NaiveTime field0)? time,
    TResult Function(Interval field0)? interval,
    TResult Function(BigInt field0)? uuid,
    TResult Function(IpAddr field0)? inet,
    TResult Function()? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Key_I8 value) i8,
    required TResult Function(Key_I16 value) i16,
    required TResult Function(Key_I32 value) i32,
    required TResult Function(Key_I64 value) i64,
    required TResult Function(Key_I128 value) i128,
    required TResult Function(Key_U8 value) u8,
    required TResult Function(Key_U16 value) u16,
    required TResult Function(Key_U32 value) u32,
    required TResult Function(Key_U64 value) u64,
    required TResult Function(Key_U128 value) u128,
    required TResult Function(Key_F32 value) f32,
    required TResult Function(Key_F64 value) f64,
    required TResult Function(Key_Decimal value) decimal,
    required TResult Function(Key_Bool value) bool,
    required TResult Function(Key_Str value) str,
    required TResult Function(Key_Bytea value) bytea,
    required TResult Function(Key_Date value) date,
    required TResult Function(Key_Timestamp value) timestamp,
    required TResult Function(Key_Time value) time,
    required TResult Function(Key_Interval value) interval,
    required TResult Function(Key_Uuid value) uuid,
    required TResult Function(Key_Inet value) inet,
    required TResult Function(Key_None value) none,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Key_I8 value)? i8,
    TResult? Function(Key_I16 value)? i16,
    TResult? Function(Key_I32 value)? i32,
    TResult? Function(Key_I64 value)? i64,
    TResult? Function(Key_I128 value)? i128,
    TResult? Function(Key_U8 value)? u8,
    TResult? Function(Key_U16 value)? u16,
    TResult? Function(Key_U32 value)? u32,
    TResult? Function(Key_U64 value)? u64,
    TResult? Function(Key_U128 value)? u128,
    TResult? Function(Key_F32 value)? f32,
    TResult? Function(Key_F64 value)? f64,
    TResult? Function(Key_Decimal value)? decimal,
    TResult? Function(Key_Bool value)? bool,
    TResult? Function(Key_Str value)? str,
    TResult? Function(Key_Bytea value)? bytea,
    TResult? Function(Key_Date value)? date,
    TResult? Function(Key_Timestamp value)? timestamp,
    TResult? Function(Key_Time value)? time,
    TResult? Function(Key_Interval value)? interval,
    TResult? Function(Key_Uuid value)? uuid,
    TResult? Function(Key_Inet value)? inet,
    TResult? Function(Key_None value)? none,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Key_I8 value)? i8,
    TResult Function(Key_I16 value)? i16,
    TResult Function(Key_I32 value)? i32,
    TResult Function(Key_I64 value)? i64,
    TResult Function(Key_I128 value)? i128,
    TResult Function(Key_U8 value)? u8,
    TResult Function(Key_U16 value)? u16,
    TResult Function(Key_U32 value)? u32,
    TResult Function(Key_U64 value)? u64,
    TResult Function(Key_U128 value)? u128,
    TResult Function(Key_F32 value)? f32,
    TResult Function(Key_F64 value)? f64,
    TResult Function(Key_Decimal value)? decimal,
    TResult Function(Key_Bool value)? bool,
    TResult Function(Key_Str value)? str,
    TResult Function(Key_Bytea value)? bytea,
    TResult Function(Key_Date value)? date,
    TResult Function(Key_Timestamp value)? timestamp,
    TResult Function(Key_Time value)? time,
    TResult Function(Key_Interval value)? interval,
    TResult Function(Key_Uuid value)? uuid,
    TResult Function(Key_Inet value)? inet,
    TResult Function(Key_None value)? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class Key_None extends Key {
  const factory Key_None() = _$Key_NoneImpl;
  const Key_None._() : super._();
}
