// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.39.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'value/literal.dart';

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ordering>>
abstract class Ordering implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>>
abstract class Value implements RustOpaqueInterface {
  Future<Value> add({required Value other});

  Future<Value> bitwiseAnd({required Value other});

  Future<Value> bitwiseShiftLeft({required Value rhs});

  Future<Value> bitwiseShiftRight({required Value rhs});

  Future<Value> cast({required DataType dataType});

  Future<Value> concat({required Value other});

  Future<Value> divide({required Value other});

  Future<Ordering?> evaluateCmp({required Value other});

  Future<Ordering?> evaluateCmpWithLiteral({required Literal other});

  Future<bool> evaluateEq({required Value other});

  Future<bool> evaluateEqWithLiteral({required Literal other});

  Future<Value> extract({required DateTimeField dateType});

  Future<Value> findIdx({required Value subVal, required Value start});

  Future<DataType?> getType();

  Future<bool> isNull();

  Future<bool> isZero();

  Future<Value> like({required Value other, required bool caseSensitive});

  Future<Value> modulo({required Value other});

  Future<Value> multiply({required Value other});

  static Future<Value> parseJsonList({required String value}) =>
      RustLib.instance.api.gluesqlCoreDataValueValueParseJsonList(value: value);

  static Future<Value> parseJsonMap({required String value}) =>
      RustLib.instance.api.gluesqlCoreDataValueValueParseJsonMap(value: value);

  /// # Description
  /// The operation method differs depending on the argument.
  /// 1. If both arguments are String
  ///     - Support only [`Value::Str`] variant
  ///     - Returns the position where the first letter of the substring starts if the string contains a substring.
  ///     - Returns [`Value::I64`] 0 if the string to be found is not found.
  ///     - Returns minimum value [`Value::I64`] 1 when the string is found.
  ///     - Returns [`Value::Null`] if NULL parameter found.
  ///
  /// 2. Other arguments
  ///     - Not Supported Yet.
  ///
  /// # Examples
  /// ```
  /// use gluesql_core::prelude::Value;
  ///
  /// let str1 = Value::Str("ramen".to_owned());
  /// let str2 = Value::Str("men".to_owned());
  ///
  /// assert_eq!(str1.position(&str2), Ok(Value::I64(3)));
  /// assert_eq!(str2.position(&str1), Ok(Value::I64(0)));
  /// assert!(Value::Null.position(&str2).unwrap().is_null());
  /// assert!(str1.position(&Value::Null).unwrap().is_null());
  /// ```
  Future<Value> position({required Value other});

  Future<Value> selector({required String selector});

  Future<Value> selectorByIndex({required List<Value> selector});

  Future<Value> sqrt();

  Future<Value> subtract({required Value other});

  /// Value to Big-Endian for comparison purpose
  Future<Uint8List> toCmpBeBytes();

  static Future<Value> tryCastFromLiteral(
          {required DataType dataType, required Literal literal}) =>
      RustLib.instance.api.gluesqlCoreDataValueValueTryCastFromLiteral(
          dataType: dataType, literal: literal);

  static Future<Value> tryFromLiteral(
          {required DataType dataType, required Literal literal}) =>
      RustLib.instance.api.gluesqlCoreDataValueValueTryFromLiteral(
          dataType: dataType, literal: literal);

  Future<Value> unaryBitwiseNot();

  Future<Value> unaryFactorial();

  Future<Value> unaryMinus();

  Future<Value> unaryPlus();

  Future<void> validateNull({required bool nullable});

  Future<void> validateType({required DataType dataType});
}
