# Development Guide

This guide is for developers who want to contribute to or modify the GlueSQL Kotlin bindings.

## Prerequisites

- **Rust** 1.70+ ([Install Rust](https://rustup.rs/))
- **Java** 11+ (JDK)
- **Kotlin** 1.9+ (bundled with Gradle)
- **Gradle** 8.0+ (use included `./gradlew`)

## Quick Start

```bash
# Clone the repository
git clone https://github.com/gluesql/gluesql.git
cd gluesql/pkg/kotlin

# Build and test
./gradlew test
```

## Project Structure

```
pkg/kotlin/
├── src/                    # Rust source files
│   ├── lib.rs             # Main library entry point
│   ├── uniffi_types.rs    # UniFFI type definitions
│   ├── executor.rs        # Query executor implementation
│   ├── storage.rs         # Storage backend wrapper
│   └── error.rs           # Error handling
├── src/test/kotlin/       # Test files
├── build.gradle.kts       # Gradle build configuration
├── Cargo.toml             # Rust dependencies
└── uniffi-bindgen.rs      # UniFFI code generator
```

Note: Kotlin bindings are automatically generated by UniFFI into `build/generated/source/uniffi/kotlin/`

## Development Workflow

### 1. Making Changes to Rust Code

When you modify Rust code:

```bash
# Clean build (recommended after Rust changes)
./gradlew clean build

# Or just rebuild and test
./gradlew test
```

**How it works:**
1. `buildRustLib` task compiles Rust → `../../target/debug/libgluesql_kotlin.*`
2. `generateBindings` task runs UniFFI → generates Kotlin bindings
3. Kotlin code is compiled with generated bindings

### 2. Making Changes to Test Code

```bash
# Test changes don't need Rust rebuild
./gradlew test
```

### 3. Regenerating Bindings (Manual)

If you modify UniFFI interface definitions:

```bash
./gradlew generateBindings
```

This runs:
```bash
cargo run --bin uniffi-bindgen generate \
    --language kotlin \
    --library ../../target/debug/libgluesql_kotlin.dylib
```

### 4. Running Tests

```bash
# Run all tests
./gradlew test

# Run specific test class
./gradlew test --tests "org.gluesql.NativeLibraryLoadingTest"

# Run with verbose output
./gradlew test --info
```

## Code Style & Formatting

We use **ktlint** for automatic code formatting:

- **Kotlin**: ktlint conventions
- Applies to both main source code and buildSrc

### Commands

```bash
# Check formatting (includes buildSrc, runs in CI)
./gradlew ktlintCheck

# Auto-format all code (includes buildSrc)
./gradlew ktlintFormat

# Check only buildSrc
./gradlew ktlintCheckBuildSrc

# Format only buildSrc
./gradlew ktlintFormatBuildSrc
```

## Build Tasks Reference

### Local Development Tasks

| Task | Description |
|------|-------------|
| `./gradlew build` | Full build (Rust + Kotlin + tests) |
| `./gradlew test` | Run all tests |
| `./gradlew clean` | Clean build artifacts |
| `./gradlew buildRustLib` | Build Rust library (debug mode for local testing) |
| `./gradlew generateBindings` | Generate UniFFI Kotlin bindings from debug library |
| `./gradlew ktlintCheck` | Check code formatting (includes buildSrc) |
| `./gradlew ktlintFormat` | Auto-format code (includes buildSrc) |
| `./gradlew ktlintCheckBuildSrc` | Check code formatting for buildSrc only |
| `./gradlew ktlintFormatBuildSrc` | Auto-format buildSrc code only |

## Distribution Builds

### Local Development Builds

**Purpose:** Development and testing only (NOT for distribution)

```bash
./gradlew build
./gradlew test
```

**Characteristics:**
- ✅ Uses **debug mode** Rust libraries from `target/debug/`
- ✅ Fast builds for quick iteration
- ✅ Tests work correctly (loads from `jna.library.path`)
- ❌ **JAR does NOT include native libraries**
- ❌ **JAR cannot run on other machines**

**Why?**
- No `src/main/resources/natives/` directory locally
- Native libraries loaded directly from Cargo target directory
- Only suitable for local development/testing

### Production JAR (CI-Built)

**Purpose:** Distribution via Maven Central

GitHub Actions builds a **Fat JAR** with native libraries for all platforms and architectures:

```yaml
# .github/workflows/publish-kotlin.yml
1. Build native libraries on each platform in parallel (Rust only)
   - Linux x86-64:    cargo build --release --target x86_64-unknown-linux-gnu
   - macOS Intel:     cargo build --release --target x86_64-apple-darwin
   - macOS ARM64:     cargo build --release --target aarch64-apple-darwin
   - Windows x86-64:  cargo build --release --target x86_64-pc-windows-msvc
   - Copy to artifact directory (shell script)
   - Upload artifacts: native-{platform}/

2. Generate UniFFI bindings (shell script)
   - Download artifacts to: downloaded-artifacts/native-*/
   - Run: cargo run --bin uniffi-bindgen generate --language kotlin ...
   - Result: build/generated/source/uniffi/kotlin/

3. Organize native libraries (shell script)
   - Copy artifacts to: src/main/resources/natives/{platform}/
     * natives/linux-x86-64/libgluesql_kotlin.so
     * natives/darwin-x86-64/libgluesql_kotlin.dylib    (Intel Mac)
     * natives/darwin-aarch64/libgluesql_kotlin.dylib   (Apple Silicon)
     * natives/win32-x86-64/gluesql_kotlin.dll

4. Build final Fat JAR (Gradle)
   - Run: ./gradlew build -x test -x buildRustLib -x generateBindings
   - All native libraries automatically packaged from resources/
```

**Characteristics:**
- ✅ **JAR includes all platform libraries** (Linux, macOS Intel/ARM, Windows)
- ✅ **Runs anywhere** - JNA automatically selects correct library
- ✅ Single JAR for all platforms (no platform-specific builds needed)
- ✅ Release-optimized binaries

**How JNA Resolves Libraries:**
- Runtime: JNA detects platform/architecture (e.g., `darwin-aarch64`)
- Extracts correct library from JAR `natives/{platform}/`
- Loads into memory
- Works transparently across all supported platforms

**Why separate CI from local builds?**
- **Local:** Fast debug builds using Gradle tasks, no multi-platform setup required
- **CI:** Release builds with shell scripts, minimal Gradle usage (only for JAR build)
- **Build logic:** Gradle tasks for local dev, shell scripts for CI simplicity
- **Testing:** Local sufficient for development; CI validates distribution

## Common Issues & Solutions

### Issue: `UnsatisfiedLinkError: Unable to load library 'gluesql_kotlin'`

**Cause:** Rust library not built or not in expected location

**Solution:**
```bash
# Rebuild Rust library
cargo build

# Verify it exists
ls -la ../../target/debug/libgluesql_kotlin.*

# Clean and rebuild
./gradlew clean build
```

### Issue: Bindings out of sync with Rust code

**Cause:** Rust interface changed but Kotlin bindings not regenerated

**Solution:**
```bash
./gradlew clean generateBindings
```

### Issue: `Gradle task 'generateBindings' failed`

**Cause:** UniFFI can't find the library or library is corrupted

**Solution:**
```bash
# Clean everything
./gradlew clean
rm -rf ../../target/debug/libgluesql_kotlin.*

# Rebuild from scratch
./gradlew build
```

### Issue: Tests pass locally but fail in CI

**Cause:** Platform-specific issues or missing dependencies

**Solution:**
- Check GitHub Actions logs
- Ensure all platforms are tested
- Verify native library paths in CI config

## Adding New Features

### 1. Add Rust Function

Edit `src/lib.rs` or relevant module:

```rust
#[uniffi::export]
impl Glue {
    pub async fn new_feature(&self, param: String) -> Result<String, GlueSQLError> {
        // Implementation
        Ok(format!("Result: {}", param))
    }
}
```

### 2. Regenerate Bindings

```bash
./gradlew generateBindings
```

This creates Kotlin bindings automatically:
```kotlin
// Auto-generated in build/generated/source/uniffi/kotlin/
class Glue {
    suspend fun newFeature(param: String): String { ... }
}
```

### 3. Add Tests

```kotlin
// src/test/kotlin/org/gluesql/NewFeatureTest.kt
@Test
fun `test new feature`() = runBlocking {
    val glue = Glue(Storage.Memory)
    val result = glue.newFeature("test")
    assertEquals("Result: test", result)
}
```

### 4. Run Tests

```bash
./gradlew test --tests "NewFeatureTest"
```

## Architecture Overview

```
┌─────────────────────────────────────────────────┐
│           JVM (Kotlin)                          │
│                                                 │
│  ┌──────────────┐         ┌─────────────┐     │
│  │ User's Code  │────────▶│    Glue     │     │
│  └──────────────┘         └─────────────┘     │
│                                  │             │
│                           ┌──────▼─────────┐  │
│                           │ UniFFI Generated│  │
│                           │    Bindings     │  │
│                           └────────────────┘  │
│                                  │             │
└──────────────────────────────────┼─────────────┘
                                   │ JNA (FFI)
┌──────────────────────────────────▼─────────────┐
│           Rust Native Library                   │
│                                                 │
│  ┌─────────────┐      ┌──────────────────┐    │
│  │    Glue     │─────▶│ QueryExecutor    │    │
│  └─────────────┘      └──────────────────┘    │
│         │                      │               │
│         │             ┌────────▼──────────┐   │
│         │             │  GlueSQL Core     │   │
│         │             └───────────────────┘   │
│         │                                      │
│  ┌──────▼────────┐                            │
│  │ StorageBackend│                            │
│  └───────────────┘                            │
└─────────────────────────────────────────────────┘
```

## Debugging Tips

### Enable JNA Debug Logging

```kotlin
System.setProperty("jna.debug_load", "true")
System.setProperty("jna.debug_load.jna", "true")
```

### Check Native Library Loading

```bash
# Run test with detailed output
./gradlew test --tests "NativeLibraryLoadingTest" --info
```

### Inspect Generated Bindings

```bash
# View generated Kotlin code
cat build/generated/source/uniffi/kotlin/org/gluesql/uniffi/gluesql_kotlin.kt
```

### Verify JAR Contents

```bash
# List all files in JAR
jar tf build/libs/gluesql-kotlin-0.1.0.jar

# Check for native libraries
jar tf build/libs/gluesql-kotlin-0.1.0.jar | grep natives
```

## Release Process

See `.github/workflows/publish-kotlin.yml` for automated release process:

1. Push tag or trigger workflow manually
2. CI builds native libraries on all platforms (parallel)
3. Artifacts collected and copied to `src/main/resources/natives/`
4. Fat JAR built with all native libraries
5. Published to Maven Central (if configured)

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Run `./gradlew ktlintFormat test`
5. Commit and push
6. Create a Pull Request

## Resources

- [UniFFI User Guide](https://mozilla.github.io/uniffi-rs/)
- [JNA Documentation](https://github.com/java-native-access/jna)
- [GlueSQL Documentation](https://gluesql.org/docs)
- [Rust Book](https://doc.rust-lang.org/book/)
- [Kotlin Coroutines](https://kotlinlang.org/docs/coroutines-overview.html)
