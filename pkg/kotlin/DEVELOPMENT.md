# Development Guide

This guide is for developers who want to contribute to or modify the GlueSQL Kotlin bindings.

## Prerequisites

- **Rust** 1.70+ ([Install Rust](https://rustup.rs/))
- **Java** 11+ (JDK)
- **Kotlin** 1.9+ (bundled with Gradle)
- **Gradle** 8.0+ (use included `./gradlew`)

## Quick Start

```bash
# Clone the repository
git clone https://github.com/gluesql/gluesql.git
cd gluesql/pkg/kotlin

# Build and test
./gradlew test
```

## Project Structure

```
pkg/kotlin/
├── src/                    # Rust source files
│   ├── lib.rs             # Main library entry point
│   ├── uniffi_types.rs    # UniFFI type definitions
│   ├── executor.rs        # Query executor implementation
│   ├── storage.rs         # Storage backend wrapper
│   └── error.rs           # Error handling
├── src/test/kotlin/       # Test files
├── build.gradle.kts       # Gradle build configuration
├── Cargo.toml             # Rust dependencies
└── uniffi-bindgen.rs      # UniFFI code generator
```

Note: Kotlin bindings are automatically generated by UniFFI into `build/generated/source/uniffi/kotlin/`

## Development Workflow

### 1. Making Changes to Rust Code

When you modify Rust code:

```bash
# Clean build (recommended after Rust changes)
./gradlew clean build

# Or just rebuild and test
./gradlew test
```

**How it works:**
1. `buildRustLib` task compiles Rust → `../../target/debug/libgluesql_kotlin.*`
2. `generateBindings` task runs UniFFI → generates Kotlin bindings
3. Kotlin code is compiled with generated bindings

### 2. Making Changes to Test Code

```bash
# Test changes don't need Rust rebuild
./gradlew test
```

### 3. Regenerating Bindings (Manual)

If you modify UniFFI interface definitions:

```bash
./gradlew generateBindings
```

This runs:
```bash
cargo run --bin uniffi-bindgen generate \
    --language kotlin \
    --library ../../target/debug/libgluesql_kotlin.dylib
```

### 4. Running Tests

```bash
# Run all tests
./gradlew test

# Run specific test class
./gradlew test --tests "org.gluesql.NativeLibraryLoadingTest"

# Run with verbose output
./gradlew test --info
```

## Code Style & Formatting

We use **ktlint** for automatic code formatting:

- **Kotlin**: ktlint conventions

### Commands

```bash
# Check formatting (runs in CI)
./gradlew ktlintCheck

# Auto-format all code
./gradlew ktlintFormat
```

## Build Tasks Reference

| Task | Description |
|------|-------------|
| `./gradlew build` | Full build (Rust + Kotlin + tests) |
| `./gradlew test` | Run all tests |
| `./gradlew clean` | Clean build artifacts |
| `./gradlew buildRustLib` | Build Rust library (debug mode for local testing) |
| `./gradlew generateBindings` | Generate UniFFI Kotlin bindings |
| `./gradlew ktlintCheck` | Check code formatting |
| `./gradlew ktlintFormat` | Auto-format code |

## Distribution Builds

### Local Development

Development builds use **debug mode** Rust libraries loaded directly from the Cargo target directory:

```bash
./gradlew test
# Uses: ../../target/debug/libgluesql_kotlin.*
```

### Production JAR

For distribution, GitHub Actions builds a **Fat JAR** with native libraries for all platforms:

```yaml
# .github/workflows/publish-kotlin.yml
1. Build native libraries on each platform in parallel (Linux, macOS, Windows)
   - Each runner executes: cargo build --release --target <platform-target>
2. Download and organize all platform artifacts
   - Copies to: pkg/kotlin/src/main/resources/natives/{platform}/
3. Generate UniFFI bindings using Linux library
4. Build final JAR with all libraries included
   - ./gradlew build -x test
```

**Why separate CI from local builds?**
- Local: Uses debug builds for faster iteration
- CI: Builds release binaries on native platforms (no cross-compilation needed)
- Gradle tasks focus on development workflow
- GitHub Actions handles production multi-platform builds

## Common Issues & Solutions

### Issue: `UnsatisfiedLinkError: Unable to load library 'gluesql_kotlin'`

**Cause:** Rust library not built or not in expected location

**Solution:**
```bash
# Rebuild Rust library
cargo build

# Verify it exists
ls -la ../../target/debug/libgluesql_kotlin.*

# Clean and rebuild
./gradlew clean build
```

### Issue: Bindings out of sync with Rust code

**Cause:** Rust interface changed but Kotlin bindings not regenerated

**Solution:**
```bash
./gradlew clean generateBindings
```

### Issue: `Gradle task 'generateBindings' failed`

**Cause:** UniFFI can't find the library or library is corrupted

**Solution:**
```bash
# Clean everything
./gradlew clean
rm -rf ../../target/debug/libgluesql_kotlin.*

# Rebuild from scratch
./gradlew build
```

### Issue: Tests pass locally but fail in CI

**Cause:** Platform-specific issues or missing dependencies

**Solution:**
- Check GitHub Actions logs
- Ensure all platforms are tested
- Verify native library paths in CI config

## Adding New Features

### 1. Add Rust Function

Edit `src/lib.rs` or relevant module:

```rust
#[uniffi::export]
impl Glue {
    pub async fn new_feature(&self, param: String) -> Result<String, GlueSQLError> {
        // Implementation
        Ok(format!("Result: {}", param))
    }
}
```

### 2. Regenerate Bindings

```bash
./gradlew generateBindings
```

This creates Kotlin bindings automatically:
```kotlin
// Auto-generated in build/generated/source/uniffi/kotlin/
class Glue {
    suspend fun newFeature(param: String): String { ... }
}
```

### 3. Add Tests

```kotlin
// src/test/kotlin/org/gluesql/NewFeatureTest.kt
@Test
fun `test new feature`() = runBlocking {
    val glue = Glue(Storage.Memory)
    val result = glue.newFeature("test")
    assertEquals("Result: test", result)
}
```

### 4. Run Tests

```bash
./gradlew test --tests "NewFeatureTest"
```

## Architecture Overview

```
┌─────────────────────────────────────────────────┐
│           JVM (Kotlin)                          │
│                                                 │
│  ┌──────────────┐         ┌─────────────┐     │
│  │ User's Code  │────────▶│    Glue     │     │
│  └──────────────┘         └─────────────┘     │
│                                  │             │
│                           ┌──────▼─────────┐  │
│                           │ UniFFI Generated│  │
│                           │    Bindings     │  │
│                           └────────────────┘  │
│                                  │             │
└──────────────────────────────────┼─────────────┘
                                   │ JNA (FFI)
┌──────────────────────────────────▼─────────────┐
│           Rust Native Library                   │
│                                                 │
│  ┌─────────────┐      ┌──────────────────┐    │
│  │    Glue     │─────▶│ QueryExecutor    │    │
│  └─────────────┘      └──────────────────┘    │
│         │                      │               │
│         │             ┌────────▼──────────┐   │
│         │             │  GlueSQL Core     │   │
│         │             └───────────────────┘   │
│         │                                      │
│  ┌──────▼────────┐                            │
│  │ StorageBackend│                            │
│  └───────────────┘                            │
└─────────────────────────────────────────────────┘
```

## Debugging Tips

### Enable JNA Debug Logging

```kotlin
System.setProperty("jna.debug_load", "true")
System.setProperty("jna.debug_load.jna", "true")
```

### Check Native Library Loading

```bash
# Run test with detailed output
./gradlew test --tests "NativeLibraryLoadingTest" --info
```

### Inspect Generated Bindings

```bash
# View generated Kotlin code
cat build/generated/source/uniffi/kotlin/org/gluesql/uniffi/gluesql_kotlin.kt
```

### Verify JAR Contents

```bash
# List all files in JAR
jar tf build/libs/gluesql-kotlin-0.1.0.jar

# Check for native libraries
jar tf build/libs/gluesql-kotlin-0.1.0.jar | grep natives
```

## Release Process

See `.github/workflows/publish-kotlin.yml` for automated release process:

1. Push tag or trigger workflow manually
2. CI builds native libraries on all platforms (parallel)
3. Artifacts collected and copied to `src/main/resources/natives/`
4. Fat JAR built with all native libraries
5. Published to Maven Central (if configured)

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Run `./gradlew ktlintFormat test`
5. Commit and push
6. Create a Pull Request

## Resources

- [UniFFI User Guide](https://mozilla.github.io/uniffi-rs/)
- [JNA Documentation](https://github.com/java-native-access/jna)
- [GlueSQL Documentation](https://gluesql.org/docs)
- [Rust Book](https://doc.rust-lang.org/book/)
- [Kotlin Coroutines](https://kotlinlang.org/docs/coroutines-overview.html)
