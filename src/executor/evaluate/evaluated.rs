use {
    super::EvaluateError,
    crate::{
        data,
        data::Value,
        result::{Error, Result},
    },
    sqlparser::ast::{DataType, Value as AstValue},
    std::{
        cmp::Ordering,
        convert::{TryFrom, TryInto},
    },
    Evaluated::*,
};

/// `LiteralRef`, `Literal` and `StringRef` are used when it is not possible to specify what kind of `Value`
/// can be applied.
///
/// * `1 + 1` is converted into `LiteralRef + LiteralRef`, `LiteralRef` of `1` can
/// become `Value::I64` but it can be also `Value::F64`.
///
/// * Specifing column `id`, it is converted into `ValueRef` because `id` can be specified from table
/// schema.
///
/// * `"hello"` is converted into `StringRef`, similar with `LiteralRef` but it is for storing
/// string value.
///
/// * Evaluated result of `1 + 1` becomes `Literal`, not `LiteralRef` because executor has
/// ownership of `1 + 1`.
///
/// * Similar with `Literal`, `Value` is also generated by any other operation with `ValueRef` or
/// `Value`.
/// e.g. `LiteralRef` + `ValueRef`, `LiteralRef` * `Value`, ...
#[derive(std::fmt::Debug)]
pub enum Evaluated<'a> {
    LiteralRef(&'a AstValue),
    Literal(AstValue),
    StringRef(&'a str),
    ValueRef(&'a Value),
    Value(Value),
}

impl<'a> PartialEq for Evaluated<'a> {
    fn eq(&self, other: &Evaluated<'a>) -> bool {
        let eq_ast = |l: &AstValue, r| match l {
            AstValue::SingleQuotedString(l) => l == r,
            _ => false,
        };

        let eq_val = |l: &Value, r| match l {
            Value::Str(l) => l == r,
            _ => false,
        };

        match (self, other) {
            (LiteralRef(l), LiteralRef(r)) => l == r,
            (LiteralRef(l), StringRef(r)) => eq_ast(l, r),
            (LiteralRef(l), ValueRef(r)) => r == l,
            (LiteralRef(l), Value(r)) => &r == l,
            (LiteralRef(l), Literal(r)) => *l == r,
            (StringRef(l), LiteralRef(r)) => eq_ast(r, l),
            (StringRef(l), StringRef(r)) => l == r,
            (StringRef(l), ValueRef(r)) => eq_val(r, l),
            (StringRef(l), Value(r)) => eq_val(&r, l),
            (ValueRef(l), LiteralRef(r)) => l == r,
            (ValueRef(l), Literal(r)) => l == &r,
            (ValueRef(l), StringRef(r)) => eq_val(l, r),
            (ValueRef(l), ValueRef(r)) => l == r,
            (ValueRef(l), Value(r)) => l == &r,
            (Value(l), LiteralRef(r)) => &l == r,
            (Value(l), StringRef(r)) => eq_val(&l, r),
            (Value(l), ValueRef(r)) => &l == r,
            (Value(l), Value(r)) => l == r,
            (Value(l), Literal(r)) => l == r,
            (Literal(l), Literal(r)) => l == r,
            (Literal(l), LiteralRef(r)) => &l == r,
            (Literal(l), ValueRef(r)) => r == &l,
            (Literal(l), Value(r)) => r == l,
            _ => false,
        }
    }
}

impl<'a> PartialOrd for Evaluated<'a> {
    fn partial_cmp(&self, other: &Evaluated<'a>) -> Option<Ordering> {
        match (self, other) {
            (LiteralRef(l), LiteralRef(r)) => literal_partial_cmp(l, r),
            (LiteralRef(l), Literal(r)) => literal_partial_cmp(&l, &r),
            (LiteralRef(l), ValueRef(r)) => r.partial_cmp(l).map(|o| o.reverse()),
            (LiteralRef(l), Value(r)) => r.partial_cmp(*l).map(|o| o.reverse()),
            (Literal(l), LiteralRef(r)) => literal_partial_cmp(&l, &r),
            (Literal(l), ValueRef(r)) => r.partial_cmp(&l).map(|o| o.reverse()),
            (Literal(l), Value(r)) => r.partial_cmp(l).map(|o| o.reverse()),
            (Literal(l), Literal(r)) => literal_partial_cmp(l, r),
            (ValueRef(l), LiteralRef(r)) => l.partial_cmp(r),
            (ValueRef(l), ValueRef(r)) => l.partial_cmp(r),
            (Value(l), Literal(r)) => l.partial_cmp(r),
            (Value(l), Value(r)) => l.partial_cmp(r),
            (StringRef(l), StringRef(r)) => l.partial_cmp(r),
            (ValueRef(l), Literal(r)) => l.partial_cmp(&r),
            (ValueRef(l), Value(r)) => l.partial_cmp(&r),
            (Value(l), LiteralRef(r)) => l.partial_cmp(*r),
            (Value(l), ValueRef(r)) => l.partial_cmp(*r),
            (ValueRef(data::Value::Str(l)), StringRef(r)) => (&l.as_str()).partial_cmp(r),
            (Value(data::Value::Str(l)), StringRef(r)) => (&l.as_str()).partial_cmp(r),
            (StringRef(l), ValueRef(data::Value::Str(r))) => l.partial_cmp(&r.as_str()),
            (StringRef(l), Value(data::Value::Str(r))) => l.partial_cmp(&r.as_str()),
            _ => None,
        }
    }
}

fn literal_partial_cmp(l: &AstValue, r: &AstValue) -> Option<Ordering> {
    match (l, r) {
        (AstValue::Number(l), AstValue::Number(r)) => match (l.parse::<i64>(), r.parse::<i64>()) {
            (Ok(l), Ok(r)) => Some(l.cmp(&r)),
            (_, Ok(r)) => match l.parse::<f64>() {
                Ok(l) => l.partial_cmp(&(r as f64)),
                _ => None,
            },
            (Ok(l), _) => match r.parse::<f64>() {
                Ok(r) => (l as f64).partial_cmp(&r),
                _ => None,
            },
            _ => match (l.parse::<f64>(), r.parse::<f64>()) {
                (Ok(l), Ok(r)) => l.partial_cmp(&r),
                _ => None,
            },
        },
        (AstValue::SingleQuotedString(l), AstValue::SingleQuotedString(r)) => Some(l.cmp(r)),
        _ => None,
    }
}

impl TryInto<Value> for Evaluated<'_> {
    type Error = Error;

    fn try_into(self) -> Result<Value> {
        match self {
            Evaluated::LiteralRef(v) => Value::try_from(v),
            Evaluated::Literal(v) => Value::try_from(&v),
            Evaluated::StringRef(v) => Ok(Value::Str(v.to_string())),
            Evaluated::ValueRef(v) => Ok(v.clone()),
            Evaluated::Value(v) => Ok(v),
        }
    }
}

macro_rules! binary_op {
    ($name:ident, $op:tt) => {
        pub fn $name(&self, other: &Evaluated<'a>) -> Result<Evaluated<'a>> {
            let literal_binary_op = |l: &&AstValue, r: &&AstValue| match (l, r) {
                (AstValue::Number(a), AstValue::Number(r)) => match (a.parse::<i64>(), r.parse::<i64>()) {
                    (Ok(a), Ok(r)) => Ok(AstValue::Number((a $op r).to_string())),
                    (Ok(a), _) => match r.parse::<f64>() {
                        Ok(r) => Ok(AstValue::Number(((a as f64) $op r).to_string())),
                        _ => Err(EvaluateError::UnreachableLiteralArithmetic.into()),
                    },
                    (_, Ok(r)) => match a.parse::<f64>() {
                        Ok(a) => Ok(AstValue::Number((a $op (r as f64)).to_string())),
                        _ => Err(EvaluateError::UnreachableLiteralArithmetic.into()),
                    },
                    (_, _) => match (a.parse::<f64>(), r.parse::<f64>()) {
                        (Ok(a), Ok(r)) => Ok(AstValue::Number((a $op r).to_string())),
                        _ => Err(EvaluateError::UnreachableLiteralArithmetic.into()),
                    },
                },
                (AstValue::Null, AstValue::Number(_)) | (AstValue::Number(_), AstValue::Null) => {
                    Ok(AstValue::Null)
                }
                _ => Err(EvaluateError::UnreachableLiteralArithmetic.into()),
            };

            match (self, other) {
                (LiteralRef(l), LiteralRef(r)) => literal_binary_op(l, r).map(Evaluated::Literal),
                (LiteralRef(l), Literal(r)) => literal_binary_op(l, &r).map(Evaluated::Literal),
                (LiteralRef(l), ValueRef(r)) => (r.clone_by(l)?).$name(r).map(Evaluated::Value),
                (LiteralRef(l), Value(r)) => (r.clone_by(l)?).$name(r).map(Evaluated::Value),
                (Literal(l), LiteralRef(r)) => literal_binary_op(&l, r).map(Evaluated::Literal),
                (Literal(l), Literal(r)) => literal_binary_op(&l, &r).map(Evaluated::Literal),
                (Literal(l), ValueRef(r)) => (r.clone_by(&l)?).$name(r).map(Evaluated::Value),
                (Literal(l), Value(r)) => (r.clone_by(&l)?).$name(r).map(Evaluated::Value),
                (ValueRef(l), LiteralRef(r)) => l.$name(&l.clone_by(r)?).map(Evaluated::Value),
                (ValueRef(l), Literal(r)) => l.$name(&l.clone_by(&r)?).map(Evaluated::Value),
                (ValueRef(l), ValueRef(r)) => l.$name(r).map(Evaluated::Value),
                (ValueRef(l), Value(r)) => l.$name(&r).map(Evaluated::Value),
                (Value(l), LiteralRef(r)) => (&l).$name(&&l.clone_by(r)?).map(Evaluated::Value),
                (Value(l), Literal(r)) => (&l).$name(&&l.clone_by(&r)?).map(Evaluated::Value),
                (Value(l), ValueRef(r)) => (&l).$name(r).map(Evaluated::Value),
                (Value(l), Value(r)) => (&l).$name(&r).map(Evaluated::Value),
                _ => Err(EvaluateError::UnreachableEvaluatedArithmetic.into()),
            }
        }
    };
}
macro_rules! unary_op {
    ($name:ident, $op:tt) => {
        pub fn $name(&self) -> Result<Evaluated<'a>> {
            let literal_unary_op = |v: &&AstValue| match v {
                AstValue::Number(v) => v
                    .parse::<i64>()
                    .map_or_else(
                        |_| v.parse::<f64>().map(|v| AstValue::Number((0.0 $op v).to_string())),
                        |v| Ok(AstValue::Number((0 $op v).to_string())),
                    )
                    .map_err(|_| EvaluateError::LiteralUnaryOperationOnNonNumeric.into()),
                AstValue::Null => Ok(AstValue::Null),
                _ => Err(EvaluateError::LiteralUnaryOperationOnNonNumeric.into()),
            };

            match self {
                LiteralRef(v) => literal_unary_op(v).map(Evaluated::Literal),
                Literal(v) => literal_unary_op(&v).map(Evaluated::Literal),
                ValueRef(v) => v.$name().map(Evaluated::Value),
                Value(v) => (&v).$name().map(Evaluated::Value),
                _ => Err(EvaluateError::UnreachableEvaluatedArithmetic.into()),
            }
        }
    };
}

macro_rules! general_op {
    ($name:ident, $type:ty, $literal:expr, $value:expr) => {
        pub fn $name(self, other: $type) -> Result<Evaluated<'a>> {
            let literal_op = $literal;
            let value_op = $value;

            match self {
                StringRef(value) => {
                    literal_op(&AstValue::SingleQuotedString(value.to_string()), other)
                }
                LiteralRef(value) => literal_op(value, other),
                Literal(value) => literal_op(&value, other),
                ValueRef(value) => value_op(value, other),
                Value(value) => value_op(&value, other),
            }
        }
    };
}

impl<'a> Evaluated<'a> {
    binary_op!(add, +);
    binary_op!(subtract, -);
    binary_op!(multiply, *);
    binary_op!(divide, /);
    unary_op!(unary_plus, +);
    unary_op!(unary_minus, -);
    general_op!(
        cast,
        &DataType,
        |value: &AstValue, data_type: &DataType| match (data_type, value) {
            (DataType::Boolean, AstValue::SingleQuotedString(value))
            | (DataType::Boolean, AstValue::Number(value)) =>
                Ok(match value.to_uppercase().as_str() {
                    "TRUE" | "1" => Ok(AstValue::Boolean(true)),
                    "FALSE" | "0" => Ok(AstValue::Boolean(false)),
                    _ => Err(EvaluateError::ImpossibleCast),
                }?),
            (DataType::Int, AstValue::Number(value)) => Ok(AstValue::Number(
                value
                    .parse::<f64>()
                    .map_err(|_| EvaluateError::UnreachableImpossibleCast)?
                    .trunc()
                    .to_string(),
            )),
            (DataType::Int, AstValue::SingleQuotedString(value))
            | (DataType::Float(_), AstValue::SingleQuotedString(value)) => {
                Ok(AstValue::Number(value.to_string()))
            }
            (DataType::Int, AstValue::Boolean(value))
            | (DataType::Float(_), AstValue::Boolean(value)) => Ok(AstValue::Number(
                (if *value { "1" } else { "0" }).to_string(),
            )),
            (DataType::Float(_), AstValue::Number(value)) =>
                Ok(AstValue::Number(value.to_string())),
            (DataType::Text, AstValue::Boolean(value)) => Ok(AstValue::SingleQuotedString(
                (if *value { "TRUE" } else { "FALSE" }).to_string(),
            )),
            (DataType::Text, AstValue::Number(value)) => {
                Ok(AstValue::SingleQuotedString(value.to_string()))
            }
            (_, AstValue::Null) => Ok(AstValue::Null),
            _ => Err(EvaluateError::UnimplementedCast.into()),
        }
        .map(Evaluated::Literal),
        |value: &data::Value, data_type: &DataType| value.cast(data_type).map(Evaluated::Value)
    );

    pub fn is_some(&self) -> bool {
        match self {
            Evaluated::ValueRef(v) => v.is_some(),
            Evaluated::Value(v) => v.is_some(),
            Evaluated::Literal(v) => v != &AstValue::Null,
            Evaluated::LiteralRef(v) => v != &&AstValue::Null,
            Evaluated::StringRef(_v) => true,
        }
    }
}
