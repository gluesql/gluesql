<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","cli","src","cli.rs"],"content":"use {\n    crate::{\n        command::{Command, CommandError},\n        helper::CliHelper,\n        print::Print,\n    },\n    edit::{Builder, edit_file, edit_with_builder},\n    futures::executor::block_on,\n    gluesql_core::{\n        prelude::Glue,\n        store::{GStore, GStoreMut},\n    },\n    rustyline::{Editor, error::ReadlineError},\n    std::{\n        error::Error,\n        fs::File,\n        io::{Read, Result, Write},\n        path::Path,\n    },\n};\n\npub struct Cli\u003cT, W\u003e\nwhere\n    T: GStore + GStoreMut,\n    W: Write,\n{\n    glue: Glue\u003cT\u003e,\n    print: Print\u003cW\u003e,\n}\n\nimpl\u003cT, W\u003e Cli\u003cT, W\u003e\nwhere\n    T: GStore + GStoreMut,\n    W: Write,\n{\n    pub fn new(storage: T, output: W) -\u003e Self {\n        let glue = Glue::new(storage);\n        let print = Print::new(output, None, Default::default());\n\n        Self { glue, print }\n    }\n\n    pub fn run(\u0026mut self) -\u003e std::result::Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        macro_rules! println {\n            ($($p:tt),*) =\u003e ( writeln!(\u0026mut self.print.output, $($p),*)?; )\n        }\n\n        self.print.help()?;\n\n        let mut rl = Editor::\u003cCliHelper\u003e::new();\n        rl.set_helper(Some(CliHelper));\n\n        loop {\n            let line = match rl.readline(\"gluesql\u003e \") {\n                Ok(line) =\u003e line,\n                Err(ReadlineError::Interrupted) =\u003e {\n                    println!(\"^C\");\n                    continue;\n                }\n                Err(ReadlineError::Eof) =\u003e {\n                    println!(\"bye\\n\");\n                    break;\n                }\n                Err(e) =\u003e {\n                    println!(\"[unknown error] {:?}\", e);\n                    break;\n                }\n            };\n\n            let line = line.trim();\n            if !(line.starts_with(\".edit\") || line.starts_with(\".run\")) {\n                rl.add_history_entry(line);\n            }\n\n            let command = match Command::parse(line, \u0026self.print.option) {\n                Ok(command) =\u003e command,\n                Err(CommandError::LackOfTable) =\u003e {\n                    println!(\"[error] should specify table. eg: .columns TableName\\n\");\n                    continue;\n                }\n                Err(CommandError::LackOfFile) =\u003e {\n                    println!(\"[error] should specify file path.\\n\");\n                    continue;\n                }\n                Err(CommandError::NotSupported) =\u003e {\n                    println!(\"[error] command not supported: {}\", line);\n                    println!(\"\\n  type .help to list all available commands.\\n\");\n                    continue;\n                }\n                Err(CommandError::LackOfOption) =\u003e {\n                    println!(\"[error] should specify option.\\n\");\n                    continue;\n                }\n                Err(CommandError::LackOfValue(usage)) =\u003e {\n                    println!(\"[error] should specify value.\\n{usage}\\n\");\n                    continue;\n                }\n                Err(CommandError::WrongOption(e)) =\u003e {\n                    println!(\"[error] cannot support option: {e}\\n\");\n                    continue;\n                }\n                Err(CommandError::LackOfSQLHistory) =\u003e {\n                    println!(\"[error] Nothing in SQL history to run.\\n\");\n                    continue;\n                }\n            };\n\n            match command {\n                Command::Help =\u003e {\n                    self.print.help()?;\n                    continue;\n                }\n                Command::Quit =\u003e {\n                    println!(\"bye\\n\");\n                    break;\n                }\n                Command::Execute(sql) =\u003e self.execute(sql)?,\n                Command::ExecuteFromFile(filename) =\u003e {\n                    if let Err(e) = self.load(\u0026filename) {\n                        println!(\"[error] {}\\n\", e);\n                    }\n                }\n                Command::SpoolOn(path) =\u003e {\n                    self.print.spool_on(path)?;\n                }\n                Command::SpoolOff =\u003e {\n                    self.print.spool_off();\n                }\n                Command::Set(option) =\u003e self.print.set_option(option),\n                Command::Show(option) =\u003e self.print.show_option(option)?,\n                Command::Edit(file_name) =\u003e {\n                    match file_name {\n                        Some(file_name) =\u003e {\n                            let file = Path::new(\u0026file_name);\n                            edit_file(file)?;\n                        }\n                        None =\u003e {\n                            let mut builder = Builder::new();\n                            builder.prefix(\"Glue_\").suffix(\".sql\");\n                            let last = rl.history().last().map_or_else(|| \"\", String::as_str);\n                            let edited = edit_with_builder(last, \u0026builder)?;\n                            rl.add_history_entry(edited);\n                        }\n                    };\n                }\n                Command::Run =\u003e {\n                    let sql = rl.history().last().ok_or(CommandError::LackOfSQLHistory);\n\n                    match sql {\n                        Ok(sql) =\u003e {\n                            self.execute(sql)?;\n                        }\n                        Err(e) =\u003e {\n                            println!(\"[error] {}\\n\", e);\n                        }\n                    };\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    fn execute(\u0026mut self, sql: impl AsRef\u003cstr\u003e) -\u003e Result\u003c()\u003e {\n        match block_on(self.glue.execute(sql)) {\n            Ok(payloads) =\u003e self.print.payloads(\u0026payloads)?,\n            Err(e) =\u003e {\n                println!(\"[error] {}\\n\", e);\n            }\n        };\n\n        Ok(())\n    }\n\n    pub fn load\u003cP: AsRef\u003cPath\u003e\u003e(\u0026mut self, filename: P) -\u003e Result\u003c()\u003e {\n        let mut sqls = String::new();\n        File::open(filename)?.read_to_string(\u0026mut sqls)?;\n        for sql in sqls.split(';').filter(|sql| !sql.trim().is_empty()) {\n            match block_on(self.glue.execute(sql)) {\n                Ok(payloads) =\u003e self.print.payloads(\u0026payloads)?,\n                Err(e) =\u003e {\n                    println!(\"[error] {}\\n\", e);\n                    break;\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":100},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","cli","src","command.rs"],"content":"use {crate::print::PrintOption, std::fmt::Debug, thiserror::Error as ThisError};\n\n#[derive(Debug, PartialEq, Eq)]\npub enum Command {\n    Help,\n    Quit,\n    Execute(String),\n    ExecuteFromFile(String),\n    SpoolOn(String),\n    SpoolOff,\n    Set(SetOption),\n    Show(ShowOption),\n    Edit(Option\u003cString\u003e),\n    Run,\n}\n\n#[derive(ThisError, Debug, PartialEq, Eq)]\npub enum CommandError {\n    #[error(\"should specify table\")]\n    LackOfTable,\n    #[error(\"should specify file path\")]\n    LackOfFile,\n    #[error(\"should specify value for option\")]\n    LackOfValue(String),\n    #[error(\"should specify option\")]\n    LackOfOption,\n    #[error(\"cannot support option: {0}\")]\n    WrongOption(String),\n    #[error(\"command not supported\")]\n    NotSupported,\n    #[error(\"Nothing in SQL history to run.\")]\n    LackOfSQLHistory,\n}\n\n#[derive(Eq, Debug, PartialEq)]\npub enum SetOption {\n    Tabular(bool),\n    Colsep(String),\n    Colwrap(String),\n    Heading(bool),\n}\n\nimpl SetOption {\n    fn parse(key: \u0026str, value: Option\u003c\u0026\u0026str\u003e, option: \u0026PrintOption) -\u003e Result\u003cSelf, CommandError\u003e {\n        fn bool_from(value: String) -\u003e Result\u003cbool, CommandError\u003e {\n            match value.to_uppercase().as_str() {\n                \"ON\" =\u003e Ok(true),\n                \"OFF\" =\u003e Ok(false),\n                _ =\u003e Err(CommandError::WrongOption(value)),\n            }\n        }\n\n        if let Some(value) = value {\n            let value = match *value {\n                \"\\\"\\\"\" =\u003e \"\",\n                _ =\u003e value,\n            }\n            .to_owned();\n\n            let set_option = match (key.to_lowercase().as_str(), \u0026option.tabular) {\n                (\"tabular\", _) =\u003e Self::Tabular(bool_from(value)?),\n                (\"colsep\", false) =\u003e Self::Colsep(value),\n                (\"colwrap\", false) =\u003e Self::Colwrap(value),\n                (\"heading\", false) =\u003e Self::Heading(bool_from(value)?),\n                (_, true) =\u003e return Err(CommandError::WrongOption(\"run .set tabular OFF\".into())),\n\n                _ =\u003e return Err(CommandError::WrongOption(key.into())),\n            };\n\n            Ok(set_option)\n        } else {\n            let payload = match key.to_lowercase().as_str() {\n                \"tabular\" =\u003e \"Usage: .set tabular {ON|OFF}\",\n                \"colsep\" =\u003e \"Usage: .set colsep {\\\"\\\"|TEXT}\",\n                \"colwrap\" =\u003e \"Usage: .set colwrap {\\\"\\\"|TEXT}\",\n                \"heading\" =\u003e \"Usage: .set heading {ON|OFF}\",\n\n                _ =\u003e return Err(CommandError::WrongOption(key.into())),\n            };\n\n            Err(CommandError::LackOfValue(payload.into()))\n        }\n    }\n}\n\n#[derive(Eq, Debug, PartialEq)]\npub enum ShowOption {\n    Tabular,\n    Colsep,\n    Colwrap,\n    Heading,\n    All,\n}\n\nimpl ShowOption {\n    fn parse(key: \u0026str) -\u003e Result\u003cSelf, CommandError\u003e {\n        let show_option = match key.to_lowercase().as_str() {\n            \"tabular\" =\u003e Self::Tabular,\n            \"colsep\" =\u003e Self::Colsep,\n            \"colwrap\" =\u003e Self::Colwrap,\n            \"heading\" =\u003e Self::Heading,\n            \"all\" =\u003e Self::All,\n            _ =\u003e return Err(CommandError::WrongOption(key.into())),\n        };\n\n        Ok(show_option)\n    }\n}\n\nimpl Command {\n    pub fn parse(line: \u0026str, option: \u0026PrintOption) -\u003e Result\u003cSelf, CommandError\u003e {\n        let line = line.trim_start().trim_end_matches([' ', ';']);\n        // We detect if the line is a command or not\n        if line.starts_with('.') {\n            let params: Vec\u003c\u0026str\u003e = line.split_whitespace().collect();\n            match params[0] {\n                \".help\" =\u003e Ok(Self::Help),\n                \".quit\" =\u003e Ok(Self::Quit),\n                \".tables\" =\u003e Ok(Self::Execute(\"SHOW TABLES\".to_owned())),\n                \".functions\" =\u003e Ok(Self::Execute(\"SHOW FUNCTIONS\".to_owned())),\n                \".columns\" =\u003e match params.get(1) {\n                    Some(table_name) =\u003e {\n                        Ok(Self::Execute(format!(\"SHOW COLUMNS FROM {}\", table_name)))\n                    }\n                    None =\u003e Err(CommandError::LackOfTable),\n                },\n                \".version\" =\u003e Ok(Self::Execute(\"SHOW VERSION\".to_owned())),\n                \".execute\" if params.len() == 2 =\u003e Ok(Self::ExecuteFromFile(params[1].to_owned())),\n                \".spool\" =\u003e match params.get(1) {\n                    Some(\u0026\"off\") =\u003e Ok(Self::SpoolOff),\n                    Some(path) =\u003e Ok(Self::SpoolOn(path.to_string())),\n                    None =\u003e Err(CommandError::LackOfFile),\n                },\n                \".set\" =\u003e match (params.get(1), params.get(2)) {\n                    (Some(key), value) =\u003e Ok(Self::Set(SetOption::parse(key, value, option)?)),\n                    (None, _) =\u003e Err(CommandError::LackOfOption),\n                },\n                \".show\" =\u003e match params.get(1) {\n                    Some(key) =\u003e Ok(Self::Show(ShowOption::parse(key)?)),\n                    None =\u003e Err(CommandError::LackOfOption),\n                },\n                \".edit\" =\u003e Ok(Self::Edit(params.get(1).map(|\u0026v| v.to_owned()))),\n                \".run\" =\u003e Ok(Self::Run),\n\n                _ =\u003e Err(CommandError::NotSupported),\n            }\n        } else {\n            Ok(Self::Execute(line.to_owned()))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{command::CommandError, print::PrintOption};\n\n    #[test]\n    fn parse_command() {\n        use super::{Command, SetOption, ShowOption};\n        let option = PrintOption::default();\n        let parse = |command| Command::parse(command, \u0026option);\n\n        assert_eq!(parse(\".help\"), Ok(Command::Help));\n        assert_eq!(parse(\"   .help;\"), Ok(Command::Help));\n        assert_eq!(parse(\".quit\"), Ok(Command::Quit));\n        assert_eq!(parse(\".quit;\"), Ok(Command::Quit));\n        assert_eq!(parse(\" .quit; \"), Ok(Command::Quit));\n        assert_eq!(parse(\".run\"), Ok(Command::Run));\n        assert_eq!(parse(\".edit\"), Ok(Command::Edit(None)));\n        assert_eq!(\n            parse(\".edit foo.sql\"),\n            Ok(Command::Edit(Some(\"foo.sql\".into())))\n        );\n        assert_eq!(\n            parse(\".tables\"),\n            Ok(Command::Execute(\"SHOW TABLES\".to_owned())),\n        );\n        assert_eq!(\n            parse(\".functions\"),\n            Ok(Command::Execute(\"SHOW FUNCTIONS\".to_owned())),\n        );\n        assert_eq!(\n            parse(\".columns Foo\"),\n            Ok(Command::Execute(\"SHOW COLUMNS FROM Foo\".to_owned())),\n        );\n        assert_eq!(parse(\".columns\"), Err(CommandError::LackOfTable));\n        assert_eq!(\n            parse(\".version\"),\n            Ok(Command::Execute(\"SHOW VERSION\".to_owned()))\n        );\n        assert_eq!(parse(\".foo\"), Err(CommandError::NotSupported));\n        assert_eq!(\n            parse(\"SELECT * FROM Foo;\"),\n            Ok(Command::Execute(\"SELECT * FROM Foo\".to_owned())),\n        );\n        assert_eq!(\n            parse(\".spool query.log\"),\n            Ok(Command::SpoolOn(\"query.log\".into()))\n        );\n        assert_eq!(parse(\".spool off\"), Ok(Command::SpoolOff));\n        assert_eq!(parse(\".spool\"), Err(CommandError::LackOfFile));\n        assert_eq!(\n            parse(\".set colsep ,\"),\n            Err(CommandError::WrongOption(\"run .set tabular OFF\".into()))\n        );\n        assert_eq!(\n            parse(\".set colwrap '\"),\n            Err(CommandError::WrongOption(\"run .set tabular OFF\".into()))\n        );\n        assert_eq!(\n            parse(\".set heading off\"),\n            Err(CommandError::WrongOption(\"run .set tabular OFF\".into()))\n        );\n        assert_eq!(parse(\".abc\"), Err(CommandError::NotSupported));\n        assert_eq!(\n            parse(\".set abc\"),\n            Err(CommandError::WrongOption(\"abc\".to_owned()))\n        );\n        assert_eq!(\n            parse(\".set tabular abc\"),\n            Err(CommandError::WrongOption(\"abc\".to_owned()))\n        );\n        assert_eq!(\n            parse(\".set tabular off\"),\n            Ok(Command::Set(SetOption::Tabular(false)))\n        );\n        assert_eq!(\n            parse(\".set tabular on\"),\n            Ok(Command::Set(SetOption::Tabular(true)))\n        );\n\n        let mut option = PrintOption::default();\n        option.tabular(false);\n        let parse = |command| Command::parse(command, \u0026option);\n\n        assert_eq!(\n            parse(\".set abc false\"),\n            Err(CommandError::WrongOption(\"abc\".to_owned()))\n        );\n        assert_eq!(\n            parse(\".set tabular\"),\n            Err(CommandError::LackOfValue(\n                \"Usage: .set tabular {ON|OFF}\".into()\n            ))\n        );\n        assert_eq!(\n            parse(\".set colsep\"),\n            Err(CommandError::LackOfValue(\n                \"Usage: .set colsep {\\\"\\\"|TEXT}\".into()\n            ))\n        );\n        assert_eq!(\n            parse(\".set colwrap\"),\n            Err(CommandError::LackOfValue(\n                \"Usage: .set colwrap {\\\"\\\"|TEXT}\".into()\n            ))\n        );\n        assert_eq!(\n            parse(\".set heading\"),\n            Err(CommandError::LackOfValue(\n                \"Usage: .set heading {ON|OFF}\".into()\n            ))\n        );\n        assert_eq!(parse(\".set\"), Err(CommandError::LackOfOption));\n        assert_eq!(\n            parse(\".show tabular\"),\n            Ok(Command::Show(ShowOption::Tabular))\n        );\n        assert_eq!(parse(\".show colsep\"), Ok(Command::Show(ShowOption::Colsep)));\n        assert_eq!(\n            parse(\".show colwrap\"),\n            Ok(Command::Show(ShowOption::Colwrap))\n        );\n        assert_eq!(\n            parse(\".show heading\"),\n            Ok(Command::Show(ShowOption::Heading))\n        );\n        assert_eq!(parse(\".show all\"), Ok(Command::Show(ShowOption::All)));\n        assert_eq!(\n            parse(\".show abc\"),\n            Err(CommandError::WrongOption(\"abc\".to_owned()))\n        );\n        assert_eq!(parse(\".show\"), Err(CommandError::LackOfOption));\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":59},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","cli","src","helper.rs"],"content":"use {\n    rustyline::{\n        Result,\n        validate::{ValidationContext, ValidationResult, Validator},\n    },\n    rustyline_derive::{Completer, Helper, Highlighter, Hinter},\n};\n\n#[derive(Completer, Helper, Highlighter, Hinter)]\npub struct CliHelper;\n\nimpl Validator for CliHelper {\n    fn validate(\u0026self, ctx: \u0026mut ValidationContext\u003c'_\u003e) -\u003e Result\u003cValidationResult\u003e {\n        let input = ctx.input().trim();\n\n        if input.ends_with(';') || input.starts_with('.') {\n            Ok(ValidationResult::Valid(None))\n        } else {\n            Ok(ValidationResult::Incomplete)\n        }\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","cli","src","lib.rs"],"content":"#![deny(clippy::str_to_string)]\n\nmod cli;\nmod command;\nmod helper;\nmod print;\n\nuse {\n    crate::cli::Cli,\n    anyhow::Result,\n    clap::Parser,\n    futures::{\n        executor::block_on,\n        stream::{StreamExt, TryStreamExt},\n    },\n    gluesql_core::{\n        ast::{Expr, SetExpr, Statement, ToSql, Values},\n        data::Value,\n        store::{DataRow, GStore, GStoreMut, Store, Transaction},\n    },\n    gluesql_csv_storage::CsvStorage,\n    gluesql_file_storage::FileStorage,\n    gluesql_json_storage::JsonStorage,\n    gluesql_memory_storage::MemoryStorage,\n    gluesql_parquet_storage::ParquetStorage,\n    gluesql_redb_storage::RedbStorage,\n    gluesql_sled_storage::SledStorage,\n    std::{\n        fmt::Debug,\n        fs::File,\n        io::Write,\n        path::{Path, PathBuf},\n    },\n};\n\n#[derive(Parser, Debug)]\n#[clap(name = \"gluesql\", about, version)]\nstruct Args {\n    /// SQL file to execute\n    #[clap(short, long, value_parser)]\n    execute: Option\u003cPathBuf\u003e,\n\n    /// PATH to dump whole database\n    #[clap(short, long, value_parser)]\n    dump: Option\u003cPathBuf\u003e,\n\n    /// Storage type to store data, default is memory\n    #[clap(short, long, value_parser)]\n    storage: Option\u003cStorage\u003e,\n\n    /// Storage path to load\n    #[clap(short, long, value_parser)]\n    path: Option\u003cPathBuf\u003e,\n}\n\n#[derive(clap::ValueEnum, Debug, Clone)]\nenum Storage {\n    Memory,\n    Sled,\n    Redb,\n    Json,\n    Csv,\n    Parquet,\n    File,\n}\n\npub fn run() -\u003e Result\u003c()\u003e {\n    let args = Args::parse();\n    let path = args.path.as_deref().and_then(Path::to_str);\n\n    match (path, args.storage, args.dump) {\n        (None, None, _) | (None, Some(Storage::Memory), _) =\u003e {\n            println!(\"[memory-storage] initialized\");\n\n            run(MemoryStorage::default(), args.execute);\n        }\n        (Some(_), Some(Storage::Memory), _) =\u003e {\n            panic!(\"failed to load memory-storage: it should be without path\");\n        }\n        (Some(path), Some(Storage::Sled), _) =\u003e {\n            println!(\"[sled-storage] connected to {}\", path);\n\n            run(\n                SledStorage::new(path).expect(\"failed to load sled-storage\"),\n                args.execute,\n            );\n        }\n        (Some(path), Some(Storage::Redb), _) =\u003e {\n            println!(\"[redb-storage] connected to {}\", path);\n\n            run(\n                RedbStorage::new(path).expect(\"failed to load redb-storage\"),\n                args.execute,\n            );\n        }\n        (Some(path), Some(Storage::Json), _) =\u003e {\n            println!(\"[json-storage] connected to {}\", path);\n\n            run(\n                JsonStorage::new(path).expect(\"failed to load json-storage\"),\n                args.execute,\n            );\n        }\n        (Some(path), Some(Storage::Csv), _) =\u003e {\n            println!(\"[csv-storage] connected to {}\", path);\n\n            run(\n                CsvStorage::new(path).expect(\"failed to load csv-storage\"),\n                args.execute,\n            );\n        }\n        (Some(path), Some(Storage::Parquet), _) =\u003e {\n            println!(\"[parquet-storage] connected to {}\", path);\n\n            run(\n                ParquetStorage::new(path).expect(\"failed to load parquet-storage\"),\n                args.execute,\n            );\n        }\n        (Some(path), Some(Storage::File), _) =\u003e {\n            println!(\"[file-storage] connected to {}\", path);\n\n            run(\n                FileStorage::new(path).expect(\"failed to load file-storage\"),\n                args.execute,\n            );\n        }\n        (Some(path), None, Some(dump_path)) =\u003e {\n            let mut storage = SledStorage::new(path).expect(\"failed to load sled-storage\");\n\n            dump_database(\u0026mut storage, dump_path)?;\n        }\n        (None, Some(_), _) | (Some(_), None, None) =\u003e {\n            panic!(\"both path and storage should be specified\");\n        }\n    }\n\n    fn run\u003cT: GStore + GStoreMut\u003e(storage: T, input: Option\u003cPathBuf\u003e) {\n        let output = std::io::stdout();\n        let mut cli = Cli::new(storage, output);\n\n        if let Some(path) = input {\n            if let Err(e) = cli.load(path.as_path()) {\n                println!(\"[error] {}\\n\", e);\n            };\n        }\n\n        if let Err(e) = cli.run() {\n            eprintln!(\"{}\", e);\n        }\n    }\n\n    Ok(())\n}\n\npub fn dump_database(storage: \u0026mut SledStorage, dump_path: PathBuf) -\u003e Result\u003c()\u003e {\n    let file = File::create(dump_path)?;\n\n    block_on(async {\n        storage.begin(true).await?;\n        let schemas = storage.fetch_all_schemas().await?;\n        for schema in schemas {\n            writeln!(\u0026file, \"{}\", schema.to_ddl())?;\n\n            let mut rows_list = storage\n                .scan_data(\u0026schema.table_name)\n                .await?\n                .map_ok(|(_, row)| row)\n                .chunks(100);\n\n            while let Some(rows) = rows_list.next().await {\n                let exprs_list = rows\n                    .into_iter()\n                    .map(|result| {\n                        result.map(|data_row| {\n                            let values = match data_row {\n                                DataRow::Vec(values) =\u003e values,\n                                DataRow::Map(values) =\u003e vec![Value::Map(values)],\n                            };\n\n                            values\n                                .into_iter()\n                                .map(|value| Ok(Expr::try_from(value)?))\n                                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n                        })?\n                    })\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n                let insert_statement = Statement::Insert {\n                    table_name: schema.table_name.clone(),\n                    columns: Vec::new(),\n                    source: gluesql_core::ast::Query {\n                        body: SetExpr::Values(Values(exprs_list)),\n                        order_by: Vec::new(),\n                        limit: None,\n                        offset: None,\n                    },\n                }\n                .to_sql();\n\n                writeln!(\u0026file, \"{}\", insert_statement)?;\n            }\n\n            writeln!(\u0026file)?;\n        }\n\n        Ok(())\n    })\n}\n","traces":[{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":82},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","cli","src","main.rs"],"content":"fn main() {\n    gluesql_cli::run().unwrap();\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":0}},{"line":2,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","cli","src","print.rs"],"content":"use {\n    crate::command::{SetOption, ShowOption},\n    gluesql_core::prelude::{Payload, PayloadVariable},\n    std::{\n        collections::{HashMap, HashSet},\n        fmt::Display,\n        fs::File,\n        io::{Result as IOResult, Write},\n        path::Path,\n    },\n    strum_macros::Display,\n    tabled::{Style, Table, builder::Builder},\n};\n\npub struct Print\u003cW: Write\u003e {\n    pub output: W,\n    spool_file: Option\u003cFile\u003e,\n    pub option: PrintOption,\n}\n\npub struct PrintOption {\n    pub tabular: bool,\n    colsep: String,\n    colwrap: String,\n    heading: bool,\n}\n\nimpl PrintOption {\n    pub fn tabular(\u0026mut self, tabular: bool) {\n        match tabular {\n            true =\u003e {\n                self.tabular = tabular;\n                self.colsep(\"|\".into());\n                self.colwrap(\"\".into());\n                self.heading(true);\n            }\n            false =\u003e self.tabular = tabular,\n        }\n    }\n\n    fn colsep(\u0026mut self, colsep: String) {\n        self.colsep = colsep;\n    }\n\n    fn colwrap(\u0026mut self, colwrap: String) {\n        self.colwrap = colwrap;\n    }\n\n    fn heading(\u0026mut self, heading: bool) {\n        self.heading = heading;\n    }\n\n    fn format(\u0026self, option: ShowOption) -\u003e String {\n        fn string_from(value: \u0026bool) -\u003e String {\n            match value {\n                true =\u003e \"ON\".into(),\n                false =\u003e \"OFF\".into(),\n            }\n        }\n        match option {\n            ShowOption::Tabular =\u003e format!(\"tabular {}\", string_from(\u0026self.tabular)),\n            ShowOption::Colsep =\u003e format!(\"colsep \\\"{}\\\"\", self.colsep),\n            ShowOption::Colwrap =\u003e format!(\"colwrap \\\"{}\\\"\", self.colwrap),\n            ShowOption::Heading =\u003e format!(\"heading {}\", string_from(\u0026self.heading)),\n            ShowOption::All =\u003e format!(\n                \"{}\\n{}\\n{}\\n{}\",\n                self.format(ShowOption::Tabular),\n                self.format(ShowOption::Colsep),\n                self.format(ShowOption::Colwrap),\n                self.format(ShowOption::Heading),\n            ),\n        }\n    }\n}\n\nimpl Default for PrintOption {\n    fn default() -\u003e Self {\n        Self {\n            tabular: true,\n            colsep: \"|\".into(),\n            colwrap: \"\".into(),\n            heading: true,\n        }\n    }\n}\n\nimpl\u003c'a, W: Write\u003e Print\u003cW\u003e {\n    pub fn new(output: W, spool_file: Option\u003cFile\u003e, option: PrintOption) -\u003e Self {\n        Print {\n            output,\n            spool_file,\n            option,\n        }\n    }\n\n    pub fn payloads(\u0026mut self, payloads: \u0026[Payload]) -\u003e IOResult\u003c()\u003e {\n        payloads.iter().try_for_each(|p| self.payload(p))\n    }\n\n    pub fn payload(\u0026mut self, payload: \u0026Payload) -\u003e IOResult\u003c()\u003e {\n        #[derive(Display)]\n        #[strum(serialize_all = \"snake_case\")]\n        enum Target {\n            Table,\n            Row,\n        }\n        let mut affected = |n: usize, target: Target, msg: \u0026str| -\u003e IOResult\u003c()\u003e {\n            let payload = format!(\"{n} {target}{} {msg}\", if n \u003e 1 { \"s\" } else { \"\" });\n            self.writeln(payload)\n        };\n\n        use Target::*;\n        match payload {\n            Payload::Create =\u003e self.writeln(\"Table created\")?,\n            Payload::DropTable(n) =\u003e affected(*n, Table, \"dropped\")?,\n            Payload::DropFunction =\u003e self.writeln(\"Function dropped\")?,\n            Payload::AlterTable =\u003e self.writeln(\"Table altered\")?,\n            Payload::CreateIndex =\u003e self.writeln(\"Index created\")?,\n            Payload::DropIndex =\u003e self.writeln(\"Index dropped\")?,\n            Payload::Commit =\u003e self.writeln(\"Commit completed\")?,\n            Payload::Rollback =\u003e self.writeln(\"Rollback completed\")?,\n            Payload::StartTransaction =\u003e self.writeln(\"Transaction started\")?,\n            Payload::Insert(n) =\u003e affected(*n, Row, \"inserted\")?,\n            Payload::Delete(n) =\u003e affected(*n, Row, \"deleted\")?,\n            Payload::Update(n) =\u003e affected(*n, Row, \"updated\")?,\n            Payload::ShowVariable(PayloadVariable::Version(v)) =\u003e self.writeln(format!(\"v{v}\"))?,\n            Payload::ShowVariable(PayloadVariable::Tables(names)) =\u003e {\n                let mut table = self.get_table([\"tables\"]);\n                for name in names {\n                    table.add_record([name]);\n                }\n                let table = self.build_table(table);\n                self.writeln(table)?;\n            }\n            Payload::ShowVariable(PayloadVariable::Functions(names)) =\u003e {\n                let mut table = self.get_table([\"functions\"]);\n                for name in names {\n                    table.add_record([name]);\n                }\n                let table = self.build_table(table);\n                self.writeln(table)?;\n            }\n            Payload::ShowColumns(columns) =\u003e {\n                let mut table = self.get_table(vec![\"Field\", \"Type\"]);\n                for (field, field_type) in columns {\n                    table.add_record([field, \u0026field_type.to_string()]);\n                }\n                let table = self.build_table(table);\n                self.writeln(table)?;\n            }\n            Payload::Select { labels, rows } =\u003e match \u0026self.option.tabular {\n                true =\u003e {\n                    let labels = labels.iter().map(AsRef::as_ref);\n                    let mut table = self.get_table(labels);\n                    for row in rows {\n                        let row: Vec\u003cString\u003e = row.iter().map(Into::into).collect();\n\n                        table.add_record(row);\n                    }\n                    let table = self.build_table(table);\n                    self.writeln(table)?;\n                }\n                false =\u003e {\n                    self.write_header(labels.iter().map(|s| s.as_str()))?;\n                    let rows = rows.iter().map(|row| row.iter().map(String::from));\n                    self.write_rows(rows)?;\n                }\n            },\n            Payload::SelectMap(rows) =\u003e {\n                let mut labels = rows\n                    .iter()\n                    .flat_map(HashMap::keys)\n                    .map(AsRef::as_ref)\n                    .collect::\u003cHashSet\u003c\u0026str\u003e\u003e()\n                    .into_iter()\n                    .collect::\u003cVec\u003c_\u003e\u003e();\n                labels.sort();\n\n                match \u0026self.option.tabular {\n                    true =\u003e {\n                        let mut table = self.get_table(labels.clone());\n                        for row in rows {\n                            let row = labels\n                                .iter()\n                                .map(|label| row.get(*label).map(Into::into).unwrap_or_default())\n                                .collect::\u003cVec\u003cString\u003e\u003e();\n\n                            table.add_record(row);\n                        }\n                        let table = self.build_table(table);\n                        self.writeln(table)?;\n                    }\n                    false =\u003e {\n                        self.write_header(labels.iter().map(AsRef::as_ref))?;\n\n                        let rows = rows.iter().map(|row| {\n                            labels\n                                .iter()\n                                .map(|label| row.get(*label).map(String::from).unwrap_or_default())\n                        });\n                        self.write_rows(rows)?;\n                    }\n                }\n            }\n        };\n\n        Ok(())\n    }\n\n    fn write_rows(\n        \u0026mut self,\n        rows: impl Iterator\u003cItem = impl Iterator\u003cItem = String\u003e\u003e,\n    ) -\u003e IOResult\u003c()\u003e {\n        for row in rows {\n            let row = row\n                .map(|v| format!(\"{c}{v}{c}\", c = self.option.colwrap))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(self.option.colsep.as_str());\n\n            self.write(row)?;\n        }\n\n        Ok(())\n    }\n\n    fn write_lf(\u0026mut self, payload: impl Display, lf: \u0026str) -\u003e IOResult\u003c()\u003e {\n        if let Some(file) = \u0026self.spool_file {\n            writeln!(file.to_owned(), \"{payload}{lf}\")?;\n        };\n\n        writeln!(self.output, \"{payload}{lf}\")\n    }\n\n    fn write(\u0026mut self, payload: impl Display) -\u003e IOResult\u003c()\u003e {\n        self.write_lf(payload, \"\")\n    }\n\n    fn writeln(\u0026mut self, payload: impl Display) -\u003e IOResult\u003c()\u003e {\n        self.write_lf(payload, \"\\n\")\n    }\n\n    fn write_header\u003c'b\u003e(\u0026mut self, labels: impl Iterator\u003cItem = \u0026'b str\u003e) -\u003e IOResult\u003c()\u003e {\n        let PrintOption {\n            heading,\n            colsep,\n            colwrap,\n            ..\n        } = \u0026self.option;\n\n        if !heading {\n            return Ok(());\n        }\n\n        let labels = labels\n            .map(|v| format!(\"{colwrap}{v}{colwrap}\"))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(colsep.as_str());\n\n        self.write(labels)\n    }\n\n    pub fn help(\u0026mut self) -\u003e IOResult\u003c()\u003e {\n        const HEADER: [\u0026str; 2] = [\"command\", \"description\"];\n        const CONTENT: [[\u0026str; 2]; 12] = [\n            [\".help\", \"show help\"],\n            [\".quit\", \"quit program\"],\n            [\".tables\", \"show table names\"],\n            [\".functions\", \"show function names\"],\n            [\".columns TABLE\", \"show columns from TABLE\"],\n            [\".version\", \"show version\"],\n            [\".execute PATH\", \"execute SQL from PATH\"],\n            [\".spool PATH|off\", \"spool to PATH or off\"],\n            [\".show OPTION\", \"show print option eg).show all\"],\n            [\".set OPTION\", \"set print option eg).set tabular off\"],\n            [\".edit [PATH]\", \"open editor with last command or PATH\"],\n            [\".run \", \"execute last command\"],\n        ];\n\n        let mut table = self.get_table(HEADER);\n        for row in CONTENT {\n            table.add_record(row);\n        }\n        let table = self.build_table(table);\n\n        writeln!(self.output, \"{}\\n\", table)\n    }\n\n    pub fn spool_on\u003cP: AsRef\u003cPath\u003e\u003e(\u0026mut self, filename: P) -\u003e IOResult\u003c()\u003e {\n        let file = File::create(filename)?;\n        self.spool_file = Some(file);\n\n        Ok(())\n    }\n\n    pub fn spool_off(\u0026mut self) {\n        self.spool_file = None;\n    }\n\n    fn get_table\u003cT: IntoIterator\u003cItem = \u0026'a str\u003e\u003e(\u0026self, headers: T) -\u003e Builder {\n        let mut table = Builder::default();\n        table.set_columns(headers);\n\n        table\n    }\n\n    fn build_table(\u0026self, builder: Builder) -\u003e Table {\n        builder.build().with(Style::markdown())\n    }\n\n    pub fn set_option(\u0026mut self, option: SetOption) {\n        match option {\n            SetOption::Tabular(value) =\u003e self.option.tabular(value),\n            SetOption::Colsep(value) =\u003e self.option.colsep(value),\n            SetOption::Colwrap(value) =\u003e self.option.colwrap(value),\n            SetOption::Heading(value) =\u003e self.option.heading(value),\n        }\n    }\n\n    pub fn show_option(\u0026mut self, option: ShowOption) -\u003e IOResult\u003c()\u003e {\n        let payload = self.option.format(option);\n        self.writeln(payload)?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::Print,\n        crate::command::{SetOption, ShowOption},\n        std::path::PathBuf,\n    };\n\n    #[test]\n    fn print_help() {\n        let mut print = Print::new(Vec::new(), None, Default::default());\n\n        let actual = {\n            print.help().unwrap();\n\n            String::from_utf8(print.output).unwrap()\n        };\n        let expected = \"\n| command         | description                           |\n|-----------------|---------------------------------------|\n| .help           | show help                             |\n| .quit           | quit program                          |\n| .tables         | show table names                      |\n| .functions      | show function names                   |\n| .columns TABLE  | show columns from TABLE               |\n| .version        | show version                          |\n| .execute PATH   | execute SQL from PATH                 |\n| .spool PATH|off | spool to PATH or off                  |\n| .show OPTION    | show print option eg).show all        |\n| .set OPTION     | set print option eg).set tabular off  |\n| .edit [PATH]    | open editor with last command or PATH |\n| .run            | execute last command                  |\";\n\n        assert_eq!(\n            actual.as_str().trim_matches('\\n'),\n            expected.trim_matches('\\n')\n        );\n    }\n\n    #[test]\n    fn print_payload() {\n        use gluesql_core::{\n            ast::DataType,\n            prelude::{Payload, PayloadVariable, Value},\n        };\n\n        let mut print = Print::new(Vec::new(), None, Default::default());\n\n        macro_rules! test {\n            ($payload: expr, $expected: literal ) =\u003e {\n                print.payloads(\u0026[$payload]).unwrap();\n\n                assert_eq!(\n                    String::from_utf8(print.output.clone())\n                        .unwrap()\n                        .as_str()\n                        .trim_matches('\\n'),\n                    $expected.trim_matches('\\n')\n                );\n\n                print.output.clear();\n            };\n        }\n\n        test!(Payload::Create, \"Table created\");\n        test!(Payload::DropTable(1), \"1 table dropped\");\n        test!(Payload::AlterTable, \"Table altered\");\n        test!(Payload::CreateIndex, \"Index created\");\n        test!(Payload::DropIndex, \"Index dropped\");\n        test!(Payload::DropFunction, \"Function dropped\");\n        test!(Payload::Commit, \"Commit completed\");\n        test!(Payload::Rollback, \"Rollback completed\");\n        test!(Payload::StartTransaction, \"Transaction started\");\n        test!(Payload::Insert(0), \"0 row inserted\");\n        test!(Payload::Insert(1), \"1 row inserted\");\n        test!(Payload::Insert(7), \"7 rows inserted\");\n        test!(Payload::Delete(300), \"300 rows deleted\");\n        test!(Payload::Update(123), \"123 rows updated\");\n        test!(\n            Payload::ShowVariable(PayloadVariable::Version(\"11.6.1989\".to_owned())),\n            \"v11.6.1989\"\n        );\n        test!(\n            Payload::ShowVariable(PayloadVariable::Tables(Vec::new())),\n            \"\n| tables |\"\n        );\n        test!(\n            Payload::ShowVariable(PayloadVariable::Functions(Vec::new())),\n            \"\n| functions |\"\n        );\n        test!(\n            Payload::ShowVariable(PayloadVariable::Tables(\n                [\n                    \"Allocator\",\n                    \"ExtendFromWithin\",\n                    \"IntoRawParts\",\n                    \"Reserve\",\n                    \"Splice\",\n                ]\n                .into_iter()\n                .map(ToOwned::to_owned)\n                .collect()\n            )),\n            \"\n| tables           |\n|------------------|\n| Allocator        |\n| ExtendFromWithin |\n| IntoRawParts     |\n| Reserve          |\n| Splice           |\"\n        );\n        test!(\n            Payload::ShowVariable(PayloadVariable::Functions(\n                [\n                    \"Allocator\",\n                    \"ExtendFromWithin\",\n                    \"IntoRawParts\",\n                    \"Reserve\",\n                    \"Splice\",\n                ]\n                .into_iter()\n                .map(ToOwned::to_owned)\n                .collect()\n            )),\n            \"\n| functions        |\n|------------------|\n| Allocator        |\n| ExtendFromWithin |\n| IntoRawParts     |\n| Reserve          |\n| Splice           |\"\n        );\n        test!(\n            Payload::Select {\n                labels: vec![\"id\".to_owned()],\n                rows: [101, 202, 301, 505, 1001]\n                    .into_iter()\n                    .map(Value::I64)\n                    .map(|v| vec![v])\n                    .collect::\u003cVec\u003cVec\u003cValue\u003e\u003e\u003e(),\n            },\n            \"\n| id   |\n|------|\n| 101  |\n| 202  |\n| 301  |\n| 505  |\n| 1001 |\"\n        );\n        test!(\n            Payload::Select {\n                labels: [\"id\", \"title\", \"valid\"]\n                    .into_iter()\n                    .map(ToOwned::to_owned)\n                    .collect(),\n                rows: vec![\n                    vec![\n                        Value::I64(1),\n                        Value::Str(\"foo\".to_owned()),\n                        Value::Bool(true)\n                    ],\n                    vec![\n                        Value::I64(2),\n                        Value::Str(\"bar\".to_owned()),\n                        Value::Bool(false)\n                    ],\n                    vec![\n                        Value::I64(3),\n                        Value::Str(\"bas\".to_owned()),\n                        Value::Bool(false)\n                    ],\n                    vec![\n                        Value::I64(4),\n                        Value::Str(\"lim\".to_owned()),\n                        Value::Bool(true)\n                    ],\n                    vec![\n                        Value::I64(5),\n                        Value::Str(\"kim\".to_owned()),\n                        Value::Bool(true)\n                    ],\n                ],\n            },\n            \"\n| id | title | valid |\n|----|-------|-------|\n| 1  | foo   | TRUE  |\n| 2  | bar   | FALSE |\n| 3  | bas   | FALSE |\n| 4  | lim   | TRUE  |\n| 5  | kim   | TRUE  |\"\n        );\n\n        test!(\n            Payload::SelectMap(vec![\n                [\n                    (\"id\".to_owned(), Value::I64(1)),\n                    (\"title\".to_owned(), Value::Str(\"foo\".to_owned()))\n                ]\n                .into_iter()\n                .collect(),\n                [(\"id\".to_owned(), Value::I64(2))].into_iter().collect(),\n                [(\"title\".to_owned(), Value::Str(\"bar\".to_owned()))]\n                    .into_iter()\n                    .collect(),\n            ]),\n            \"\n| id | title |\n|----|-------|\n| 1  | foo   |\n| 2  |       |\n|    | bar   |\"\n        );\n\n        test!(\n            Payload::ShowColumns(vec![\n                (\"id\".to_owned(), DataType::Int),\n                (\"name\".to_owned(), DataType::Text),\n                (\"isabear\".to_owned(), DataType::Boolean),\n            ],),\n            \"\n| Field   | Type    |\n|---------|---------|\n| id      | INT     |\n| name    | TEXT    |\n| isabear | BOOLEAN |\"\n        );\n\n        test!(\n            Payload::ShowColumns(vec![\n                (\"id\".to_owned(), DataType::Int8),\n                (\"calc1\".to_owned(), DataType::Float),\n                (\"cost\".to_owned(), DataType::Decimal),\n                (\"DOB\".to_owned(), DataType::Date),\n                (\"clock\".to_owned(), DataType::Time),\n                (\"tstamp\".to_owned(), DataType::Timestamp),\n                (\"ival\".to_owned(), DataType::Interval),\n                (\"uuid\".to_owned(), DataType::Uuid),\n                (\"hash\".to_owned(), DataType::Map),\n                (\"mylist\".to_owned(), DataType::List),\n            ],),\n            \"\n| Field  | Type      |\n|--------|-----------|\n| id     | INT8      |\n| calc1  | FLOAT     |\n| cost   | DECIMAL   |\n| DOB    | DATE      |\n| clock  | TIME      |\n| tstamp | TIMESTAMP |\n| ival   | INTERVAL  |\n| uuid   | UUID      |\n| hash   | MAP       |\n| mylist | LIST      |\"\n        );\n\n        // \".set tabular OFF\" should print SELECTED payload without tabular option\n        print.set_option(SetOption::Tabular(false));\n        test!(\n            Payload::Select {\n                labels: [\"id\", \"title\", \"valid\"]\n                    .into_iter()\n                    .map(ToOwned::to_owned)\n                    .collect(),\n                rows: vec![\n                    vec![\n                        Value::I64(1),\n                        Value::Str(\"foo\".to_owned()),\n                        Value::Bool(true)\n                    ],\n                    vec![\n                        Value::I64(2),\n                        Value::Str(\"bar\".to_owned()),\n                        Value::Bool(false)\n                    ],\n                ]\n            },\n            \"\nid|title|valid\n1|foo|TRUE\n2|bar|FALSE\"\n        );\n\n        test!(\n            Payload::SelectMap(vec![\n                [\n                    (\"id\".to_owned(), Value::I64(1)),\n                    (\"title\".to_owned(), Value::Str(\"foo\".to_owned()))\n                ]\n                .into_iter()\n                .collect(),\n                [(\"id\".to_owned(), Value::I64(2))].into_iter().collect(),\n                [(\"title\".to_owned(), Value::Str(\"bar\".to_owned()))]\n                    .into_iter()\n                    .collect(),\n            ]),\n            \"\nid|title\n1|foo\n2|\n|bar\"\n        );\n\n        // \".set colsep ,\" should set column separator as \",\"\n        print.set_option(SetOption::Colsep(\",\".into()));\n        assert_eq!(print.option.format(ShowOption::Colsep), r#\"colsep \",\"\"#);\n\n        test!(\n            Payload::Select {\n                labels: [\"id\", \"title\", \"valid\"]\n                    .into_iter()\n                    .map(ToOwned::to_owned)\n                    .collect(),\n                rows: vec![\n                    vec![\n                        Value::I64(1),\n                        Value::Str(\"foo\".to_owned()),\n                        Value::Bool(true)\n                    ],\n                    vec![\n                        Value::I64(2),\n                        Value::Str(\"bar\".to_owned()),\n                        Value::Bool(false)\n                    ],\n                ],\n            },\n            \"\nid,title,valid\n1,foo,TRUE\n2,bar,FALSE\"\n        );\n\n        // \".set colwrap '\" should set column separator as \"'\"\n        print.set_option(SetOption::Colwrap(\"'\".into()));\n        assert_eq!(print.option.format(ShowOption::Colwrap), r#\"colwrap \"'\"\"#);\n        test!(\n            Payload::Select {\n                labels: [\"id\", \"title\", \"valid\"]\n                    .into_iter()\n                    .map(ToOwned::to_owned)\n                    .collect(),\n                rows: vec![\n                    vec![\n                        Value::I64(1),\n                        Value::Str(\"foo\".to_owned()),\n                        Value::Bool(true)\n                    ],\n                    vec![\n                        Value::I64(2),\n                        Value::Str(\"bar\".to_owned()),\n                        Value::Bool(false)\n                    ],\n                ],\n            },\n            \"\n'id','title','valid'\n'1','foo','TRUE'\n'2','bar','FALSE'\"\n        );\n\n        // \".set header OFF should print without column name\"\n        print.set_option(SetOption::Heading(false));\n        test!(\n            Payload::Select {\n                labels: [\"id\", \"title\", \"valid\"]\n                    .into_iter()\n                    .map(ToOwned::to_owned)\n                    .collect(),\n                rows: vec![\n                    vec![\n                        Value::I64(1),\n                        Value::Str(\"foo\".to_owned()),\n                        Value::Bool(true)\n                    ],\n                    vec![\n                        Value::I64(2),\n                        Value::Str(\"bar\".to_owned()),\n                        Value::Bool(false)\n                    ],\n                ],\n            },\n            \"\n'1','foo','TRUE'\n'2','bar','FALSE'\"\n        );\n\n        // \".set header ON should print with column name\"\n        print.set_option(SetOption::Heading(true));\n        print.set_option(SetOption::Tabular(false));\n        test!(\n            Payload::Select {\n                labels: [\"id\", \"title\", \"valid\"]\n                    .into_iter()\n                    .map(ToOwned::to_owned)\n                    .collect(),\n                rows: vec![\n                    vec![\n                        Value::I64(1),\n                        Value::Str(\"foo\".to_owned()),\n                        Value::Bool(true)\n                    ],\n                    vec![\n                        Value::I64(2),\n                        Value::Str(\"bar\".to_owned()),\n                        Value::Bool(false)\n                    ],\n                ],\n            },\n            \"\n'id','title','valid'\n'1','foo','TRUE'\n'2','bar','FALSE'\"\n        );\n\n        print.set_option(SetOption::Heading(false));\n        print.set_option(SetOption::Tabular(false));\n        test!(\n            Payload::Select {\n                labels: [\"id\"].into_iter().map(ToOwned::to_owned).collect(),\n                rows: vec![vec![Value::I64(1),], vec![Value::I64(2),],],\n            },\n            \"'1'\\n'2'\"\n        );\n\n        // \".set tabular ON\" should recover default option: colsep(\"|\"), colwrap(\"\")\n        print.set_option(SetOption::Tabular(true));\n        assert_eq!(print.option.format(ShowOption::Tabular), \"tabular ON\");\n        assert_eq!(print.option.format(ShowOption::Colsep), r#\"colsep \"|\"\"#);\n        assert_eq!(print.option.format(ShowOption::Colwrap), r#\"colwrap \"\"\"#);\n        assert_eq!(print.option.format(ShowOption::Heading), \"heading ON\");\n        assert_eq!(\n            print.option.format(ShowOption::All),\n            \"\ntabular ON\ncolsep \\\"|\\\"\ncolwrap \\\"\\\"\nheading ON\"\n                .trim_matches('\\n')\n        );\n    }\n\n    #[test]\n    fn print_spool() {\n        use std::fs;\n\n        let mut print = Print::new(Vec::new(), None, Default::default());\n\n        // Spooling on file\n        fs::create_dir_all(\"tmp\").unwrap();\n        assert!(print.spool_on(PathBuf::from(\"tmp/spool.txt\")).is_ok());\n        assert!(print.writeln(\"Test\").is_ok());\n        assert!(print.show_option(ShowOption::All).is_ok());\n        print.spool_off();\n        assert!(print.writeln(\"Test\").is_ok());\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":162},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","cli","tests","dump.rs"],"content":"use {\n    gluesql_cli::dump_database,\n    gluesql_core::prelude::Glue,\n    gluesql_sled_storage::{SledStorage, sled},\n    std::{fs::File, io::Read, path::PathBuf},\n};\n\n#[tokio::test]\nasync fn dump_and_import() {\n    let data_path = \"tmp/src\";\n    let dump_path = PathBuf::from(\"tmp/dump.sql\");\n\n    let config = sled::Config::default().path(data_path).temporary(true);\n    let source_storage = SledStorage::try_from(config).unwrap();\n    let mut source_glue = Glue::new(source_storage);\n\n    let sqls = vec![\n        \"CREATE TABLE Foo (\n            boolean BOOLEAN,\n            int8 INT8,\n            int16 INT16,\n            int32 INT32,\n            int INT,\n            int128 INT128,\n            uinti8 UINT8,\n            text TEXT,\n            bytea BYTEA,\n            inet INET,\n            date DATE,\n            timestamp TIMESTAMP,\n            time TIME,\n            interval INTERVAL,\n            uuid UUID,\n            map MAP,\n            list LIST\n         );\",\n        r#\"INSERT INTO Foo\n         VALUES (\n         true,\n         1,\n         2,\n         3,\n         4,\n         5,\n         6,\n         'a',\n         X'123456',\n         '::1',\n         DATE '2022-11-01',\n         TIMESTAMP '2022-11-02',\n         TIME '23:59:59',\n         INTERVAL '1' DAY,\n         '550e8400-e29b-41d4-a716-446655440000',\n         '{\"a\": {\"red\": \"apple\", \"blue\": 1}, \"b\": 10}',\n         '[{ \"foo\": 100, \"bar\": [true, 0, [10.5, false] ] }, 10, 20]'\n         );\"#,\n        \"CREATE INDEX Foo_int ON Foo (int);\",\n        \"CREATE TABLE Bar AS SELECT N FROM SERIES(101);\",\n        \"CREATE TABLE Baz;\",\n        r#\"\n        INSERT INTO Baz VALUES\n            ('{\"a\": {\"red\": \"apple\", \"blue\": 1}, \"b\": 10}'),\n            ('{\"a\": 100, \"c\": true}');\n        \"#,\n    ];\n\n    for sql in sqls {\n        source_glue.execute(sql).await.unwrap();\n    }\n\n    dump_database(\u0026mut source_glue.storage, dump_path.clone()).unwrap();\n\n    let data_path = \"tmp/target\";\n    let config = sled::Config::default().path(data_path).temporary(true);\n    let target_storage = SledStorage::try_from(config).unwrap();\n    let mut target_glue = Glue::new(target_storage);\n\n    let mut sqls = String::new();\n    File::open(dump_path)\n        .unwrap()\n        .read_to_string(\u0026mut sqls)\n        .unwrap();\n\n    for sql in sqls.split(';').filter(|sql| !sql.trim().is_empty()) {\n        target_glue.execute(sql).await.unwrap();\n    }\n\n    // schemas should be identical\n    let sql = \"SELECT OBJECT_TYPE, OBJECT_NAME FROM GLUE_OBJECTS\";\n    let source_data = source_glue.execute(sql).await.unwrap();\n    let target_data = target_glue.execute(sql).await.unwrap();\n    assert_eq!(source_data, target_data);\n\n    // data should be identical\n    let sql = \"SELECT * FROM Foo JOIN Bar;\";\n    let source_data = source_glue.execute(sql).await.unwrap();\n    let target_data = target_glue.execute(sql).await.unwrap();\n    assert_eq!(source_data, target_data);\n\n    let sql = \"SELECT * FROM Baz;\";\n    let source_data = source_glue.execute(sql).await.unwrap();\n    let target_data = target_glue.execute(sql).await.unwrap();\n    assert_eq!(source_data, target_data);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast","ast_literal.rs"],"content":"use {\n    crate::ast::ToSql,\n    bigdecimal::BigDecimal,\n    serde::{Deserialize, Serialize},\n    strum_macros::Display,\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum AstLiteral {\n    Boolean(bool),\n    Number(BigDecimal),\n    QuotedString(String),\n    HexString(String),\n    Null,\n}\n\nimpl ToSql for AstLiteral {\n    fn to_sql(\u0026self) -\u003e String {\n        match self {\n            AstLiteral::Boolean(b) =\u003e b.to_string().to_uppercase(),\n            AstLiteral::Number(n) =\u003e n.to_string(),\n            AstLiteral::QuotedString(qs) =\u003e {\n                let escaped = qs.replace('\\'', \"''\");\n                format!(\"'{escaped}'\")\n            }\n            AstLiteral::HexString(hs) =\u003e format!(\"'{hs}'\"),\n            AstLiteral::Null =\u003e \"NULL\".to_owned(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Display)]\n#[strum(serialize_all = \"SCREAMING_SNAKE_CASE\")]\npub enum DateTimeField {\n    Year,\n    Month,\n    Day,\n    Hour,\n    Minute,\n    Second,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Display)]\n#[strum(serialize_all = \"SCREAMING_SNAKE_CASE\")]\npub enum TrimWhereField {\n    Both,\n    Leading,\n    Trailing,\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::ast::{AstLiteral, ToSql},\n        bigdecimal::BigDecimal,\n    };\n\n    #[test]\n    fn to_sql() {\n        assert_eq!(\"TRUE\", AstLiteral::Boolean(true).to_sql());\n        assert_eq!(\"123\", AstLiteral::Number(BigDecimal::from(123)).to_sql());\n        assert_eq!(\n            \"'hello'\",\n            AstLiteral::QuotedString(\"hello\".to_owned()).to_sql()\n        );\n        assert_eq!(\n            \"'can''t'\",\n            AstLiteral::QuotedString(\"can't\".to_owned()).to_sql()\n        );\n        assert_eq!(\"NULL\", AstLiteral::Null.to_sql());\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast","data_type.rs"],"content":"use {\n    serde::{Deserialize, Serialize},\n    strum_macros::Display,\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Display)]\n#[strum(serialize_all = \"SCREAMING_SNAKE_CASE\")]\npub enum DataType {\n    Boolean,\n    Int8,\n    Int16,\n    Int32,\n    Int,\n    Int128,\n    Uint8,\n    Uint16,\n    Uint32,\n    Uint64,\n    Uint128,\n    Float32,\n    Float,\n    Text,\n    Bytea,\n    Inet,\n    Date,\n    Timestamp,\n    Time,\n    Interval,\n    Uuid,\n    Map,\n    List,\n    Decimal,\n    Point,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast","ddl.rs"],"content":"use {\n    super::{DataType, Expr},\n    crate::ast::ToSql,\n    serde::{Deserialize, Serialize},\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum AlterTableOperation {\n    /// `ADD [ COLUMN ] \u003ccolumn_def\u003e`\n    AddColumn { column_def: ColumnDef },\n    /// `DROP [ COLUMN ] [ IF EXISTS ] \u003ccolumn_name\u003e [ CASCADE ]`\n    DropColumn {\n        column_name: String,\n        if_exists: bool,\n    },\n    /// `RENAME [ COLUMN ] \u003cold_column_name\u003e TO \u003cnew_column_name\u003e`\n    RenameColumn {\n        old_column_name: String,\n        new_column_name: String,\n    },\n    /// `RENAME TO \u003ctable_name\u003e`\n    RenameTable { table_name: String },\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ColumnDef {\n    pub name: String,\n    pub data_type: DataType,\n    pub nullable: bool,\n    /// `DEFAULT \u003crestricted-expr\u003e`\n    pub default: Option\u003cExpr\u003e,\n    /// `{ PRIMARY KEY | UNIQUE }`\n    pub unique: Option\u003cColumnUniqueOption\u003e,\n    pub comment: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ColumnUniqueOption {\n    pub is_primary: bool,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct OperateFunctionArg {\n    pub name: String,\n    pub data_type: DataType,\n    /// `DEFAULT \u003crestricted-expr\u003e`\n    pub default: Option\u003cExpr\u003e,\n}\n\nimpl ToSql for AlterTableOperation {\n    fn to_sql(\u0026self) -\u003e String {\n        match self {\n            AlterTableOperation::AddColumn { column_def } =\u003e {\n                format!(\"ADD COLUMN {}\", column_def.to_sql())\n            }\n            AlterTableOperation::DropColumn {\n                column_name,\n                if_exists,\n            } =\u003e match if_exists {\n                true =\u003e format!(r#\"DROP COLUMN IF EXISTS \"{column_name}\"\"#),\n                false =\u003e format!(r#\"DROP COLUMN \"{column_name}\"\"#),\n            },\n            AlterTableOperation::RenameColumn {\n                old_column_name,\n                new_column_name,\n            } =\u003e format!(r#\"RENAME COLUMN \"{old_column_name}\" TO \"{new_column_name}\"\"#),\n            AlterTableOperation::RenameTable { table_name } =\u003e {\n                format!(r#\"RENAME TO \"{table_name}\"\"#)\n            }\n        }\n    }\n}\n\nimpl ToSql for ColumnDef {\n    fn to_sql(\u0026self) -\u003e String {\n        let ColumnDef {\n            name,\n            data_type,\n            nullable,\n            default,\n            unique,\n            comment,\n        } = self;\n        {\n            let nullable = match nullable {\n                true =\u003e \"NULL\",\n                false =\u003e \"NOT NULL\",\n            };\n            let column_def = format!(r#\"\"{name}\" {data_type} {nullable}\"#);\n            let default = default\n                .as_ref()\n                .map(|expr| format!(\"DEFAULT {}\", expr.to_sql()));\n            let unique = unique.as_ref().map(ToSql::to_sql);\n            let comment = comment\n                .as_ref()\n                .map(|comment| format!(\"COMMENT '{}'\", comment));\n\n            [Some(column_def), default, unique, comment]\n                .into_iter()\n                .flatten()\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\" \")\n        }\n    }\n}\n\nimpl ToSql for ColumnUniqueOption {\n    fn to_sql(\u0026self) -\u003e String {\n        if self.is_primary {\n            \"PRIMARY KEY\"\n        } else {\n            \"UNIQUE\"\n        }\n        .to_owned()\n    }\n}\n\nimpl ToSql for OperateFunctionArg {\n    fn to_sql(\u0026self) -\u003e String {\n        let OperateFunctionArg {\n            name,\n            data_type,\n            default,\n        } = self;\n        let default = default\n            .as_ref()\n            .map(|expr| format!(\" DEFAULT {}\", expr.to_sql()))\n            .unwrap_or_else(|| \"\".to_owned());\n        format!(r#\"\"{name}\" {data_type}{default}\"#)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::{\n        AstLiteral, ColumnDef, ColumnUniqueOption, DataType, Expr, OperateFunctionArg, ToSql,\n    };\n\n    #[test]\n    fn to_sql_column_def() {\n        assert_eq!(\n            r#\"\"name\" TEXT NOT NULL UNIQUE\"#,\n            ColumnDef {\n                name: \"name\".to_owned(),\n                data_type: DataType::Text,\n                nullable: false,\n                default: None,\n                unique: Some(ColumnUniqueOption { is_primary: false }),\n                comment: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"accepted\" BOOLEAN NULL\"#,\n            ColumnDef {\n                name: \"accepted\".to_owned(),\n                data_type: DataType::Boolean,\n                nullable: true,\n                default: None,\n                unique: None,\n                comment: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"id\" INT NOT NULL PRIMARY KEY\"#,\n            ColumnDef {\n                name: \"id\".to_owned(),\n                data_type: DataType::Int,\n                nullable: false,\n                default: None,\n                unique: Some(ColumnUniqueOption { is_primary: true }),\n                comment: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"accepted\" BOOLEAN NOT NULL DEFAULT FALSE\"#,\n            ColumnDef {\n                name: \"accepted\".to_owned(),\n                data_type: DataType::Boolean,\n                nullable: false,\n                default: Some(Expr::Literal(AstLiteral::Boolean(false))),\n                unique: None,\n                comment: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"accepted\" BOOLEAN NOT NULL DEFAULT FALSE UNIQUE\"#,\n            ColumnDef {\n                name: \"accepted\".to_owned(),\n                data_type: DataType::Boolean,\n                nullable: false,\n                default: Some(Expr::Literal(AstLiteral::Boolean(false))),\n                unique: Some(ColumnUniqueOption { is_primary: false }),\n                comment: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"accepted\" BOOLEAN NOT NULL COMMENT 'this is comment'\"#,\n            ColumnDef {\n                name: \"accepted\".to_owned(),\n                data_type: DataType::Boolean,\n                nullable: false,\n                default: None,\n                unique: None,\n                comment: Some(\"this is comment\".to_owned()),\n            }\n            .to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_operate_function_arg() {\n        assert_eq!(\n            r#\"\"name\" TEXT\"#,\n            OperateFunctionArg {\n                name: \"name\".to_owned(),\n                data_type: DataType::Text,\n                default: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"accepted\" BOOLEAN DEFAULT FALSE\"#,\n            OperateFunctionArg {\n                name: \"accepted\".to_owned(),\n                data_type: DataType::Boolean,\n                default: Some(Expr::Literal(AstLiteral::Boolean(false))),\n            }\n            .to_sql()\n        );\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast","expr.rs"],"content":"use {\n    super::{\n        Aggregate, AstLiteral, BinaryOperator, DataType, DateTimeField, Function, Query, ToSql,\n        ToSqlUnquoted, UnaryOperator,\n    },\n    serde::{Deserialize, Serialize},\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Expr {\n    Identifier(String),\n    CompoundIdentifier {\n        alias: String,\n        ident: String,\n    },\n    IsNull(Box\u003cExpr\u003e),\n    IsNotNull(Box\u003cExpr\u003e),\n    InList {\n        expr: Box\u003cExpr\u003e,\n        list: Vec\u003cExpr\u003e,\n        negated: bool,\n    },\n    InSubquery {\n        expr: Box\u003cExpr\u003e,\n        subquery: Box\u003cQuery\u003e,\n        negated: bool,\n    },\n    Between {\n        expr: Box\u003cExpr\u003e,\n        negated: bool,\n        low: Box\u003cExpr\u003e,\n        high: Box\u003cExpr\u003e,\n    },\n    Like {\n        expr: Box\u003cExpr\u003e,\n        negated: bool,\n        pattern: Box\u003cExpr\u003e,\n    },\n    ILike {\n        expr: Box\u003cExpr\u003e,\n        negated: bool,\n        pattern: Box\u003cExpr\u003e,\n    },\n    BinaryOp {\n        left: Box\u003cExpr\u003e,\n        op: BinaryOperator,\n        right: Box\u003cExpr\u003e,\n    },\n    UnaryOp {\n        op: UnaryOperator,\n        expr: Box\u003cExpr\u003e,\n    },\n    Nested(Box\u003cExpr\u003e),\n    Literal(AstLiteral),\n    TypedString {\n        data_type: DataType,\n        value: String,\n    },\n    Function(Box\u003cFunction\u003e),\n    Aggregate(Box\u003cAggregate\u003e),\n    Exists {\n        subquery: Box\u003cQuery\u003e,\n        negated: bool,\n    },\n    Subquery(Box\u003cQuery\u003e),\n    Case {\n        operand: Option\u003cBox\u003cExpr\u003e\u003e,\n        when_then: Vec\u003c(Expr, Expr)\u003e,\n        else_result: Option\u003cBox\u003cExpr\u003e\u003e,\n    },\n    ArrayIndex {\n        obj: Box\u003cExpr\u003e,\n        indexes: Vec\u003cExpr\u003e,\n    },\n    Interval {\n        expr: Box\u003cExpr\u003e,\n        leading_field: Option\u003cDateTimeField\u003e,\n        last_field: Option\u003cDateTimeField\u003e,\n    },\n    Array {\n        elem: Vec\u003cExpr\u003e,\n    },\n}\n\nimpl ToSql for Expr {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for Expr {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl Expr {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        match self {\n            Expr::Identifier(s) =\u003e match quoted {\n                true =\u003e format! {r#\"\"{s}\"\"#},\n                false =\u003e s.to_owned(),\n            },\n            Expr::BinaryOp { left, op, right } =\u003e {\n                format!(\n                    \"{} {} {}\",\n                    left.to_sql_with(quoted),\n                    op.to_sql(),\n                    right.to_sql_with(quoted),\n                )\n            }\n            Expr::CompoundIdentifier { alias, ident } =\u003e match quoted {\n                true =\u003e format!(r#\"\"{alias}\".\"{ident}\"\"#),\n                false =\u003e format!(\"{alias}.{ident}\"),\n            },\n            Expr::IsNull(s) =\u003e format!(\"{} IS NULL\", s.to_sql_with(quoted)),\n            Expr::IsNotNull(s) =\u003e format!(\"{} IS NOT NULL\", s.to_sql_with(quoted)),\n            Expr::InList {\n                expr,\n                list,\n                negated,\n            } =\u003e {\n                let expr = expr.to_sql_with(quoted);\n                let list = list\n                    .iter()\n                    .map(|expr| expr.to_sql_with(quoted))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \");\n\n                match negated {\n                    true =\u003e format!(\"{expr} NOT IN ({list})\"),\n                    false =\u003e format!(\"{expr} IN ({list})\"),\n                }\n            }\n            Expr::Between {\n                expr,\n                negated,\n                low,\n                high,\n            } =\u003e {\n                let expr = expr.to_sql_with(quoted);\n                let low = low.to_sql_with(quoted);\n                let high = high.to_sql_with(quoted);\n\n                match negated {\n                    true =\u003e format!(\"{expr} NOT BETWEEN {low} AND {high}\"),\n                    false =\u003e format!(\"{expr} BETWEEN {low} AND {high}\"),\n                }\n            }\n            Expr::Like {\n                expr,\n                negated,\n                pattern,\n            } =\u003e {\n                let expr = expr.to_sql_with(quoted);\n                let pattern = pattern.to_sql_with(quoted);\n\n                match negated {\n                    true =\u003e format!(\"{expr} NOT LIKE {pattern}\"),\n                    false =\u003e format!(\"{expr} LIKE {pattern}\"),\n                }\n            }\n            Expr::ILike {\n                expr,\n                negated,\n                pattern,\n            } =\u003e {\n                let expr = expr.to_sql_with(quoted);\n                let pattern = pattern.to_sql_with(quoted);\n\n                match negated {\n                    true =\u003e format!(\"{expr} NOT ILIKE {pattern}\"),\n                    false =\u003e format!(\"{expr} ILIKE {pattern}\"),\n                }\n            }\n            Expr::UnaryOp { op, expr } =\u003e match op {\n                UnaryOperator::Factorial =\u003e {\n                    format!(\"{}{}\", expr.to_sql_with(quoted), op.to_sql())\n                }\n                _ =\u003e format!(\"{}{}\", op.to_sql(), expr.to_sql_with(quoted)),\n            },\n            Expr::Nested(expr) =\u003e format!(\"({})\", expr.to_sql_with(quoted)),\n            Expr::Literal(s) =\u003e s.to_sql(),\n            Expr::TypedString { data_type, value } =\u003e format!(\"{data_type} '{value}'\"),\n            Expr::Case {\n                operand,\n                when_then,\n                else_result,\n            } =\u003e {\n                let operand = match operand {\n                    Some(operand) =\u003e format!(\"CASE {}\", operand.to_sql_with(quoted)),\n                    None =\u003e \"CASE\".to_owned(),\n                };\n\n                let when_then = when_then\n                    .iter()\n                    .map(|(when, then)| {\n                        format!(\n                            \"WHEN {} THEN {}\",\n                            when.to_sql_with(quoted),\n                            then.to_sql_with(quoted)\n                        )\n                    })\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\"\\n\");\n\n                let else_result = else_result\n                    .as_ref()\n                    .map(|else_result| format!(\"ELSE {}\", else_result.to_sql_with(quoted)));\n\n                match else_result {\n                    Some(else_result) =\u003e {\n                        [operand, when_then, else_result, \"END\".to_owned()].join(\"\\n\")\n                    }\n                    None =\u003e [operand, when_then, \"END\".to_owned()].join(\"\\n\"),\n                }\n            }\n            Expr::Aggregate(a) =\u003e a.to_sql(),\n            Expr::Function(func) =\u003e func.to_sql(),\n            Expr::InSubquery {\n                expr,\n                subquery,\n                negated,\n            } =\u003e match negated {\n                true =\u003e format!(\n                    \"{} NOT IN ({})\",\n                    expr.to_sql_with(quoted),\n                    subquery.to_sql()\n                ),\n                false =\u003e format!(\"{} IN ({})\", expr.to_sql_with(quoted), subquery.to_sql()),\n            },\n            Expr::Exists { subquery, negated } =\u003e match negated {\n                true =\u003e format!(\"NOT EXISTS({})\", subquery.to_sql()),\n                false =\u003e format!(\"EXISTS({})\", subquery.to_sql()),\n            },\n            Expr::ArrayIndex { obj, indexes } =\u003e {\n                let obj = obj.to_sql_with(quoted);\n                let indexes = indexes\n                    .iter()\n                    .map(|index| format!(\"[{}]\", index.to_sql_with(quoted)))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\"\");\n                format!(\"{obj}{indexes}\")\n            }\n            Expr::Array { elem } =\u003e {\n                let elem = elem\n                    .iter()\n                    .map(|e| e.to_sql_with(quoted))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \");\n                format!(\"[{}]\", elem)\n            }\n            Expr::Subquery(query) =\u003e format!(\"({})\", query.to_sql()),\n            Expr::Interval {\n                expr,\n                leading_field,\n                last_field,\n            } =\u003e {\n                let expr = expr.to_sql_with(quoted);\n                let leading_field = leading_field\n                    .as_ref()\n                    .map(|field| field.to_string())\n                    .unwrap_or_else(|| \"\".to_owned());\n\n                match last_field {\n                    Some(last_field) =\u003e format!(\"INTERVAL {expr} {leading_field} TO {last_field}\"),\n                    None =\u003e format!(\"INTERVAL {expr} {leading_field}\"),\n                }\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use {\n        crate::ast::{\n            AstLiteral, BinaryOperator, DataType, DateTimeField, Expr, Query, Select, SelectItem,\n            SetExpr, TableFactor, TableWithJoins, ToSql, ToSqlUnquoted, UnaryOperator,\n        },\n        bigdecimal::BigDecimal,\n        regex::Regex,\n        std::str::FromStr,\n    };\n\n    #[test]\n    fn to_sql() {\n        let re = Regex::new(r\"\\n\\s+\").unwrap();\n        let trim = |s: \u0026str| re.replace_all(s.trim(), \"\\n\").into_owned();\n\n        assert_eq!(r#\"\"id\"\"#, Expr::Identifier(\"id\".to_owned()).to_sql());\n\n        assert_eq!(\n            r#\"\"id\" + \"num\"\"#,\n            Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(\"id\".to_owned())),\n                op: BinaryOperator::Plus,\n                right: Box::new(Expr::Identifier(\"num\".to_owned()))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            r#\"-\"id\"\"#,\n            Expr::UnaryOp {\n                op: UnaryOperator::Minus,\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n            }\n            .to_sql(),\n        );\n\n        assert_eq!(\n            r#\"\"alias\".\"column\"\"#,\n            Expr::CompoundIdentifier {\n                alias: \"alias\".into(),\n                ident: \"column\".into()\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"alias.column\",\n            Expr::CompoundIdentifier {\n                alias: \"alias\".into(),\n                ident: \"column\".into()\n            }\n            .to_sql_unquoted()\n        );\n\n        let id_expr: Box\u003cExpr\u003e = Box::new(Expr::Identifier(\"id\".to_owned()));\n        assert_eq!(r#\"\"id\" IS NULL\"#, Expr::IsNull(id_expr).to_sql());\n\n        let id_expr: Box\u003cExpr\u003e = Box::new(Expr::Identifier(\"id\".to_owned()));\n        assert_eq!(r#\"\"id\" IS NOT NULL\"#, Expr::IsNotNull(id_expr).to_sql());\n\n        assert_eq!(\n            \"INT '1'\",\n            Expr::TypedString {\n                data_type: DataType::Int,\n                value: \"1\".to_owned()\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"(\"id\")\"#,\n            Expr::Nested(Box::new(Expr::Identifier(\"id\".to_owned()))).to_sql(),\n        );\n\n        assert_eq!(\n            r#\"\"id\" BETWEEN \"low\" AND \"high\"\"#,\n            Expr::Between {\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n                negated: false,\n                low: Box::new(Expr::Identifier(\"low\".to_owned())),\n                high: Box::new(Expr::Identifier(\"high\".to_owned()))\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"id\" NOT BETWEEN \"low\" AND \"high\"\"#,\n            Expr::Between {\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n                negated: true,\n                low: Box::new(Expr::Identifier(\"low\".to_owned())),\n                high: Box::new(Expr::Identifier(\"high\".to_owned()))\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"id\" LIKE '%abc'\"#,\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n                negated: false,\n                pattern: Box::new(Expr::Literal(AstLiteral::QuotedString(\"%abc\".to_owned()))),\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"id\" NOT LIKE '%abc'\"#,\n            Expr::Like {\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n                negated: true,\n                pattern: Box::new(Expr::Literal(AstLiteral::QuotedString(\"%abc\".to_owned()))),\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"id\" ILIKE '%abc_'\"#,\n            Expr::ILike {\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n                negated: false,\n                pattern: Box::new(Expr::Literal(AstLiteral::QuotedString(\"%abc_\".to_owned()))),\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"id\" NOT ILIKE '%abc_'\"#,\n            Expr::ILike {\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n                negated: true,\n                pattern: Box::new(Expr::Literal(AstLiteral::QuotedString(\"%abc_\".to_owned()))),\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"id\" IN ('a', 'b', 'c')\"#,\n            Expr::InList {\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n                list: vec![\n                    Expr::Literal(AstLiteral::QuotedString(\"a\".to_owned())),\n                    Expr::Literal(AstLiteral::QuotedString(\"b\".to_owned())),\n                    Expr::Literal(AstLiteral::QuotedString(\"c\".to_owned()))\n                ],\n                negated: false\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"id\" NOT IN ('a', 'b', 'c')\"#,\n            Expr::InList {\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n                list: vec![\n                    Expr::Literal(AstLiteral::QuotedString(\"a\".to_owned())),\n                    Expr::Literal(AstLiteral::QuotedString(\"b\".to_owned())),\n                    Expr::Literal(AstLiteral::QuotedString(\"c\".to_owned()))\n                ],\n                negated: true\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"id\" IN (SELECT * FROM \"FOO\")\"#,\n            Expr::InSubquery {\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n                subquery: Box::new(Query {\n                    body: SetExpr::Select(Box::new(Select {\n                        projection: vec![SelectItem::Wildcard],\n                        from: TableWithJoins {\n                            relation: TableFactor::Table {\n                                name: \"FOO\".to_owned(),\n                                alias: None,\n                                index: None,\n                            },\n                            joins: Vec::new(),\n                        },\n                        selection: None,\n                        group_by: Vec::new(),\n                        having: None,\n                    })),\n                    order_by: Vec::new(),\n                    limit: None,\n                    offset: None,\n                }),\n                negated: false\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"id\" NOT IN (SELECT * FROM \"FOO\")\"#,\n            Expr::InSubquery {\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n                subquery: Box::new(Query {\n                    body: SetExpr::Select(Box::new(Select {\n                        projection: vec![SelectItem::Wildcard],\n                        from: TableWithJoins {\n                            relation: TableFactor::Table {\n                                name: \"FOO\".to_owned(),\n                                alias: None,\n                                index: None,\n                            },\n                            joins: Vec::new(),\n                        },\n                        selection: None,\n                        group_by: Vec::new(),\n                        having: None,\n                    })),\n                    order_by: Vec::new(),\n                    limit: None,\n                    offset: None,\n                }),\n                negated: true\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"EXISTS(SELECT * FROM \"FOO\")\"#,\n            Expr::Exists {\n                subquery: Box::new(Query {\n                    body: SetExpr::Select(Box::new(Select {\n                        projection: vec![SelectItem::Wildcard],\n                        from: TableWithJoins {\n                            relation: TableFactor::Table {\n                                name: \"FOO\".to_owned(),\n                                alias: None,\n                                index: None,\n                            },\n                            joins: Vec::new(),\n                        },\n                        selection: None,\n                        group_by: Vec::new(),\n                        having: None,\n                    })),\n                    order_by: Vec::new(),\n                    limit: None,\n                    offset: None,\n                }),\n                negated: false,\n            }\n            .to_sql(),\n        );\n\n        assert_eq!(\n            r#\"NOT EXISTS(SELECT * FROM \"FOO\")\"#,\n            Expr::Exists {\n                subquery: Box::new(Query {\n                    body: SetExpr::Select(Box::new(Select {\n                        projection: vec![SelectItem::Wildcard],\n                        from: TableWithJoins {\n                            relation: TableFactor::Table {\n                                name: \"FOO\".to_owned(),\n                                alias: None,\n                                index: None,\n                            },\n                            joins: Vec::new(),\n                        },\n                        selection: None,\n                        group_by: Vec::new(),\n                        having: None,\n                    })),\n                    order_by: Vec::new(),\n                    limit: None,\n                    offset: None,\n                }),\n                negated: true,\n            }\n            .to_sql(),\n        );\n\n        assert_eq!(\n            r#\"(SELECT * FROM \"FOO\")\"#,\n            Expr::Subquery(Box::new(Query {\n                body: SetExpr::Select(Box::new(Select {\n                    projection: vec![SelectItem::Wildcard],\n                    from: TableWithJoins {\n                        relation: TableFactor::Table {\n                            name: \"FOO\".to_owned(),\n                            alias: None,\n                            index: None,\n                        },\n                        joins: Vec::new(),\n                    },\n                    selection: None,\n                    group_by: Vec::new(),\n                    having: None,\n                })),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            trim(\n                r#\"CASE \"id\"\n                  WHEN 1 THEN 'a'\n                  WHEN 2 THEN 'b'\n                  ELSE 'c'\n                END\"#,\n            ),\n            Expr::Case {\n                operand: Some(Box::new(Expr::Identifier(\"id\".to_owned()))),\n                when_then: vec![\n                    (\n                        Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1\").unwrap())),\n                        Expr::Literal(AstLiteral::QuotedString(\"a\".to_owned()))\n                    ),\n                    (\n                        Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap())),\n                        Expr::Literal(AstLiteral::QuotedString(\"b\".to_owned()))\n                    )\n                ],\n                else_result: Some(Box::new(Expr::Literal(AstLiteral::QuotedString(\n                    \"c\".to_owned()\n                ))))\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            trim(\n                r#\"CASE\n                  WHEN \"id\" = 1 THEN 'a'\n                  WHEN \"id\" = 2 THEN 'b'\n                END\"#,\n            ),\n            Expr::Case {\n                operand: None,\n                when_then: vec![\n                    (\n                        Expr::BinaryOp {\n                            left: Box::new(Expr::Identifier(\"id\".to_owned())),\n                            op: BinaryOperator::Eq,\n                            right: Box::new(Expr::Literal(AstLiteral::Number(\n                                BigDecimal::from_str(\"1\").unwrap()\n                            )))\n                        },\n                        Expr::Literal(AstLiteral::QuotedString(\"a\".to_owned()))\n                    ),\n                    (\n                        Expr::BinaryOp {\n                            left: Box::new(Expr::Identifier(\"id\".to_owned())),\n                            op: BinaryOperator::Eq,\n                            right: Box::new(Expr::Literal(AstLiteral::Number(\n                                BigDecimal::from_str(\"2\").unwrap()\n                            )))\n                        },\n                        Expr::Literal(AstLiteral::QuotedString(\"b\".to_owned()))\n                    )\n                ],\n                else_result: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            trim(\n                r#\"CASE \"id\"\n                  WHEN 1 THEN 'a'\n                  WHEN 2 THEN 'b'\n                END\"#,\n            ),\n            Expr::Case {\n                operand: Some(Box::new(Expr::Identifier(\"id\".to_owned()))),\n                when_then: vec![\n                    (\n                        Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1\").unwrap())),\n                        Expr::Literal(AstLiteral::QuotedString(\"a\".to_owned()))\n                    ),\n                    (\n                        Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap())),\n                        Expr::Literal(AstLiteral::QuotedString(\"b\".to_owned()))\n                    )\n                ],\n                else_result: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"\"choco\"[1][2]\"#,\n            Expr::ArrayIndex {\n                obj: Box::new(Expr::Identifier(\"choco\".to_owned())),\n                indexes: vec![\n                    Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1\").unwrap())),\n                    Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap()))\n                ]\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"['GlueSQL', 'Rust']\"#,\n            Expr::Array {\n                elem: vec![\n                    Expr::Literal(AstLiteral::QuotedString(\"GlueSQL\".to_owned())),\n                    Expr::Literal(AstLiteral::QuotedString(\"Rust\".to_owned()))\n                ]\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"INTERVAL \"col1\" + 3 DAY\"#,\n            \u0026Expr::Interval {\n                expr: Box::new(Expr::BinaryOp {\n                    left: Box::new(Expr::Identifier(\"col1\".to_owned())),\n                    op: BinaryOperator::Plus,\n                    right: Box::new(Expr::Literal(AstLiteral::Number(3.into()))),\n                }),\n                leading_field: Some(DateTimeField::Day),\n                last_field: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"INTERVAL '3-5' HOUR TO MINUTE\",\n            \u0026Expr::Interval {\n                expr: Box::new(Expr::Literal(AstLiteral::QuotedString(\"3-5\".to_owned()))),\n                leading_field: Some(DateTimeField::Hour),\n                last_field: Some(DateTimeField::Minute),\n            }\n            .to_sql()\n        );\n    }\n}\n","traces":[{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":116},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast","function.rs"],"content":"use {\n    super::{DataType, DateTimeField, Expr, ast_literal::TrimWhereField},\n    crate::ast::ToSql,\n    serde::{Deserialize, Serialize},\n    strum_macros::Display,\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Display)]\n#[strum(serialize_all = \"SCREAMING_SNAKE_CASE\")]\npub enum Function {\n    Abs(Expr),\n    AddMonth {\n        expr: Expr,\n        size: Expr,\n    },\n    Lower(Expr),\n    Initcap(Expr),\n    Upper(Expr),\n    Left {\n        expr: Expr,\n        size: Expr,\n    },\n    Right {\n        expr: Expr,\n        size: Expr,\n    },\n    Asin(Expr),\n    Acos(Expr),\n    Atan(Expr),\n    Lpad {\n        expr: Expr,\n        size: Expr,\n        fill: Option\u003cExpr\u003e,\n    },\n    Rpad {\n        expr: Expr,\n        size: Expr,\n        fill: Option\u003cExpr\u003e,\n    },\n    Replace {\n        expr: Expr,\n        old: Expr,\n        new: Expr,\n    },\n    Cast {\n        expr: Expr,\n        data_type: DataType,\n    },\n    Ceil(Expr),\n    Coalesce(Vec\u003cExpr\u003e),\n    Concat(Vec\u003cExpr\u003e),\n    ConcatWs {\n        separator: Expr,\n        exprs: Vec\u003cExpr\u003e,\n    },\n    Custom {\n        name: String,\n        exprs: Vec\u003cExpr\u003e,\n    },\n    IfNull {\n        expr: Expr,\n        then: Expr,\n    },\n    Iif {\n        cond: Expr,\n        then: Expr,\n        else_result: Expr,\n    },\n    NullIf {\n        expr1: Expr,\n        expr2: Expr,\n    },\n    Rand(Option\u003cExpr\u003e),\n    Round(Expr),\n    Floor(Expr),\n    Trim {\n        expr: Expr,\n        filter_chars: Option\u003cExpr\u003e,\n        trim_where_field: Option\u003cTrimWhereField\u003e,\n    },\n    Exp(Expr),\n    Extract {\n        field: DateTimeField,\n        expr: Expr,\n    },\n    Ln(Expr),\n    Log {\n        antilog: Expr,\n        base: Expr,\n    },\n    Log2(Expr),\n    Log10(Expr),\n    Div {\n        dividend: Expr,\n        divisor: Expr,\n    },\n    Mod {\n        dividend: Expr,\n        divisor: Expr,\n    },\n    Gcd {\n        left: Expr,\n        right: Expr,\n    },\n    Lcm {\n        left: Expr,\n        right: Expr,\n    },\n    Sin(Expr),\n    Cos(Expr),\n    Tan(Expr),\n    Sqrt(Expr),\n    Power {\n        expr: Expr,\n        power: Expr,\n    },\n    Radians(Expr),\n    Degrees(Expr),\n    Now(),\n    CurrentDate(),\n    CurrentTime(),\n    CurrentTimestamp(),\n    Pi(),\n    LastDay(Expr),\n    Ltrim {\n        expr: Expr,\n        chars: Option\u003cExpr\u003e,\n    },\n    Rtrim {\n        expr: Expr,\n        chars: Option\u003cExpr\u003e,\n    },\n    Reverse(Expr),\n    Repeat {\n        expr: Expr,\n        num: Expr,\n    },\n    Sign(Expr),\n    Substr {\n        expr: Expr,\n        start: Expr,\n        count: Option\u003cExpr\u003e,\n    },\n    Unwrap {\n        expr: Expr,\n        selector: Expr,\n    },\n    GenerateUuid(),\n    Greatest(Vec\u003cExpr\u003e),\n    Format {\n        expr: Expr,\n        format: Expr,\n    },\n    ToDate {\n        expr: Expr,\n        format: Expr,\n    },\n    ToTimestamp {\n        expr: Expr,\n        format: Expr,\n    },\n    ToTime {\n        expr: Expr,\n        format: Expr,\n    },\n    Position {\n        from_expr: Expr,\n        sub_expr: Expr,\n    },\n    FindIdx {\n        from_expr: Expr,\n        sub_expr: Expr,\n        start: Option\u003cExpr\u003e,\n    },\n    Ascii(Expr),\n    Chr(Expr),\n    Md5(Expr),\n    Hex(Expr),\n    Append {\n        expr: Expr,\n        value: Expr,\n    },\n    Sort {\n        expr: Expr,\n        order: Option\u003cExpr\u003e,\n    },\n    Slice {\n        expr: Expr,\n        start: Expr,\n        length: Expr,\n    },\n    Prepend {\n        expr: Expr,\n        value: Expr,\n    },\n    Skip {\n        expr: Expr,\n        size: Expr,\n    },\n    Take {\n        expr: Expr,\n        size: Expr,\n    },\n    GetX(Expr),\n    GetY(Expr),\n    Point {\n        x: Expr,\n        y: Expr,\n    },\n    CalcDistance {\n        geometry1: Expr,\n        geometry2: Expr,\n    },\n    IsEmpty(Expr),\n    Length(Expr),\n    Entries(Expr),\n    Keys(Expr),\n    Values(Expr),\n    Splice {\n        list_data: Expr,\n        begin_index: Expr,\n        end_index: Expr,\n        values: Option\u003cExpr\u003e,\n    },\n    Dedup(Expr),\n}\n\nimpl ToSql for Function {\n    fn to_sql(\u0026self) -\u003e String {\n        match self {\n            Function::Abs(e) =\u003e format!(\"ABS({})\", e.to_sql()),\n            Function::AddMonth { expr, size } =\u003e {\n                format!(\"ADD_MONTH({},{})\", expr.to_sql(), size.to_sql())\n            }\n            Function::Initcap(e) =\u003e format!(\"INITCAP({})\", e.to_sql()),\n            Function::Lower(e) =\u003e format!(\"LOWER({})\", e.to_sql()),\n            Function::Upper(e) =\u003e format!(\"UPPER({})\", e.to_sql()),\n            Function::Left { expr, size } =\u003e format!(\"LEFT({}, {})\", expr.to_sql(), size.to_sql()),\n            Function::Right { expr, size } =\u003e {\n                format!(\"RIGHT({}, {})\", expr.to_sql(), size.to_sql())\n            }\n            Function::Asin(e) =\u003e format!(\"ASIN({})\", e.to_sql()),\n            Function::Acos(e) =\u003e format!(\"ACOS({})\", e.to_sql()),\n            Function::Atan(e) =\u003e format!(\"ATAN({})\", e.to_sql()),\n            Function::Lpad { expr, size, fill } =\u003e match fill {\n                None =\u003e format!(\"LPAD({}, {})\", expr.to_sql(), size.to_sql()),\n                Some(fill) =\u003e format!(\n                    \"LPAD({}, {}, {})\",\n                    expr.to_sql(),\n                    size.to_sql(),\n                    fill.to_sql()\n                ),\n            },\n            Function::Rpad { expr, size, fill } =\u003e match fill {\n                None =\u003e format!(\"RPAD({}, {})\", expr.to_sql(), size.to_sql()),\n                Some(fill) =\u003e format!(\n                    \"RPAD({}, {}, {})\",\n                    expr.to_sql(),\n                    size.to_sql(),\n                    fill.to_sql()\n                ),\n            },\n            Function::Cast { expr, data_type } =\u003e {\n                format!(\"CAST({} AS {data_type})\", expr.to_sql())\n            }\n            Function::Ceil(e) =\u003e format!(\"CEIL({})\", e.to_sql()),\n            Function::Coalesce(items) =\u003e {\n                let items = items\n                    .iter()\n                    .map(ToSql::to_sql)\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \");\n                format!(\"COALESCE({items})\")\n            }\n            Function::Concat(items) =\u003e {\n                let items = items\n                    .iter()\n                    .map(ToSql::to_sql)\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \");\n                format!(\"CONCAT({items})\")\n            }\n            Function::Custom { name, exprs } =\u003e {\n                let exprs = exprs\n                    .iter()\n                    .map(ToSql::to_sql)\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \");\n                format!(\"{name}({exprs})\")\n            }\n            Function::ConcatWs { separator, exprs } =\u003e {\n                let exprs = exprs\n                    .iter()\n                    .map(ToSql::to_sql)\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \");\n                format!(\"CONCAT_WS({}, {})\", separator.to_sql(), exprs)\n            }\n            Function::IfNull { expr, then } =\u003e {\n                format!(\"IFNULL({}, {})\", expr.to_sql(), then.to_sql())\n            }\n            Function::Iif {\n                cond,\n                then,\n                else_result,\n            } =\u003e {\n                format!(\n                    \"IIF({}, {}, {})\",\n                    cond.to_sql(),\n                    then.to_sql(),\n                    else_result.to_sql()\n                )\n            }\n            Function::NullIf { expr1, expr2 } =\u003e {\n                format!(\"NULLIF({}, {})\", expr1.to_sql(), expr2.to_sql())\n            }\n            Function::Rand(e) =\u003e match e {\n                Some(v) =\u003e format!(\"RAND({})\", v.to_sql()),\n                None =\u003e \"RAND()\".to_owned(),\n            },\n            Function::Round(e) =\u003e format!(\"ROUND({})\", e.to_sql()),\n            Function::Floor(e) =\u003e format!(\"FLOOR({})\", e.to_sql()),\n            Function::Trim {\n                expr,\n                filter_chars,\n                trim_where_field,\n            } =\u003e {\n                let trim_where_field = match trim_where_field {\n                    None =\u003e \"\".to_owned(),\n                    Some(t) =\u003e format!(\"{t} \"),\n                };\n\n                match filter_chars {\n                    None =\u003e format!(\"TRIM({}{})\", trim_where_field, expr.to_sql()),\n                    Some(filter_chars) =\u003e format!(\n                        \"TRIM({}{} FROM {})\",\n                        trim_where_field,\n                        filter_chars.to_sql(),\n                        expr.to_sql()\n                    ),\n                }\n            }\n            Function::Exp(e) =\u003e format!(\"EXP({})\", e.to_sql()),\n            Function::Ln(e) =\u003e format!(\"LN({})\", e.to_sql()),\n            Function::Log { antilog, base } =\u003e {\n                format!(\"LOG({}, {})\", antilog.to_sql(), base.to_sql())\n            }\n            Function::Log2(e) =\u003e format!(\"LOG2({})\", e.to_sql()),\n            Function::Log10(e) =\u003e format!(\"LOG10({})\", e.to_sql()),\n            Function::Div { dividend, divisor } =\u003e {\n                format!(\"DIV({}, {})\", dividend.to_sql(), divisor.to_sql())\n            }\n            Function::Mod { dividend, divisor } =\u003e {\n                format!(\"MOD({}, {})\", dividend.to_sql(), divisor.to_sql())\n            }\n            Function::Gcd { left, right } =\u003e format!(\"GCD({}, {})\", left.to_sql(), right.to_sql()),\n            Function::Lcm { left, right } =\u003e format!(\"LCM({}, {})\", left.to_sql(), right.to_sql()),\n            Function::Sin(e) =\u003e format!(\"SIN({})\", e.to_sql()),\n            Function::Cos(e) =\u003e format!(\"COS({})\", e.to_sql()),\n            Function::Tan(e) =\u003e format!(\"TAN({})\", e.to_sql()),\n            Function::Sqrt(e) =\u003e format!(\"SQRT({})\", e.to_sql()),\n            Function::Power { expr, power } =\u003e {\n                format!(\"POWER({}, {})\", expr.to_sql(), power.to_sql())\n            }\n            Function::Radians(e) =\u003e format!(\"RADIANS({})\", e.to_sql()),\n            Function::Degrees(e) =\u003e format!(\"DEGREES({})\", e.to_sql()),\n            Function::Now() =\u003e \"NOW()\".to_owned(),\n            Function::CurrentDate() =\u003e \"CURRENT_DATE()\".to_owned(),\n            Function::CurrentTime() =\u003e \"CURRENT_TIME()\".to_owned(),\n            Function::CurrentTimestamp() =\u003e \"CURRENT_TIMESTAMP()\".to_owned(),\n            Function::Pi() =\u003e \"PI()\".to_owned(),\n            Function::LastDay(expr) =\u003e format!(\"LAST_DAY({})\", expr.to_sql()),\n            Function::Ltrim { expr, chars } =\u003e match chars {\n                None =\u003e format!(\"LTRIM({})\", expr.to_sql()),\n                Some(chars) =\u003e format!(\"LTRIM({}, {})\", expr.to_sql(), chars.to_sql()),\n            },\n            Function::Rtrim { expr, chars } =\u003e match chars {\n                None =\u003e format!(\"RTRIM({})\", expr.to_sql()),\n                Some(chars) =\u003e format!(\"RTRIM({}, {})\", expr.to_sql(), chars.to_sql()),\n            },\n            Function::Reverse(e) =\u003e format!(\"REVERSE({})\", e.to_sql()),\n            Function::Repeat { expr, num } =\u003e {\n                format!(\"REPEAT({}, {})\", expr.to_sql(), num.to_sql())\n            }\n            Function::Replace { expr, old, new } =\u003e format!(\n                \"REPLACE({},{},{})\",\n                expr.to_sql(),\n                old.to_sql(),\n                new.to_sql()\n            ),\n\n            Function::Sign(e) =\u003e format!(\"SIGN({})\", e.to_sql()),\n            Function::Substr { expr, start, count } =\u003e match count {\n                None =\u003e format!(\"SUBSTR({}, {})\", expr.to_sql(), start.to_sql()),\n                Some(count) =\u003e format!(\n                    \"SUBSTR({}, {}, {})\",\n                    expr.to_sql(),\n                    start.to_sql(),\n                    count.to_sql()\n                ),\n            },\n            Function::Unwrap { expr, selector } =\u003e {\n                format!(\"UNWRAP({}, {})\", expr.to_sql(), selector.to_sql())\n            }\n            Function::GenerateUuid() =\u003e \"GENERATE_UUID()\".to_owned(),\n            Function::Greatest(items) =\u003e {\n                let items = items\n                    .iter()\n                    .map(ToSql::to_sql)\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \");\n                format!(\"GREATEST({})\", items)\n            }\n            Function::Format { expr, format } =\u003e {\n                format!(\"FORMAT({}, {})\", expr.to_sql(), format.to_sql())\n            }\n            Function::ToDate { expr, format } =\u003e {\n                format!(\"TO_DATE({}, {})\", expr.to_sql(), format.to_sql())\n            }\n            Function::ToTimestamp { expr, format } =\u003e {\n                format!(\"TO_TIMESTAMP({}, {})\", expr.to_sql(), format.to_sql())\n            }\n            Function::ToTime { expr, format } =\u003e {\n                format!(\"TO_TIME({}, {})\", expr.to_sql(), format.to_sql())\n            }\n            Function::Position {\n                from_expr,\n                sub_expr,\n            } =\u003e format!(\"POSITION({} IN {})\", sub_expr.to_sql(), from_expr.to_sql()),\n            Function::FindIdx {\n                from_expr,\n                sub_expr,\n                start,\n            } =\u003e match start {\n                None =\u003e format!(\"FIND_IDX({}, {})\", from_expr.to_sql(), sub_expr.to_sql()),\n                Some(start_expr) =\u003e format!(\n                    \"FIND_IDX({}, {}, {})\",\n                    from_expr.to_sql(),\n                    sub_expr.to_sql(),\n                    start_expr.to_sql()\n                ),\n            },\n            Function::Extract { field, expr } =\u003e {\n                format!(\"EXTRACT({field} FROM {})\", expr.to_sql())\n            }\n            Function::Ascii(e) =\u003e format!(\"ASCII({})\", e.to_sql()),\n            Function::Chr(e) =\u003e format!(\"CHR({})\", e.to_sql()),\n            Function::Md5(e) =\u003e format!(\"MD5({})\", e.to_sql()),\n            Function::Hex(e) =\u003e format!(\"HEX({})\", e.to_sql()),\n            Function::Append { expr, value } =\u003e {\n                format!(\n                    \"APPEND({items}, {value})\",\n                    items = expr.to_sql(),\n                    value = value.to_sql()\n                )\n            }\n            Function::Prepend { expr, value } =\u003e {\n                format! {\n                    \"PREPEND({items}, {value})\",\n                    items = expr.to_sql(),\n                    value = value.to_sql()\n                }\n            }\n            Function::Skip { expr, size } =\u003e {\n                format!(\"SKIP({}, {})\", expr.to_sql(), size.to_sql())\n            }\n            Function::Sort { expr, order } =\u003e match order {\n                None =\u003e format!(\"SORT({})\", expr.to_sql()),\n                Some(order) =\u003e {\n                    format!(\"SORT({}, {})\", expr.to_sql(), order.to_sql())\n                }\n            },\n            Function::Slice {\n                expr,\n                start,\n                length,\n            } =\u003e {\n                format!(\n                    \"SLICE({}, {}, {})\",\n                    expr.to_sql(),\n                    start.to_sql(),\n                    length.to_sql()\n                )\n            }\n            Function::Take { expr, size } =\u003e {\n                format!(\"TAKE({}, {})\", expr.to_sql(), size.to_sql())\n            }\n            Function::GetX(e) =\u003e format!(\"GET_X({})\", e.to_sql()),\n            Function::GetY(e) =\u003e format!(\"GET_Y({})\", e.to_sql()),\n            Function::Point { x, y } =\u003e format!(\"POINT({}, {})\", x.to_sql(), y.to_sql()),\n            Function::CalcDistance {\n                geometry1,\n                geometry2,\n            } =\u003e {\n                format!(\n                    \"CALC_DISTANCE({}, {})\",\n                    geometry1.to_sql(),\n                    geometry2.to_sql()\n                )\n            }\n            Function::IsEmpty(e) =\u003e format!(\"IS_EMPTY({})\", e.to_sql()),\n            Function::Length(e) =\u003e format!(\"LENGTH({})\", e.to_sql()),\n            Function::Entries(e) =\u003e format!(\"ENTRIES({})\", e.to_sql()),\n            Function::Keys(e) =\u003e format!(\"KEYS({})\", e.to_sql()),\n            Function::Values(e) =\u003e format!(\"VALUES({})\", e.to_sql()),\n            Function::Splice {\n                list_data,\n                begin_index,\n                end_index,\n                values,\n            } =\u003e match values {\n                Some(v) =\u003e format!(\n                    \"SPLICE({}, {}, {}, {})\",\n                    list_data.to_sql(),\n                    begin_index.to_sql(),\n                    end_index.to_sql(),\n                    v.to_sql()\n                ),\n                None =\u003e format!(\n                    \"SPLICE({}, {}, {})\",\n                    list_data.to_sql(),\n                    begin_index.to_sql(),\n                    end_index.to_sql(),\n                ),\n            },\n            Function::Dedup(list) =\u003e format!(\"DEDUP({})\", list.to_sql()),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Aggregate {\n    Count(CountArgExpr),\n    Sum(Expr),\n    Max(Expr),\n    Min(Expr),\n    Avg(Expr),\n    Variance(Expr),\n    Stdev(Expr),\n}\n\nimpl ToSql for Aggregate {\n    fn to_sql(\u0026self) -\u003e String {\n        match self {\n            Aggregate::Count(cae) =\u003e format!(\"COUNT({})\", cae.to_sql()),\n            Aggregate::Sum(e) =\u003e format!(\"SUM({})\", e.to_sql()),\n            Aggregate::Max(e) =\u003e format!(\"MAX({})\", e.to_sql()),\n            Aggregate::Min(e) =\u003e format!(\"MIN({})\", e.to_sql()),\n            Aggregate::Avg(e) =\u003e format!(\"AVG({})\", e.to_sql()),\n            Aggregate::Variance(e) =\u003e format!(\"VARIANCE({})\", e.to_sql()),\n            Aggregate::Stdev(e) =\u003e format!(\"STDEV({})\", e.to_sql()),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum CountArgExpr {\n    Expr(Expr),\n    Wildcard,\n}\n\nimpl ToSql for CountArgExpr {\n    fn to_sql(\u0026self) -\u003e String {\n        match self {\n            CountArgExpr::Expr(e) =\u003e e.to_sql(),\n            CountArgExpr::Wildcard =\u003e \"*\".to_owned(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::ast::{\n            Aggregate, AstLiteral, CountArgExpr, DataType, DateTimeField, Expr, Function, ToSql,\n            TrimWhereField,\n        },\n        bigdecimal::BigDecimal,\n        std::str::FromStr,\n    };\n\n    #[test]\n    fn to_sql_function() {\n        assert_eq!(\n            r#\"ABS(\"num\")\"#,\n            \u0026Expr::Function(Box::new(Function::Abs(Expr::Identifier(\"num\".to_owned())))).to_sql()\n        );\n\n        assert_eq!(\n            \"LOWER('Bye')\",\n            \u0026Expr::Function(Box::new(Function::Lower(Expr::Literal(\n                AstLiteral::QuotedString(\"Bye\".to_owned())\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"INITCAP('Bye')\",\n            \u0026Expr::Function(Box::new(Function::Initcap(Expr::Literal(\n                AstLiteral::QuotedString(\"Bye\".to_owned())\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"UPPER('Hi')\",\n            \u0026Expr::Function(Box::new(Function::Upper(Expr::Literal(\n                AstLiteral::QuotedString(\"Hi\".to_owned())\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"LEFT('GlueSQL', 2)\",\n            \u0026Expr::Function(Box::new(Function::Left {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"GlueSQL\".to_owned())),\n                size: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"RIGHT('GlueSQL', 3)\",\n            \u0026Expr::Function(Box::new(Function::Right {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"GlueSQL\".to_owned())),\n                size: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"3\").unwrap()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"ASIN(2)\",\n            \u0026Expr::Function(Box::new(Function::Asin(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"2\").unwrap()\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"ACOS(2)\",\n            \u0026Expr::Function(Box::new(Function::Acos(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"2\").unwrap()\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"ATAN(2)\",\n            \u0026Expr::Function(Box::new(Function::Atan(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"2\").unwrap()\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"LPAD('GlueSQL', 2)\",\n            \u0026Expr::Function(Box::new(Function::Lpad {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"GlueSQL\".to_owned())),\n                size: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap())),\n                fill: None\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"LPAD('GlueSQL', 10, 'Go')\",\n            \u0026Expr::Function(Box::new(Function::Lpad {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"GlueSQL\".to_owned())),\n                size: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"10\").unwrap())),\n                fill: Some(Expr::Literal(AstLiteral::QuotedString(\"Go\".to_owned())))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"RPAD('GlueSQL', 10)\",\n            \u0026Expr::Function(Box::new(Function::Rpad {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"GlueSQL\".to_owned())),\n                size: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"10\").unwrap())),\n                fill: None\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"RPAD('GlueSQL', 10, 'Go')\",\n            \u0026Expr::Function(Box::new(Function::Rpad {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"GlueSQL\".to_owned())),\n                size: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"10\").unwrap())),\n                fill: Some(Expr::Literal(AstLiteral::QuotedString(\"Go\".to_owned())))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"CAST(1.0 AS INT)\",\n            \u0026Expr::Function(Box::new(Function::Cast {\n                expr: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1.0\").unwrap())),\n                data_type: DataType::Int\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"CEIL(\"num\")\"#,\n            \u0026Expr::Function(Box::new(Function::Ceil(Expr::Identifier(\"num\".to_owned())))).to_sql()\n        );\n\n        assert_eq!(\n            r#\"CUSTOM_FUNC(\"Tic\", 1, \"num\", 'abc')\"#,\n            \u0026Expr::Function(Box::new(Function::Custom {\n                name: \"CUSTOM_FUNC\".to_owned(),\n                exprs: vec![\n                    Expr::Identifier(\"Tic\".to_owned()),\n                    Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1\").unwrap())),\n                    Expr::Identifier(\"num\".to_owned()),\n                    Expr::Literal(AstLiteral::QuotedString(\"abc\".to_owned()))\n                ]\n            }))\n            .to_sql()\n        );\n        assert_eq!(\n            r#\"CUSTOM_FUNC(\"num\")\"#,\n            \u0026Expr::Function(Box::new(Function::Custom {\n                name: \"CUSTOM_FUNC\".to_owned(),\n                exprs: vec![Expr::Identifier(\"num\".to_owned())]\n            }))\n            .to_sql()\n        );\n        assert_eq!(\n            \"CUSTOM_FUNC()\",\n            \u0026Expr::Function(Box::new(Function::Custom {\n                name: \"CUSTOM_FUNC\".to_owned(),\n                exprs: vec![]\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"COALESCE(\"First\", NULL, \"Last\")\"#,\n            \u0026Expr::Function(Box::new(Function::Coalesce(vec![\n                Expr::Identifier(\"First\".to_owned()),\n                Expr::Literal(AstLiteral::Null),\n                Expr::Identifier(\"Last\".to_owned()),\n            ])))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"CONCAT(\\\"Tic\\\", \\\"tac\\\", \\\"toe\\\")\",\n            \u0026Expr::Function(Box::new(Function::Concat(vec![\n                Expr::Identifier(\"Tic\".to_owned()),\n                Expr::Identifier(\"tac\".to_owned()),\n                Expr::Identifier(\"toe\".to_owned())\n            ])))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"CONCAT_WS('-', \"Tic\", \"tac\", \"toe\")\"#,\n            \u0026Expr::Function(Box::new(Function::ConcatWs {\n                separator: Expr::Literal(AstLiteral::QuotedString(\"-\".to_owned())),\n                exprs: vec![\n                    Expr::Identifier(\"Tic\".to_owned()),\n                    Expr::Identifier(\"tac\".to_owned()),\n                    Expr::Identifier(\"toe\".to_owned())\n                ]\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"REPLACE('Mticky GlueMQL','M','S')\",\n            \u0026Expr::Function(Box::new(Function::Replace {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"Mticky GlueMQL\".to_owned())),\n                old: Expr::Literal(AstLiteral::QuotedString(\"M\".to_owned())),\n                new: Expr::Literal(AstLiteral::QuotedString(\"S\".to_owned()))\n            }))\n            .to_sql()\n        );\n        assert_eq!(\n            r#\"IFNULL(\"updated_at\", \"created_at\")\"#,\n            \u0026Expr::Function(Box::new(Function::IfNull {\n                expr: Expr::Identifier(\"updated_at\".to_owned()),\n                then: Expr::Identifier(\"created_at\".to_owned())\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"NULLIF(\"updated_at\", \"created_at\")\"#,\n            \u0026Expr::Function(Box::new(Function::NullIf {\n                expr1: Expr::Identifier(\"updated_at\".to_owned()),\n                expr2: Expr::Identifier(\"created_at\".to_owned())\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"RAND()\",\n            \u0026Expr::Function(Box::new(Function::Rand(None))).to_sql()\n        );\n\n        assert_eq!(\n            r#\"RAND(\"num\")\"#,\n            \u0026Expr::Function(Box::new(Function::Rand(Some(Expr::Identifier(\n                \"num\".to_owned()\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"ROUND(\"num\")\"#,\n            \u0026Expr::Function(Box::new(Function::Round(Expr::Identifier(\n                \"num\".to_owned()\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"FLOOR(\"num\")\"#,\n            \u0026Expr::Function(Box::new(Function::Floor(Expr::Identifier(\n                \"num\".to_owned()\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"TRIM(\"name\")\"#,\n            \u0026Expr::Function(Box::new(Function::Trim {\n                expr: Expr::Identifier(\"name\".to_owned()),\n                filter_chars: None,\n                trim_where_field: None\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"TRIM('*' FROM \"name\")\"#,\n            \u0026Expr::Function(Box::new(Function::Trim {\n                expr: Expr::Identifier(\"name\".to_owned()),\n                filter_chars: Some(Expr::Literal(AstLiteral::QuotedString(\"*\".to_owned()))),\n                trim_where_field: None\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"TRIM(BOTH '*' FROM \"name\")\"#,\n            \u0026Expr::Function(Box::new(Function::Trim {\n                expr: Expr::Identifier(\"name\".to_owned()),\n                filter_chars: Some(Expr::Literal(AstLiteral::QuotedString(\"*\".to_owned()))),\n                trim_where_field: Some(TrimWhereField::Both)\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"TRIM(LEADING '*' FROM \"name\")\"#,\n            \u0026Expr::Function(Box::new(Function::Trim {\n                expr: Expr::Identifier(\"name\".to_owned()),\n                filter_chars: Some(Expr::Literal(AstLiteral::QuotedString(\"*\".to_owned()))),\n                trim_where_field: Some(TrimWhereField::Leading)\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"TRIM(LEADING \"name\")\"#,\n            \u0026Expr::Function(Box::new(Function::Trim {\n                expr: Expr::Identifier(\"name\".to_owned()),\n                filter_chars: None,\n                trim_where_field: Some(TrimWhereField::Leading)\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"EXP(1)\",\n            \u0026Expr::Function(Box::new(Function::Exp(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"1\").unwrap()\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"LN(1)\",\n            \u0026Expr::Function(Box::new(Function::Ln(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"1\").unwrap()\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"LOG(64, 8)\",\n            \u0026Expr::Function(Box::new(Function::Log {\n                antilog: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"64\").unwrap())),\n                base: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"8\").unwrap()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"LOG2(\"num\")\"#,\n            \u0026Expr::Function(Box::new(Function::Log2(Expr::Identifier(\"num\".to_owned())))).to_sql()\n        );\n\n        assert_eq!(\n            r#\"LOG10(\"num\")\"#,\n            \u0026Expr::Function(Box::new(Function::Log10(Expr::Identifier(\n                \"num\".to_owned()\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"DIV(64, 8)\",\n            \u0026Expr::Function(Box::new(Function::Div {\n                dividend: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"64\").unwrap())),\n                divisor: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"8\").unwrap()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"MOD(64, 8)\",\n            \u0026Expr::Function(Box::new(Function::Mod {\n                dividend: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"64\").unwrap())),\n                divisor: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"8\").unwrap()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"GCD(64, 8)\",\n            \u0026Expr::Function(Box::new(Function::Gcd {\n                left: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"64\").unwrap())),\n                right: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"8\").unwrap()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"LCM(64, 8)\",\n            \u0026Expr::Function(Box::new(Function::Lcm {\n                left: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"64\").unwrap())),\n                right: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"8\").unwrap()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"SIN(2)\",\n            \u0026Expr::Function(Box::new(Function::Sin(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"2\").unwrap()\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"COS(2)\",\n            \u0026Expr::Function(Box::new(Function::Cos(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"2\").unwrap()\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"TAN(2)\",\n            \u0026Expr::Function(Box::new(Function::Tan(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"2\").unwrap()\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"SQRT(2)\",\n            \u0026Expr::Function(Box::new(Function::Sqrt(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"2\").unwrap()\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"POWER(2, 10)\",\n            \u0026Expr::Function(Box::new(Function::Power {\n                expr: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap())),\n                power: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"10\").unwrap())),\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"RADIANS(1)\",\n            \u0026Expr::Function(Box::new(Function::Radians(Expr::Literal(\n                AstLiteral::Number(BigDecimal::from_str(\"1\").unwrap())\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"DEGREES(1)\",\n            \u0026Expr::Function(Box::new(Function::Degrees(Expr::Literal(\n                AstLiteral::Number(BigDecimal::from_str(\"1\").unwrap())\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\"NOW()\", \u0026Expr::Function(Box::new(Function::Now())).to_sql());\n        assert_eq!(\n            \"CURRENT_DATE()\",\n            \u0026Expr::Function(Box::new(Function::CurrentDate())).to_sql()\n        );\n        assert_eq!(\n            \"CURRENT_TIME()\",\n            \u0026Expr::Function(Box::new(Function::CurrentTime())).to_sql()\n        );\n        assert_eq!(\n            \"CURRENT_TIMESTAMP()\",\n            \u0026Expr::Function(Box::new(Function::CurrentTimestamp())).to_sql()\n        );\n\n        assert_eq!(\"PI()\", \u0026Expr::Function(Box::new(Function::Pi())).to_sql());\n\n        assert_eq!(\n            \"LTRIM('   HI ')\",\n            \u0026Expr::Function(Box::new(Function::Ltrim {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"   HI \".to_owned())),\n                chars: None\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"LTRIM('*IMPORTANT', '*')\",\n            \u0026Expr::Function(Box::new(Function::Ltrim {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"*IMPORTANT\".to_owned())),\n                chars: Some(Expr::Literal(AstLiteral::QuotedString(\"*\".to_owned()))),\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"RTRIM('   HI ')\",\n            \u0026Expr::Function(Box::new(Function::Rtrim {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"   HI \".to_owned())),\n                chars: None\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"RTRIM('IMPORTANT*', '*')\",\n            \u0026Expr::Function(Box::new(Function::Rtrim {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"IMPORTANT*\".to_owned())),\n                chars: Some(Expr::Literal(AstLiteral::QuotedString(\"*\".to_owned()))),\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"REVERSE(\"name\")\"#,\n            \u0026Expr::Function(Box::new(Function::Reverse(Expr::Identifier(\n                \"name\".to_owned()\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"REPEAT('Ha', 8)\",\n            \u0026Expr::Function(Box::new(Function::Repeat {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"Ha\".to_owned())),\n                num: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"8\").unwrap()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"SIGN(1.0)\",\n            \u0026Expr::Function(Box::new(Function::Sign(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"1.0\").unwrap()\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"SUBSTR('GlueSQL', 2)\",\n            \u0026Expr::Function(Box::new(Function::Substr {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"GlueSQL\".to_owned())),\n                start: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap())),\n                count: None\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"SUBSTR('GlueSQL', 1, 3)\",\n            \u0026Expr::Function(Box::new(Function::Substr {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"GlueSQL\".to_owned())),\n                start: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1\").unwrap())),\n                count: Some(Expr::Literal(AstLiteral::Number(\n                    BigDecimal::from_str(\"3\").unwrap()\n                )))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"UNWRAP(\"nested\", 'a.foo')\"#,\n            \u0026Expr::Function(Box::new(Function::Unwrap {\n                expr: Expr::Identifier(\"nested\".to_owned()),\n                selector: Expr::Literal(AstLiteral::QuotedString(\"a.foo\".to_owned()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"GENERATE_UUID()\",\n            \u0026Expr::Function(Box::new(Function::GenerateUuid())).to_sql()\n        );\n        assert_eq!(\n            \"ADD_MONTH('2023-06-15',1)\",\n            \u0026Expr::Function(Box::new(Function::AddMonth {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"2023-06-15\".to_owned())),\n                size: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1\").unwrap()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"GREATEST(16, 9, 7)\",\n            \u0026Expr::Function(Box::new(Function::Greatest(vec![\n                Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"16\").unwrap())),\n                Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"9\").unwrap())),\n                Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"7\").unwrap()))\n            ])))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"FORMAT(DATE '2022-10-12', '%Y-%m')\",\n            \u0026Expr::Function(Box::new(Function::Format {\n                expr: Expr::TypedString {\n                    data_type: DataType::Date,\n                    value: \"2022-10-12\".to_owned()\n                },\n                format: Expr::Literal(AstLiteral::QuotedString(\"%Y-%m\".to_owned()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"LAST_DAY(DATE '2022-10-12')\",\n            \u0026Expr::Function(Box::new(Function::LastDay(Expr::TypedString {\n                data_type: DataType::Date,\n                value: \"2022-10-12\".to_owned()\n            })))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"TO_DATE('2022-10-12', '%Y-%m-%d')\",\n            \u0026Expr::Function(Box::new(Function::ToDate {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"2022-10-12\".to_owned())),\n                format: Expr::Literal(AstLiteral::QuotedString(\"%Y-%m-%d\".to_owned()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"TO_TIMESTAMP('2022-10-12 00:34:23', '%Y-%m-%d %H:%M:%S')\",\n            \u0026Expr::Function(Box::new(Function::ToTimestamp {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"2022-10-12 00:34:23\".to_owned())),\n                format: Expr::Literal(AstLiteral::QuotedString(\"%Y-%m-%d %H:%M:%S\".to_owned()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"TO_TIME('00:34:23', '%H:%M:%S')\",\n            \u0026Expr::Function(Box::new(Function::ToTime {\n                expr: Expr::Literal(AstLiteral::QuotedString(\"00:34:23\".to_owned())),\n                format: Expr::Literal(AstLiteral::QuotedString(\"%H:%M:%S\".to_owned()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"POSITION('cup' IN 'cupcake')\",\n            \u0026Expr::Function(Box::new(Function::Position {\n                from_expr: Expr::Literal(AstLiteral::QuotedString(\"cupcake\".to_owned())),\n                sub_expr: Expr::Literal(AstLiteral::QuotedString(\"cup\".to_owned())),\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"FIND_IDX('noodle', 'o', 2)\",\n            \u0026Expr::Function(Box::new(Function::FindIdx {\n                from_expr: Expr::Literal(AstLiteral::QuotedString(\"noodle\".to_owned())),\n                sub_expr: Expr::Literal(AstLiteral::QuotedString(\"o\".to_owned())),\n                start: Some(Expr::Literal(AstLiteral::Number(\n                    BigDecimal::from_str(\"2\").unwrap()\n                )))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"FIND_IDX('goat cheese', 'goat')\",\n            \u0026Expr::Function(Box::new(Function::FindIdx {\n                from_expr: Expr::Literal(AstLiteral::QuotedString(\"goat cheese\".to_owned())),\n                sub_expr: Expr::Literal(AstLiteral::QuotedString(\"goat\".to_owned())),\n                start: None\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"ASCII('H')\",\n            \u0026Expr::Function(Box::new(Function::Ascii(Expr::Literal(\n                AstLiteral::QuotedString(\"H\".to_owned())\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"CHR(72)\"#,\n            \u0026Expr::Function(Box::new(Function::Chr(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"72\").unwrap()\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"MD5('GlueSQL')\",\n            \u0026Expr::Function(Box::new(Function::Md5(Expr::Literal(\n                AstLiteral::QuotedString(\"GlueSQL\".to_owned())\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"HEX(228)\",\n            \u0026Expr::Function(Box::new(Function::Hex(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from(228)\n            )))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"HEX('GlueSQL')\",\n            \u0026Expr::Function(Box::new(Function::Hex(Expr::Literal(\n                AstLiteral::QuotedString(\"GlueSQL\".to_owned())\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"EXTRACT(MINUTE FROM '2022-05-05 01:02:03')\"#,\n            \u0026Expr::Function(Box::new(Function::Extract {\n                field: DateTimeField::Minute,\n                expr: Expr::Literal(AstLiteral::QuotedString(\"2022-05-05 01:02:03\".to_owned()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"APPEND(\"list\", \"value\")\"#,\n            \u0026Expr::Function(Box::new(Function::Append {\n                expr: Expr::Identifier(\"list\".to_owned()),\n                value: Expr::Identifier(\"value\".to_owned())\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"PREPEND(\"list\", \"value\")\"#,\n            \u0026Expr::Function(Box::new(Function::Prepend {\n                expr: Expr::Identifier(\"list\".to_owned()),\n                value: Expr::Identifier(\"value\".to_owned())\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"SKIP(\"list\", 2)\"#,\n            \u0026Expr::Function(Box::new(Function::Skip {\n                expr: Expr::Identifier(\"list\".to_owned()),\n                size: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"SORT(\"list\")\"#,\n            \u0026Expr::Function(Box::new(Function::Sort {\n                expr: Expr::Identifier(\"list\".to_owned()),\n                order: None\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"SORT(\"list\", 'ASC')\"#,\n            \u0026Expr::Function(Box::new(Function::Sort {\n                expr: Expr::Identifier(\"list\".to_owned()),\n                order: Some(Expr::Literal(AstLiteral::QuotedString(\"ASC\".to_owned())))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"SLICE(\"list\", 1, 2)\"#,\n            \u0026Expr::Function(Box::new(Function::Slice {\n                expr: (Expr::Identifier(\"list\".to_owned())),\n                start: (Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1\").unwrap()))),\n                length: (Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap())))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"TAKE(\"list\", 3)\"#,\n            \u0026Expr::Function(Box::new(Function::Take {\n                expr: Expr::Identifier(\"list\".to_owned()),\n                size: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"3\").unwrap()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"IIF(\"cond\", \"then\", \"else_result\")\"#,\n            \u0026Expr::Function(Box::new(Function::Iif {\n                cond: Expr::Identifier(\"cond\".to_owned()),\n                then: Expr::Identifier(\"then\".to_owned()),\n                else_result: Expr::Identifier(\"else_result\".to_owned())\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"GET_X(\\\"point\\\")\",\n            \u0026Expr::Function(Box::new(Function::GetX(Expr::Identifier(\n                \"point\".to_owned()\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"GET_Y(\\\"point\\\")\",\n            \u0026Expr::Function(Box::new(Function::GetY(Expr::Identifier(\n                \"point\".to_owned()\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"POINT(0.1, 0.2)\",\n            \u0026Expr::Function(Box::new(Function::Point {\n                x: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"0.1\").unwrap())),\n                y: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"0.2\").unwrap()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"CALC_DISTANCE(POINT(1.1, 2.3), POINT(1.4, 3.6))\",\n            \u0026Expr::Function(Box::new(Function::CalcDistance {\n                geometry1: Expr::Function(Box::new(Function::Point {\n                    x: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1.1\").unwrap())),\n                    y: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2.3\").unwrap()))\n                })),\n                geometry2: Expr::Function(Box::new(Function::Point {\n                    x: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1.4\").unwrap())),\n                    y: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"3.6\").unwrap()))\n                }))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"IS_EMPTY(\"list\")\"#,\n            \u0026Expr::Function(Box::new(Function::IsEmpty(Expr::Identifier(\n                \"list\".to_owned()\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"LENGTH(\"GlueSQL\")\"#,\n            \u0026Expr::Function(Box::new(Function::Length(Expr::Identifier(\n                \"GlueSQL\".to_owned()\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"ENTRIES(\"map\")\"#,\n            \u0026Expr::Function(Box::new(Function::Entries(Expr::Identifier(\n                \"map\".to_owned()\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"KEYS(\"map\")\"#,\n            \u0026Expr::Function(Box::new(Function::Keys(Expr::Identifier(\"map\".to_owned())))).to_sql()\n        );\n\n        assert_eq!(\n            r#\"VALUES(\"map\")\"#,\n            \u0026Expr::Function(Box::new(Function::Values(Expr::Identifier(\n                \"map\".to_owned()\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"SPLICE(\"list\", 2, 4)\"#,\n            \u0026Expr::Function(Box::new(Function::Splice {\n                list_data: Expr::Identifier(\"list\".to_owned()),\n                begin_index: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap())),\n                end_index: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"4\").unwrap())),\n                values: None\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"SPLICE(\"list\", 2, 4, \"values\")\"#,\n            \u0026Expr::Function(Box::new(Function::Splice {\n                list_data: Expr::Identifier(\"list\".to_owned()),\n                begin_index: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap())),\n                end_index: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"4\").unwrap())),\n                values: Some(Expr::Identifier(\"values\".to_owned()))\n            }))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"DEDUP(\"list\")\"#,\n            \u0026Expr::Function(Box::new(Function::Dedup(Expr::Identifier(\n                \"list\".to_owned()\n            ))))\n            .to_sql(),\n        )\n    }\n\n    #[test]\n    fn to_sql_aggregate() {\n        assert_eq!(\n            r#\"MAX(\"id\")\"#,\n            Expr::Aggregate(Box::new(Aggregate::Max(Expr::Identifier(\"id\".to_owned())))).to_sql()\n        );\n\n        assert_eq!(\n            \"COUNT(*)\",\n            Expr::Aggregate(Box::new(Aggregate::Count(CountArgExpr::Wildcard))).to_sql()\n        );\n\n        assert_eq!(\n            r#\"MIN(\"id\")\"#,\n            Expr::Aggregate(Box::new(Aggregate::Min(Expr::Identifier(\"id\".to_owned())))).to_sql()\n        );\n\n        assert_eq!(\n            r#\"SUM(\"price\")\"#,\n            \u0026Expr::Aggregate(Box::new(Aggregate::Sum(Expr::Identifier(\n                \"price\".to_owned()\n            ))))\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"AVG(\"pay\")\"#,\n            \u0026Expr::Aggregate(Box::new(Aggregate::Avg(Expr::Identifier(\"pay\".to_owned())))).to_sql()\n        );\n        assert_eq!(\n            r#\"VARIANCE(\"pay\")\"#,\n            \u0026Expr::Aggregate(Box::new(Aggregate::Variance(Expr::Identifier(\n                \"pay\".to_owned()\n            ))))\n            .to_sql()\n        );\n        assert_eq!(\n            r#\"STDEV(\"total\")\"#,\n            \u0026Expr::Aggregate(Box::new(Aggregate::Stdev(Expr::Identifier(\n                \"total\".to_owned()\n            ))))\n            .to_sql()\n        );\n    }\n}\n","traces":[{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":220},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast","operator.rs"],"content":"use {\n    crate::ast::ToSql,\n    serde::{Deserialize, Serialize},\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum UnaryOperator {\n    Plus,\n    Minus,\n    Not,\n    Factorial,\n    BitwiseNot,\n}\n\nimpl ToSql for UnaryOperator {\n    fn to_sql(\u0026self) -\u003e String {\n        match self {\n            UnaryOperator::Plus =\u003e \"+\".to_owned(),\n            UnaryOperator::Minus =\u003e \"-\".to_owned(),\n            UnaryOperator::Not =\u003e \"NOT \".to_owned(),\n            UnaryOperator::Factorial =\u003e \"!\".to_owned(),\n            UnaryOperator::BitwiseNot =\u003e \"~\".to_owned(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum BinaryOperator {\n    Plus,\n    Minus,\n    Multiply,\n    Divide,\n    Modulo,\n    StringConcat,\n    Gt,\n    Lt,\n    GtEq,\n    LtEq,\n    Eq,\n    NotEq,\n    And,\n    Or,\n    Xor,\n    BitwiseAnd,\n    BitwiseShiftLeft,\n    BitwiseShiftRight,\n}\n\nimpl ToSql for BinaryOperator {\n    fn to_sql(\u0026self) -\u003e String {\n        match self {\n            BinaryOperator::Plus =\u003e \"+\".to_owned(),\n            BinaryOperator::Minus =\u003e \"-\".to_owned(),\n            BinaryOperator::Multiply =\u003e \"*\".to_owned(),\n            BinaryOperator::Divide =\u003e \"/\".to_owned(),\n            BinaryOperator::Modulo =\u003e \"%\".to_owned(),\n            BinaryOperator::StringConcat =\u003e \"+\".to_owned(),\n            BinaryOperator::Gt =\u003e \"\u003e\".to_owned(),\n            BinaryOperator::Lt =\u003e \"\u003c\".to_owned(),\n            BinaryOperator::GtEq =\u003e \"\u003e=\".to_owned(),\n            BinaryOperator::LtEq =\u003e \"\u003c=\".to_owned(),\n            BinaryOperator::Eq =\u003e \"=\".to_owned(),\n            BinaryOperator::NotEq =\u003e \"\u003c\u003e\".to_owned(),\n            BinaryOperator::And =\u003e \"AND\".to_owned(),\n            BinaryOperator::Or =\u003e \"OR\".to_owned(),\n            BinaryOperator::Xor =\u003e \"XOR\".to_owned(),\n            BinaryOperator::BitwiseAnd =\u003e \"\u0026\".to_owned(),\n            BinaryOperator::BitwiseShiftLeft =\u003e \"\u003c\u003c\".to_owned(),\n            BinaryOperator::BitwiseShiftRight =\u003e \"\u003e\u003e\".to_owned(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum IndexOperator {\n    Gt,\n    Lt,\n    GtEq,\n    LtEq,\n    Eq,\n}\n\nimpl IndexOperator {\n    pub fn reverse(self) -\u003e Self {\n        use IndexOperator::*;\n\n        match self {\n            Gt =\u003e Lt,\n            Lt =\u003e Gt,\n            GtEq =\u003e LtEq,\n            LtEq =\u003e GtEq,\n            Eq =\u003e Eq,\n        }\n    }\n}\n\nimpl From\u003cIndexOperator\u003e for BinaryOperator {\n    fn from(index_op: IndexOperator) -\u003e Self {\n        match index_op {\n            IndexOperator::Gt =\u003e BinaryOperator::Gt,\n            IndexOperator::Lt =\u003e BinaryOperator::Lt,\n            IndexOperator::GtEq =\u003e BinaryOperator::GtEq,\n            IndexOperator::LtEq =\u003e BinaryOperator::LtEq,\n            IndexOperator::Eq =\u003e BinaryOperator::Eq,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::ast::{AstLiteral, BinaryOperator, Expr, ToSql, UnaryOperator},\n        bigdecimal::BigDecimal,\n    };\n    #[test]\n    fn to_sql() {\n        assert_eq!(\n            \"1 + 2\",\n            Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1)))),\n                op: BinaryOperator::Plus,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(2))))\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"100 - 10\",\n            Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(100)))),\n                op: BinaryOperator::Minus,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(10))))\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"1024 * 1024\",\n            Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1024)))),\n                op: BinaryOperator::Multiply,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1024))))\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"1024 / 8\",\n            Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1024)))),\n                op: BinaryOperator::Divide,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(8))))\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"1024 % 4\",\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1024)))),\n                op: BinaryOperator::Modulo,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(4))))\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"'Glue' + 'SQL'\",\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::QuotedString(\"Glue\".to_owned()))),\n                op: BinaryOperator::StringConcat,\n                right: Box::new(Expr::Literal(AstLiteral::QuotedString(\"SQL\".to_owned())))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            \"1024 \u003e 4\",\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1024)))),\n                op: BinaryOperator::Gt,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(4))))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            \"8 \u003c 1024\",\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(8)))),\n                op: BinaryOperator::Lt,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1024))))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            \"1024 \u003e= 1024\",\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1024)))),\n                op: BinaryOperator::GtEq,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1024))))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            \"8 \u003c= 8\",\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(8)))),\n                op: BinaryOperator::LtEq,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(8))))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            \"1024 = 1024\",\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1024)))),\n                op: BinaryOperator::Eq,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1024))))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            \"1024 \u003c\u003e 1024\",\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1024)))),\n                op: BinaryOperator::NotEq,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1024))))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            \"1 \u003c\u003c 2\",\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1)))),\n                op: BinaryOperator::BitwiseShiftLeft,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(2))))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            \"1 \u003e\u003e 2\",\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1)))),\n                op: BinaryOperator::BitwiseShiftRight,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(2))))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            r#\"\"condition_0\" AND \"condition_1\"\"#,\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(\"condition_0\".to_owned())),\n                op: BinaryOperator::And,\n                right: Box::new(Expr::Identifier(\"condition_1\".to_owned()))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            r#\"\"condition_0\" OR \"condition_1\"\"#,\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(\"condition_0\".to_owned())),\n                op: BinaryOperator::Or,\n                right: Box::new(Expr::Identifier(\"condition_1\".to_owned()))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            r#\"\"condition_0\" XOR \"condition_1\"\"#,\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(\"condition_0\".to_owned())),\n                op: BinaryOperator::Xor,\n                right: Box::new(Expr::Identifier(\"condition_1\".to_owned()))\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            \"+8\",\n            Expr::UnaryOp {\n                op: UnaryOperator::Plus,\n                expr: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(8)))),\n            }\n            .to_sql(),\n        );\n\n        assert_eq!(\n            \"-8\",\n            Expr::UnaryOp {\n                op: UnaryOperator::Minus,\n                expr: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(8)))),\n            }\n            .to_sql(),\n        );\n\n        assert_eq!(\n            r#\"NOT \"id\"\"#,\n            Expr::UnaryOp {\n                op: UnaryOperator::Not,\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n            }\n            .to_sql(),\n        );\n\n        assert_eq!(\n            \"5!\",\n            Expr::UnaryOp {\n                op: UnaryOperator::Factorial,\n                expr: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(5)))),\n            }\n            .to_sql(),\n        );\n\n        assert_eq!(\n            \"29 \u0026 15\",\n            \u0026Expr::BinaryOp {\n                left: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(29)))),\n                op: BinaryOperator::BitwiseAnd,\n                right: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(15))))\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"~1\",\n            Expr::UnaryOp {\n                op: UnaryOperator::BitwiseNot,\n                expr: Box::new(Expr::Literal(AstLiteral::Number(BigDecimal::from(1)))),\n            }\n            .to_sql(),\n        )\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":41},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast","query.rs"],"content":"use {\n    super::{Expr, IndexOperator, ToSqlUnquoted},\n    crate::ast::ToSql,\n    itertools::Itertools,\n    serde::{Deserialize, Serialize},\n    strum_macros::Display,\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Query {\n    pub body: SetExpr,\n    pub order_by: Vec\u003cOrderByExpr\u003e,\n    pub limit: Option\u003cExpr\u003e,\n    pub offset: Option\u003cExpr\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum SetExpr {\n    Select(Box\u003cSelect\u003e),\n    Values(Values),\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Select {\n    pub projection: Vec\u003cSelectItem\u003e,\n    pub from: TableWithJoins,\n    /// WHERE\n    pub selection: Option\u003cExpr\u003e,\n    pub group_by: Vec\u003cExpr\u003e,\n    pub having: Option\u003cExpr\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum SelectItem {\n    /// An expression\n    Expr { expr: Expr, label: String },\n    /// `alias.*` or even `schema.table.*`\n    QualifiedWildcard(String),\n    /// An unqualified `*`\n    Wildcard,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct TableWithJoins {\n    pub relation: TableFactor,\n    pub joins: Vec\u003cJoin\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum IndexItem {\n    PrimaryKey(Expr),\n    NonClustered {\n        name: String,\n        asc: Option\u003cbool\u003e,\n        cmp_expr: Option\u003c(IndexOperator, Expr)\u003e,\n    },\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum TableFactor {\n    Table {\n        name: String,\n        alias: Option\u003cTableAlias\u003e,\n        /// Query planner result\n        index: Option\u003cIndexItem\u003e,\n    },\n    Derived {\n        subquery: Query,\n        alias: TableAlias,\n    },\n    Series {\n        alias: TableAlias,\n        size: Expr,\n    },\n    Dictionary {\n        dict: Dictionary,\n        alias: TableAlias,\n    },\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Display)]\n#[strum(serialize_all = \"SCREAMING_SNAKE_CASE\")]\npub enum Dictionary {\n    GlueTables,\n    GlueTableColumns,\n    GlueIndexes,\n    GlueObjects,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct TableAlias {\n    pub name: String,\n    pub columns: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Join {\n    pub relation: TableFactor,\n    pub join_operator: JoinOperator,\n    pub join_executor: JoinExecutor,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum JoinExecutor {\n    NestedLoop,\n    Hash {\n        key_expr: Expr,\n        value_expr: Expr,\n        where_clause: Option\u003cExpr\u003e,\n    },\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum JoinOperator {\n    Inner(JoinConstraint),\n    LeftOuter(JoinConstraint),\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum JoinConstraint {\n    On(Expr),\n    None,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct OrderByExpr {\n    pub expr: Expr,\n    pub asc: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Values(pub Vec\u003cVec\u003cExpr\u003e\u003e);\n\nimpl ToSql for Query {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for Query {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl Query {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        let to_sql = |expr: \u0026Expr| match quoted {\n            true =\u003e expr.to_sql(),\n            false =\u003e expr.to_sql_unquoted(),\n        };\n\n        let Query {\n            body,\n            order_by,\n            limit,\n            offset,\n        } = self;\n\n        let order_by = if order_by.is_empty() {\n            \"\".to_owned()\n        } else {\n            format!(\n                \"ORDER BY {}\",\n                order_by\n                    .iter()\n                    .map(|expr| expr.to_sql_with(quoted))\n                    .join(\" \")\n            )\n        };\n\n        let limit = match limit {\n            Some(expr) =\u003e format!(\"LIMIT {}\", to_sql(expr)),\n            _ =\u003e \"\".to_owned(),\n        };\n\n        let offset = match offset {\n            Some(expr) =\u003e format!(\"OFFSET {}\", to_sql(expr)),\n            _ =\u003e \"\".to_owned(),\n        };\n\n        let string = [order_by, limit, offset]\n            .iter()\n            .filter(|sql| !sql.is_empty())\n            .join(\" \");\n\n        if string.is_empty() {\n            body.to_sql_with(quoted)\n        } else {\n            format!(\"{} {}\", body.to_sql_with(quoted), string)\n        }\n    }\n}\n\nimpl ToSql for SetExpr {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for SetExpr {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl SetExpr {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        match (self, quoted) {\n            (SetExpr::Select(select), true) =\u003e select.to_sql(),\n            (SetExpr::Select(select), false) =\u003e select.to_sql_unquoted(),\n            (SetExpr::Values(values), true) =\u003e format!(\"VALUES {}\", values.to_sql()),\n            (SetExpr::Values(values), false) =\u003e format!(\"VALUES {}\", values.to_sql_unquoted()),\n        }\n    }\n}\n\nimpl ToSql for Select {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for Select {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl Select {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        let to_sql = |expr: \u0026Expr| match quoted {\n            true =\u003e expr.to_sql(),\n            false =\u003e expr.to_sql_unquoted(),\n        };\n\n        let Select {\n            projection,\n            from,\n            selection,\n            group_by,\n            having,\n        } = self;\n        let projection = projection\n            .iter()\n            .map(|item| item.to_sql_with(quoted))\n            .join(\", \");\n\n        let selection = match selection {\n            Some(expr) =\u003e format!(\"WHERE {}\", to_sql(expr)),\n            None =\u003e \"\".to_owned(),\n        };\n\n        let group_by = if group_by.is_empty() {\n            \"\".to_owned()\n        } else {\n            format!(\"GROUP BY {}\", group_by.iter().map(to_sql).join(\", \"))\n        };\n\n        let having = match having {\n            Some(having) =\u003e format!(\"HAVING {}\", to_sql(having)),\n            None =\u003e \"\".to_owned(),\n        };\n\n        let condition = [selection, group_by, having]\n            .iter()\n            .filter(|sql| !sql.is_empty())\n            .join(\" \");\n\n        if condition.is_empty() {\n            format!(\"SELECT {projection} FROM {}\", from.to_sql_with(quoted))\n        } else {\n            format!(\n                \"SELECT {projection} FROM {} {condition}\",\n                from.to_sql_with(quoted)\n            )\n        }\n    }\n}\n\nimpl ToSql for SelectItem {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for SelectItem {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl SelectItem {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        let to_sql = |expr: \u0026Expr| match quoted {\n            true =\u003e expr.to_sql(),\n            false =\u003e expr.to_sql_unquoted(),\n        };\n\n        match self {\n            SelectItem::Expr { expr, label } =\u003e {\n                let expr = to_sql(expr);\n                match (label.is_empty(), quoted) {\n                    (true, _) =\u003e expr,\n                    (false, true) =\u003e format!(r#\"{expr} AS \"{label}\"\"#),\n                    (false, false) =\u003e format!(\"{expr} AS {label}\"),\n                }\n            }\n            SelectItem::QualifiedWildcard(obj) =\u003e match quoted {\n                true =\u003e format!(r#\"\"{}\".*\"#, obj),\n                false =\u003e format!(\"{}.*\", obj),\n            },\n            SelectItem::Wildcard =\u003e \"*\".to_owned(),\n        }\n    }\n}\n\nimpl ToSql for TableWithJoins {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for TableWithJoins {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl TableWithJoins {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        let TableWithJoins { relation, joins } = self;\n\n        if joins.is_empty() {\n            relation.to_sql_with(quoted)\n        } else {\n            format!(\n                \"{} {}\",\n                relation.to_sql_with(quoted),\n                joins.iter().map(|join| join.to_sql_with(quoted)).join(\" \")\n            )\n        }\n    }\n}\n\nimpl ToSql for TableFactor {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for TableFactor {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl TableFactor {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        let to_sql = |expr: \u0026Expr| match quoted {\n            true =\u003e expr.to_sql(),\n            false =\u003e expr.to_sql_unquoted(),\n        };\n\n        match (self, quoted) {\n            (TableFactor::Table { name, alias, .. }, true) =\u003e match alias {\n                Some(alias) =\u003e format!(r#\"\"{}\" {}\"#, name, alias.to_sql_with(quoted)),\n                None =\u003e format!(r#\"\"{name}\"\"#),\n            },\n            (TableFactor::Table { name, alias, .. }, false) =\u003e match alias {\n                Some(alias) =\u003e format!(\"{} {}\", name, alias.to_sql_with(quoted)),\n                None =\u003e name.to_owned(),\n            },\n            (TableFactor::Derived { subquery, alias }, _) =\u003e {\n                format!(\n                    \"({}) {}\",\n                    subquery.to_sql_with(quoted),\n                    alias.to_sql_with(quoted)\n                )\n            }\n            (TableFactor::Series { alias, size }, _) =\u003e {\n                format!(\"SERIES({}) {}\", to_sql(size), alias.to_sql_with(quoted))\n            }\n            (TableFactor::Dictionary { dict, alias }, true) =\u003e {\n                format!(r#\"\"{dict}\" {}\"#, alias.to_sql_with(quoted))\n            }\n            (TableFactor::Dictionary { dict, alias }, false) =\u003e {\n                format!(\"{dict} {}\", alias.to_sql_with(quoted))\n            }\n        }\n    }\n}\n\nimpl ToSql for TableAlias {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for TableAlias {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl TableAlias {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        let TableAlias { name, .. } = self;\n\n        match quoted {\n            true =\u003e format!(r#\"AS \"{name}\"\"#),\n            false =\u003e format!(\"AS {name}\"),\n        }\n    }\n}\n\nimpl ToSql for Join {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for Join {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl Join {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        let Join {\n            relation,\n            join_operator,\n            join_executor,\n        } = self;\n\n        let (join_operator, join_constraint) = match join_operator {\n            JoinOperator::Inner(join_constraint) =\u003e (\"INNER JOIN\", join_constraint),\n            JoinOperator::LeftOuter(join_constraint) =\u003e (\"LEFT OUTER JOIN\", join_constraint),\n        };\n\n        let (join_constraint, join_executor) = match quoted {\n            true =\u003e (join_constraint.to_sql(), join_executor.to_sql()),\n            false =\u003e (\n                join_constraint.to_sql_unquoted(),\n                join_executor.to_sql_unquoted(),\n            ),\n        };\n\n        let join_constraints = [join_constraint, join_executor]\n            .iter()\n            .filter(|sql| !sql.is_empty())\n            .join(\" AND \");\n\n        if join_constraints.is_empty() {\n            format!(\"{join_operator} {}\", relation.to_sql_with(quoted))\n        } else {\n            format!(\n                \"{join_operator} {} ON {join_constraints}\",\n                relation.to_sql_with(quoted)\n            )\n        }\n    }\n}\n\nimpl ToSql for JoinExecutor {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for JoinExecutor {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl JoinExecutor {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        let to_sql = |expr: \u0026Expr| match quoted {\n            true =\u003e expr.to_sql(),\n            false =\u003e expr.to_sql_unquoted(),\n        };\n\n        match self {\n            JoinExecutor::NestedLoop =\u003e \"\".to_owned(),\n            JoinExecutor::Hash {\n                key_expr,\n                value_expr,\n                where_clause,\n            } =\u003e {\n                let key_value = format!(\"{} = {}\", to_sql(key_expr), to_sql(value_expr));\n                match where_clause {\n                    Some(expr) =\u003e format!(\"{key_value} AND {}\", to_sql(expr)),\n                    None =\u003e key_value,\n                }\n            }\n        }\n    }\n}\n\nimpl ToSql for JoinConstraint {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for JoinConstraint {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl JoinConstraint {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        match (self, quoted) {\n            (JoinConstraint::On(expr), true) =\u003e expr.to_sql(),\n            (JoinConstraint::On(expr), false) =\u003e expr.to_sql_unquoted(),\n            (JoinConstraint::None, _) =\u003e \"\".to_owned(),\n        }\n    }\n}\n\nimpl ToSql for OrderByExpr {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for OrderByExpr {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl OrderByExpr {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        let OrderByExpr { expr, asc } = self;\n        let expr = match quoted {\n            true =\u003e expr.to_sql(),\n            false =\u003e expr.to_sql_unquoted(),\n        };\n\n        match asc {\n            Some(true) =\u003e format!(\"{} ASC\", expr),\n            Some(false) =\u003e format!(\"{} DESC\", expr),\n            None =\u003e expr,\n        }\n    }\n}\n\nimpl ToSql for Values {\n    fn to_sql(\u0026self) -\u003e String {\n        self.to_sql_with(true)\n    }\n}\n\nimpl ToSqlUnquoted for Values {\n    fn to_sql_unquoted(\u0026self) -\u003e String {\n        self.to_sql_with(false)\n    }\n}\n\nimpl Values {\n    fn to_sql_with(\u0026self, quoted: bool) -\u003e String {\n        let Values(expr) = self;\n\n        expr.iter()\n            .map(|value| {\n                format!(\n                    \"({})\",\n                    value\n                        .iter()\n                        .map(|expr| match quoted {\n                            true =\u003e expr.to_sql(),\n                            false =\u003e expr.to_sql_unquoted(),\n                        })\n                        .join(\", \")\n                )\n            })\n            .join(\", \")\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::{\n                AstLiteral, BinaryOperator, Dictionary, Expr, Join, JoinConstraint, JoinExecutor,\n                JoinOperator, OrderByExpr, Query, Select, SelectItem, SetExpr, TableAlias,\n                TableFactor, TableWithJoins, ToSql, ToSqlUnquoted, Values,\n            },\n            parse_sql::parse_expr,\n            translate::translate_expr,\n        },\n        bigdecimal::BigDecimal,\n        std::str::FromStr,\n    };\n\n    fn expr(sql: \u0026str) -\u003e Expr {\n        let parsed = parse_expr(sql).expect(sql);\n\n        translate_expr(\u0026parsed).expect(sql)\n    }\n\n    #[test]\n    fn to_sql_query() {\n        let order_by = vec![OrderByExpr {\n            expr: Expr::Identifier(\"name\".to_owned()),\n            asc: Some(true),\n        }];\n        let actual =\n            r#\"SELECT * FROM \"FOO\" AS \"F\" ORDER BY \"name\" ASC LIMIT 10 OFFSET 3\"#.to_owned();\n        let expected = Query {\n            body: SetExpr::Select(Box::new(Select {\n                projection: vec![SelectItem::Wildcard],\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"FOO\".to_owned(),\n                        alias: Some(TableAlias {\n                            name: \"F\".to_owned(),\n                            columns: Vec::new(),\n                        }),\n                        index: None,\n                    },\n                    joins: Vec::new(),\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            })),\n            order_by,\n            limit: Some(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"10\").unwrap(),\n            ))),\n            offset: Some(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"3\").unwrap(),\n            ))),\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_unquoted_query() {\n        let order_by = vec![OrderByExpr {\n            expr: Expr::Identifier(\"name\".to_owned()),\n            asc: Some(true),\n        }];\n        let actual = \"SELECT * FROM FOO AS F ORDER BY name ASC LIMIT 10 OFFSET 3\".to_owned();\n        let expected = Query {\n            body: SetExpr::Select(Box::new(Select {\n                projection: vec![SelectItem::Wildcard],\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"FOO\".to_owned(),\n                        alias: Some(TableAlias {\n                            name: \"F\".to_owned(),\n                            columns: Vec::new(),\n                        }),\n                        index: None,\n                    },\n                    joins: Vec::new(),\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            })),\n            order_by,\n            limit: Some(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"10\").unwrap(),\n            ))),\n            offset: Some(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_str(\"3\").unwrap(),\n            ))),\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_set_expr() {\n        let actual = r#\"SELECT * FROM \"FOO\" AS \"F\" INNER JOIN \"PlayerItem\"\"#.to_owned();\n        let expected = SetExpr::Select(Box::new(Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"FOO\".to_owned(),\n                    alias: Some(TableAlias {\n                        name: \"F\".to_owned(),\n                        columns: Vec::new(),\n                    }),\n                    index: None,\n                },\n                joins: vec![Join {\n                    relation: TableFactor::Table {\n                        name: \"PlayerItem\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    join_operator: JoinOperator::Inner(JoinConstraint::None),\n                    join_executor: JoinExecutor::NestedLoop,\n                }],\n            },\n            selection: None,\n            group_by: Vec::new(),\n            having: None,\n        }))\n        .to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = \"VALUES (1, 'glue', 3), (2, 'sql', 2)\".to_owned();\n        let expected = SetExpr::Values(Values(vec![\n            vec![\n                Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1\").unwrap())),\n                Expr::Literal(AstLiteral::QuotedString(\"glue\".to_owned())),\n                Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"3\").unwrap())),\n            ],\n            vec![\n                Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap())),\n                Expr::Literal(AstLiteral::QuotedString(\"sql\".to_owned())),\n                Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap())),\n            ],\n        ]))\n        .to_sql();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_unquoted_set_expr() {\n        let actual = \"SELECT * FROM FOO AS F INNER JOIN PlayerItem\".to_owned();\n        let expected = SetExpr::Select(Box::new(Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"FOO\".to_owned(),\n                    alias: Some(TableAlias {\n                        name: \"F\".to_owned(),\n                        columns: Vec::new(),\n                    }),\n                    index: None,\n                },\n                joins: vec![Join {\n                    relation: TableFactor::Table {\n                        name: \"PlayerItem\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    join_operator: JoinOperator::Inner(JoinConstraint::None),\n                    join_executor: JoinExecutor::NestedLoop,\n                }],\n            },\n            selection: None,\n            group_by: Vec::new(),\n            having: None,\n        }))\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n\n        let actual = \"VALUES (1 + 1, 'glue'), (3 - 2, 'sql')\".to_owned();\n        let expected = SetExpr::Values(Values(vec![\n            vec![\n                Expr::BinaryOp {\n                    left: Box::new(Expr::Literal(AstLiteral::Number(\n                        BigDecimal::from_str(\"1\").unwrap(),\n                    ))),\n                    op: BinaryOperator::Plus,\n                    right: Box::new(Expr::Literal(AstLiteral::Number(\n                        BigDecimal::from_str(\"1\").unwrap(),\n                    ))),\n                },\n                Expr::Literal(AstLiteral::QuotedString(\"glue\".to_owned())),\n            ],\n            vec![\n                Expr::BinaryOp {\n                    left: Box::new(Expr::Literal(AstLiteral::Number(\n                        BigDecimal::from_str(\"3\").unwrap(),\n                    ))),\n                    op: BinaryOperator::Minus,\n                    right: Box::new(Expr::Literal(AstLiteral::Number(\n                        BigDecimal::from_str(\"2\").unwrap(),\n                    ))),\n                },\n                Expr::Literal(AstLiteral::QuotedString(\"sql\".to_owned())),\n            ],\n        ]))\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_select() {\n        let actual =\n            r#\"SELECT * FROM \"FOO\" AS \"F\" GROUP BY \"name\" HAVING \"name\" = 'glue'\"#.to_owned();\n        let expected = Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"FOO\".to_owned(),\n                    alias: Some(TableAlias {\n                        name: \"F\".to_owned(),\n                        columns: Vec::new(),\n                    }),\n                    index: None,\n                },\n                joins: Vec::new(),\n            },\n            selection: None,\n            group_by: vec![Expr::Identifier(\"name\".to_owned())],\n            having: Some(Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(\"name\".to_owned())),\n                op: BinaryOperator::Eq,\n                right: Box::new(Expr::Literal(AstLiteral::QuotedString(\"glue\".to_owned()))),\n            }),\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = r#\"SELECT * FROM \"FOO\" WHERE \"name\" = 'glue'\"#.to_owned();\n        let expected = Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"FOO\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                joins: Vec::new(),\n            },\n            selection: Some(Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(\"name\".to_owned())),\n                op: BinaryOperator::Eq,\n                right: Box::new(Expr::Literal(AstLiteral::QuotedString(\"glue\".to_owned()))),\n            }),\n            group_by: Vec::new(),\n            having: None,\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_unquoted_select() {\n        let actual = \"SELECT * FROM FOO AS F GROUP BY name HAVING name = 'glue'\".to_owned();\n        let expected = Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"FOO\".to_owned(),\n                    alias: Some(TableAlias {\n                        name: \"F\".to_owned(),\n                        columns: Vec::new(),\n                    }),\n                    index: None,\n                },\n                joins: Vec::new(),\n            },\n            selection: None,\n            group_by: vec![Expr::Identifier(\"name\".to_owned())],\n            having: Some(Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(\"name\".to_owned())),\n                op: BinaryOperator::Eq,\n                right: Box::new(Expr::Literal(AstLiteral::QuotedString(\"glue\".to_owned()))),\n            }),\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n\n        let actual = \"SELECT * FROM FOO WHERE name = 'glue'\".to_owned();\n        let expected = Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"FOO\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                joins: Vec::new(),\n            },\n            selection: Some(Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(\"name\".to_owned())),\n                op: BinaryOperator::Eq,\n                right: Box::new(Expr::Literal(AstLiteral::QuotedString(\"glue\".to_owned()))),\n            }),\n            group_by: Vec::new(),\n            having: None,\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_select_item() {\n        let actual = r#\"\"name\" AS \"n\"\"#.to_owned();\n        let expected = SelectItem::Expr {\n            expr: Expr::Identifier(\"name\".to_owned()),\n            label: \"n\".to_owned(),\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = r#\"\"foo\".*\"#.to_owned();\n        let expected = SelectItem::QualifiedWildcard(\"foo\".to_owned()).to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = \"*\".to_owned();\n        let expected = SelectItem::Wildcard.to_sql();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_unquoted_select_item() {\n        let actual = \"name AS n\".to_owned();\n        let expected = SelectItem::Expr {\n            expr: Expr::Identifier(\"name\".to_owned()),\n            label: \"n\".to_owned(),\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n\n        let actual = \"foo.*\".to_owned();\n        let expected = SelectItem::QualifiedWildcard(\"foo\".to_owned()).to_sql_unquoted();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_table_with_joins() {\n        let actual = r#\"\"FOO\" AS \"F\"\"#;\n        let expected = TableWithJoins {\n            relation: TableFactor::Table {\n                name: \"FOO\".to_owned(),\n                alias: Some(TableAlias {\n                    name: \"F\".to_owned(),\n                    columns: Vec::new(),\n                }),\n                index: None,\n            },\n            joins: Vec::new(),\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_unquoted_table_with_joins() {\n        let actual = \"FOO AS F\";\n        let expected = TableWithJoins {\n            relation: TableFactor::Table {\n                name: \"FOO\".to_owned(),\n                alias: Some(TableAlias {\n                    name: \"F\".to_owned(),\n                    columns: Vec::new(),\n                }),\n                index: None,\n            },\n            joins: Vec::new(),\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_table_factor() {\n        let actual = r#\"\"FOO\" AS \"F\"\"#;\n        let expected = TableFactor::Table {\n            name: \"FOO\".to_owned(),\n            alias: Some(TableAlias {\n                name: \"F\".to_owned(),\n                columns: Vec::new(),\n            }),\n            index: None,\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = r#\"(SELECT * FROM \"FOO\") AS \"F\"\"#;\n        let expected = TableFactor::Derived {\n            subquery: Query {\n                body: SetExpr::Select(Box::new(Select {\n                    projection: vec![SelectItem::Wildcard],\n                    from: TableWithJoins {\n                        relation: TableFactor::Table {\n                            name: \"FOO\".to_owned(),\n                            alias: None,\n                            index: None,\n                        },\n                        joins: Vec::new(),\n                    },\n                    selection: None,\n                    group_by: Vec::new(),\n                    having: None,\n                })),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            },\n            alias: TableAlias {\n                name: \"F\".to_owned(),\n                columns: Vec::new(),\n            },\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = r#\"SERIES(3) AS \"S\"\"#;\n        let expected = TableFactor::Series {\n            alias: TableAlias {\n                name: \"S\".to_owned(),\n                columns: Vec::new(),\n            },\n            size: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"3\").unwrap())),\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = r#\"\"GLUE_TABLES\" AS \"glue\"\"#;\n        let expected = TableFactor::Dictionary {\n            dict: Dictionary::GlueTables,\n            alias: TableAlias {\n                name: \"glue\".to_owned(),\n                columns: Vec::new(),\n            },\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_unquoted_table_factor() {\n        let actual = \"FOO AS F\";\n        let expected = TableFactor::Table {\n            name: \"FOO\".to_owned(),\n            alias: Some(TableAlias {\n                name: \"F\".to_owned(),\n                columns: Vec::new(),\n            }),\n            index: None,\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n\n        let actual = \"(SELECT * FROM FOO) AS F\";\n        let expected = TableFactor::Derived {\n            subquery: Query {\n                body: SetExpr::Select(Box::new(Select {\n                    projection: vec![SelectItem::Wildcard],\n                    from: TableWithJoins {\n                        relation: TableFactor::Table {\n                            name: \"FOO\".to_owned(),\n                            alias: None,\n                            index: None,\n                        },\n                        joins: Vec::new(),\n                    },\n                    selection: None,\n                    group_by: Vec::new(),\n                    having: None,\n                })),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            },\n            alias: TableAlias {\n                name: \"F\".to_owned(),\n                columns: Vec::new(),\n            },\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n\n        let actual = \"SERIES(3) AS S\";\n        let expected = TableFactor::Series {\n            alias: TableAlias {\n                name: \"S\".to_owned(),\n                columns: Vec::new(),\n            },\n            size: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"3\").unwrap())),\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n\n        let actual = \"GLUE_TABLES AS glue\";\n        let expected = TableFactor::Dictionary {\n            dict: Dictionary::GlueTables,\n            alias: TableAlias {\n                name: \"glue\".to_owned(),\n                columns: Vec::new(),\n            },\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_table_alias() {\n        let actual = r#\"AS \"F\"\"#;\n        let expected = TableAlias {\n            name: \"F\".to_owned(),\n            columns: Vec::new(),\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_unquoted_table_alias() {\n        let actual = \"AS F\";\n        let expected = TableAlias {\n            name: \"F\".to_owned(),\n            columns: Vec::new(),\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_join() {\n        let actual = r#\"INNER JOIN \"PlayerItem\"\"#;\n        let expected = Join {\n            relation: TableFactor::Table {\n                name: \"PlayerItem\".to_owned(),\n                alias: None,\n                index: None,\n            },\n            join_operator: JoinOperator::Inner(JoinConstraint::None),\n            join_executor: JoinExecutor::NestedLoop,\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = r#\"INNER JOIN \"PlayerItem\" ON \"PlayerItem\".\"user_id\" = \"Player\".\"id\"\"#;\n        let expected = Join {\n            relation: TableFactor::Table {\n                name: \"PlayerItem\".to_owned(),\n                alias: None,\n                index: None,\n            },\n            join_operator: JoinOperator::Inner(JoinConstraint::On(expr(\n                r#\"\"PlayerItem\".\"user_id\" = \"Player\".\"id\"\"#,\n            ))),\n            join_executor: JoinExecutor::NestedLoop,\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = r#\"LEFT OUTER JOIN \"PlayerItem\"\"#;\n        let expected = Join {\n            relation: TableFactor::Table {\n                name: \"PlayerItem\".to_owned(),\n                alias: None,\n                index: None,\n            },\n            join_operator: JoinOperator::LeftOuter(JoinConstraint::None),\n            join_executor: JoinExecutor::NestedLoop,\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = r#\"LEFT OUTER JOIN \"PlayerItem\" ON \"PlayerItem\".\"user_id\" = \"Player\".\"id\"\"#;\n        let expected = Join {\n            relation: TableFactor::Table {\n                name: \"PlayerItem\".to_owned(),\n                alias: None,\n                index: None,\n            },\n            join_operator: JoinOperator::LeftOuter(JoinConstraint::None),\n            join_executor: JoinExecutor::Hash {\n                key_expr: expr(\"PlayerItem.user_id\"),\n                value_expr: expr(\"Player.id\"),\n                where_clause: None,\n            },\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = r#\"LEFT OUTER JOIN \"PlayerItem\" ON \"PlayerItem\".\"age\" \u003e \"Player\".\"age\" AND \"PlayerItem\".\"user_id\" = \"Player\".\"id\" AND \"PlayerItem\".\"amount\" \u003e 10 AND \"PlayerItem\".\"amount\" * 3 \u003c= 2\"#;\n        let expected = Join {\n            relation: TableFactor::Table {\n                name: \"PlayerItem\".to_owned(),\n                alias: None,\n                index: None,\n            },\n            join_operator: JoinOperator::LeftOuter(JoinConstraint::On(expr(\n                r#\"\"PlayerItem\".\"age\" \u003e \"Player\".\"age\"\"#,\n            ))),\n            join_executor: JoinExecutor::Hash {\n                key_expr: expr(\"PlayerItem.user_id\"),\n                value_expr: expr(\"Player.id\"),\n                where_clause: Some(expr(\n                    r#\"\"PlayerItem\".\"amount\" \u003e 10 AND \"PlayerItem\".\"amount\" * 3 \u003c= 2\"#,\n                )),\n            },\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_unquoted_join() {\n        let actual = \"INNER JOIN PlayerItem\";\n        let expected = Join {\n            relation: TableFactor::Table {\n                name: \"PlayerItem\".to_owned(),\n                alias: None,\n                index: None,\n            },\n            join_operator: JoinOperator::Inner(JoinConstraint::None),\n            join_executor: JoinExecutor::NestedLoop,\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n\n        let actual = \"INNER JOIN PlayerItem ON PlayerItem.user_id = Player.id AND PlayerItem.group_id = Player.group_id\";\n        let expected = Join {\n            relation: TableFactor::Table {\n                name: \"PlayerItem\".to_owned(),\n                alias: None,\n                index: None,\n            },\n            join_operator: JoinOperator::Inner(JoinConstraint::On(expr(\n                \"PlayerItem.user_id = Player.id\",\n            ))),\n            join_executor: JoinExecutor::Hash {\n                key_expr: expr(\"PlayerItem.group_id\"),\n                value_expr: expr(\"Player.group_id\"),\n                where_clause: None,\n            },\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n\n        let actual = \"LEFT OUTER JOIN PlayerItem\";\n        let expected = Join {\n            relation: TableFactor::Table {\n                name: \"PlayerItem\".to_owned(),\n                alias: None,\n                index: None,\n            },\n            join_operator: JoinOperator::LeftOuter(JoinConstraint::None),\n            join_executor: JoinExecutor::NestedLoop,\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n\n        let actual = \"LEFT OUTER JOIN PlayerItem ON PlayerItem.user_id = Player.id\";\n        let expected = Join {\n            relation: TableFactor::Table {\n                name: \"PlayerItem\".to_owned(),\n                alias: None,\n                index: None,\n            },\n            join_operator: JoinOperator::LeftOuter(JoinConstraint::None),\n            join_executor: JoinExecutor::Hash {\n                key_expr: expr(\"PlayerItem.user_id\"),\n                value_expr: expr(\"Player.id\"),\n                where_clause: None,\n            },\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n\n        let actual = \"LEFT OUTER JOIN PlayerItem ON PlayerItem.age \u003e Player.age AND PlayerItem.user_id = Player.id AND PlayerItem.amount \u003e 10 AND PlayerItem.amount * 3 \u003c= 2\";\n        let expected = Join {\n            relation: TableFactor::Table {\n                name: \"PlayerItem\".to_owned(),\n                alias: None,\n                index: None,\n            },\n            join_operator: JoinOperator::LeftOuter(JoinConstraint::On(expr(\n                \"PlayerItem.age \u003e Player.age\",\n            ))),\n            join_executor: JoinExecutor::Hash {\n                key_expr: expr(\"PlayerItem.user_id\"),\n                value_expr: expr(\"Player.id\"),\n                where_clause: Some(expr(\n                    \"PlayerItem.amount \u003e 10 AND PlayerItem.amount * 3 \u003c= 2\",\n                )),\n            },\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_order_by_expr() {\n        let actual = r#\"\"foo\" ASC\"#;\n        let expected = OrderByExpr {\n            expr: Expr::Identifier(\"foo\".to_owned()),\n            asc: Some(true),\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = r#\"\"foo\" DESC\"#;\n        let expected = OrderByExpr {\n            expr: Expr::Identifier(\"foo\".to_owned()),\n            asc: Some(false),\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n\n        let actual = r#\"\"foo\"\"#;\n        let expected = OrderByExpr {\n            expr: Expr::Identifier(\"foo\".to_owned()),\n            asc: None,\n        }\n        .to_sql();\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn to_sql_unquoted_order_by_expr() {\n        let actual = \"foo ASC\";\n        let expected = OrderByExpr {\n            expr: Expr::Identifier(\"foo\".to_owned()),\n            asc: Some(true),\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n\n        let actual = \"foo DESC\";\n        let expected = OrderByExpr {\n            expr: Expr::Identifier(\"foo\".to_owned()),\n            asc: Some(false),\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n\n        let actual = \"foo\";\n        let expected = OrderByExpr {\n            expr: Expr::Identifier(\"foo\".to_owned()),\n            asc: None,\n        }\n        .to_sql_unquoted();\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":215},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast.rs"],"content":"mod ast_literal;\nmod data_type;\nmod ddl;\nmod expr;\nmod function;\nmod operator;\nmod query;\n\npub use {\n    ast_literal::{AstLiteral, DateTimeField, TrimWhereField},\n    data_type::DataType,\n    ddl::*,\n    expr::Expr,\n    function::{Aggregate, CountArgExpr, Function},\n    operator::*,\n    query::*,\n};\n\nuse {\n    serde::{Deserialize, Serialize},\n    strum_macros::Display,\n};\n\npub trait ToSql {\n    fn to_sql(\u0026self) -\u003e String;\n}\n\npub trait ToSqlUnquoted {\n    fn to_sql_unquoted(\u0026self) -\u003e String;\n}\n\n#[derive(PartialEq, Debug, Clone, Eq, Hash, Serialize, Deserialize)]\npub struct ForeignKey {\n    pub name: String,\n    pub referencing_column_name: String,\n    pub referenced_table_name: String,\n    pub referenced_column_name: String,\n    pub on_delete: ReferentialAction,\n    pub on_update: ReferentialAction,\n}\n\n#[derive(PartialEq, Debug, Clone, Eq, Hash, Serialize, Deserialize, Display)]\npub enum ReferentialAction {\n    #[strum(to_string = \"NO ACTION\")]\n    NoAction,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Statement {\n    ShowColumns {\n        table_name: String,\n    },\n    /// SELECT, VALUES\n    Query(Query),\n    /// INSERT\n    Insert {\n        /// TABLE\n        table_name: String,\n        /// COLUMNS\n        columns: Vec\u003cString\u003e,\n        /// A SQL query that specifies what to insert\n        source: Query,\n    },\n    /// UPDATE\n    Update {\n        /// TABLE\n        table_name: String,\n        /// Column assignments\n        assignments: Vec\u003cAssignment\u003e,\n        /// WHERE\n        selection: Option\u003cExpr\u003e,\n    },\n    /// DELETE\n    Delete {\n        /// FROM\n        table_name: String,\n        /// WHERE\n        selection: Option\u003cExpr\u003e,\n    },\n    /// CREATE TABLE\n    CreateTable {\n        if_not_exists: bool,\n        /// Table name\n        name: String,\n        /// Optional schema\n        columns: Option\u003cVec\u003cColumnDef\u003e\u003e,\n        source: Option\u003cBox\u003cQuery\u003e\u003e,\n        engine: Option\u003cString\u003e,\n        foreign_keys: Vec\u003cForeignKey\u003e,\n        comment: Option\u003cString\u003e,\n    },\n    /// CREATE FUNCTION\n    CreateFunction {\n        or_replace: bool,\n        name: String,\n        /// Optional schema\n        args: Vec\u003cOperateFunctionArg\u003e,\n        return_: Expr,\n    },\n    /// ALTER TABLE\n    AlterTable {\n        /// Table name\n        name: String,\n        operation: AlterTableOperation,\n    },\n    /// DROP TABLE\n    DropTable {\n        /// An optional `IF EXISTS` clause. (Non-standard.)\n        if_exists: bool,\n        /// One or more objects to drop. (ANSI SQL requires exactly one.)\n        names: Vec\u003cString\u003e,\n        /// An optional `CASCADE` clause for dropping dependent constructs.\n        cascade: bool,\n    },\n    /// DROP FUNCTION\n    DropFunction {\n        /// An optional `IF EXISTS` clause. (Non-standard.)\n        if_exists: bool,\n        /// One or more objects to drop. (ANSI SQL requires exactly one.)\n        names: Vec\u003cString\u003e,\n    },\n    /// CREATE INDEX\n    CreateIndex {\n        name: String,\n        table_name: String,\n        column: OrderByExpr,\n    },\n    /// DROP INDEX\n    DropIndex {\n        name: String,\n        table_name: String,\n    },\n    /// START TRANSACTION, BEGIN\n    StartTransaction,\n    /// COMMIT\n    Commit,\n    /// ROLLBACK\n    Rollback,\n    /// SHOW VARIABLE\n    ShowVariable(Variable),\n    ShowIndexes(String),\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Assignment {\n    pub id: String,\n    pub value: Expr,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Variable {\n    Tables,\n    Functions,\n    Version,\n}\n\nimpl ToSql for Statement {\n    fn to_sql(\u0026self) -\u003e String {\n        match self {\n            Statement::ShowColumns { table_name } =\u003e {\n                format!(\"SHOW COLUMNS FROM {table_name};\")\n            }\n            Statement::Insert {\n                table_name,\n                columns,\n                source,\n            } =\u003e {\n                let columns = match columns.is_empty() {\n                    true =\u003e \"\".to_owned(),\n                    false =\u003e format!(\"({}) \", columns.join(\", \")),\n                };\n\n                format!(\n                    r#\"INSERT INTO \"{table_name}\" {columns}{};\"#,\n                    source.to_sql()\n                )\n            }\n            Statement::Update {\n                table_name,\n                assignments,\n                selection,\n            } =\u003e {\n                let assignments = assignments\n                    .iter()\n                    .map(ToSql::to_sql)\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \");\n                match selection {\n                    Some(expr) =\u003e {\n                        format!(\n                            r#\"UPDATE \"{table_name}\" SET {assignments} WHERE {};\"#,\n                            expr.to_sql()\n                        )\n                    }\n                    None =\u003e format!(r#\"UPDATE \"{table_name}\" SET {assignments};\"#),\n                }\n            }\n            Statement::Delete {\n                table_name,\n                selection,\n            } =\u003e match selection {\n                Some(expr) =\u003e format!(r#\"DELETE FROM \"{table_name}\" WHERE {};\"#, expr.to_sql()),\n                None =\u003e format!(r#\"DELETE FROM \"{table_name}\";\"#),\n            },\n            Statement::CreateTable {\n                if_not_exists,\n                name,\n                columns,\n                source,\n                engine,\n                foreign_keys,\n                comment,\n            } =\u003e {\n                let if_not_exists = if_not_exists.then_some(\"IF NOT EXISTS\");\n                let body = match (source, columns) {\n                    (Some(query), _) =\u003e Some(format!(\"AS {}\", query.to_sql())),\n                    (None, None) =\u003e None,\n                    (None, Some(columns)) =\u003e {\n                        let foreign_keys = foreign_keys.iter().map(ToSql::to_sql);\n                        let body = columns\n                            .iter()\n                            .map(ToSql::to_sql)\n                            .chain(foreign_keys)\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\", \");\n\n                        Some(format!(\"({body})\"))\n                    }\n                };\n                let engine = engine.as_ref().map(|engine| format!(\"ENGINE = {engine}\"));\n                let comment = comment\n                    .as_ref()\n                    .map(|comment| format!(\"COMMENT = '{comment}'\"));\n                let sql = vec![\n                    Some(\"CREATE TABLE\"),\n                    if_not_exists,\n                    Some(\u0026format! {r#\"\"{name}\"\"#}),\n                    body.as_deref(),\n                    engine.as_deref(),\n                    comment.as_deref(),\n                ]\n                .into_iter()\n                .flatten()\n                .collect::\u003cVec\u003c\u0026str\u003e\u003e()\n                .join(\" \");\n\n                format!(\"{sql};\")\n            }\n            Statement::CreateFunction {\n                or_replace,\n                name,\n                args,\n                return_,\n                ..\n            } =\u003e {\n                let or_replace = or_replace.then_some(\" OR REPLACE\").unwrap_or(\"\");\n                let args = args\n                    .iter()\n                    .map(ToSql::to_sql)\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \");\n                let return_ = format!(\" RETURN {}\", return_.to_sql());\n                format!(\"CREATE{or_replace} FUNCTION {name}({args}){return_};\")\n            }\n            Statement::AlterTable { name, operation } =\u003e {\n                format!(r#\"ALTER TABLE \"{name}\" {};\"#, operation.to_sql())\n            }\n            Statement::DropTable {\n                if_exists,\n                names,\n                cascade,\n            } =\u003e {\n                let if_exists = if_exists.then_some(\"IF EXISTS\").unwrap_or_default();\n                let names = names\n                    .iter()\n                    .map(|name| format!(r#\"\"{name}\"\"#))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \");\n                let cascade = cascade.then_some(\"CASCADE\").unwrap_or_default();\n\n                vec![\"DROP TABLE\", if_exists, \u0026names, cascade]\n                    .into_iter()\n                    .filter(|s| !s.is_empty())\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\" \")\n                    + \";\"\n            }\n            Statement::DropFunction { if_exists, names } =\u003e {\n                let names = names.join(\", \");\n                match if_exists {\n                    true =\u003e format!(\"DROP FUNCTION IF EXISTS {};\", names),\n                    false =\u003e format!(\"DROP FUNCTION {};\", names),\n                }\n            }\n            Statement::CreateIndex {\n                name,\n                table_name,\n                column,\n            } =\u003e {\n                format!(\n                    r#\"CREATE INDEX \"{name}\" ON \"{table_name}\" ({});\"#,\n                    column.to_sql()\n                )\n            }\n            Statement::DropIndex { name, table_name } =\u003e {\n                format!(\"DROP INDEX {table_name}.{name};\")\n            }\n            Statement::StartTransaction =\u003e \"START TRANSACTION;\".to_owned(),\n            Statement::Commit =\u003e \"COMMIT;\".to_owned(),\n            Statement::Rollback =\u003e \"ROLLBACK;\".to_owned(),\n            Statement::ShowVariable(variable) =\u003e match variable {\n                Variable::Tables =\u003e \"SHOW TABLES;\".to_owned(),\n                Variable::Functions =\u003e \"SHOW FUNCTIONS;\".to_owned(),\n                Variable::Version =\u003e \"SHOW VERSIONS;\".to_owned(),\n            },\n            Statement::ShowIndexes(object_name) =\u003e {\n                format!(r#\"SHOW INDEXES FROM \"{object_name}\";\"#)\n            }\n            _ =\u003e \"(..statement..)\".to_owned(),\n        }\n    }\n}\n\nimpl ToSql for Assignment {\n    fn to_sql(\u0026self) -\u003e String {\n        format!(r#\"\"{}\" = {}\"#, self.id, self.value.to_sql())\n    }\n}\n\nimpl ToSql for ForeignKey {\n    fn to_sql(\u0026self) -\u003e String {\n        let ForeignKey {\n            referencing_column_name,\n            referenced_table_name,\n            referenced_column_name,\n            name,\n            on_delete,\n            on_update,\n        } = self;\n\n        format!(\n            r#\"CONSTRAINT \"{}\" FOREIGN KEY (\"{}\") REFERENCES \"{}\" (\"{}\") ON DELETE {} ON UPDATE {}\"#,\n            name,\n            referencing_column_name,\n            referenced_table_name,\n            referenced_column_name,\n            on_delete,\n            on_update\n        )\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Array {\n    pub elem: Vec\u003cExpr\u003e,\n    pub named: bool,\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::ast::{\n            AlterTableOperation, Assignment, AstLiteral, BinaryOperator, ColumnDef, DataType, Expr,\n            ForeignKey, OperateFunctionArg, OrderByExpr, Query, ReferentialAction, Select,\n            SelectItem, SetExpr, Statement, TableFactor, TableWithJoins, ToSql, Values, Variable,\n        },\n        bigdecimal::BigDecimal,\n        std::str::FromStr,\n    };\n\n    #[test]\n    fn to_sql_show_columns() {\n        assert_eq!(\n            \"SHOW COLUMNS FROM Bar;\",\n            Statement::ShowColumns {\n                table_name: \"Bar\".into()\n            }\n            .to_sql()\n        )\n    }\n\n    #[test]\n    fn to_sql_insert() {\n        assert_eq!(\n            r#\"INSERT INTO \"Test\" (id, num, name) VALUES (1, 2, 'Hello');\"#,\n            Statement::Insert {\n                table_name: \"Test\".into(),\n                columns: vec![\"id\".to_owned(), \"num\".to_owned(), \"name\".to_owned()],\n                source: Query {\n                    body: SetExpr::Values(Values(vec![vec![\n                        Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1\").unwrap())),\n                        Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"2\").unwrap())),\n                        Expr::Literal(AstLiteral::QuotedString(\"Hello\".to_owned()))\n                    ]])),\n                    order_by: vec![],\n                    limit: None,\n                    offset: None\n                }\n            }\n            .to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_update() {\n        assert_eq!(\n            r#\"UPDATE \"Foo\" SET \"id\" = 4, \"color\" = 'blue';\"#,\n            Statement::Update {\n                table_name: \"Foo\".into(),\n                assignments: vec![\n                    Assignment {\n                        id: \"id\".to_owned(),\n                        value: Expr::Literal(AstLiteral::Number(\n                            BigDecimal::from_str(\"4\").unwrap()\n                        ))\n                    },\n                    Assignment {\n                        id: \"color\".to_owned(),\n                        value: Expr::Literal(AstLiteral::QuotedString(\"blue\".to_owned()))\n                    }\n                ],\n                selection: None\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"UPDATE \"Foo\" SET \"name\" = 'first' WHERE \"a\" \u003e \"b\";\"#,\n            Statement::Update {\n                table_name: \"Foo\".into(),\n                assignments: vec![Assignment {\n                    id: \"name\".to_owned(),\n                    value: Expr::Literal(AstLiteral::QuotedString(\"first\".to_owned()))\n                }],\n                selection: Some(Expr::BinaryOp {\n                    left: Box::new(Expr::Identifier(\"a\".to_owned())),\n                    op: BinaryOperator::Gt,\n                    right: Box::new(Expr::Identifier(\"b\".to_owned()))\n                })\n            }\n            .to_sql()\n        )\n    }\n\n    #[test]\n    fn to_sql_delete() {\n        assert_eq!(\n            r#\"DELETE FROM \"Foo\";\"#,\n            Statement::Delete {\n                table_name: \"Foo\".into(),\n                selection: None\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"DELETE FROM \"Foo\" WHERE \"item\" = 'glue';\"#,\n            Statement::Delete {\n                table_name: \"Foo\".into(),\n                selection: Some(Expr::BinaryOp {\n                    left: Box::new(Expr::Identifier(\"item\".to_owned())),\n                    op: BinaryOperator::Eq,\n                    right: Box::new(Expr::Literal(AstLiteral::QuotedString(\"glue\".to_owned())))\n                })\n            }\n            .to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_create_table() {\n        assert_eq!(\n            r#\"CREATE TABLE IF NOT EXISTS \"Foo\";\"#,\n            Statement::CreateTable {\n                if_not_exists: true,\n                name: \"Foo\".into(),\n                columns: None,\n                source: None,\n                engine: None,\n                foreign_keys: Vec::new(),\n                comment: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"CREATE TABLE \"Foo\";\"#,\n            Statement::CreateTable {\n                if_not_exists: false,\n                name: \"Foo\".into(),\n                columns: None,\n                source: None,\n                engine: None,\n                foreign_keys: Vec::new(),\n                comment: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"CREATE TABLE IF NOT EXISTS \"Foo\" (\"id\" BOOLEAN NOT NULL) COMMENT = 'this is comment';\"#,\n            Statement::CreateTable {\n                if_not_exists: true,\n                name: \"Foo\".into(),\n                columns: Some(vec![ColumnDef {\n                    name: \"id\".to_owned(),\n                    data_type: DataType::Boolean,\n                    nullable: false,\n                    default: None,\n                    unique: None,\n                    comment: None,\n                },]),\n                source: None,\n                engine: None,\n                foreign_keys: Vec::new(),\n                comment: Some(\"this is comment\".to_owned()),\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"CREATE TABLE \"Foo\" (\"id\" INT NOT NULL, \"num\" INT NULL, \"name\" TEXT NOT NULL);\"#,\n            Statement::CreateTable {\n                if_not_exists: false,\n                name: \"Foo\".into(),\n                columns: Some(vec![\n                    ColumnDef {\n                        name: \"id\".to_owned(),\n                        data_type: DataType::Int,\n                        nullable: false,\n                        default: None,\n                        unique: None,\n                        comment: None,\n                    },\n                    ColumnDef {\n                        name: \"num\".to_owned(),\n                        data_type: DataType::Int,\n                        nullable: true,\n                        default: None,\n                        unique: None,\n                        comment: None,\n                    },\n                    ColumnDef {\n                        name: \"name\".to_owned(),\n                        data_type: DataType::Text,\n                        nullable: false,\n                        default: None,\n                        unique: None,\n                        comment: None,\n                    }\n                ]),\n                source: None,\n                engine: None,\n                foreign_keys: Vec::new(),\n                comment: None,\n            }\n            .to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_create_table_as() {\n        assert_eq!(\n            r#\"CREATE TABLE \"Foo\" AS SELECT \"id\", \"count\" FROM \"Bar\";\"#,\n            Statement::CreateTable {\n                if_not_exists: false,\n                name: \"Foo\".into(),\n                columns: None,\n                source: Some(Box::new(Query {\n                    body: SetExpr::Select(Box::new(Select {\n                        projection: vec![\n                            SelectItem::Expr {\n                                expr: Expr::Identifier(\"id\".to_owned()),\n                                label: \"\".to_owned()\n                            },\n                            SelectItem::Expr {\n                                expr: Expr::Identifier(\"count\".to_owned()),\n                                label: \"\".to_owned()\n                            }\n                        ],\n                        from: TableWithJoins {\n                            relation: TableFactor::Table {\n                                name: \"Bar\".to_owned(),\n                                alias: None,\n                                index: None\n                            },\n                            joins: vec![]\n                        },\n                        selection: None,\n                        group_by: vec![],\n                        having: None\n                    })),\n                    order_by: vec![],\n                    limit: None,\n                    offset: None\n                })),\n                engine: None,\n                foreign_keys: Vec::new(),\n                comment: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"CREATE TABLE IF NOT EXISTS \"Foo\" AS VALUES (TRUE);\"#,\n            Statement::CreateTable {\n                if_not_exists: true,\n                name: \"Foo\".into(),\n                columns: None,\n                source: Some(Box::new(Query {\n                    body: SetExpr::Values(Values(vec![vec![Expr::Literal(AstLiteral::Boolean(\n                        true\n                    ))]])),\n                    order_by: vec![],\n                    limit: None,\n                    offset: None\n                })),\n                engine: None,\n                foreign_keys: Vec::new(),\n                comment: None,\n            }\n            .to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_create_table_with_engine() {\n        assert_eq!(\n            r#\"CREATE TABLE \"Foo\" ENGINE = MEMORY;\"#,\n            Statement::CreateTable {\n                if_not_exists: false,\n                name: \"Foo\".into(),\n                columns: None,\n                source: None,\n                engine: Some(\"MEMORY\".to_owned()),\n                foreign_keys: Vec::new(),\n                comment: None,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"CREATE TABLE \"Foo\" (\"id\" BOOLEAN NOT NULL) ENGINE = SLED;\"#,\n            Statement::CreateTable {\n                if_not_exists: false,\n                name: \"Foo\".into(),\n                columns: Some(vec![ColumnDef {\n                    name: \"id\".to_owned(),\n                    data_type: DataType::Boolean,\n                    nullable: false,\n                    default: None,\n                    unique: None,\n                    comment: None,\n                },]),\n                source: None,\n                engine: Some(\"SLED\".to_owned()),\n                foreign_keys: Vec::new(),\n                comment: None,\n            }\n            .to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_insert_function() {\n        assert_eq!(\n            r#\"CREATE FUNCTION add(\"num\" INT DEFAULT 0) RETURN \"num\";\"#,\n            Statement::CreateFunction {\n                or_replace: false,\n                name: \"add\".into(),\n                args: vec![OperateFunctionArg {\n                    name: \"num\".into(),\n                    data_type: DataType::Int,\n                    default: Some(Expr::Literal(AstLiteral::Number(\n                        BigDecimal::from_str(\"0\").unwrap()\n                    ))),\n                }],\n                return_: Expr::Identifier(\"num\".to_owned())\n            }\n            .to_sql()\n        );\n        assert_eq!(\n            \"CREATE OR REPLACE FUNCTION add() RETURN 1;\",\n            Statement::CreateFunction {\n                or_replace: true,\n                name: \"add\".into(),\n                args: vec![],\n                return_: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"1\").unwrap()))\n            }\n            .to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_alter_table() {\n        assert_eq!(\n            r#\"ALTER TABLE \"Foo\" ADD COLUMN \"amount\" INT NOT NULL DEFAULT 10;\"#,\n            Statement::AlterTable {\n                name: \"Foo\".into(),\n                operation: AlterTableOperation::AddColumn {\n                    column_def: ColumnDef {\n                        name: \"amount\".to_owned(),\n                        data_type: DataType::Int,\n                        nullable: false,\n                        default: Some(Expr::Literal(AstLiteral::Number(\n                            BigDecimal::from_str(\"10\").unwrap()\n                        ))),\n                        unique: None,\n                        comment: None,\n                    }\n                }\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"ALTER TABLE \"Foo\" DROP COLUMN \"something\";\"#,\n            Statement::AlterTable {\n                name: \"Foo\".into(),\n                operation: AlterTableOperation::DropColumn {\n                    column_name: \"something\".to_owned(),\n                    if_exists: false\n                }\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"ALTER TABLE \"Foo\" DROP COLUMN IF EXISTS \"something\";\"#,\n            Statement::AlterTable {\n                name: \"Foo\".into(),\n                operation: AlterTableOperation::DropColumn {\n                    column_name: \"something\".to_owned(),\n                    if_exists: true\n                }\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"ALTER TABLE \"Bar\" RENAME COLUMN \"id\" TO \"new_id\";\"#,\n            Statement::AlterTable {\n                name: \"Bar\".into(),\n                operation: AlterTableOperation::RenameColumn {\n                    old_column_name: \"id\".to_owned(),\n                    new_column_name: \"new_id\".to_owned()\n                }\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"ALTER TABLE \"Foo\" RENAME TO \"Bar\";\"#,\n            Statement::AlterTable {\n                name: \"Foo\".to_owned(),\n                operation: AlterTableOperation::RenameTable {\n                    table_name: \"Bar\".to_owned(),\n                }\n            }\n            .to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_drop_table() {\n        assert_eq!(\n            r#\"DROP TABLE \"Test\";\"#,\n            Statement::DropTable {\n                if_exists: false,\n                names: vec![\"Test\".into()],\n                cascade: false,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"DROP TABLE IF EXISTS \"Test\";\"#,\n            Statement::DropTable {\n                if_exists: true,\n                names: vec![\"Test\".into()],\n                cascade: false,\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            r#\"DROP TABLE \"Foo\", \"Bar\";\"#,\n            Statement::DropTable {\n                if_exists: false,\n                names: vec![\"Foo\".into(), \"Bar\".into(),],\n                cascade: false,\n            }\n            .to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_delete_function() {\n        assert_eq!(\n            \"DROP FUNCTION Test;\",\n            Statement::DropFunction {\n                if_exists: false,\n                names: vec![\"Test\".into()]\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"DROP FUNCTION IF EXISTS Test;\",\n            Statement::DropFunction {\n                if_exists: true,\n                names: vec![\"Test\".into()]\n            }\n            .to_sql()\n        );\n\n        assert_eq!(\n            \"DROP FUNCTION Foo, Bar;\",\n            Statement::DropFunction {\n                if_exists: false,\n                names: vec![\"Foo\".into(), \"Bar\".into(),]\n            }\n            .to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_create_index() {\n        assert_eq!(\n            r#\"CREATE INDEX \"idx_name\" ON \"Test\" (\"LastName\");\"#,\n            Statement::CreateIndex {\n                name: \"idx_name\".into(),\n                table_name: \"Test\".into(),\n                column: OrderByExpr {\n                    expr: Expr::Identifier(\"LastName\".to_owned()),\n                    asc: None\n                }\n            }\n            .to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_drop_index() {\n        assert_eq!(\n            \"DROP INDEX Test.idx_id;\",\n            Statement::DropIndex {\n                name: \"idx_id\".into(),\n                table_name: \"Test\".into(),\n            }\n            .to_sql()\n        )\n    }\n\n    #[test]\n    fn to_sql_transaction() {\n        assert_eq!(\"START TRANSACTION;\", Statement::StartTransaction.to_sql());\n        assert_eq!(\"COMMIT;\", Statement::Commit.to_sql());\n        assert_eq!(\"ROLLBACK;\", Statement::Rollback.to_sql());\n    }\n\n    #[test]\n    fn to_sql_show_variable() {\n        assert_eq!(\n            \"SHOW TABLES;\",\n            Statement::ShowVariable(Variable::Tables).to_sql()\n        );\n        assert_eq!(\n            \"SHOW FUNCTIONS;\",\n            Statement::ShowVariable(Variable::Functions).to_sql()\n        );\n        assert_eq!(\n            \"SHOW VERSIONS;\",\n            Statement::ShowVariable(Variable::Version).to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_show_indexes() {\n        assert_eq!(\n            r#\"SHOW INDEXES FROM \"Test\";\"#,\n            Statement::ShowIndexes(\"Test\".into()).to_sql()\n        );\n    }\n\n    #[test]\n    fn to_sql_assignment() {\n        assert_eq!(\n            r#\"\"count\" = 5\"#,\n            Assignment {\n                id: \"count\".to_owned(),\n                value: Expr::Literal(AstLiteral::Number(BigDecimal::from_str(\"5\").unwrap()))\n            }\n            .to_sql()\n        )\n    }\n\n    #[test]\n    fn to_sql_foreign_key() {\n        assert_eq!(\n            r#\"CONSTRAINT \"fk_id\" FOREIGN KEY (\"id\") REFERENCES \"Test\" (\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION\"#,\n            ForeignKey {\n                name: \"fk_id\".into(),\n                referencing_column_name: \"id\".into(),\n                referenced_table_name: \"Test\".into(),\n                referenced_column_name: \"id\".into(),\n                on_delete: ReferentialAction::NoAction,\n                on_update: ReferentialAction::NoAction,\n            }\n            .to_sql()\n        )\n    }\n}\n","traces":[{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":125},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","alter_table.rs"],"content":"use {\n    super::Build,\n    crate::{\n        ast::{AlterTableOperation, Statement},\n        ast_builder::ColumnDefNode,\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub struct AlterTableNode {\n    table_name: String,\n}\n\nimpl AlterTableNode {\n    pub fn new(table_name: String) -\u003e Self {\n        Self { table_name }\n    }\n\n    pub fn add_column\u003cT: Into\u003cColumnDefNode\u003e\u003e(self, column: T) -\u003e AddColumnNode {\n        AddColumnNode {\n            table_node: self,\n            column_def: column.into(),\n        }\n    }\n\n    pub fn drop_column(self, column_name: \u0026str) -\u003e DropColumnNode {\n        DropColumnNode {\n            table_node: self,\n            column_name: column_name.to_owned(),\n            if_exists: false,\n        }\n    }\n\n    pub fn drop_column_if_exists(self, column_name: \u0026str) -\u003e DropColumnNode {\n        DropColumnNode {\n            table_node: self,\n            column_name: column_name.to_owned(),\n            if_exists: true,\n        }\n    }\n\n    pub fn rename_column(self, old_name: \u0026str, new_name: \u0026str) -\u003e RenameColumnNode {\n        RenameColumnNode {\n            table_node: self,\n            old_column_name: old_name.to_owned(),\n            new_column_name: new_name.to_owned(),\n        }\n    }\n\n    pub fn rename_table(self, new_table_name: \u0026str) -\u003e RenameTableNode {\n        RenameTableNode {\n            table_node: self,\n            new_table_name: new_table_name.to_owned(),\n        }\n    }\n}\n\npub struct AddColumnNode {\n    table_node: AlterTableNode,\n    column_def: ColumnDefNode,\n}\n\nimpl Build for AddColumnNode {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let table_name = self.table_node.table_name;\n        let operation = AlterTableOperation::AddColumn {\n            column_def: self.column_def.try_into()?,\n        };\n        Ok(Statement::AlterTable {\n            name: table_name,\n            operation,\n        })\n    }\n}\n\npub struct DropColumnNode {\n    table_node: AlterTableNode,\n    column_name: String,\n    if_exists: bool,\n}\n\nimpl Build for DropColumnNode {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let table_name = self.table_node.table_name;\n        let operation = AlterTableOperation::DropColumn {\n            column_name: self.column_name,\n            if_exists: self.if_exists,\n        };\n        Ok(Statement::AlterTable {\n            name: table_name,\n            operation,\n        })\n    }\n}\n\npub struct RenameColumnNode {\n    table_node: AlterTableNode,\n    old_column_name: String,\n    new_column_name: String,\n}\n\nimpl Build for RenameColumnNode {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let table_name = self.table_node.table_name;\n        let operation = AlterTableOperation::RenameColumn {\n            old_column_name: self.old_column_name,\n            new_column_name: self.new_column_name,\n        };\n        Ok(Statement::AlterTable {\n            name: table_name,\n            operation,\n        })\n    }\n}\n\npub struct RenameTableNode {\n    table_node: AlterTableNode,\n    new_table_name: String,\n}\n\nimpl Build for RenameTableNode {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let old_table_name = self.table_node.table_name;\n        let operation = AlterTableOperation::RenameTable {\n            table_name: self.new_table_name,\n        };\n        Ok(Statement::AlterTable {\n            name: old_table_name,\n            operation,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{Build, table, test};\n\n    #[test]\n    fn alter_table() {\n        let actual = table(\"Foo\")\n            .alter_table()\n            .add_column(\"opt BOOLEAN NULL\")\n            .build();\n        let expected = \"ALTER TABLE Foo ADD COLUMN opt BOOLEAN NULL\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\").alter_table().drop_column(\"col_name\").build();\n        let expected = \"ALTER TABLE Foo DROP COLUMN col_name\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\")\n            .alter_table()\n            .drop_column_if_exists(\"col_name\")\n            .build();\n        let expected = \"ALTER TABLE Foo DROP COLUMN IF EXISTS col_name\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\")\n            .alter_table()\n            .rename_column(\"old\", \"new\")\n            .build();\n        let expected = \"ALTER TABLE Foo RENAME COLUMN old TO new\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\")\n            .alter_table()\n            .rename_table(\"new_table_name\")\n            .build();\n        let expected = \"ALTER TABLE Foo RENAME TO new_table_name\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":35},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","assignment.rs"],"content":"use {\n    super::ExprNode,\n    crate::{\n        ast::{Assignment, Expr},\n        parse_sql::parse_assignment,\n        result::{Error, Result},\n        translate::translate_assignment,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum AssignmentNode\u003c'a\u003e {\n    Expr(String, ExprNode\u003c'a\u003e),\n    Text(String),\n}\n\nimpl\u003c'a\u003e From\u003c\u0026str\u003e for AssignmentNode\u003c'a\u003e {\n    fn from(expr: \u0026str) -\u003e Self {\n        Self::Text(expr.to_owned())\n    }\n}\n\nimpl\u003c'a\u003e TryFrom\u003cAssignmentNode\u003c'a\u003e\u003e for Assignment {\n    type Error = Error;\n\n    fn try_from(node: AssignmentNode\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        match node {\n            AssignmentNode::Text(expr) =\u003e {\n                let expr = parse_assignment(expr)\n                    .and_then(|assignment| translate_assignment(\u0026assignment))?;\n                Ok(expr)\n            }\n            AssignmentNode::Expr(col, expr_node) =\u003e {\n                let value = Expr::try_from(expr_node)?;\n                let id = col;\n                Ok(Assignment { id, value })\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast_builder::AssignmentNode, parse_sql::parse_assignment,\n            translate::translate_assignment,\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    fn test(actual: AssignmentNode, expected: \u0026str) {\n        let parsed = \u0026parse_assignment(expected).expect(expected);\n        let expected = translate_assignment(parsed);\n        assert_eq!(actual.try_into(), expected);\n    }\n\n    #[test]\n    fn assignment() {\n        let actual = \"foo = 1\".into();\n        let expected = \"foo = 1\";\n        test(actual, expected);\n\n        let actual = r#\"foo = \"choco\"\"#.into();\n        let expected = r#\"foo = \"choco\"\"#;\n        test(actual, expected);\n\n        let actual = r#\"Bar = mild\"#.into();\n        let expected = r#\"Bar = mild\"#;\n        test(actual, expected);\n\n        let actual = AssignmentNode::Expr(\"foo\".into(), \"1\".into());\n        let expected = \"foo = 1\";\n        test(actual, expected);\n\n        let actual = AssignmentNode::Expr(\"foo\".into(), r#\"\"cocoa\"\"#.into());\n        let expected = r#\"foo = \"cocoa\"\"#;\n        test(actual, expected);\n\n        let actual = AssignmentNode::Expr(\"Bar\".into(), \"mild\".into());\n        let expected = \"Bar = mild\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","build.rs"],"content":"use crate::{ast::Statement, result::Result};\n\npub trait Build {\n    fn build(self) -\u003e Result\u003cStatement\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","column_def.rs"],"content":"use crate::{\n    ast::ColumnDef,\n    parse_sql::parse_column_def,\n    result::{Error, Result},\n    translate::translate_column_def,\n};\n\n#[derive(Clone, Debug)]\npub enum ColumnDefNode {\n    Text(String),\n}\n\nimpl From\u003c\u0026str\u003e for ColumnDefNode {\n    fn from(column_def: \u0026str) -\u003e Self {\n        ColumnDefNode::Text(column_def.to_owned())\n    }\n}\n\nimpl TryFrom\u003cColumnDefNode\u003e for ColumnDef {\n    type Error = Error;\n\n    fn try_from(column_def_node: ColumnDefNode) -\u003e Result\u003cColumnDef\u003e {\n        match column_def_node {\n            ColumnDefNode::Text(column_def) =\u003e parse_column_def(column_def)\n                .and_then(|column_def| translate_column_def(\u0026column_def)),\n        }\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","column_list.rs"],"content":"use crate::{\n    parse_sql::parse_identifiers,\n    result::{Error, Result},\n    translate::translate_idents,\n};\n\n#[derive(Clone, Debug)]\npub enum ColumnList {\n    Text(String),\n    Columns(Vec\u003cString\u003e),\n}\n\nimpl From\u003c\u0026str\u003e for ColumnList {\n    fn from(columns: \u0026str) -\u003e Self {\n        ColumnList::Text(columns.to_owned())\n    }\n}\n\nimpl From\u003cVec\u003c\u0026str\u003e\u003e for ColumnList {\n    fn from(columns: Vec\u003c\u0026str\u003e) -\u003e Self {\n        ColumnList::Columns(columns.into_iter().map(ToOwned::to_owned).collect())\n    }\n}\n\nimpl TryFrom\u003cColumnList\u003e for Vec\u003cString\u003e {\n    type Error = Error;\n\n    fn try_from(column_list: ColumnList) -\u003e Result\u003cSelf\u003e {\n        match column_list {\n            ColumnList::Text(columns) =\u003e {\n                let idents = parse_identifiers(columns)?;\n                Ok(translate_idents(idents.as_slice()))\n            }\n            ColumnList::Columns(columns) =\u003e Ok(columns),\n        }\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","create_table.rs"],"content":"use {\n    super::Build,\n    crate::{ast::Statement, ast_builder::ColumnDefNode, result::Result},\n};\n\n#[derive(Clone, Debug)]\npub struct CreateTableNode {\n    table_name: String,\n    if_not_exists: bool,\n    columns: Option\u003cVec\u003cColumnDefNode\u003e\u003e,\n}\n\nimpl CreateTableNode {\n    pub fn new(table_name: String, not_exists: bool) -\u003e Self {\n        Self {\n            table_name,\n            if_not_exists: not_exists,\n            columns: None,\n        }\n    }\n\n    pub fn add_column\u003cT: Into\u003cColumnDefNode\u003e\u003e(mut self, column: T) -\u003e Self {\n        match self.columns {\n            Some(ref mut columns) =\u003e {\n                columns.push(column.into());\n            }\n            None =\u003e {\n                self.columns = Some(vec![column.into()]);\n            }\n        }\n\n        self\n    }\n}\n\nimpl Build for CreateTableNode {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let table_name = self.table_name;\n        let columns = match self.columns {\n            Some(columns) =\u003e Some(\n                columns\n                    .into_iter()\n                    .map(TryInto::try_into)\n                    .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n            ),\n            None =\u003e None,\n        };\n\n        Ok(Statement::CreateTable {\n            name: table_name,\n            if_not_exists: self.if_not_exists,\n            columns,\n            source: None,\n            engine: None,\n            foreign_keys: Vec::new(),\n            comment: None,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{Build, table, test};\n\n    #[test]\n    fn create_table() {\n        let actual = table(\"Foo\")\n            .create_table()\n            .add_column(\"id INTEGER NULL\")\n            .add_column(\"num INTEGER\")\n            .add_column(\"name TEXT\")\n            .build();\n        let expected = \"CREATE TABLE Foo (id INTEGER NULL, num INTEGER, name TEXT)\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\")\n            .create_table_if_not_exists()\n            .add_column(\"id UUID UNIQUE\")\n            .add_column(\"name TEXT\")\n            .build();\n        let expected = \"CREATE TABLE IF NOT EXISTS Foo (id UUID UNIQUE, name TEXT)\";\n        test(actual, expected);\n    }\n\n    #[test]\n    fn create_table_without_column() {\n        let actual = table(\"Foo\").create_table().build();\n        let expected = \"CREATE TABLE Foo\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","data_type.rs"],"content":"use crate::{\n    ast::DataType,\n    parse_sql::parse_data_type,\n    result::{Error, Result},\n    translate::translate_data_type,\n};\n\n#[derive(Clone, Debug)]\npub enum DataTypeNode {\n    DataType(DataType),\n    Text(String),\n}\n\nimpl From\u003cDataType\u003e for DataTypeNode {\n    fn from(data_type: DataType) -\u003e Self {\n        Self::DataType(data_type)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for DataTypeNode {\n    fn from(data_type: \u0026str) -\u003e Self {\n        Self::Text(data_type.to_owned())\n    }\n}\n\nimpl TryFrom\u003cDataTypeNode\u003e for DataType {\n    type Error = Error;\n\n    fn try_from(data_type: DataTypeNode) -\u003e Result\u003cSelf\u003e {\n        match data_type {\n            DataTypeNode::DataType(data_type) =\u003e Ok(data_type),\n            DataTypeNode::Text(data_type) =\u003e {\n                parse_data_type(data_type).and_then(|datatype| translate_data_type(\u0026datatype))\n            }\n        }\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","delete.rs"],"content":"use {\n    super::{Build, ExprNode},\n    crate::{\n        ast::{Expr, Statement},\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub struct DeleteNode\u003c'a\u003e {\n    table_name: String,\n    filter_expr: Option\u003cExprNode\u003c'a\u003e\u003e,\n}\n\nimpl\u003c'a\u003e DeleteNode\u003c'a\u003e {\n    pub fn new(table_name: String) -\u003e Self {\n        Self {\n            table_name,\n            filter_expr: None,\n        }\n    }\n\n    pub fn filter\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(mut self, expr: T) -\u003e Self {\n        self.filter_expr = Some(expr.into());\n\n        self\n    }\n}\n\nimpl\u003c'a\u003e Build for DeleteNode\u003c'a\u003e {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let table_name = self.table_name;\n        let selection = self.filter_expr.map(Expr::try_from).transpose()?;\n\n        Ok(Statement::Delete {\n            table_name,\n            selection,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::Expr,\n        ast_builder::{Build, col, table, test},\n    };\n\n    #[test]\n    fn delete() {\n        let actual = table(\"Foo\").delete().build();\n        let expected = \"DELETE FROM Foo\";\n        test(actual, expected);\n\n        let actual = table(\"Bar\").delete().filter(\"id \u003c (1 + 3 + rate)\").build();\n        let expected = \"DELETE FROM Bar WHERE id \u003c (1 + 3 + rate)\";\n        test(actual, expected);\n\n        let actual = table(\"Person\")\n            .delete()\n            .filter(Expr::IsNull(Box::new(Expr::Identifier(\"name\".to_owned()))))\n            .build();\n        let expected = \"DELETE FROM Person WHERE name IS NULL\";\n        test(actual, expected);\n\n        let actual = table(\"Person\")\n            .delete()\n            .filter(col(\"name\").is_null())\n            .build();\n        let expected = \"DELETE FROM Person WHERE name IS NULL\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","drop_table.rs"],"content":"use {\n    super::Build,\n    crate::{ast::Statement, result::Result},\n};\n\n#[derive(Clone, Debug)]\npub struct DropTableNode {\n    table_name: String,\n    if_exists: bool,\n    cascade: bool,\n}\n\nimpl DropTableNode {\n    pub fn new(table_name: String, exists: bool, cascade: bool) -\u003e Self {\n        Self {\n            table_name,\n            if_exists: exists,\n            cascade,\n        }\n    }\n}\n\nimpl Build for DropTableNode {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let names = vec![self.table_name];\n        let if_exists = self.if_exists;\n        let cascade = self.cascade;\n\n        Ok(Statement::DropTable {\n            names,\n            if_exists,\n            cascade,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{Build, table, test};\n\n    #[test]\n    fn drop_table() {\n        let actual = table(\"Foo\").drop_table().build();\n        let expected = \"DROP TABLE Foo\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\").drop_table_if_exists().build();\n        let expected = \"DROP TABLE IF EXISTS Foo\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\").drop_table_cascade().build();\n        let expected = \"DROP TABLE Foo CASCADE\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\").drop_table_if_exists_cascade().build();\n        let expected = \"DROP TABLE IF EXISTS Foo CASCADE\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","error.rs"],"content":"use {serde::Serialize, std::fmt::Debug, thiserror::Error};\n\n#[derive(Error, Serialize, Debug, PartialEq, Eq)]\npub enum AstBuilderError {\n    #[error(\"failed to parse numeric value: {0}\")]\n    FailedToParseNumeric(String),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","execute.rs"],"content":"use {\n    super::Build,\n    crate::{\n        ast::Statement,\n        executor::Payload,\n        prelude::Glue,\n        result::Result,\n        store::{GStore, GStoreMut},\n    },\n    async_trait::async_trait,\n};\n\n#[async_trait(?Send)]\npub trait Execute\u003cT: GStore + GStoreMut\u003e\nwhere\n    Self: Sized + Build,\n{\n    async fn execute(self, glue: \u0026mut Glue\u003cT\u003e) -\u003e Result\u003cPayload\u003e {\n        let statement = self.build()?;\n\n        glue.execute_stmt(\u0026statement).await\n    }\n}\n\n#[async_trait(?Send)]\nimpl\u003cT: GStore + GStoreMut, B: Build\u003e Execute\u003cT\u003e for B {}\n\nimpl Build for Statement {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        Ok(self)\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","aggregate.rs"],"content":"use {\n    super::ExprNode,\n    crate::{\n        ast::{Aggregate, CountArgExpr},\n        parse_sql::parse_expr,\n        result::{Error, Result},\n        translate::translate_expr,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum AggregateNode\u003c'a\u003e {\n    Count(CountArgExprNode\u003c'a\u003e),\n    Sum(ExprNode\u003c'a\u003e),\n    Min(ExprNode\u003c'a\u003e),\n    Max(ExprNode\u003c'a\u003e),\n    Avg(ExprNode\u003c'a\u003e),\n    Variance(ExprNode\u003c'a\u003e),\n    Stdev(ExprNode\u003c'a\u003e),\n}\n\n#[derive(Clone, Debug)]\npub enum CountArgExprNode\u003c'a\u003e {\n    Text(String),\n    Expr(ExprNode\u003c'a\u003e),\n}\n\nimpl\u003c'a\u003e From\u003c\u0026'a str\u003e for CountArgExprNode\u003c'a\u003e {\n    fn from(count_arg_str: \u0026str) -\u003e Self {\n        Self::Text(count_arg_str.to_owned())\n    }\n}\n\nimpl\u003c'a\u003e From\u003cExprNode\u003c'a\u003e\u003e for CountArgExprNode\u003c'a\u003e {\n    fn from(expr_node: ExprNode\u003c'a\u003e) -\u003e Self {\n        Self::Expr(expr_node)\n    }\n}\n\nimpl\u003c'a\u003e TryFrom\u003cCountArgExprNode\u003c'a\u003e\u003e for CountArgExpr {\n    type Error = Error;\n\n    fn try_from(count_expr_node: CountArgExprNode\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        match count_expr_node {\n            CountArgExprNode::Text(s) if \u0026s == \"*\" =\u003e Ok(CountArgExpr::Wildcard),\n            CountArgExprNode::Text(s) =\u003e {\n                let expr = parse_expr(s).and_then(|expr| translate_expr(\u0026expr))?;\n\n                Ok(CountArgExpr::Expr(expr))\n            }\n            CountArgExprNode::Expr(expr_node) =\u003e expr_node.try_into().map(CountArgExpr::Expr),\n        }\n    }\n}\n\nimpl\u003c'a\u003e TryFrom\u003cAggregateNode\u003c'a\u003e\u003e for Aggregate {\n    type Error = Error;\n\n    fn try_from(aggr_node: AggregateNode\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        match aggr_node {\n            AggregateNode::Count(count_arg_expr_node) =\u003e {\n                count_arg_expr_node.try_into().map(Aggregate::Count)\n            }\n            AggregateNode::Sum(expr_node) =\u003e expr_node.try_into().map(Aggregate::Sum),\n            AggregateNode::Min(expr_node) =\u003e expr_node.try_into().map(Aggregate::Min),\n            AggregateNode::Max(expr_node) =\u003e expr_node.try_into().map(Aggregate::Max),\n            AggregateNode::Avg(expr_node) =\u003e expr_node.try_into().map(Aggregate::Avg),\n            AggregateNode::Variance(expr_node) =\u003e expr_node.try_into().map(Aggregate::Variance),\n            AggregateNode::Stdev(expr_node) =\u003e expr_node.try_into().map(Aggregate::Stdev),\n        }\n    }\n}\n\nimpl\u003c'a\u003e ExprNode\u003c'a\u003e {\n    pub fn count(self) -\u003e Self {\n        count(self)\n    }\n\n    pub fn sum(self) -\u003e Self {\n        sum(self)\n    }\n\n    pub fn min(self) -\u003e Self {\n        min(self)\n    }\n\n    pub fn max(self) -\u003e Self {\n        max(self)\n    }\n\n    pub fn avg(self) -\u003e Self {\n        avg(self)\n    }\n\n    pub fn variance(self) -\u003e Self {\n        variance(self)\n    }\n\n    pub fn stdev(self) -\u003e Self {\n        stdev(self)\n    }\n}\n\npub fn count\u003c'a, T: Into\u003cCountArgExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Aggregate(Box::new(AggregateNode::Count(expr.into())))\n}\n\npub fn sum\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Aggregate(Box::new(AggregateNode::Sum(expr.into())))\n}\n\npub fn min\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Aggregate(Box::new(AggregateNode::Min(expr.into())))\n}\n\npub fn max\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Aggregate(Box::new(AggregateNode::Max(expr.into())))\n}\n\npub fn avg\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Aggregate(Box::new(AggregateNode::Avg(expr.into())))\n}\n\npub fn variance\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Aggregate(Box::new(AggregateNode::Variance(expr.into())))\n}\n\npub fn stdev\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Aggregate(Box::new(AggregateNode::Stdev(expr.into())))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{avg, col, count, max, min, stdev, sum, test_expr, variance};\n\n    #[test]\n    fn aggregate() {\n        let actual = col(\"id\").count();\n        let expected = \"COUNT(id)\";\n        test_expr(actual, expected);\n\n        let actual = count(\"id\");\n        let expected = \"COUNT(id)\";\n        test_expr(actual, expected);\n\n        let actual = count(\"*\");\n        let expected = \"COUNT(*)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"amount\").sum();\n        let expected = \"SUM(amount)\";\n        test_expr(actual, expected);\n\n        let actual = sum(\"amount\");\n        let expected = \"SUM(amount)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"budget\").min();\n        let expected = \"MIN(budget)\";\n        test_expr(actual, expected);\n        let actual = min(\"budget\");\n        let expected = \"MIN(budget)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"score\").max();\n        let expected = \"MAX(score)\";\n        test_expr(actual, expected);\n\n        let actual = max(\"score\");\n        let expected = \"MAX(score)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"grade\").avg();\n        let expected = \"AVG(grade)\";\n        test_expr(actual, expected);\n\n        let actual = avg(\"grade\");\n        let expected = \"AVG(grade)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"statistic\").variance();\n        let expected = \"VARIANCE(statistic)\";\n        test_expr(actual, expected);\n\n        let actual = variance(\"statistic\");\n        let expected = \"VARIANCE(statistic)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"scatterplot\").stdev();\n        let expected = \"STDEV(scatterplot)\";\n        test_expr(actual, expected);\n\n        let actual = stdev(\"scatterplot\");\n        let expected = \"STDEV(scatterplot)\";\n        test_expr(actual, expected);\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":49},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","alias_as.rs"],"content":"use {super::ExprNode, crate::ast_builder::ExprWithAliasNode};\n\nimpl\u003c'a\u003e ExprNode\u003c'a\u003e {\n    pub fn alias_as(self, alias: \u0026str) -\u003e ExprWithAliasNode\u003c'a\u003e {\n        ExprWithAliasNode {\n            expr: self,\n            alias: alias.to_owned(),\n        }\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","between.rs"],"content":"use super::ExprNode;\n\nimpl\u003c'a\u003e ExprNode\u003c'a\u003e {\n    pub fn between\u003cT: Into\u003cSelf\u003e, U: Into\u003cSelf\u003e\u003e(self, low: T, high: U) -\u003e Self {\n        Self::Between {\n            expr: Box::new(self),\n            negated: false,\n            low: Box::new(low.into()),\n            high: Box::new(high.into()),\n        }\n    }\n\n    pub fn not_between\u003cT: Into\u003cSelf\u003e, U: Into\u003cSelf\u003e\u003e(self, low: T, high: U) -\u003e Self {\n        Self::Between {\n            expr: Box::new(self),\n            negated: true,\n            low: Box::new(low.into()),\n            high: Box::new(high.into()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{col, num, test_expr, text};\n\n    #[test]\n    fn between() {\n        let actual = col(\"num\").between(1, 10);\n        let expected = \"num BETWEEN 1 AND 10\";\n        test_expr(actual, expected);\n\n        let actual = col(\"date\").between(text(\"2022-01-01\"), \"'2023-01-01'\");\n        let expected = \"date BETWEEN '2022-01-01' AND '2023-01-01'\";\n        test_expr(actual, expected);\n\n        let actual = col(\"num\").not_between(num(1), 10);\n        let expected = \"num NOT BETWEEN 1 AND 10\";\n        test_expr(actual, expected);\n\n        let actual = col(\"date\").not_between(text(\"2022-01-01\"), text(\"2023-01-01\"));\n        let expected = \"date NOT BETWEEN '2022-01-01' AND '2023-01-01'\";\n        test_expr(actual, expected);\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","binary_op.rs"],"content":"use {super::ExprNode, crate::ast::BinaryOperator};\n\nimpl\u003c'a\u003e ExprNode\u003c'a\u003e {\n    fn binary_op\u003cT: Into\u003cSelf\u003e\u003e(self, op: BinaryOperator, other: T) -\u003e Self {\n        Self::BinaryOp {\n            left: Box::new(self),\n            op,\n            right: Box::new(other.into()),\n        }\n    }\n\n    #[allow(clippy::should_implement_trait)]\n    pub fn add\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::Plus, other)\n    }\n\n    #[allow(clippy::should_implement_trait)]\n    pub fn sub\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::Minus, other)\n    }\n\n    #[allow(clippy::should_implement_trait)]\n    pub fn mul\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::Multiply, other)\n    }\n\n    #[allow(clippy::should_implement_trait)]\n    pub fn div\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::Divide, other)\n    }\n\n    pub fn modulo\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::Modulo, other)\n    }\n\n    pub fn concat\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::StringConcat, other)\n    }\n\n    pub fn gt\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::Gt, other)\n    }\n\n    pub fn lt\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::Lt, other)\n    }\n\n    pub fn gte\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::GtEq, other)\n    }\n\n    pub fn lte\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::LtEq, other)\n    }\n\n    pub fn eq\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::Eq, other)\n    }\n\n    pub fn neq\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::NotEq, other)\n    }\n\n    pub fn and\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::And, other)\n    }\n\n    pub fn or\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::Or, other)\n    }\n\n    pub fn bitwise_and\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::BitwiseAnd, other)\n    }\n\n    pub fn bitwise_shift_left\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::BitwiseShiftLeft, other)\n    }\n\n    pub fn bitwise_shift_right\u003cT: Into\u003cSelf\u003e\u003e(self, other: T) -\u003e Self {\n        self.binary_op(BinaryOperator::BitwiseShiftRight, other)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{col, num, test_expr, text};\n\n    #[test]\n    fn binary_op() {\n        let actual = col(\"id\").add(10);\n        let expected = \"id + 10\";\n        test_expr(actual, expected);\n\n        let actual = num(10).sub(text(\"abc\"));\n        let expected = \"10 - 'abc'\";\n        test_expr(actual, expected);\n\n        let actual = col(\"rate\").mul(\"amount\");\n        let expected = \"rate * amount\";\n        test_expr(actual, expected);\n\n        let actual = col(\"amount\").div(30);\n        let expected = \"amount / 30\";\n        test_expr(actual, expected);\n\n        let actual = col(\"amount\").modulo(30);\n        let expected = \"amount % 30\";\n        test_expr(actual, expected);\n\n        let actual = text(\"hello\").concat(\"'world'\");\n        let expected = \"'hello' || 'world'\";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\").gt(col(\"Bar.id\"));\n        let expected = \"id \u003e Bar.id\";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\").lt(col(\"Bar.id\"));\n        let expected = \"id \u003c Bar.id\";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\").gte(col(\"Bar.id\"));\n        let expected = \"id \u003e= Bar.id\";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\").lte(col(\"Bar.id\"));\n        let expected = \"id \u003c= Bar.id\";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\").eq(10);\n        let expected = \"id = 10\";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\").neq(\"'abcde'\");\n        let expected = \"id != 'abcde'\";\n        test_expr(actual, expected);\n\n        let actual = (col(\"id\").gt(num(10))).and(col(\"id\").lt(num(20)));\n        let expected = \"id \u003e 10 AND id \u003c 20\";\n        test_expr(actual, expected);\n\n        let actual = (col(\"id\").gt(num(10))).or(col(\"id\").lt(num(20)));\n        let expected = \"id \u003e 10 OR id \u003c 20\";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\").bitwise_and(col(\"value\"));\n        let expected = \"id \u0026 value\";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\").bitwise_shift_left(num(1));\n        let expected = \"id \u003c\u003c 1\";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\").bitwise_shift_right(num(1));\n        let expected = \"id \u003e\u003e 1\";\n        test_expr(actual, expected);\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","case.rs"],"content":"use super::ExprNode;\n\nimpl\u003c'a\u003e ExprNode\u003c'a\u003e {\n    pub fn case(self) -\u003e CaseNode\u003c'a\u003e {\n        CaseNode {\n            operand: Some(Box::new(self)),\n        }\n    }\n}\n\npub fn case() -\u003e CaseNode\u003c'static\u003e {\n    CaseNode { operand: None }\n}\n\n#[derive(Clone, Debug)]\npub struct CaseNode\u003c'a\u003e {\n    operand: Option\u003cBox\u003cExprNode\u003c'a\u003e\u003e\u003e,\n}\n\nimpl\u003c'a\u003e CaseNode\u003c'a\u003e {\n    pub fn when_then\u003cW: Into\u003cExprNode\u003c'a\u003e\u003e, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n        self,\n        when: W,\n        then: T,\n    ) -\u003e WhenThenNode\u003c'a\u003e {\n        WhenThenNode {\n            prev_node: self,\n            when_then: vec![(when.into(), then.into())],\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct WhenThenNode\u003c'a\u003e {\n    prev_node: CaseNode\u003c'a\u003e,\n    when_then: Vec\u003c(ExprNode\u003c'a\u003e, ExprNode\u003c'a\u003e)\u003e,\n}\n\nimpl\u003c'a\u003e WhenThenNode\u003c'a\u003e {\n    pub fn when_then\u003cW: Into\u003cExprNode\u003c'a\u003e\u003e, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n        mut self,\n        when: W,\n        then: T,\n    ) -\u003e Self {\n        self.when_then.push((when.into(), then.into()));\n        self\n    }\n\n    pub fn or_else\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, else_result: T) -\u003e ExprNode\u003c'a\u003e {\n        ExprNode::Case {\n            operand: self.prev_node.operand,\n            when_then: self.when_then,\n            else_result: Some(Box::new(else_result.into())),\n        }\n    }\n\n    pub fn end(self) -\u003e ExprNode\u003c'a\u003e {\n        ExprNode::Case {\n            operand: self.prev_node.operand,\n            when_then: self.when_then,\n            else_result: None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{case, col, num, test_expr, text};\n\n    #[test]\n    fn case_with_operand() {\n        let actual = col(\"id\")\n            .case()\n            .when_then(num(1), text(\"a\"))\n            .when_then(2, text(\"b\"))\n            .or_else(text(\"c\"));\n        let expected = \"\n            CASE id\n              WHEN 1 THEN 'a'\n              WHEN 2 THEN 'b'\n              ELSE 'c'\n            END\n            \";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\")\n            .gt(10)\n            .case()\n            .when_then(true, text(\"a\"))\n            .when_then(false, text(\"b\"))\n            .end();\n        let expected = \"\n            CASE id \u003e 10\n              WHEN True THEN 'a'\n              WHEN False THEN 'b'\n            END\n            \";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn case_without_operand() {\n        let actual = case()\n            .when_then(\n                \"City IS NULL\",\n                case()\n                    .when_then(\"Country IS NULL\", text(\"weird\"))\n                    .or_else(\"Country\"),\n            )\n            .or_else(\"City\");\n        let expected = r#\"\n            CASE\n              WHEN City IS NULL THEN CASE WHEN Country IS NULL THEN 'weird'\n                                          ELSE Country\n                                          END\n              ELSE City\n            END\n            \"#;\n        test_expr(actual, expected);\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","exists.rs"],"content":"use {super::ExprNode, crate::ast_builder::QueryNode};\n\npub fn exists\u003c'a, T: Into\u003cQueryNode\u003c'a\u003e\u003e\u003e(query: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Exists {\n        subquery: Box::new(query.into()),\n        negated: false,\n    }\n}\n\npub fn not_exists\u003c'a, T: Into\u003cQueryNode\u003c'a\u003e\u003e\u003e(query: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Exists {\n        subquery: Box::new(query.into()),\n        negated: true,\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use crate::ast_builder::{Build, col, exists, not_exists, table, test, test_expr};\n\n    #[test]\n    fn exist() {\n        let actual = table(\"FOO\")\n            .select()\n            .filter(exists(\n                table(\"BAR\")\n                    .select()\n                    .filter(\"id IS NOT NULL\")\n                    .group_by(\"name\"),\n            ))\n            .build();\n        let expected =\n            \"SELECT * FROM FOO WHERE EXISTS (SELECT * FROM BAR WHERE id IS NOT NULL GROUP BY name)\";\n        test(actual, expected);\n\n        let actual = table(\"FOO\")\n            .select()\n            .filter(not_exists(table(\"BAR\").select().filter(\"id IS NOT NULL\")))\n            .build();\n        let expected =\n            \"SELECT * FROM FOO WHERE NOT EXISTS (SELECT * FROM BAR WHERE id IS NOT NULL)\";\n        test(actual, expected);\n\n        let actual = exists(table(\"FOO\").select().filter(col(\"id\").gt(2)));\n        let expected = \"EXISTS (SELECT * FROM FOO WHERE id \u003e 2)\";\n        test_expr(actual, expected);\n\n        let actual = not_exists(table(\"FOO\").select().filter(col(\"id\").gt(2)));\n        let expected = \"NOT EXISTS (SELECT * FROM FOO WHERE id \u003e 2)\";\n        test_expr(actual, expected);\n\n        let actual = exists(\"SELECT * FROM FOO\");\n        let expected = \"EXISTS (SELECT * FROM FOO)\";\n        test_expr(actual, expected);\n\n        let actual = not_exists(\"SELECT * FROM FOO\");\n        let expected = \"NOT EXISTS (SELECT * FROM FOO)\";\n        test_expr(actual, expected);\n    }\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","function.rs"],"content":"use crate::{\n    ast::{DateTimeField, Function},\n    ast_builder::{DataTypeNode, ExprList, ExprNode},\n    result::{Error, Result},\n};\n\n#[derive(Clone, Debug)]\npub enum FunctionNode\u003c'a\u003e {\n    Abs(ExprNode\u003c'a\u003e),\n    Upper(ExprNode\u003c'a\u003e),\n    IfNull {\n        expr: ExprNode\u003c'a\u003e,\n        then: ExprNode\u003c'a\u003e,\n    },\n    Iif {\n        cond: ExprNode\u003c'a\u003e,\n        then: ExprNode\u003c'a\u003e,\n        else_result: ExprNode\u003c'a\u003e,\n    },\n    NullIf {\n        expr1: ExprNode\u003c'a\u003e,\n        expr2: ExprNode\u003c'a\u003e,\n    },\n    Ceil(ExprNode\u003c'a\u003e),\n    Rand(Option\u003cExprNode\u003c'a\u003e\u003e),\n    Round(ExprNode\u003c'a\u003e),\n    Floor(ExprNode\u003c'a\u003e),\n    Asin(ExprNode\u003c'a\u003e),\n    Acos(ExprNode\u003c'a\u003e),\n    Atan(ExprNode\u003c'a\u003e),\n    Sin(ExprNode\u003c'a\u003e),\n    Cos(ExprNode\u003c'a\u003e),\n    Tan(ExprNode\u003c'a\u003e),\n    Pi,\n    Now,\n    CurrentDate,\n    CurrentTime,\n    CurrentTimestamp,\n    Left {\n        expr: ExprNode\u003c'a\u003e,\n        size: ExprNode\u003c'a\u003e,\n    },\n    Log {\n        antilog: ExprNode\u003c'a\u003e,\n        base: ExprNode\u003c'a\u003e,\n    },\n    Log2(ExprNode\u003c'a\u003e),\n    Log10(ExprNode\u003c'a\u003e),\n    Ln(ExprNode\u003c'a\u003e),\n    Right {\n        expr: ExprNode\u003c'a\u003e,\n        size: ExprNode\u003c'a\u003e,\n    },\n    Reverse(ExprNode\u003c'a\u003e),\n    Sign(ExprNode\u003c'a\u003e),\n    Power {\n        expr: ExprNode\u003c'a\u003e,\n        power: ExprNode\u003c'a\u003e,\n    },\n    Sqrt(ExprNode\u003c'a\u003e),\n    Skip {\n        expr: ExprNode\u003c'a\u003e,\n        size: ExprNode\u003c'a\u003e,\n    },\n    Gcd {\n        left: ExprNode\u003c'a\u003e,\n        right: ExprNode\u003c'a\u003e,\n    },\n    Lcm {\n        left: ExprNode\u003c'a\u003e,\n        right: ExprNode\u003c'a\u003e,\n    },\n    GenerateUuid,\n    Repeat {\n        expr: ExprNode\u003c'a\u003e,\n        num: ExprNode\u003c'a\u003e,\n    },\n    Replace {\n        expr: ExprNode\u003c'a\u003e,\n        old: ExprNode\u003c'a\u003e,\n        new: ExprNode\u003c'a\u003e,\n    },\n    Exp(ExprNode\u003c'a\u003e),\n    Lpad {\n        expr: ExprNode\u003c'a\u003e,\n        size: ExprNode\u003c'a\u003e,\n        fill: Option\u003cExprNode\u003c'a\u003e\u003e,\n    },\n    Rpad {\n        expr: ExprNode\u003c'a\u003e,\n        size: ExprNode\u003c'a\u003e,\n        fill: Option\u003cExprNode\u003c'a\u003e\u003e,\n    },\n    Degrees(ExprNode\u003c'a\u003e),\n    Radians(ExprNode\u003c'a\u003e),\n    Coalesce(ExprList\u003c'a\u003e),\n    Concat(ExprList\u003c'a\u003e),\n    ConcatWs {\n        separator: ExprNode\u003c'a\u003e,\n        exprs: ExprList\u003c'a\u003e,\n    },\n    Take {\n        expr: ExprNode\u003c'a\u003e,\n        size: ExprNode\u003c'a\u003e,\n    },\n    Substr {\n        expr: ExprNode\u003c'a\u003e,\n        start: ExprNode\u003c'a\u003e,\n        count: Option\u003cExprNode\u003c'a\u003e\u003e,\n    },\n    Ltrim {\n        expr: ExprNode\u003c'a\u003e,\n        chars: Option\u003cExprNode\u003c'a\u003e\u003e,\n    },\n    Rtrim {\n        expr: ExprNode\u003c'a\u003e,\n        chars: Option\u003cExprNode\u003c'a\u003e\u003e,\n    },\n    Div {\n        dividend: ExprNode\u003c'a\u003e,\n        divisor: ExprNode\u003c'a\u003e,\n    },\n    Mod {\n        dividend: ExprNode\u003c'a\u003e,\n        divisor: ExprNode\u003c'a\u003e,\n    },\n    Format {\n        expr: ExprNode\u003c'a\u003e,\n        format: ExprNode\u003c'a\u003e,\n    },\n    ToDate {\n        expr: ExprNode\u003c'a\u003e,\n        format: ExprNode\u003c'a\u003e,\n    },\n    ToTimestamp {\n        expr: ExprNode\u003c'a\u003e,\n        format: ExprNode\u003c'a\u003e,\n    },\n    ToTime {\n        expr: ExprNode\u003c'a\u003e,\n        format: ExprNode\u003c'a\u003e,\n    },\n    Lower(ExprNode\u003c'a\u003e),\n    Initcap(ExprNode\u003c'a\u003e),\n    Position {\n        from_expr: ExprNode\u003c'a\u003e,\n        sub_expr: ExprNode\u003c'a\u003e,\n    },\n    FindIdx {\n        from_expr: ExprNode\u003c'a\u003e,\n        sub_expr: ExprNode\u003c'a\u003e,\n        start: Option\u003cExprNode\u003c'a\u003e\u003e,\n    },\n    Cast {\n        expr: ExprNode\u003c'a\u003e,\n        data_type: DataTypeNode,\n    },\n    Extract {\n        field: DateTimeField,\n        expr: ExprNode\u003c'a\u003e,\n    },\n    Ascii(ExprNode\u003c'a\u003e),\n    Chr(ExprNode\u003c'a\u003e),\n    Md5(ExprNode\u003c'a\u003e),\n    Hex(ExprNode\u003c'a\u003e),\n    Point {\n        x: ExprNode\u003c'a\u003e,\n        y: ExprNode\u003c'a\u003e,\n    },\n    GetX(ExprNode\u003c'a\u003e),\n    GetY(ExprNode\u003c'a\u003e),\n    Greatest(ExprList\u003c'a\u003e),\n    CalcDistance {\n        geometry1: ExprNode\u003c'a\u003e,\n        geometry2: ExprNode\u003c'a\u003e,\n    },\n    Length(ExprNode\u003c'a\u003e),\n    IsEmpty(ExprNode\u003c'a\u003e),\n    LastDay(ExprNode\u003c'a\u003e),\n    Entries(ExprNode\u003c'a\u003e),\n    Keys(ExprNode\u003c'a\u003e),\n    Values(ExprNode\u003c'a\u003e),\n}\n\nimpl\u003c'a\u003e TryFrom\u003cFunctionNode\u003c'a\u003e\u003e for Function {\n    type Error = Error;\n\n    fn try_from(func_node: FunctionNode\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        match func_node {\n            FunctionNode::Abs(expr_node) =\u003e expr_node.try_into().map(Function::Abs),\n            FunctionNode::Upper(expr_node) =\u003e expr_node.try_into().map(Function::Upper),\n            FunctionNode::Lower(expr_node) =\u003e expr_node.try_into().map(Function::Lower),\n            FunctionNode::Initcap(expr_node) =\u003e expr_node.try_into().map(Function::Initcap),\n            FunctionNode::IfNull { expr, then } =\u003e {\n                let expr = expr.try_into()?;\n                let then = then.try_into()?;\n                Ok(Function::IfNull { expr, then })\n            }\n            FunctionNode::Iif {\n                cond,\n                then,\n                else_result,\n            } =\u003e {\n                let cond = cond.try_into()?;\n                let then = then.try_into()?;\n                let else_result = else_result.try_into()?;\n                Ok(Function::Iif {\n                    cond,\n                    then,\n                    else_result,\n                })\n            }\n            FunctionNode::NullIf { expr1, expr2 } =\u003e {\n                let expr1 = expr1.try_into()?;\n                let expr2 = expr2.try_into()?;\n                Ok(Function::NullIf { expr1, expr2 })\n            }\n            FunctionNode::Ceil(expr_node) =\u003e expr_node.try_into().map(Function::Ceil),\n            FunctionNode::Rand(expr_node) =\u003e Ok(Function::Rand(\n                expr_node.map(TryInto::try_into).transpose()?,\n            )),\n            FunctionNode::Round(expr_node) =\u003e expr_node.try_into().map(Function::Round),\n            FunctionNode::Floor(expr_node) =\u003e expr_node.try_into().map(Function::Floor),\n            FunctionNode::Asin(expr_node) =\u003e expr_node.try_into().map(Function::Asin),\n            FunctionNode::Acos(expr_node) =\u003e expr_node.try_into().map(Function::Acos),\n            FunctionNode::Atan(expr_node) =\u003e expr_node.try_into().map(Function::Atan),\n            FunctionNode::Sin(expr_node) =\u003e expr_node.try_into().map(Function::Sin),\n            FunctionNode::Cos(expr_node) =\u003e expr_node.try_into().map(Function::Cos),\n            FunctionNode::Tan(expr_node) =\u003e expr_node.try_into().map(Function::Tan),\n            FunctionNode::Pi =\u003e Ok(Function::Pi()),\n            FunctionNode::Now =\u003e Ok(Function::Now()),\n            FunctionNode::CurrentDate =\u003e Ok(Function::CurrentDate()),\n            FunctionNode::CurrentTime =\u003e Ok(Function::CurrentTime()),\n            FunctionNode::CurrentTimestamp =\u003e Ok(Function::CurrentTimestamp()),\n            FunctionNode::Left { expr, size } =\u003e {\n                let expr = expr.try_into()?;\n                let size = size.try_into()?;\n                Ok(Function::Left { expr, size })\n            }\n            FunctionNode::Log { antilog, base } =\u003e {\n                let antilog = antilog.try_into()?;\n                let base = base.try_into()?;\n                Ok(Function::Log { antilog, base })\n            }\n            FunctionNode::Log2(expr_node) =\u003e expr_node.try_into().map(Function::Log2),\n            FunctionNode::Log10(expr_node) =\u003e expr_node.try_into().map(Function::Log10),\n            FunctionNode::Ln(expr_node) =\u003e expr_node.try_into().map(Function::Ln),\n            FunctionNode::Right { expr, size } =\u003e {\n                let expr = expr.try_into()?;\n                let size = size.try_into()?;\n                Ok(Function::Right { expr, size })\n            }\n            FunctionNode::Reverse(expr_node) =\u003e expr_node.try_into().map(Function::Reverse),\n            FunctionNode::Sign(expr_node) =\u003e expr_node.try_into().map(Function::Sign),\n            FunctionNode::Power { expr, power } =\u003e {\n                let expr = expr.try_into()?;\n                let power = power.try_into()?;\n                Ok(Function::Power { expr, power })\n            }\n            FunctionNode::Sqrt(expr_node) =\u003e expr_node.try_into().map(Function::Sqrt),\n            FunctionNode::Skip { expr, size } =\u003e {\n                let expr = expr.try_into()?;\n                let size = size.try_into()?;\n                Ok(Function::Skip { expr, size })\n            }\n            FunctionNode::Gcd { left, right } =\u003e {\n                let left = left.try_into()?;\n                let right = right.try_into()?;\n                Ok(Function::Gcd { left, right })\n            }\n            FunctionNode::Lcm { left, right } =\u003e {\n                let left = left.try_into()?;\n                let right = right.try_into()?;\n                Ok(Function::Lcm { left, right })\n            }\n            FunctionNode::GenerateUuid =\u003e Ok(Function::GenerateUuid()),\n            FunctionNode::Repeat { expr, num } =\u003e {\n                let expr = expr.try_into()?;\n                let num = num.try_into()?;\n                Ok(Function::Repeat { expr, num })\n            }\n            FunctionNode::Replace { expr, old, new } =\u003e {\n                let expr = expr.try_into()?;\n                let old = old.try_into()?;\n                let new = new.try_into()?;\n                Ok(Function::Replace { expr, old, new })\n            }\n            FunctionNode::Lpad { expr, size, fill } =\u003e {\n                let fill = fill.map(TryInto::try_into).transpose()?;\n                let expr = expr.try_into()?;\n                let size = size.try_into()?;\n                Ok(Function::Lpad { expr, size, fill })\n            }\n            FunctionNode::Rpad { expr, size, fill } =\u003e {\n                let fill = fill.map(TryInto::try_into).transpose()?;\n                let expr = expr.try_into()?;\n                let size = size.try_into()?;\n                Ok(Function::Rpad { expr, size, fill })\n            }\n            FunctionNode::Coalesce(expr_list) =\u003e expr_list.try_into().map(Function::Coalesce),\n            FunctionNode::Concat(expr_list) =\u003e expr_list.try_into().map(Function::Concat),\n            FunctionNode::ConcatWs { separator, exprs } =\u003e {\n                let separator = separator.try_into()?;\n                let exprs = exprs.try_into()?;\n                Ok(Function::ConcatWs { separator, exprs })\n            }\n            FunctionNode::Take { expr, size } =\u003e {\n                let expr = expr.try_into()?;\n                let size = size.try_into()?;\n                Ok(Function::Take { expr, size })\n            }\n            FunctionNode::Degrees(expr) =\u003e expr.try_into().map(Function::Degrees),\n            FunctionNode::Radians(expr) =\u003e expr.try_into().map(Function::Radians),\n            FunctionNode::Exp(expr) =\u003e expr.try_into().map(Function::Exp),\n            FunctionNode::Substr { expr, start, count } =\u003e {\n                let count = count.map(TryInto::try_into).transpose()?;\n                let expr = expr.try_into()?;\n                let start = start.try_into()?;\n                Ok(Function::Substr { expr, start, count })\n            }\n            FunctionNode::Ltrim { expr, chars } =\u003e {\n                let chars = chars.map(TryInto::try_into).transpose()?;\n                let expr = expr.try_into()?;\n                Ok(Function::Ltrim { expr, chars })\n            }\n            FunctionNode::Rtrim { expr, chars } =\u003e {\n                let chars = chars.map(TryInto::try_into).transpose()?;\n                let expr = expr.try_into()?;\n                Ok(Function::Rtrim { expr, chars })\n            }\n            FunctionNode::Div { dividend, divisor } =\u003e {\n                let dividend = dividend.try_into()?;\n                let divisor = divisor.try_into()?;\n                Ok(Function::Div { dividend, divisor })\n            }\n            FunctionNode::Mod { dividend, divisor } =\u003e {\n                let dividend = dividend.try_into()?;\n                let divisor = divisor.try_into()?;\n                Ok(Function::Mod { dividend, divisor })\n            }\n            FunctionNode::Format { expr, format } =\u003e {\n                let expr = expr.try_into()?;\n                let format = format.try_into()?;\n                Ok(Function::Format { expr, format })\n            }\n            FunctionNode::ToDate { expr, format } =\u003e {\n                let expr = expr.try_into()?;\n                let format = format.try_into()?;\n                Ok(Function::ToDate { expr, format })\n            }\n            FunctionNode::ToTimestamp { expr, format } =\u003e {\n                let expr = expr.try_into()?;\n                let format = format.try_into()?;\n                Ok(Function::ToTimestamp { expr, format })\n            }\n            FunctionNode::ToTime { expr, format } =\u003e {\n                let expr = expr.try_into()?;\n                let format = format.try_into()?;\n                Ok(Function::ToTime { expr, format })\n            }\n            FunctionNode::Position {\n                from_expr,\n                sub_expr,\n            } =\u003e {\n                let from_expr = from_expr.try_into()?;\n                let sub_expr = sub_expr.try_into()?;\n                Ok(Function::Position {\n                    from_expr,\n                    sub_expr,\n                })\n            }\n            FunctionNode::FindIdx {\n                from_expr,\n                sub_expr,\n                start,\n            } =\u003e {\n                let from_expr = from_expr.try_into()?;\n                let sub_expr = sub_expr.try_into()?;\n                let start = start.map(TryInto::try_into).transpose()?;\n                Ok(Function::FindIdx {\n                    from_expr,\n                    sub_expr,\n                    start,\n                })\n            }\n            FunctionNode::Cast { expr, data_type } =\u003e {\n                let expr = expr.try_into()?;\n                let data_type = data_type.try_into()?;\n                Ok(Function::Cast { expr, data_type })\n            }\n            FunctionNode::Extract { field, expr } =\u003e {\n                let expr = expr.try_into()?;\n                Ok(Function::Extract { field, expr })\n            }\n            FunctionNode::Ascii(expr) =\u003e expr.try_into().map(Function::Ascii),\n            FunctionNode::Chr(expr) =\u003e expr.try_into().map(Function::Chr),\n            FunctionNode::Md5(expr) =\u003e expr.try_into().map(Function::Md5),\n            FunctionNode::Hex(expr) =\u003e expr.try_into().map(Function::Hex),\n            FunctionNode::Point { x, y } =\u003e {\n                let x = x.try_into()?;\n                let y = y.try_into()?;\n                Ok(Function::Point { x, y })\n            }\n            FunctionNode::GetX(expr) =\u003e expr.try_into().map(Function::GetX),\n            FunctionNode::GetY(expr) =\u003e expr.try_into().map(Function::GetY),\n            FunctionNode::Greatest(expr_list) =\u003e expr_list.try_into().map(Function::Greatest),\n            FunctionNode::CalcDistance {\n                geometry1,\n                geometry2,\n            } =\u003e {\n                let geometry1 = geometry1.try_into()?;\n                let geometry2 = geometry2.try_into()?;\n                Ok(Function::CalcDistance {\n                    geometry1,\n                    geometry2,\n                })\n            }\n            FunctionNode::Length(expr) =\u003e expr.try_into().map(Function::Length),\n            FunctionNode::IsEmpty(expr) =\u003e expr.try_into().map(Function::IsEmpty),\n            FunctionNode::LastDay(expr) =\u003e expr.try_into().map(Function::LastDay),\n            FunctionNode::Entries(expr) =\u003e expr.try_into().map(Function::Entries),\n            FunctionNode::Keys(expr) =\u003e expr.try_into().map(Function::Keys),\n            FunctionNode::Values(expr) =\u003e expr.try_into().map(Function::Values),\n        }\n    }\n}\n\nimpl\u003c'a\u003e ExprNode\u003c'a\u003e {\n    pub fn abs(self) -\u003e ExprNode\u003c'a\u003e {\n        abs(self)\n    }\n    pub fn upper(self) -\u003e ExprNode\u003c'a\u003e {\n        upper(self)\n    }\n    pub fn lower(self) -\u003e ExprNode\u003c'a\u003e {\n        lower(self)\n    }\n    pub fn initcap(self) -\u003e ExprNode\u003c'a\u003e {\n        initcap(self)\n    }\n    pub fn ifnull\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, another: T) -\u003e ExprNode\u003c'a\u003e {\n        ifnull(self, another)\n    }\n    pub fn iif\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n        self,\n        then_: T,\n        else_: U,\n    ) -\u003e ExprNode\u003c'a\u003e {\n        iif(self, then_, else_)\n    }\n    pub fn nullif\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, another: T) -\u003e ExprNode\u003c'a\u003e {\n        nullif(self, another)\n    }\n    pub fn ceil(self) -\u003e ExprNode\u003c'a\u003e {\n        ceil(self)\n    }\n    pub fn rand(self) -\u003e ExprNode\u003c'a\u003e {\n        rand(Some(self))\n    }\n    pub fn round(self) -\u003e ExprNode\u003c'a\u003e {\n        round(self)\n    }\n    pub fn floor(self) -\u003e ExprNode\u003c'a\u003e {\n        floor(self)\n    }\n    pub fn asin(self) -\u003e ExprNode\u003c'a\u003e {\n        asin(self)\n    }\n    pub fn acos(self) -\u003e ExprNode\u003c'a\u003e {\n        acos(self)\n    }\n    pub fn atan(self) -\u003e ExprNode\u003c'a\u003e {\n        atan(self)\n    }\n    pub fn sin(self) -\u003e ExprNode\u003c'a\u003e {\n        sin(self)\n    }\n    pub fn cos(self) -\u003e ExprNode\u003c'a\u003e {\n        cos(self)\n    }\n    pub fn tan(self) -\u003e ExprNode\u003c'a\u003e {\n        tan(self)\n    }\n    pub fn left\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, size: T) -\u003e Self {\n        left(self, size)\n    }\n    pub fn log\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, base: T) -\u003e ExprNode\u003c'a\u003e {\n        log(self, base)\n    }\n    pub fn log2(self) -\u003e ExprNode\u003c'a\u003e {\n        log2(self)\n    }\n    pub fn log10(self) -\u003e ExprNode\u003c'a\u003e {\n        log10(self)\n    }\n    pub fn ln(self) -\u003e ExprNode\u003c'a\u003e {\n        ln(self)\n    }\n    pub fn right\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, size: T) -\u003e Self {\n        right(self, size)\n    }\n\n    pub fn reverse(self) -\u003e ExprNode\u003c'a\u003e {\n        reverse(self)\n    }\n\n    pub fn sign(self) -\u003e ExprNode\u003c'a\u003e {\n        sign(self)\n    }\n\n    pub fn skip\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, size: T) -\u003e ExprNode\u003c'a\u003e {\n        skip(self, size)\n    }\n\n    pub fn power\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, pwr: T) -\u003e ExprNode\u003c'a\u003e {\n        power(self, pwr)\n    }\n\n    pub fn sqrt(self) -\u003e ExprNode\u003c'a\u003e {\n        sqrt(self)\n    }\n    pub fn gcd\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, right: T) -\u003e ExprNode\u003c'a\u003e {\n        gcd(self, right)\n    }\n    pub fn lcm\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, right: T) -\u003e ExprNode\u003c'a\u003e {\n        lcm(self, right)\n    }\n    pub fn repeat\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, num: T) -\u003e ExprNode\u003c'a\u003e {\n        repeat(self, num)\n    }\n    pub fn replace\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n        self,\n        old: T,\n        new: U,\n    ) -\u003e ExprNode\u003c'a\u003e {\n        replace(self, old, new)\n    }\n    pub fn degrees(self) -\u003e ExprNode\u003c'a\u003e {\n        degrees(self)\n    }\n    pub fn radians(self) -\u003e ExprNode\u003c'a\u003e {\n        radians(self)\n    }\n    pub fn lpad\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, size: T, fill: Option\u003cExprNode\u003c'a\u003e\u003e) -\u003e ExprNode\u003c'a\u003e {\n        lpad(self, size, fill)\n    }\n    pub fn rpad\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, size: T, fill: Option\u003cExprNode\u003c'a\u003e\u003e) -\u003e ExprNode\u003c'a\u003e {\n        rpad(self, size, fill)\n    }\n    pub fn take\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, size: T) -\u003e ExprNode\u003c'a\u003e {\n        take(self, size)\n    }\n    pub fn exp(self) -\u003e ExprNode\u003c'a\u003e {\n        exp(self)\n    }\n    pub fn substr\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n        self,\n        start: T,\n        count: Option\u003cExprNode\u003c'a\u003e\u003e,\n    ) -\u003e ExprNode\u003c'a\u003e {\n        substr(self, start, count)\n    }\n    pub fn rtrim(self, chars: Option\u003cExprNode\u003c'a\u003e\u003e) -\u003e ExprNode\u003c'a\u003e {\n        rtrim(self, chars)\n    }\n    pub fn ltrim(self, chars: Option\u003cExprNode\u003c'a\u003e\u003e) -\u003e ExprNode\u003c'a\u003e {\n        ltrim(self, chars)\n    }\n    pub fn format\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, fmt: T) -\u003e ExprNode\u003c'a\u003e {\n        format(self, fmt)\n    }\n    pub fn to_date\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, format: T) -\u003e ExprNode\u003c'a\u003e {\n        to_date(self, format)\n    }\n    pub fn to_timestamp\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, format: T) -\u003e ExprNode\u003c'a\u003e {\n        to_timestamp(self, format)\n    }\n    pub fn to_time\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, format: T) -\u003e ExprNode\u003c'a\u003e {\n        to_time(self, format)\n    }\n    pub fn position\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, format: T) -\u003e ExprNode\u003c'a\u003e {\n        position(self, format)\n    }\n    pub fn find_idx\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n        self,\n        sub: T,\n        start: Option\u003cExprNode\u003c'a\u003e\u003e,\n    ) -\u003e ExprNode\u003c'a\u003e {\n        find_idx(self, sub, start)\n    }\n    pub fn cast\u003cT: Into\u003cDataTypeNode\u003e\u003e(self, data_type: T) -\u003e ExprNode\u003c'a\u003e {\n        cast(self, data_type)\n    }\n    pub fn extract(self, field: DateTimeField) -\u003e ExprNode\u003c'a\u003e {\n        extract(field, self)\n    }\n    pub fn is_empty(self) -\u003e ExprNode\u003c'a\u003e {\n        is_empty(self)\n    }\n    pub fn last_day(self) -\u003e ExprNode\u003c'a\u003e {\n        last_day(self)\n    }\n    pub fn entries(self) -\u003e ExprNode\u003c'a\u003e {\n        entries(self)\n    }\n    pub fn keys(self) -\u003e ExprNode\u003c'a\u003e {\n        keys(self)\n    }\n    pub fn values(self) -\u003e ExprNode\u003c'a\u003e {\n        values(self)\n    }\n}\n\npub fn abs\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Abs(expr.into())))\n}\npub fn upper\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Upper(expr.into())))\n}\npub fn lower\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Lower(expr.into())))\n}\npub fn initcap\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Initcap(expr.into())))\n}\npub fn ifnull\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T, then: U) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::IfNull {\n        expr: expr.into(),\n        then: then.into(),\n    }))\n}\n\npub fn iif\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e, V: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    cond: T,\n    then_: U,\n    else_: V,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Iif {\n        cond: cond.into(),\n        then: then_.into(),\n        else_result: else_.into(),\n    }))\n}\n\npub fn nullif\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    expr1: T,\n    expr2: U,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::NullIf {\n        expr1: expr1.into(),\n        expr2: expr2.into(),\n    }))\n}\npub fn ceil\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Ceil(expr.into())))\n}\npub fn rand(expr: Option\u003cExprNode\u003e) -\u003e ExprNode {\n    ExprNode::Function(Box::new(FunctionNode::Rand(expr)))\n}\npub fn round\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Round(expr.into())))\n}\npub fn coalesce\u003c'a, T: Into\u003cExprList\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Coalesce(expr.into())))\n}\npub fn concat\u003c'a, T: Into\u003cExprList\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Concat(expr.into())))\n}\n\npub fn concat_ws\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprList\u003c'a\u003e\u003e\u003e(\n    separator: T,\n    exprs: U,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::ConcatWs {\n        separator: separator.into(),\n        exprs: exprs.into(),\n    }))\n}\n\npub fn floor\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Floor(expr.into())))\n}\npub fn asin\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Asin(expr.into())))\n}\npub fn acos\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Acos(expr.into())))\n}\npub fn atan\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Atan(expr.into())))\n}\npub fn sin\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Sin(expr.into())))\n}\npub fn cos\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Cos(expr.into())))\n}\npub fn tan\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Tan(expr.into())))\n}\npub fn pi\u003c'a\u003e() -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Pi))\n}\npub fn generate_uuid\u003c'a\u003e() -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::GenerateUuid))\n}\npub fn now\u003c'a\u003e() -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Now))\n}\npub fn current_date\u003c'a\u003e() -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::CurrentDate))\n}\npub fn current_time\u003c'a\u003e() -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::CurrentTime))\n}\npub fn current_timestamp\u003c'a\u003e() -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::CurrentTimestamp))\n}\npub fn left\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T, size: U) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Left {\n        expr: expr.into(),\n        size: size.into(),\n    }))\n}\npub fn log\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(antilog: T, base: U) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Log {\n        antilog: antilog.into(),\n        base: base.into(),\n    }))\n}\npub fn log2\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Log2(expr.into())))\n}\npub fn log10\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Log10(expr.into())))\n}\npub fn ln\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Ln(expr.into())))\n}\npub fn right\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T, size: U) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Right {\n        expr: expr.into(),\n        size: size.into(),\n    }))\n}\n\npub fn reverse\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Reverse(expr.into())))\n}\n\npub fn sign\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Sign(expr.into())))\n}\n\npub fn skip\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, V: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T, size: V) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Skip {\n        expr: expr.into(),\n        size: size.into(),\n    }))\n}\n\npub fn power\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T, power: U) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Power {\n        expr: expr.into(),\n        power: power.into(),\n    }))\n}\n\npub fn sqrt\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Sqrt(expr.into())))\n}\n\npub fn gcd\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(left: T, right: U) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Gcd {\n        left: left.into(),\n        right: right.into(),\n    }))\n}\n\npub fn lcm\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(left: T, right: U) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Lcm {\n        left: left.into(),\n        right: right.into(),\n    }))\n}\n\npub fn repeat\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, V: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T, num: V) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Repeat {\n        expr: expr.into(),\n        num: num.into(),\n    }))\n}\n\npub fn replace\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e, V: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    expr: T,\n    old: U,\n    new: V,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Replace {\n        expr: expr.into(),\n        old: old.into(),\n        new: new.into(),\n    }))\n}\n\npub fn lpad\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    expr: T,\n    size: U,\n    fill: Option\u003cExprNode\u003c'a\u003e\u003e,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Lpad {\n        expr: expr.into(),\n        size: size.into(),\n        fill,\n    }))\n}\n\npub fn rpad\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    expr: T,\n    size: U,\n    fill: Option\u003cExprNode\u003c'a\u003e\u003e,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Rpad {\n        expr: expr.into(),\n        size: size.into(),\n        fill,\n    }))\n}\n\npub fn degrees\u003c'a, V: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: V) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Degrees(expr.into())))\n}\n\npub fn radians\u003c'a, V: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: V) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Radians(expr.into())))\n}\n\npub fn take\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T, size: U) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Take {\n        expr: expr.into(),\n        size: size.into(),\n    }))\n}\n\npub fn exp\u003c'a, V: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: V) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Exp(expr.into())))\n}\npub fn substr\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    expr: T,\n    start: U,\n    count: Option\u003cExprNode\u003c'a\u003e\u003e,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Substr {\n        expr: expr.into(),\n        start: start.into(),\n        count,\n    }))\n}\n\npub fn ltrim\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T, chars: Option\u003cExprNode\u003c'a\u003e\u003e) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Ltrim {\n        expr: expr.into(),\n        chars,\n    }))\n}\n\npub fn rtrim\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T, chars: Option\u003cExprNode\u003c'a\u003e\u003e) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Rtrim {\n        expr: expr.into(),\n        chars,\n    }))\n}\n\npub fn divide\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    dividend: T,\n    divisor: U,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Div {\n        dividend: dividend.into(),\n        divisor: divisor.into(),\n    }))\n}\n\npub fn modulo\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    dividend: T,\n    divisor: U,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Mod {\n        dividend: dividend.into(),\n        divisor: divisor.into(),\n    }))\n}\n\npub fn format\u003c'a, D: Into\u003cExprNode\u003c'a\u003e\u003e, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    expr: D,\n    format: T,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Format {\n        expr: expr.into(),\n        format: format.into(),\n    }))\n}\n\npub fn to_date\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    expr: T,\n    format: U,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::ToDate {\n        expr: expr.into(),\n        format: format.into(),\n    }))\n}\n\npub fn to_timestamp\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    expr: T,\n    format: U,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::ToTimestamp {\n        expr: expr.into(),\n        format: format.into(),\n    }))\n}\n\npub fn to_time\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    expr: T,\n    format: U,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::ToTime {\n        expr: expr.into(),\n        format: format.into(),\n    }))\n}\n\npub fn position\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    from_expr: T,\n    sub_expr: U,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Position {\n        from_expr: from_expr.into(),\n        sub_expr: sub_expr.into(),\n    }))\n}\n\npub fn find_idx\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    from_expr: T,\n    sub_expr: U,\n    start: Option\u003cExprNode\u003c'a\u003e\u003e,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::FindIdx {\n        from_expr: from_expr.into(),\n        sub_expr: sub_expr.into(),\n        start,\n    }))\n}\n\npub fn cast\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cDataTypeNode\u003e\u003e(\n    expr: T,\n    data_type: U,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Cast {\n        expr: expr.into(),\n        data_type: data_type.into(),\n    }))\n}\n\npub fn extract\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(field: DateTimeField, expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Extract {\n        field,\n        expr: expr.into(),\n    }))\n}\n\npub fn ascii\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Ascii(expr.into())))\n}\n\npub fn chr\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Chr(expr.into())))\n}\n\npub fn md5\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Md5(expr.into())))\n}\n\npub fn hex\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Hex(expr.into())))\n}\n\npub fn point\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(x: T, y: U) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Point {\n        x: x.into(),\n        y: y.into(),\n    }))\n}\n\npub fn get_x\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::GetX(expr.into())))\n}\n\npub fn get_y\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::GetY(expr.into())))\n}\n\npub fn greatest\u003c'a, T: Into\u003cExprList\u003c'a\u003e\u003e\u003e(exprs: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Greatest(exprs.into())))\n}\n\npub fn calc_distance\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n    geometry1: T,\n    geometry2: U,\n) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::CalcDistance {\n        geometry1: geometry1.into(),\n        geometry2: geometry2.into(),\n    }))\n}\n\npub fn length\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Length(expr.into())))\n}\n\npub fn is_empty\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::IsEmpty(expr.into())))\n}\n\npub fn last_day\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::LastDay(expr.into())))\n}\n\npub fn entries\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Entries(expr.into())))\n}\n\npub fn keys\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Keys(expr.into())))\n}\n\npub fn values\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Function(Box::new(FunctionNode::Values(expr.into())))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::DateTimeField,\n        ast_builder::function as f,\n        ast_builder::{col, date, expr, null, num, test_expr, text, time, timestamp},\n        prelude::DataType,\n    };\n\n    #[test]\n    fn function_abs() {\n        let actual = f::abs(col(\"num\"));\n        let expected = \"ABS(num)\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"base - 10\").abs();\n        let expected = \"ABS(base - 10)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_upper() {\n        let actual = f::upper(text(\"ABC\"));\n        let expected = \"UPPER('ABC')\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"HoHo\").upper();\n        let expected = \"UPPER(HoHo)\";\n        test_expr(actual, expected);\n    }\n    #[test]\n    fn function_ifnull() {\n        let actual = f::ifnull(text(\"HELLO\"), text(\"WORLD\"));\n        let expected = \"IFNULL('HELLO', 'WORLD')\";\n        test_expr(actual, expected);\n\n        let actual = col(\"updated_at\").ifnull(col(\"created_at\"));\n        let expected = \"IFNULL(updated_at, created_at)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_nullif() {\n        let actual = f::nullif(text(\"hello\"), text(\"world\"));\n        let expected = \"NULLIF('hello', 'world')\";\n        test_expr(actual, expected);\n\n        let actual = col(\"updated_at\").nullif(col(\"created_at\"));\n        let expected = \"NULLIF(updated_at, created_at)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_ceil() {\n        let actual = f::ceil(col(\"num\"));\n        let expected = \"CEIL(num)\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"base - 10\").ceil();\n        let expected = \"CEIL(base - 10)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_rand() {\n        let actual = f::rand(None);\n        let expected = \"RAND()\";\n        test_expr(actual, expected);\n\n        let actual = f::rand(Some(col(\"num\")));\n        let expected = \"RAND(num)\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"base - 10\").rand();\n        let expected = \"RAND(base - 10)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_round() {\n        let actual = f::round(col(\"num\"));\n        let expected = \"ROUND(num)\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"base - 10\").round();\n        let expected = \"ROUND(base - 10)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_floor() {\n        let actual = f::floor(col(\"num\"));\n        let expected = \"FLOOR(num)\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"base - 10\").floor();\n        let expected = \"FLOOR(base - 10)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_trigonometrics() {\n        // asin\n        let actual = f::asin(col(\"num\"));\n        let expected = \"ASIN(num)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"num\").asin();\n        let expected = \"ASIN(num)\";\n        test_expr(actual, expected);\n\n        // acos\n        let actual = f::acos(col(\"num\"));\n        let expected = \"ACOS(num)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"num\").acos();\n        let expected = \"ACOS(num)\";\n        test_expr(actual, expected);\n\n        // atan\n        let actual = f::atan(col(\"num\"));\n        let expected = \"ATAN(num)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"num\").atan();\n        let expected = \"ATAN(num)\";\n        test_expr(actual, expected);\n\n        // sin\n        let actual = f::sin(col(\"num\"));\n        let expected = \"SIN(num)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"num\").sin();\n        let expected = \"SIN(num)\";\n        test_expr(actual, expected);\n\n        // cos\n        let actual = f::cos(col(\"num\"));\n        let expected = \"COS(num)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"num\").cos();\n        let expected = \"COS(num)\";\n        test_expr(actual, expected);\n\n        // tan\n        let actual = f::tan(col(\"num\"));\n        let expected = \"TAN(num)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"num\").tan();\n        let expected = \"TAN(num)\";\n        test_expr(actual, expected);\n\n        // pi\n        let actual = f::pi();\n        let expected = \"PI()\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_now() {\n        let actual = f::now();\n        let expected = \"NOW()\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_current_date() {\n        let actual = f::current_date();\n        let expected = \"CURRENT_DATE()\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_current_time() {\n        let actual = f::current_time();\n        let expected = \"CURRENT_TIME()\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_current_timestamp() {\n        let actual = f::current_timestamp();\n        let expected = \"CURRENT_TIMESTAMP()\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_generate_uuid() {\n        let actual = f::generate_uuid();\n        let expected = \"GENERATE_UUID()\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_left() {\n        let actual = f::left(text(\"GlueSQL\"), num(2));\n        let expected = \"LEFT('GlueSQL', 2)\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"GlueSQL\").left(num(2));\n        let expected = \"LEFT(GlueSQL, 2)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_log() {\n        let actual = f::log(num(64), num(8));\n        let expected = \"log(64,8)\";\n        test_expr(actual, expected);\n\n        let actual = num(64).log(num(8));\n        let expected = \"LOG(64,8)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_log2() {\n        let actual = f::log2(col(\"num\"));\n        let expected = \"LOG2(num)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"num\").log2();\n        let expected = \"LOG2(num)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_log10() {\n        let actual = f::log10(col(\"num\"));\n        let expected = \"LOG10(num)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"num\").log10();\n        let expected = \"LOG10(num)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_ln() {\n        let actual = f::ln(num(2));\n        let expected = \"LN(2)\";\n        test_expr(actual, expected);\n\n        let actual = num(2).ln();\n        let expected = \"LN(2)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_right() {\n        let actual = f::right(text(\"GlueSQL\"), num(2));\n        let expected = \"RIGHT('GlueSQL', 2)\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"GlueSQL\").right(num(2));\n        let expected = \"RIGHT(GlueSQL, 2)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_reverse() {\n        let actual = f::reverse(text(\"GlueSQL\"));\n        let expected = \"REVERSE('GlueSQL')\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"GlueSQL\").reverse();\n        let expected = \"REVERSE(GlueSQL)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_sign() {\n        let actual = f::sign(col(\"id\"));\n        let expected = \"SIGN(id)\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"id\").sign();\n        let expected = \"SIGN(id)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_skip() {\n        let actual = f::skip(col(\"list\"), num(2));\n        let expected = \"SKIP(list,2)\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"list\").skip(num(2));\n        let expected = \"SKIP(list,2)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_power() {\n        let actual = f::power(num(2), num(4));\n        let expected = \"POWER(2,4)\";\n        test_expr(actual, expected);\n\n        let actual = num(2).power(num(4));\n        let expected = \"POWER(2,4)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_sqrt() {\n        let actual = f::sqrt(num(9));\n        let expected = \"SQRT(9)\";\n        test_expr(actual, expected);\n\n        let actual = num(9).sqrt();\n        let expected = \"SQRT(9)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_gcd() {\n        let actual = f::gcd(num(64), num(8));\n        let expected = \"gcd(64,8)\";\n        test_expr(actual, expected);\n\n        let actual = num(64).gcd(num(8));\n        let expected = \"GCD(64,8)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_lcm() {\n        let actual = f::lcm(num(64), num(8));\n        let expected = \"lcm(64,8)\";\n        test_expr(actual, expected);\n\n        let actual = num(64).lcm(num(8));\n        let expected = \"LCM(64,8)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_repeat() {\n        let actual = f::repeat(text(\"GlueSQL\"), num(2));\n        let expected = \"REPEAT('GlueSQL', 2)\";\n        test_expr(actual, expected);\n\n        let actual = text(\"GlueSQL\").repeat(num(2));\n        let expected = \"REPEAT('GlueSQL', 2)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_degrees() {\n        let actual = f::degrees(num(1));\n        let expected = \"DEGREES(1)\";\n        test_expr(actual, expected);\n\n        let actual = num(1).degrees();\n        let expected = \"DEGREES(1)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_radians() {\n        let actual = f::radians(num(1));\n        let expected = \"RADIANS(1)\";\n        test_expr(actual, expected);\n\n        let actual = num(1).radians();\n        let expected = \"RADIANS(1)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_coalesce() {\n        let actual = f::coalesce(vec![null(), text(\"Glue\")]);\n        let expected = \"COALESCE(NULL, 'Glue')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_concat() {\n        let actual = f::concat(vec![text(\"Glue\"), text(\"SQL\"), text(\"Go\")]);\n        let expected = \"CONCAT('Glue','SQL','Go')\";\n        test_expr(actual, expected);\n\n        let actual = f::concat(vec![\"Glue\", \"SQL\", \"Go\"]);\n        let expected = \"CONCAT(Glue, SQL, Go)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_concat_ws() {\n        let actual = f::concat_ws(text(\",\"), vec![text(\"Glue\"), text(\"SQL\"), text(\"Go\")]);\n        let expected = \"CONCAT_WS(',', 'Glue', 'SQL', 'Go')\";\n        test_expr(actual, expected);\n\n        let actual = f::concat_ws(text(\",\"), vec![\"Glue\", \"SQL\", \"Go\"]);\n        let expected = \"CONCAT_WS(',', Glue, SQL, Go)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_lpad() {\n        let actual = f::lpad(text(\"GlueSQL\"), num(10), Some(text(\"Go\")));\n        let expected = \"LPAD('GlueSQL', 10, 'Go')\";\n        test_expr(actual, expected);\n\n        let actual = f::lpad(text(\"GlueSQL\"), num(10), None);\n        let expected = \"LPAD('GlueSQL', 10)\";\n        test_expr(actual, expected);\n\n        let actual = text(\"GlueSQL\").lpad(num(10), Some(text(\"Go\")));\n        let expected = \"LPAD('GlueSQL', 10, 'Go')\";\n        test_expr(actual, expected);\n\n        let actual = text(\"GlueSQL\").lpad(num(10), None);\n        let expected = \"LPAD('GlueSQL', 10)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_rpad() {\n        let actual = f::rpad(text(\"GlueSQL\"), num(10), Some(text(\"Go\")));\n        let expected = \"RPAD('GlueSQL', 10, 'Go')\";\n        test_expr(actual, expected);\n\n        let actual = f::rpad(text(\"GlueSQL\"), num(10), None);\n        let expected = \"RPAD('GlueSQL', 10)\";\n        test_expr(actual, expected);\n\n        let actual = text(\"GlueSQL\").rpad(num(10), Some(text(\"Go\")));\n        let expected = \"RPAD('GlueSQL', 10, 'Go')\";\n        test_expr(actual, expected);\n\n        let actual = text(\"GlueSQL\").rpad(num(10), None);\n        let expected = \"RPAD('GlueSQL', 10)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_take() {\n        let actual = f::take(col(\"list\"), num(3));\n        let expected = \"TAKE(list,3)\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"list\").take(num(3));\n        let expected = \"TAKE(list,3)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_exp() {\n        let actual = f::exp(num(2));\n        let expected = \"EXP(2)\";\n        test_expr(actual, expected);\n\n        let actual = num(2).exp();\n        let expected = \"EXP(2)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_substr() {\n        let actual = f::substr(text(\"GlueSQL\"), num(2), Some(num(4)));\n        let expected = \"SUBSTR('GlueSQL', 2, 4)\";\n        test_expr(actual, expected);\n\n        let actual = f::substr(text(\"GlueSQL\"), num(2), None);\n        let expected = \"SUBSTR('GlueSQL', 2)\";\n        test_expr(actual, expected);\n\n        let actual = text(\"GlueSQL\").substr(num(2), Some(num(4)));\n        let expected = \"SUBSTR('GlueSQL', 2, 4)\";\n        test_expr(actual, expected);\n\n        let actual = text(\"GlueSQL\").substr(num(2), None);\n        let expected = \"SUBSTR('GlueSQL', 2)\";\n        test_expr(actual, expected);\n\n        let actual = text(\"GlueSQL\").substr(num(2), None);\n        let expected = \"SUBSTR('GlueSQL', 2)\";\n        test_expr(actual, expected);\n\n        let actual = f::substr(text(\"GlueSQL      \").rtrim(None), num(2), None);\n        let expected = \"SUBSTR(RTRIM('GlueSQL      '), 2)\";\n        test_expr(actual, expected);\n\n        let actual = text(\"GlueSQL      \").rtrim(None).substr(num(2), None);\n        let expected = \"SUBSTR(RTRIM('GlueSQL      '), 2)\";\n        test_expr(actual, expected);\n\n        let actual = f::substr(text(\"      GlueSQL\").ltrim(None), num(2), None);\n        let expected = \"SUBSTR(LTRIM('      GlueSQL'), 2)\";\n        test_expr(actual, expected);\n\n        let actual = text(\"      GlueSQL\").ltrim(None).substr(num(2), None);\n        let expected = \"SUBSTR(LTRIM('      GlueSQL'), 2)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_rtrim() {\n        let actual = f::rtrim(text(\"GlueSQL      \"), None);\n        let expected = \"RTRIM('GlueSQL      ')\";\n        test_expr(actual, expected);\n\n        let actual = text(\"GlueSQL      \").rtrim(None);\n        let expected = \"RTRIM('GlueSQL      ')\";\n        test_expr(actual, expected);\n\n        let actual = f::rtrim(text(\"GlueSQLABC\"), Some(text(\"ABC\")));\n        let expected = \"RTRIM('GlueSQLABC','ABC')\";\n        test_expr(actual, expected);\n\n        let actual = text(\"GlueSQLABC\").rtrim(Some(text(\"ABC\")));\n        let expected = \"RTRIM('GlueSQLABC','ABC')\";\n        test_expr(actual, expected);\n\n        let actual = text(\"chicken\").ltrim(None).rtrim(Some(text(\"en\")));\n        let expected = \"RTRIM(LTRIM('chicken'),'en')\";\n        test_expr(actual, expected);\n\n        let actual = f::rtrim(text(\"chicken\").ltrim(Some(text(\"chick\"))), None);\n        let expected = \"RTRIM(LTRIM('chicken','chick'))\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_ltrim() {\n        let actual = f::ltrim(text(\"      GlueSQL\"), None);\n        let expected = \"LTRIM('      GlueSQL')\";\n        test_expr(actual, expected);\n\n        let actual = text(\"      GlueSQL\").ltrim(None);\n        let expected = \"LTRIM('      GlueSQL')\";\n        test_expr(actual, expected);\n\n        let actual = f::ltrim(text(\"ABCGlueSQL\"), Some(text(\"ABC\")));\n        let expected = \"LTRIM('ABCGlueSQL','ABC')\";\n        test_expr(actual, expected);\n\n        let actual = text(\"ABCGlueSQL\").ltrim(Some(text(\"ABC\")));\n        let expected = \"LTRIM('ABCGlueSQL','ABC')\";\n        test_expr(actual, expected);\n\n        let actual = text(\"chicken\").rtrim(Some(text(\"en\"))).ltrim(None);\n        let expected = \"LTRIM(RTRIM('chicken','en'))\";\n        test_expr(actual, expected);\n\n        let actual = text(\"chicken\").rtrim(None).ltrim(Some(text(\"chick\")));\n        let expected = \"LTRIM(RTRIM('chicken'),'chick')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_mod() {\n        let actual = f::modulo(num(64), num(8));\n        let expected = \"mod(64,8)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_div() {\n        let actual = f::divide(num(64), num(8));\n        let expected = \"div(64,8)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_format() {\n        let actual = f::format(date(\"2017-06-15\"), text(\"%Y-%m\"));\n        let expected = \"FORMAT(DATE'2017-06-15','%Y-%m')\";\n        test_expr(actual, expected);\n\n        let actual = date(\"2017-06-15\").format(text(\"%Y-%m\"));\n        let expected = \"FORMAT(DATE '2017-06-15','%Y-%m')\";\n        test_expr(actual, expected);\n\n        let actual = f::format(timestamp(\"2015-09-05 23:56:04\"), text(\"%Y-%m-%d %H:%M:%S\"));\n        let expected = \"FORMAT(TIMESTAMP '2015-09-05 23:56:04', '%Y-%m-%d %H:%M:%S')\";\n        test_expr(actual, expected);\n\n        let actual = timestamp(\"2015-09-05 23:56:04\").format(text(\"%Y-%m-%d %H:%M:%S\"));\n        let expected = \"FORMAT(TIMESTAMP '2015-09-05 23:56:04', '%Y-%m-%d %H:%M:%S')\";\n        test_expr(actual, expected);\n\n        let actual = f::format(time(\"23:56:04\"), text(\"%H:%M:%S\"));\n        let expected = \"FORMAT(TIME '23:56:04', '%H:%M:%S')\";\n        test_expr(actual, expected);\n\n        let actual = time(\"23:56:04\").format(text(\"%H:%M:%S\"));\n        let expected = \"FORMAT(TIME '23:56:04', '%H:%M:%S')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_to_date() {\n        let actual = f::to_date(text(\"2017-06-15\"), text(\"%Y-%m-%d\"));\n        let expected = \"TO_DATE('2017-06-15','%Y-%m-%d')\";\n        test_expr(actual, expected);\n\n        let actual = text(\"2017-06-15\").to_date(text(\"%Y-%m-%d\"));\n        let expected = \"TO_DATE('2017-06-15','%Y-%m-%d')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_to_timestamp() {\n        let actual = f::to_timestamp(text(\"2015-09-05 23:56:04\"), text(\"%Y-%m-%d %H:%M:%S\"));\n        let expected = \"TO_TIMESTAMP('2015-09-05 23:56:04','%Y-%m-%d %H:%M:%S')\";\n        test_expr(actual, expected);\n\n        let actual = text(\"2015-09-05 23:56:04\").to_timestamp(text(\"%Y-%m-%d %H:%M:%S\"));\n        let expected = \"TO_TIMESTAMP('2015-09-05 23:56:04','%Y-%m-%d %H:%M:%S')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_to_time() {\n        let actual = f::to_time(text(\"23:56:04\"), text(\"%H:%M:%S\"));\n        let expected = \"TO_TIME('23:56:04','%H:%M:%S')\";\n        test_expr(actual, expected);\n\n        let actual = text(\"23:56:04\").to_time(text(\"%H:%M:%S\"));\n        let expected = \"TO_TIME('23:56:04','%H:%M:%S')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_lower() {\n        // Lower\n        let actual = f::lower(text(\"ABC\"));\n        let expected = \"LOWER('ABC')\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"HoHo\").lower();\n        let expected = \"LOWER(HoHo)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_initcap() {\n        // Initcap\n        let actual = f::initcap(text(\"ABC\"));\n        let expected = \"INITCAP('ABC')\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"HoHo\").initcap();\n        let expected = \"INITCAP(HoHo)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_position() {\n        let actual = f::position(expr(\"cake\"), text(\"ke\"));\n        let expected = \"POSITION('ke' IN cake)\";\n        test_expr(actual, expected);\n\n        let actual = text(\"rice\").position(text(\"cake\"));\n        let expected = \"POSITION('cake' IN 'rice')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_find_idx() {\n        let actual = f::find_idx(expr(\"oatmeal\"), text(\"meal\"), Some(num(2)));\n        let expected = \"FIND_IDX(oatmeal, 'meal', 2)\";\n        test_expr(actual, expected);\n\n        let actual = f::find_idx(expr(\"strawberry\"), text(\"berry\"), None);\n        let expected = \"FIND_IDX(strawberry, 'berry')\";\n        test_expr(actual, expected);\n\n        let actual = expr(\"blackberry\").find_idx(text(\"black\"), Some(num(1)));\n        let expected = \"FIND_IDX(blackberry, 'black', 1)\";\n        test_expr(actual, expected);\n\n        let actual = text(\"blue cheese\").find_idx(text(\"blue\"), None);\n        let expected = \"FIND_IDX('blue cheese', 'blue')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_cast() {\n        let actual = col(\"date\").cast(DataType::Int);\n        let expected = \"CAST(date AS INTEGER)\";\n        test_expr(actual, expected);\n\n        let actual = f::cast(expr(\"date\"), \"INTEGER\");\n        let expected = \"CAST(date AS INTEGER)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_extract() {\n        let actual = col(\"date\").extract(DateTimeField::Year);\n        let expected = \"EXTRACT(YEAR FROM date)\";\n        test_expr(actual, expected);\n\n        let actual = f::extract(DateTimeField::Year, expr(\"date\"));\n        let expected = \"EXTRACT(YEAR FROM date)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_ascii() {\n        let actual = f::ascii(text(\"A\"));\n        let expected = \"ASCII('A')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_chr() {\n        let actual = f::chr(num(65));\n        let expected = \"CHR(65)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_md5() {\n        let actual = f::md5(text(\"abc\"));\n        let expected = \"MD5('abc')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_hex() {\n        let actual = f::hex(num(10));\n        let expected = \"HEX(10)\";\n        test_expr(actual, expected);\n\n        let actual = f::hex(text(\"10\"));\n        let expected = \"HEX('10')\";\n        test_expr(actual, expected);\n\n        let actual = f::hex(text(\"GlueSQL\"));\n        let expected = \"HEX('GlueSQL')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_point() {\n        let actual = f::point(num(1), num(2));\n        let expected = \"POINT(1, 2)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_get_x() {\n        let actual = f::get_x(f::point(num(1), num(2)));\n        let expected = \"GET_X(POINT(1, 2))\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_get_y() {\n        let actual = f::get_y(f::point(num(1), num(2)));\n        let expected = \"GET_Y(POINT(1, 2))\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_greatest() {\n        let actual = f::greatest(vec![num(1), num(2), num(3)]);\n        let expected = \"GREATEST(1, 2, 3)\";\n        test_expr(actual, expected);\n\n        let actual = f::greatest(vec![text(\"Glue\"), text(\"SQL\"), text(\"Go\")]);\n        let expected = \"GREATEST('Glue','SQL','Go')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_calc_distance() {\n        let actual = f::calc_distance(f::point(num(1), num(2)), f::point(num(3), num(4)));\n        let expected = \"CALC_DISTANCE(POINT(1, 2), POINT(3, 4))\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_replace() {\n        let actual = f::replace(text(\"Mticky GlueMQL\"), text(\"M\"), text(\"S\"));\n        let expected = \"REPLACE('Mticky GlueMQL','M','S')\";\n        test_expr(actual, expected);\n\n        let actual = text(\"Mticky GlueMQL\").replace(text(\"M\"), text(\"S\"));\n        let expected = \"REPLACE('Mticky GlueMQL','M','S')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_length() {\n        let actual = f::length(text(\"GlueSQL\"));\n        let expected = \"LENGTH('GlueSQL')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_is_empty() {\n        let actual = col(\"list\").is_empty();\n        let expected = \"IS_EMPTY(list)\";\n        test_expr(actual, expected);\n\n        let actual = f::is_empty(col(\"list\"));\n        let expected = \"IS_EMPTY(list)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_last_day_date() {\n        let actual = f::last_day(date(\"2023-07-29\"));\n        let expected = \"LAST_DAY(DATE'2023-07-29')\";\n        test_expr(actual, expected);\n\n        let actual = date(\"2023-07-29\").last_day();\n        let expected = \"LAST_DAY(DATE'2023-07-29')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_last_day_timestamp() {\n        let actual = f::last_day(timestamp(\"2023-07-29 11:00:00\"));\n        let expected = \"LAST_DAY(TIMESTAMP '2023-07-29 11:00:00')\";\n        test_expr(actual, expected);\n\n        let actual = timestamp(\"2023-07-29 11:00:00\").last_day();\n        let expected = \"LAST_DAY(TIMESTAMP '2023-07-29 11:00:00')\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_entries() {\n        let actual = f::entries(col(\"map\"));\n        let expected = \"ENTRIES(map)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"map\").entries();\n        let expected = \"ENTRIES(map)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_fn_values() {\n        let actual = col(\"map\").values();\n        let expected = \"VALUES(map)\";\n        test_expr(actual, expected);\n\n        let actual = f::values(col(\"map\"));\n        let expected = \"VALUES(map)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn function_keys() {\n        let actual = f::keys(col(\"map\"));\n        let expected = \"KEYS(map)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"map\").keys();\n        let expected = \"KEYS(map)\";\n        test_expr(actual, expected);\n    }\n}\n","traces":[{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":526},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","in_list.rs"],"content":"use {\n    super::ExprNode,\n    crate::ast_builder::{\n        FilterNode, GroupByNode, HashJoinNode, HavingNode, JoinConstraintNode, JoinNode, LimitNode,\n        OffsetLimitNode, OffsetNode, OrderByNode, ProjectNode, QueryNode, SelectNode,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum InListNode\u003c'a\u003e {\n    InList(Vec\u003cExprNode\u003c'a\u003e\u003e),\n    Query(Box\u003cQueryNode\u003c'a\u003e\u003e),\n    Text(String),\n}\n\nimpl\u003c'a\u003e From\u003cVec\u003cExprNode\u003c'a\u003e\u003e\u003e for InListNode\u003c'a\u003e {\n    fn from(list: Vec\u003cExprNode\u003c'a\u003e\u003e) -\u003e Self {\n        InListNode::InList(list)\n    }\n}\n\nimpl\u003c'a\u003e From\u003c\u0026str\u003e for InListNode\u003c'a\u003e {\n    fn from(query: \u0026str) -\u003e Self {\n        InListNode::Text(query.to_owned())\n    }\n}\n\nimpl\u003c'a\u003e From\u003cQueryNode\u003c'a\u003e\u003e for InListNode\u003c'a\u003e {\n    fn from(node: QueryNode\u003c'a\u003e) -\u003e Self {\n        InListNode::Query(Box::new(node))\n    }\n}\n\nmacro_rules! impl_from_select_nodes {\n    ($type: path) =\u003e {\n        impl\u003c'a\u003e From\u003c$type\u003e for InListNode\u003c'a\u003e {\n            fn from(list: $type) -\u003e Self {\n                InListNode::Query(Box::new(list.into()))\n            }\n        }\n    };\n}\n\nimpl_from_select_nodes!(SelectNode\u003c'a\u003e);\nimpl_from_select_nodes!(JoinNode\u003c'a\u003e);\nimpl_from_select_nodes!(JoinConstraintNode\u003c'a\u003e);\nimpl_from_select_nodes!(HashJoinNode\u003c'a\u003e);\nimpl_from_select_nodes!(GroupByNode\u003c'a\u003e);\nimpl_from_select_nodes!(HavingNode\u003c'a\u003e);\nimpl_from_select_nodes!(FilterNode\u003c'a\u003e);\nimpl_from_select_nodes!(LimitNode\u003c'a\u003e);\nimpl_from_select_nodes!(OffsetNode\u003c'a\u003e);\nimpl_from_select_nodes!(OffsetLimitNode\u003c'a\u003e);\nimpl_from_select_nodes!(ProjectNode\u003c'a\u003e);\nimpl_from_select_nodes!(OrderByNode\u003c'a\u003e);\n\nimpl\u003c'a\u003e ExprNode\u003c'a\u003e {\n    pub fn in_list\u003cT: Into\u003cInListNode\u003c'a\u003e\u003e\u003e(self, value: T) -\u003e Self {\n        Self::InList {\n            expr: Box::new(self),\n            list: Box::new(value.into()),\n            negated: false,\n        }\n    }\n\n    pub fn not_in_list\u003cT: Into\u003cInListNode\u003c'a\u003e\u003e\u003e(self, value: T) -\u003e Self {\n        Self::InList {\n            expr: Box::new(self),\n            list: Box::new(value.into()),\n            negated: true,\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use crate::{\n        ast::{\n            Expr, Join, JoinConstraint, JoinExecutor, JoinOperator, Query, Select, SetExpr,\n            TableFactor, TableWithJoins,\n        },\n        ast_builder::{QueryNode, SelectItemList, col, table, test_expr, text},\n    };\n\n    #[test]\n    fn in_list() {\n        let actual = col(\"id\").in_list(vec![text(\"a\"), text(\"b\"), text(\"c\")]);\n        let expected = \"id IN ('a', 'b', 'c')\";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\").not_in_list(\"opt1, opt2, opt3\");\n        let expected = \"id NOT IN (opt1, opt2, opt3)\";\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn from_nodes() {\n        // from Vec\u003cExprNode\u003e\n        let actual = col(\"id\").not_in_list(vec![text(\"a\"), text(\"b\"), text(\"c\")]);\n        let expected = \"id NOT IN ('a', 'b', 'c')\";\n        test_expr(actual, expected);\n\n        // from \u0026str\n        let actual = col(\"id\").in_list(\"1, 2, 3, 4, 5\");\n        let expected = \"id IN (1, 2, 3, 4, 5)\";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\").in_list(\"SELECT id FROM FOO\");\n        let expected = \"id IN (SELECT id FROM FOO)\";\n        test_expr(actual, expected);\n\n        // from QueryNode\n        let query_node = QueryNode::from(\"SELECT name FROM ItemList\");\n        let actual = col(\"id\").in_list(query_node);\n        let expected = \"id IN (SELECT name FROM ItemList)\";\n        test_expr(actual, expected);\n\n        // from SelectNode\n        let actual = col(\"id\").in_list(table(\"FOO\").select());\n        let expected = \"id IN (SELECT * FROM FOO)\";\n        test_expr(actual, expected);\n\n        // from JoinNode\n        let actual = col(\"id\").in_list(table(\"Bar\").select().join(\"Foo\"));\n        let expected = \"id IN (SELECT * FROM Bar JOIN Foo)\";\n        test_expr(actual, expected);\n\n        // from JoinConstraintNode\n        let actual = col(\"id\").in_list(table(\"Bar\").select().join(\"Foo\").on(\"Foo.id = Bar.foo_id\"));\n        let expected = \"id IN (SELECT * FROM Bar JOIN Foo ON Foo.id = Bar.foo_id)\";\n        test_expr(actual, expected);\n\n        // from HashJoinNode\n        let actual = col(\"id\").in_list(\n            table(\"Player\")\n                .select()\n                .join(\"PlayerItem\")\n                .hash_executor(\"PlayerItem.user_id\", \"Player.id\"),\n        );\n        let expected = {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"PlayerItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"PlayerItem.user_id\").try_into().unwrap(),\n                    value_expr: col(\"Player.id\").try_into().unwrap(),\n                    where_clause: None,\n                },\n            };\n            let select = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join],\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            let query = Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            };\n\n            Expr::InSubquery {\n                expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n                subquery: Box::new(query),\n                negated: false,\n            }\n        };\n        assert_eq!(Expr::try_from(actual).unwrap(), expected);\n\n        // from GroupByNode\n        let actual = col(\"id\").not_in_list(\n            table(\"Bar\")\n                .select()\n                .filter(col(\"id\").is_null())\n                .group_by(\"id, (a + name)\"),\n        );\n        let expected = \"id NOT IN (SELECT * FROM Bar WHERE id IS NULL GROUP BY id, (a + name))\";\n        test_expr(actual, expected);\n\n        // from HavingNode\n        let actual = col(\"id\").in_list(\n            table(\"Bar\")\n                .select()\n                .filter(\"id IS NULL\")\n                .group_by(\"id, (a + name)\")\n                .having(\"COUNT(id) \u003e 10\"),\n        );\n        let expected = \"\n            id IN (\n                SELECT * FROM Bar\n                WHERE id IS NULL\n                GROUP BY id, (a + name)\n                HAVING COUNT(id) \u003e 10\n            )\n        \";\n        test_expr(actual, expected);\n\n        // from FilterNode\n        let actual = col(\"id\").in_list(table(\"Bar\").select().filter(\"num \u003e 10\"));\n        let expected = \"id IN (SELECT * FROM Bar WHERE num \u003e 10)\";\n        test_expr(actual, expected);\n\n        // from LimitNode\n        let actual = col(\"id\").in_list(table(\"FOO\").select().filter(\"id IS NULL\").limit(10));\n        let expected = \"id IN (SELECT * FROM FOO WHERE id IS NULL LIMIT 10)\";\n        test_expr(actual, expected);\n\n        // from OffsetNode\n        let actual = col(\"id\").not_in_list(table(\"Hello\").select().offset(10));\n        let expected = \"id NOT IN (SELECT * FROM Hello OFFSET 10)\";\n        test_expr(actual, expected);\n\n        // from OffsetLimitNode\n        let actual = col(\"id\").in_list(table(\"Bar\").select().offset(1).limit(3));\n        let expected = \"id IN (SELECT * FROM Bar OFFSET 1 LIMIT 3)\";\n        test_expr(actual, expected);\n\n        // from ProjectNode\n        let actual = col(\"name\").in_list(table(\"Item\").select().project(\"name\"));\n        let expected = \"name IN (SELECT name FROM Item)\";\n        test_expr(actual, expected);\n\n        // from OrderByNode\n        let actual = col(\"id\").in_list(table(\"Item\").select().order_by(\"score ASC\"));\n        let expected = \"id IN (SELECT * FROM Item ORDER BY score ASC)\";\n        test_expr(actual, expected);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","is_null.rs"],"content":"use super::ExprNode;\n\nimpl\u003c'a\u003e ExprNode\u003c'a\u003e {\n    pub fn is_null(self) -\u003e Self {\n        Self::IsNull(Box::new(self))\n    }\n\n    pub fn is_not_null(self) -\u003e Self {\n        Self::IsNotNull(Box::new(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{col, num, test_expr};\n\n    #[test]\n    fn is_null() {\n        let actual = col(\"id\").is_null();\n        let expected = \"id IS NULL\";\n        test_expr(actual, expected);\n\n        let actual = num(10).add(\"id\").is_not_null();\n        let expected = \"10 + id IS NOT NULL\";\n        test_expr(actual, expected);\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","like.rs"],"content":"use super::ExprNode;\n\nimpl\u003c'a\u003e ExprNode\u003c'a\u003e {\n    pub fn like\u003cT: Into\u003cSelf\u003e\u003e(self, pattern: T) -\u003e Self {\n        Self::Like {\n            expr: Box::new(self),\n            negated: false,\n            pattern: Box::new(pattern.into()),\n        }\n    }\n\n    pub fn ilike\u003cT: Into\u003cSelf\u003e\u003e(self, pattern: T) -\u003e Self {\n        Self::ILike {\n            expr: Box::new(self),\n            negated: false,\n            pattern: Box::new(pattern.into()),\n        }\n    }\n\n    pub fn not_like\u003cT: Into\u003cSelf\u003e\u003e(self, pattern: T) -\u003e Self {\n        Self::Like {\n            expr: Box::new(self),\n            negated: true,\n            pattern: Box::new(pattern.into()),\n        }\n    }\n\n    pub fn not_ilike\u003cT: Into\u003cSelf\u003e\u003e(self, pattern: T) -\u003e Self {\n        Self::ILike {\n            expr: Box::new(self),\n            negated: true,\n            pattern: Box::new(pattern.into()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{col, test_expr, text};\n\n    #[test]\n    fn like_ilike() {\n        let actual = col(\"name\").like(text(\"a%\"));\n        let expected = \"name LIKE 'a%'\";\n        test_expr(actual, expected);\n\n        let actual = col(\"name\").ilike(text(\"a%\"));\n        let expected = \"name ILIKE 'a%'\";\n        test_expr(actual, expected);\n\n        let actual = col(\"name\").not_like(text(\"a%\"));\n        let expected = \"name NOT LIKE 'a%'\";\n        test_expr(actual, expected);\n\n        let actual = col(\"name\").not_ilike(text(\"a%\"));\n        let expected = \"name NOT ILIKE 'a%'\";\n        test_expr(actual, expected);\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","nested.rs"],"content":"use super::ExprNode;\n\nimpl\u003c'a\u003e ExprNode\u003c'a\u003e {\n    pub fn nested(self) -\u003e Self {\n        nested(self)\n    }\n}\n\npub fn nested\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Nested(Box::new(expr.into()))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{col, nested, test_expr};\n\n    #[test]\n    fn test_nested() {\n        let actual = col(\"val1\").add(col(\"val2\")).nested();\n        let expected = \"(val1 + val2)\";\n        test_expr(actual, expected);\n\n        let actual = nested(col(\"val1\").add(col(\"val2\")));\n        let expected = \"(val1 + val2)\";\n        test_expr(actual, expected);\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","numeric.rs"],"content":"use {\n    crate::{\n        ast::AstLiteral,\n        ast_builder::AstBuilderError,\n        result::{Error, Result},\n    },\n    bigdecimal::BigDecimal,\n    std::{borrow::Cow, str::FromStr},\n};\n\n#[derive(Clone, Debug)]\npub enum NumericNode\u003c'a\u003e {\n    I8(i8),\n    I16(i16),\n    I32(i32),\n    I64(i64),\n    U8(u8),\n    U16(u16),\n    U32(u32),\n    U64(u64),\n    F32(f32),\n    F64(f64),\n    Str(Cow\u003c'a, str\u003e),\n}\n\nmacro_rules! impl_from {\n    ($type: path, $name: ident) =\u003e {\n        impl\u003c'a\u003e From\u003c$type\u003e for NumericNode\u003c'a\u003e {\n            fn from(v: $type) -\u003e Self {\n                NumericNode::$name(v)\n            }\n        }\n    };\n}\n\nimpl_from!(i8, I8);\nimpl_from!(i16, I16);\nimpl_from!(i32, I32);\nimpl_from!(i64, I64);\nimpl_from!(u8, U8);\nimpl_from!(u16, U16);\nimpl_from!(u32, U32);\nimpl_from!(u64, U64);\nimpl_from!(f32, F32);\nimpl_from!(f64, F64);\n\nimpl\u003c'a\u003e From\u003cString\u003e for NumericNode\u003c'a\u003e {\n    fn from(v: String) -\u003e Self {\n        Self::Str(Cow::Owned(v))\n    }\n}\n\nimpl\u003c'a\u003e From\u003c\u0026'a str\u003e for NumericNode\u003c'a\u003e {\n    fn from(v: \u0026'a str) -\u003e Self {\n        Self::Str(Cow::Borrowed(v))\n    }\n}\n\nimpl\u003c'a\u003e TryFrom\u003cNumericNode\u003c'a\u003e\u003e for AstLiteral {\n    type Error = Error;\n\n    fn try_from(node: NumericNode\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        match node {\n            NumericNode::I8(v) =\u003e Ok(AstLiteral::Number(v.into())),\n            NumericNode::I16(v) =\u003e Ok(AstLiteral::Number(v.into())),\n            NumericNode::I32(v) =\u003e Ok(AstLiteral::Number(v.into())),\n            NumericNode::I64(v) =\u003e Ok(AstLiteral::Number(v.into())),\n            NumericNode::U8(v) =\u003e Ok(AstLiteral::Number(v.into())),\n            NumericNode::U16(v) =\u003e Ok(AstLiteral::Number(v.into())),\n            NumericNode::U32(v) =\u003e Ok(AstLiteral::Number(v.into())),\n            NumericNode::U64(v) =\u003e Ok(AstLiteral::Number(v.into())),\n            NumericNode::F32(v) =\u003e BigDecimal::try_from(v)\n                .map_err(|_| AstBuilderError::FailedToParseNumeric(v.to_string()).into())\n                .map(AstLiteral::Number),\n            NumericNode::F64(v) =\u003e BigDecimal::try_from(v)\n                .map_err(|_| AstBuilderError::FailedToParseNumeric(v.to_string()).into())\n                .map(AstLiteral::Number),\n            NumericNode::Str(v) =\u003e BigDecimal::from_str(\u0026v)\n                .map_err(|_| AstBuilderError::FailedToParseNumeric(v.into_owned()).into())\n                .map(AstLiteral::Number),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::AstLiteral,\n            ast_builder::{AstBuilderError, NumericNode},\n        },\n        bigdecimal::BigDecimal,\n        std::str::FromStr,\n    };\n\n    #[test]\n    fn numeric() {\n        let num = |n| Ok(AstLiteral::Number(BigDecimal::from_str(n).unwrap()));\n\n        assert_eq!(NumericNode::from(1_i8).try_into(), num(\"1\"));\n        assert_eq!(NumericNode::from(1_i16).try_into(), num(\"1\"));\n        assert_eq!(NumericNode::from(1_i32).try_into(), num(\"1\"));\n        assert_eq!(NumericNode::from(1_i64).try_into(), num(\"1\"));\n        assert_eq!(NumericNode::from(1_u8).try_into(), num(\"1\"));\n        assert_eq!(NumericNode::from(1_u16).try_into(), num(\"1\"));\n        assert_eq!(NumericNode::from(1_u32).try_into(), num(\"1\"));\n        assert_eq!(NumericNode::from(1_u64).try_into(), num(\"1\"));\n        assert_eq!(NumericNode::from(1.50_f32).try_into(), num(\"1.50\"));\n        assert_eq!(NumericNode::from(4.125_f64).try_into(), num(\"4.125\"));\n        assert_eq!(NumericNode::from(\"123.456\").try_into(), num(\"123.456\"));\n        assert_eq!(NumericNode::from(\"1.6\".to_owned()).try_into(), num(\"1.6\"));\n\n        assert_eq!(\n            AstLiteral::try_from(NumericNode::from(f32::NAN)),\n            Err(AstBuilderError::FailedToParseNumeric(f32::NAN.to_string()).into()),\n        );\n        assert_eq!(\n            AstLiteral::try_from(NumericNode::from(f64::NAN)),\n            Err(AstBuilderError::FailedToParseNumeric(f64::NAN.to_string()).into()),\n        );\n        assert_eq!(\n            AstLiteral::try_from(NumericNode::from(\"not a number\")),\n            Err(AstBuilderError::FailedToParseNumeric(\"not a number\".to_owned()).into()),\n        );\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr","unary_op.rs"],"content":"use {super::ExprNode, crate::ast::UnaryOperator};\n\nimpl\u003c'a\u003e ExprNode\u003c'a\u003e {\n    pub fn plus(self) -\u003e Self {\n        plus(self)\n    }\n    pub fn minus(self) -\u003e Self {\n        minus(self)\n    }\n    #[allow(clippy::should_implement_trait)]\n    pub fn negate(self) -\u003e Self {\n        not(self)\n    }\n    pub fn factorial(self) -\u003e Self {\n        factorial(self)\n    }\n    pub fn bitwise_not(self) -\u003e Self {\n        bitwise_not(self)\n    }\n}\n\npub fn plus\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::UnaryOp {\n        op: UnaryOperator::Plus,\n        expr: Box::new(expr.into()),\n    }\n}\n\npub fn minus\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::UnaryOp {\n        op: UnaryOperator::Minus,\n        expr: Box::new(expr.into()),\n    }\n}\n\npub fn not\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::UnaryOp {\n        op: UnaryOperator::Not,\n        expr: Box::new(expr.into()),\n    }\n}\n\npub fn factorial\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::UnaryOp {\n        op: UnaryOperator::Factorial,\n        expr: Box::new(expr.into()),\n    }\n}\n\npub fn bitwise_not\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(expr: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::UnaryOp {\n        op: UnaryOperator::BitwiseNot,\n        expr: Box::new(expr.into()),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{col, num, test_expr};\n\n    #[test]\n    fn unary_op() {\n        let actual = num(5).plus();\n        let expected = \"+5\";\n        test_expr(actual, expected);\n\n        let actual = num(10).minus();\n        let expected = \"-10\";\n        test_expr(actual, expected);\n\n        let actual = (col(\"count\").gt(num(5))).negate();\n        let expected = \"NOT count \u003e 5\";\n        test_expr(actual, expected);\n\n        let actual = num(10).factorial();\n        let expected = \"10!\";\n        test_expr(actual, expected);\n\n        let actual = num(10).bitwise_not();\n        let expected = \"~10\";\n        test_expr(actual, expected);\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr.rs"],"content":"mod binary_op;\nmod case;\nmod exists;\nmod is_null;\nmod like;\nmod nested;\nmod unary_op;\n\npub mod aggregate;\npub mod alias_as;\npub mod between;\npub mod function;\npub mod in_list;\npub mod numeric;\n\nuse {\n    crate::{\n        ast::{Aggregate, AstLiteral, BinaryOperator, Expr, Function, Query, UnaryOperator},\n        ast_builder::QueryNode,\n        parse_sql::{parse_comma_separated_exprs, parse_expr, parse_query},\n        prelude::DataType,\n        result::{Error, Result},\n        translate::{translate_expr, translate_query},\n    },\n    aggregate::AggregateNode,\n    bigdecimal::BigDecimal,\n    function::FunctionNode,\n    in_list::InListNode,\n    numeric::NumericNode,\n    std::borrow::Cow,\n};\npub use {\n    case::case,\n    exists::{exists, not_exists},\n    nested::nested,\n    unary_op::{bitwise_not, factorial, minus, not, plus},\n};\n\n#[derive(Clone, Debug)]\npub enum ExprNode\u003c'a\u003e {\n    Expr(Cow\u003c'a, Expr\u003e),\n    SqlExpr(Cow\u003c'a, str\u003e),\n    Identifier(Cow\u003c'a, str\u003e),\n    Numeric(NumericNode\u003c'a\u003e),\n    QuotedString(Cow\u003c'a, str\u003e),\n    TypedString {\n        data_type: DataType,\n        value: Cow\u003c'a, str\u003e,\n    },\n    Between {\n        expr: Box\u003cExprNode\u003c'a\u003e\u003e,\n        negated: bool,\n        low: Box\u003cExprNode\u003c'a\u003e\u003e,\n        high: Box\u003cExprNode\u003c'a\u003e\u003e,\n    },\n    Like {\n        expr: Box\u003cExprNode\u003c'a\u003e\u003e,\n        negated: bool,\n        pattern: Box\u003cExprNode\u003c'a\u003e\u003e,\n    },\n    ILike {\n        expr: Box\u003cExprNode\u003c'a\u003e\u003e,\n        negated: bool,\n        pattern: Box\u003cExprNode\u003c'a\u003e\u003e,\n    },\n    BinaryOp {\n        left: Box\u003cExprNode\u003c'a\u003e\u003e,\n        op: BinaryOperator,\n        right: Box\u003cExprNode\u003c'a\u003e\u003e,\n    },\n    UnaryOp {\n        op: UnaryOperator,\n        expr: Box\u003cExprNode\u003c'a\u003e\u003e,\n    },\n    IsNull(Box\u003cExprNode\u003c'a\u003e\u003e),\n    IsNotNull(Box\u003cExprNode\u003c'a\u003e\u003e),\n    InList {\n        expr: Box\u003cExprNode\u003c'a\u003e\u003e,\n        list: Box\u003cInListNode\u003c'a\u003e\u003e,\n        negated: bool,\n    },\n    Nested(Box\u003cExprNode\u003c'a\u003e\u003e),\n    Function(Box\u003cFunctionNode\u003c'a\u003e\u003e),\n    Aggregate(Box\u003cAggregateNode\u003c'a\u003e\u003e),\n    Exists {\n        subquery: Box\u003cQueryNode\u003c'a\u003e\u003e,\n        negated: bool,\n    },\n    Subquery(Box\u003cQueryNode\u003c'a\u003e\u003e),\n    Case {\n        operand: Option\u003cBox\u003cExprNode\u003c'a\u003e\u003e\u003e,\n        when_then: Vec\u003c(ExprNode\u003c'a\u003e, ExprNode\u003c'a\u003e)\u003e,\n        else_result: Option\u003cBox\u003cExprNode\u003c'a\u003e\u003e\u003e,\n    },\n}\n\nimpl\u003c'a\u003e TryFrom\u003cExprNode\u003c'a\u003e\u003e for Expr {\n    type Error = Error;\n\n    fn try_from(expr_node: ExprNode\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        match expr_node {\n            ExprNode::Expr(expr) =\u003e Ok(expr.into_owned()),\n            ExprNode::SqlExpr(expr) =\u003e {\n                let expr = parse_expr(expr)?;\n\n                translate_expr(\u0026expr)\n            }\n            ExprNode::Identifier(value) =\u003e {\n                let idents = value.as_ref().split('.').collect::\u003cVec\u003c_\u003e\u003e();\n\n                Ok(match idents.as_slice() {\n                    [alias, ident] =\u003e Expr::CompoundIdentifier {\n                        alias: alias.to_string(),\n                        ident: ident.to_string(),\n                    },\n                    _ =\u003e Expr::Identifier(value.into_owned()),\n                })\n            }\n            ExprNode::Numeric(node) =\u003e node.try_into().map(Expr::Literal),\n            ExprNode::QuotedString(value) =\u003e {\n                let value = value.into_owned();\n\n                Ok(Expr::Literal(AstLiteral::QuotedString(value)))\n            }\n            ExprNode::TypedString { data_type, value } =\u003e Ok(Expr::TypedString {\n                data_type,\n                value: value.into_owned(),\n            }),\n            ExprNode::Between {\n                expr,\n                negated,\n                low,\n                high,\n            } =\u003e {\n                let expr = Expr::try_from(*expr).map(Box::new)?;\n                let low = Expr::try_from(*low).map(Box::new)?;\n                let high = Expr::try_from(*high).map(Box::new)?;\n\n                Ok(Expr::Between {\n                    expr,\n                    negated,\n                    low,\n                    high,\n                })\n            }\n            ExprNode::Like {\n                expr,\n                negated,\n                pattern,\n            } =\u003e {\n                let expr = Expr::try_from(*expr).map(Box::new)?;\n                let pattern = Expr::try_from(*pattern).map(Box::new)?;\n\n                Ok(Expr::Like {\n                    expr,\n                    negated,\n                    pattern,\n                })\n            }\n            ExprNode::ILike {\n                expr,\n                negated,\n                pattern,\n            } =\u003e {\n                let expr = Expr::try_from(*expr).map(Box::new)?;\n                let pattern = Expr::try_from(*pattern).map(Box::new)?;\n\n                Ok(Expr::ILike {\n                    expr,\n                    negated,\n                    pattern,\n                })\n            }\n            ExprNode::BinaryOp { left, op, right } =\u003e {\n                let left = Expr::try_from(*left).map(Box::new)?;\n                let right = Expr::try_from(*right).map(Box::new)?;\n\n                Ok(Expr::BinaryOp { left, op, right })\n            }\n            ExprNode::UnaryOp { op, expr } =\u003e {\n                let expr = Expr::try_from(*expr).map(Box::new)?;\n                Ok(Expr::UnaryOp { op, expr })\n            }\n            ExprNode::IsNull(expr) =\u003e Expr::try_from(*expr).map(Box::new).map(Expr::IsNull),\n            ExprNode::IsNotNull(expr) =\u003e Expr::try_from(*expr).map(Box::new).map(Expr::IsNotNull),\n            ExprNode::InList {\n                expr,\n                list,\n                negated,\n            } =\u003e {\n                let expr = Expr::try_from(*expr).map(Box::new)?;\n\n                match *list {\n                    InListNode::InList(list) =\u003e {\n                        let list = list\n                            .into_iter()\n                            .map(Expr::try_from)\n                            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n                        Ok(Expr::InList {\n                            expr,\n                            list,\n                            negated,\n                        })\n                    }\n                    InListNode::Query(subquery) =\u003e {\n                        let subquery = Query::try_from(*subquery).map(Box::new)?;\n                        Ok(Expr::InSubquery {\n                            expr,\n                            subquery,\n                            negated,\n                        })\n                    }\n                    InListNode::Text(value) =\u003e {\n                        let subquery = parse_query(value.clone())\n                            .and_then(|item| translate_query(\u0026item))\n                            .map(Box::new);\n\n                        if let Ok(subquery) = subquery {\n                            return Ok(Expr::InSubquery {\n                                expr,\n                                subquery,\n                                negated,\n                            });\n                        }\n\n                        parse_comma_separated_exprs(\u0026*value)?\n                            .iter()\n                            .map(translate_expr)\n                            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n                            .map(|list| Expr::InList {\n                                expr,\n                                list,\n                                negated,\n                            })\n                    }\n                }\n            }\n            ExprNode::Nested(expr) =\u003e Expr::try_from(*expr).map(Box::new).map(Expr::Nested),\n            ExprNode::Function(func_expr) =\u003e Function::try_from(*func_expr)\n                .map(Box::new)\n                .map(Expr::Function),\n            ExprNode::Aggregate(aggr_expr) =\u003e Aggregate::try_from(*aggr_expr)\n                .map(Box::new)\n                .map(Expr::Aggregate),\n            ExprNode::Exists { subquery, negated } =\u003e Query::try_from(*subquery)\n                .map(Box::new)\n                .map(|subquery| Expr::Exists { subquery, negated }),\n            ExprNode::Subquery(subquery) =\u003e {\n                Query::try_from(*subquery).map(Box::new).map(Expr::Subquery)\n            }\n            ExprNode::Case {\n                operand,\n                when_then,\n                else_result,\n            } =\u003e {\n                let operand = operand\n                    .map(|expr| Expr::try_from(*expr))\n                    .transpose()?\n                    .map(Box::new);\n                let when_then = when_then\n                    .into_iter()\n                    .map(|(when, then)| {\n                        let when = Expr::try_from(when)?;\n                        let then = Expr::try_from(then)?;\n                        Ok((when, then))\n                    })\n                    .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n                let else_result = else_result\n                    .map(|expr| Expr::try_from(*expr))\n                    .transpose()?\n                    .map(Box::new);\n                Ok(Expr::Case {\n                    operand,\n                    when_then,\n                    else_result,\n                })\n            }\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003c\u0026'a str\u003e for ExprNode\u003c'a\u003e {\n    fn from(expr: \u0026'a str) -\u003e Self {\n        ExprNode::SqlExpr(Cow::Borrowed(expr))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cString\u003e for ExprNode\u003c'a\u003e {\n    fn from(expr: String) -\u003e Self {\n        ExprNode::SqlExpr(Cow::Owned(expr))\n    }\n}\n\nimpl\u003c'a\u003e From\u003ci64\u003e for ExprNode\u003c'a\u003e {\n    fn from(n: i64) -\u003e Self {\n        ExprNode::Expr(Cow::Owned(Expr::Literal(AstLiteral::Number(\n            BigDecimal::from(n),\n        ))))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cbool\u003e for ExprNode\u003c'a\u003e {\n    fn from(b: bool) -\u003e Self {\n        ExprNode::Expr(Cow::Owned(Expr::Literal(AstLiteral::Boolean(b))))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cQueryNode\u003c'a\u003e\u003e for ExprNode\u003c'a\u003e {\n    fn from(node: QueryNode\u003c'a\u003e) -\u003e Self {\n        ExprNode::Subquery(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cExpr\u003e for ExprNode\u003c'a\u003e {\n    fn from(expr: Expr) -\u003e Self {\n        ExprNode::Expr(Cow::Owned(expr))\n    }\n}\n\nimpl\u003c'a\u003e From\u003c\u0026'a Expr\u003e for ExprNode\u003c'a\u003e {\n    fn from(expr: \u0026'a Expr) -\u003e Self {\n        ExprNode::Expr(Cow::Borrowed(expr))\n    }\n}\n\npub fn expr\u003c'a, T: Into\u003cCow\u003c'a, str\u003e\u003e\u003e(value: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::SqlExpr(value.into())\n}\n\npub fn col\u003c'a, T: Into\u003cCow\u003c'a, str\u003e\u003e\u003e(value: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Identifier(value.into())\n}\n\npub fn num\u003c'a, T: Into\u003cNumericNode\u003c'a\u003e\u003e\u003e(value: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Numeric(value.into())\n}\n\npub fn text\u003c'a, T: Into\u003cCow\u003c'a, str\u003e\u003e\u003e(value: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::QuotedString(value.into())\n}\n\npub fn date\u003c'a, T: Into\u003cCow\u003c'a, str\u003e\u003e\u003e(date: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::TypedString {\n        data_type: DataType::Date,\n        value: date.into(),\n    }\n}\n\npub fn timestamp\u003c'a, T: Into\u003cCow\u003c'a, str\u003e\u003e\u003e(timestamp: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::TypedString {\n        data_type: DataType::Timestamp,\n        value: timestamp.into(),\n    }\n}\n\npub fn time\u003c'a, T: Into\u003cCow\u003c'a, str\u003e\u003e\u003e(time: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::TypedString {\n        data_type: DataType::Time,\n        value: time.into(),\n    }\n}\n\npub fn uuid\u003c'a, T: Into\u003cCow\u003c'a, str\u003e\u003e\u003e(uuid: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::TypedString {\n        data_type: DataType::Uuid,\n        value: uuid.into(),\n    }\n}\n\n/// Returns an AST ExprNode containing the provided Bytea.\n///\n/// # Arguments\n/// * `bytea` - A byte array to be converted to a Bytea AST node.\n///\npub fn bytea\u003c'a, T: AsRef\u003c[u8]\u003e\u003e(bytea: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::TypedString {\n        data_type: DataType::Bytea,\n        value: hex::encode(bytea).into(),\n    }\n}\n\npub fn subquery\u003c'a, T: Into\u003cQueryNode\u003c'a\u003e\u003e\u003e(query_node: T) -\u003e ExprNode\u003c'a\u003e {\n    ExprNode::Subquery(Box::new(query_node.into()))\n}\n\npub fn null() -\u003e ExprNode\u003c'static\u003e {\n    ExprNode::Expr(Cow::Owned(Expr::Literal(AstLiteral::Null)))\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::ExprNode,\n        crate::{\n            ast::Expr,\n            ast_builder::{\n                QueryNode, bytea, col, date, expr, null, num, subquery, table, test_expr, text,\n                time, timestamp, uuid,\n            },\n        },\n    };\n\n    #[test]\n    fn into_expr_node() {\n        let actual: ExprNode = \"id IS NOT NULL\".into();\n        let expected = \"id IS NOT NULL\";\n        test_expr(actual, expected);\n\n        let actual: ExprNode = String::from(\"1 + 10)\").into();\n        let expected = \"1 + 10\";\n        test_expr(actual, expected);\n\n        let actual: ExprNode = 1024.into();\n        let expected = \"1024\";\n        test_expr(actual, expected);\n\n        let actual: ExprNode = true.into();\n        let expected = \"True\";\n        test_expr(actual, expected);\n\n        let actual: ExprNode = QueryNode::from(table(\"Foo\").select().project(\"id\")).into();\n        let expected = \"(SELECT id FROM Foo)\";\n        test_expr(actual, expected);\n\n        let expr = Expr::Identifier(\"id\".to_owned());\n        let actual: ExprNode = (\u0026expr).into();\n        let expected = \"id\";\n        test_expr(actual, expected);\n\n        let actual: ExprNode = expr.into();\n        test_expr(actual, expected);\n    }\n\n    #[test]\n    fn syntactic_sugar() {\n        let actual = expr(\"col1 \u003e 10\");\n        let expected = \"col1 \u003e 10\";\n        test_expr(actual, expected);\n\n        let actual = col(\"id\");\n        let expected = \"id\";\n        test_expr(actual, expected);\n\n        let actual = col(\"Foo.id\");\n        let expected = \"Foo.id\";\n        test_expr(actual, expected);\n\n        let actual = num(2048);\n        let expected = \"2048\";\n        test_expr(actual, expected);\n\n        let actual = num(6.5);\n        let expected = \"6.5\";\n        test_expr(actual, expected);\n\n        let actual = num(\"123.456\");\n        let expected = \"123.456\";\n        test_expr(actual, expected);\n\n        let actual = text(\"hello world\");\n        let expected = \"'hello world'\";\n        test_expr(actual, expected);\n\n        let actual = date(\"2022-10-11\");\n        let expected = \"DATE '2022-10-11'\";\n        test_expr(actual, expected);\n\n        let actual = timestamp(\"2022-10-11 13:34:49\");\n        let expected = \"TIMESTAMP '2022-10-11 13:34:49'\";\n        test_expr(actual, expected);\n\n        let actual = time(\"15:00:07\");\n        let expected = \"TIME '15:00:07'\";\n        test_expr(actual, expected);\n\n        let actual = uuid(\"936DA01F9ABD4d9d80C702AF85C822A8\");\n        let expected = \"UUID '936DA01F9ABD4d9d80C702AF85C822A8'\";\n        test_expr(actual, expected);\n\n        let actual = bytea(b\"hello world\");\n        let expected = \"BYTEA '68656c6c6f20776f726c64'\";\n        test_expr(actual, expected);\n\n        let actual = subquery(table(\"Foo\").select().filter(\"id IS NOT NULL\"));\n        let expected = \"(SELECT * FROM Foo WHERE id IS NOT NULL)\";\n        test_expr(actual, expected);\n\n        let actual = null();\n        let expected = \"NULL\";\n        test_expr(actual, expected);\n    }\n}\n","traces":[{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":169},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr_list.rs"],"content":"use {\n    super::ExprNode,\n    crate::{\n        ast::Expr,\n        parse_sql::parse_comma_separated_exprs,\n        result::{Error, Result},\n        translate::translate_expr,\n    },\n    std::borrow::Cow,\n};\n\n#[derive(Clone, Debug)]\npub enum ExprList\u003c'a\u003e {\n    Text(Cow\u003c'a, str\u003e),\n    Exprs(Cow\u003c'a, [ExprNode\u003c'a\u003e]\u003e),\n}\n\nimpl\u003c'a\u003e From\u003c\u0026'a str\u003e for ExprList\u003c'a\u003e {\n    fn from(exprs: \u0026'a str) -\u003e Self {\n        ExprList::Text(Cow::Borrowed(exprs))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cString\u003e for ExprList\u003c'a\u003e {\n    fn from(exprs: String) -\u003e Self {\n        ExprList::Text(Cow::from(exprs))\n    }\n}\n\nimpl\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e From\u003cVec\u003cT\u003e\u003e for ExprList\u003c'a\u003e {\n    fn from(exprs: Vec\u003cT\u003e) -\u003e Self {\n        ExprList::Exprs(Cow::Owned(exprs.into_iter().map(Into::into).collect()))\n    }\n}\n\nimpl\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e + Copy\u003e From\u003c\u0026'a Vec\u003cT\u003e\u003e for ExprList\u003c'a\u003e {\n    fn from(exprs: \u0026'a Vec\u003cT\u003e) -\u003e Self {\n        exprs.as_slice().into()\n    }\n}\n\nimpl\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e + Copy\u003e From\u003c\u0026'a [T]\u003e for ExprList\u003c'a\u003e {\n    fn from(exprs: \u0026'a [T]) -\u003e Self {\n        ExprList::Exprs(Cow::Owned(exprs.iter().map(|\u0026v| v.into()).collect()))\n    }\n}\n\nimpl\u003c'a\u003e From\u003c\u0026'a [ExprNode\u003c'a\u003e]\u003e for ExprList\u003c'a\u003e {\n    fn from(exprs: \u0026'a [ExprNode\u003c'a\u003e]) -\u003e Self {\n        ExprList::Exprs(Cow::Borrowed(exprs))\n    }\n}\n\nimpl\u003c'a\u003e TryFrom\u003cExprList\u003c'a\u003e\u003e for Vec\u003cExpr\u003e {\n    type Error = Error;\n\n    fn try_from(expr_list: ExprList\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        match expr_list {\n            ExprList::Text(exprs) =\u003e parse_comma_separated_exprs(exprs)?\n                .iter()\n                .map(translate_expr)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e(),\n            ExprList::Exprs(exprs) =\u003e {\n                let exprs = exprs.into_owned();\n\n                exprs\n                    .into_iter()\n                    .map(TryInto::try_into)\n                    .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::ExprList,\n        crate::{\n            ast::Expr, ast_builder::col, parse_sql::parse_comma_separated_exprs, result::Result,\n            translate::translate_expr,\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    fn test(actual: ExprList, expected: \u0026str) {\n        let parsed = parse_comma_separated_exprs(expected).expect(expected);\n        let expected = parsed\n            .iter()\n            .map(translate_expr)\n            .collect::\u003cResult\u003cVec\u003cExpr\u003e\u003e\u003e();\n\n        assert_eq!(actual.try_into(), expected);\n    }\n\n    #[test]\n    fn into_expr_list() {\n        let actual: ExprList = \"1, a * 2, b\".into();\n        let expected = \"1, a * 2, b\";\n        test(actual, expected);\n\n        let actual: ExprList = String::from(\"'hello' || 'world', col1\").into();\n        let expected = \"'hello' || 'world', col1\";\n        test(actual, expected);\n\n        // Vec\u003cInto\u003cExprNode\u003e\u003e\n        let actual: ExprList = vec![\"id\", \"name\"].into();\n        let expected = \"id, name\";\n        test(actual, expected);\n\n        // Vec\u003cExprNode\u003e\n        let actual: ExprList = vec![col(\"id\"), col(\"name\")].into();\n        let expected = \"id, name\";\n        test(actual, expected);\n\n        // \u0026Vec\u003cExprNode\u003e\n        let actual = vec![\"id\", \"name\"];\n        let actual: ExprList = (\u0026actual).into();\n        let expected = \"id, name\";\n        test(actual, expected);\n\n        // \u0026[Into\u003cExprNode\u003e]\n        let actual = vec![\"rate / 10\", \"col1\"];\n        let actual: ExprList = actual.as_slice().into();\n        let expected = \"rate / 10, col1\";\n        test(actual, expected);\n\n        // \u0026[ExprNode]\n        let actual = vec![col(\"id\"), col(\"name\")];\n        let actual: ExprList = actual.as_slice().into();\n        let expected = \"id, name\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","expr_with_alias.rs"],"content":"use crate::{\n    ast::Expr,\n    ast_builder::ExprNode,\n    result::{Error, Result},\n};\n\n#[derive(Clone, Debug)]\npub struct ExprWithAliasNode\u003c'a\u003e {\n    pub expr: ExprNode\u003c'a\u003e,\n    pub alias: String,\n}\n\nimpl\u003c'a\u003e TryFrom\u003cExprWithAliasNode\u003c'a\u003e\u003e for (Expr, String) {\n    type Error = Error;\n\n    fn try_from(node: ExprWithAliasNode\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        Ok((Expr::try_from(node.expr)?, node.alias))\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","index.rs"],"content":"use {\n    super::{Build, OrderByExprNode},\n    crate::{ast::Statement, result::Result},\n};\n\n#[derive(Clone, Debug)]\npub struct CreateIndexNode\u003c'a\u003e {\n    name: String,\n    table_name: String,\n    column: OrderByExprNode\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e CreateIndexNode\u003c'a\u003e {\n    pub fn new(table_name: String, name: String, column: OrderByExprNode\u003c'a\u003e) -\u003e Self {\n        Self {\n            table_name,\n            name,\n            column,\n        }\n    }\n}\n\nimpl\u003c'a\u003e Build for CreateIndexNode\u003c'a\u003e {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let table_name = self.table_name;\n        let name = self.name;\n        let column = self.column.try_into()?;\n\n        Ok(Statement::CreateIndex {\n            name,\n            table_name,\n            column,\n        })\n    }\n}\n\n#[derive(Clone)]\npub struct DropIndexNode {\n    name: String,\n    table_name: String,\n}\n\nimpl DropIndexNode {\n    pub fn new(table_name: String, name: String) -\u003e Self {\n        Self { table_name, name }\n    }\n}\n\nimpl Build for DropIndexNode {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let table_name = self.table_name;\n        let name = self.name;\n\n        Ok(Statement::DropIndex { name, table_name })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{Build, table, test};\n\n    #[test]\n    fn create_index() {\n        let actual = table(\"Foo\").create_index(\"nameIndex\", \"name asc\").build();\n        let expected = \"CREATE INDEX nameIndex ON Foo (name Asc)\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\").create_index(\"nameIndex\", \"name desc\").build();\n        let expected = \"CREATE INDEX nameIndex ON Foo (name Desc)\";\n        test(actual, expected);\n    }\n\n    #[test]\n    fn drop_index() {\n        let actual = table(\"Foo\").drop_index(\"nameIndex\").build();\n        let expected = \"DROP INDEX Foo.nameIndex\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","index_item","cmp_expr.rs"],"content":"use {\n    super::IndexItemNode,\n    crate::{ast::IndexOperator, ast_builder::ExprNode},\n};\n\n#[derive(Clone, Debug)]\npub struct CmpExprNode\u003c'a\u003e {\n    pub index_name: String,\n    pub operator: IndexOperator,\n    pub expr: ExprNode\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e CmpExprNode\u003c'a\u003e {\n    pub fn new\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n        index_name: String,\n        operator: IndexOperator,\n        expr: T,\n    ) -\u003e Self {\n        Self {\n            index_name,\n            operator,\n            expr: expr.into(),\n        }\n    }\n\n    pub fn asc(self) -\u003e IndexItemNode\u003c'a\u003e {\n        IndexItemNode::NonClustered {\n            name: self.index_name,\n            asc: Some(true),\n            cmp_expr: Some((self.operator, self.expr)),\n        }\n    }\n\n    pub fn desc(self) -\u003e IndexItemNode\u003c'a\u003e {\n        IndexItemNode::NonClustered {\n            name: self.index_name,\n            asc: Some(false),\n            cmp_expr: Some((self.operator, self.expr)),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use crate::{\n        ast::{AstLiteral, Expr, IndexOperator},\n        ast_builder::{\n            IndexItemNode,\n            index_item::{IndexItem, non_clustered},\n            select::Prebuild,\n        },\n    };\n\n    #[test]\n    fn test() {\n        let actual = non_clustered(\"idx\".to_owned())\n            .eq(\"1\")\n            .asc()\n            .prebuild()\n            .unwrap();\n        let expected = IndexItem::NonClustered {\n            name: \"idx\".to_owned(),\n            asc: Some(true),\n            cmp_expr: Some((\n                IndexOperator::Eq,\n                Expr::Literal(AstLiteral::Number(1.into())),\n            )),\n        };\n        assert_eq!(actual, expected);\n\n        let actual = non_clustered(\"idx\".to_owned())\n            .eq(\"2\")\n            .desc()\n            .prebuild()\n            .unwrap();\n        let expected = IndexItem::NonClustered {\n            name: \"idx\".to_owned(),\n            asc: Some(false),\n            cmp_expr: Some((\n                IndexOperator::Eq,\n                Expr::Literal(AstLiteral::Number(2.into())),\n            )),\n        };\n        assert_eq!(actual, expected);\n\n        let index_item: IndexItemNode = non_clustered(\"idx\".to_owned()).eq(\"3\").into();\n        let actual = index_item.prebuild().unwrap();\n        let expected = IndexItem::NonClustered {\n            name: \"idx\".to_owned(),\n            asc: None,\n            cmp_expr: Some((\n                IndexOperator::Eq,\n                Expr::Literal(AstLiteral::Number(3.into())),\n            )),\n        };\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","index_item","non_clustered.rs"],"content":"use {\n    super::CmpExprNode,\n    crate::{ast::IndexOperator, ast_builder::ExprNode},\n};\n\n#[derive(Clone, Debug)]\npub struct NonClusteredNode {\n    pub index_name: String,\n}\n\nimpl\u003c'a\u003e NonClusteredNode {\n    pub fn gt\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e CmpExprNode\u003c'a\u003e {\n        CmpExprNode::new(self.index_name, IndexOperator::Gt, expr.into())\n    }\n\n    pub fn lt\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e CmpExprNode\u003c'a\u003e {\n        CmpExprNode::new(self.index_name, IndexOperator::Lt, expr.into())\n    }\n\n    pub fn gte\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e CmpExprNode\u003c'a\u003e {\n        CmpExprNode::new(self.index_name, IndexOperator::GtEq, expr.into())\n    }\n\n    pub fn lte\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e CmpExprNode\u003c'a\u003e {\n        CmpExprNode::new(self.index_name, IndexOperator::LtEq, expr.into())\n    }\n\n    pub fn eq\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e CmpExprNode\u003c'a\u003e {\n        CmpExprNode::new(self.index_name, IndexOperator::Eq, expr.into())\n    }\n}\n\npub fn non_clustered(index_name: String) -\u003e NonClusteredNode {\n    NonClusteredNode { index_name }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::{AstLiteral, Expr, IndexOperator},\n        ast_builder::{\n            IndexItemNode,\n            index_item::{IndexItem, non_clustered},\n            select::Prebuild,\n        },\n    };\n\n    #[test]\n    fn test() {\n        let index_node: IndexItemNode = non_clustered(\"idx\".to_owned()).gt(\"1\").into();\n        let actual = index_node.prebuild().unwrap();\n        let expected = IndexItem::NonClustered {\n            name: \"idx\".to_owned(),\n            asc: None,\n            cmp_expr: Some((\n                IndexOperator::Gt,\n                Expr::Literal(AstLiteral::Number(1.into())),\n            )),\n        };\n        assert_eq!(actual, expected);\n\n        let index_node: IndexItemNode = non_clustered(\"idx\".to_owned()).lt(\"1\").into();\n        let actual = index_node.prebuild().unwrap();\n        let expected = IndexItem::NonClustered {\n            name: \"idx\".to_owned(),\n            asc: None,\n            cmp_expr: Some((\n                IndexOperator::Lt,\n                Expr::Literal(AstLiteral::Number(1.into())),\n            )),\n        };\n        assert_eq!(actual, expected);\n\n        let index_node: IndexItemNode = non_clustered(\"idx\".to_owned()).gte(\"1\").into();\n        let actual = index_node.prebuild().unwrap();\n        let expected = IndexItem::NonClustered {\n            name: \"idx\".to_owned(),\n            asc: None,\n            cmp_expr: Some((\n                IndexOperator::GtEq,\n                Expr::Literal(AstLiteral::Number(1.into())),\n            )),\n        };\n        assert_eq!(actual, expected);\n\n        let index_node: IndexItemNode = non_clustered(\"idx\".to_owned()).lte(\"1\").into();\n        let actual = index_node.prebuild().unwrap();\n        let expected = IndexItem::NonClustered {\n            name: \"idx\".to_owned(),\n            asc: None,\n            cmp_expr: Some((\n                IndexOperator::LtEq,\n                Expr::Literal(AstLiteral::Number(1.into())),\n            )),\n        };\n        assert_eq!(actual, expected);\n\n        let index_node: IndexItemNode = non_clustered(\"idx\".to_owned()).eq(\"1\").into();\n        let actual = index_node.prebuild().unwrap();\n        let expected = IndexItem::NonClustered {\n            name: \"idx\".to_owned(),\n            asc: None,\n            cmp_expr: Some((\n                IndexOperator::Eq,\n                Expr::Literal(AstLiteral::Number(1.into())),\n            )),\n        };\n        assert_eq!(actual, expected);\n\n        let index_node: IndexItemNode = non_clustered(\"idx\".to_owned()).into();\n        let actual = index_node.prebuild().unwrap();\n        let expected = IndexItem::NonClustered {\n            name: \"idx\".to_owned(),\n            asc: None,\n            cmp_expr: None,\n        };\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","index_item","primary_key.rs"],"content":"use {super::IndexItemNode, crate::ast_builder::ExprNode};\n\n#[derive(Clone, Debug)]\npub struct PrimaryKeyNode;\n\nimpl\u003c'a\u003e PrimaryKeyNode {\n    pub fn eq\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e IndexItemNode\u003c'a\u003e {\n        IndexItemNode::PrimaryKey(expr.into())\n    }\n}\n\n/// Entry point function to Primary Key\npub fn primary_key() -\u003e PrimaryKeyNode {\n    PrimaryKeyNode\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::{AstLiteral, Expr},\n        ast_builder::{index_item::IndexItem, primary_key, select::Prebuild},\n    };\n\n    #[test]\n    fn test() {\n        let actual = primary_key().eq(\"1\").prebuild().unwrap();\n        let expected = IndexItem::PrimaryKey(Expr::Literal(AstLiteral::Number(1.into())));\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","index_item.rs"],"content":"mod cmp_expr;\nmod non_clustered;\nmod primary_key;\n\nuse {\n    super::{ExprNode, select::Prebuild},\n    crate::ast::{Expr, IndexOperator},\n};\npub use {\n    crate::{ast::IndexItem, result::Result},\n    cmp_expr::CmpExprNode,\n    non_clustered::{NonClusteredNode, non_clustered},\n    primary_key::{PrimaryKeyNode, primary_key},\n};\n\n#[derive(Clone, Debug)]\npub enum IndexItemNode\u003c'a\u003e {\n    NonClustered {\n        name: String,\n        asc: Option\u003cbool\u003e,\n        cmp_expr: Option\u003c(IndexOperator, ExprNode\u003c'a\u003e)\u003e,\n    },\n    PrimaryKey(ExprNode\u003c'a\u003e),\n}\n\nimpl\u003c'a\u003e From\u003cCmpExprNode\u003c'a\u003e\u003e for IndexItemNode\u003c'a\u003e {\n    fn from(cmp_expr: CmpExprNode\u003c'a\u003e) -\u003e Self {\n        IndexItemNode::NonClustered {\n            name: cmp_expr.index_name,\n            asc: None,\n            cmp_expr: Some((cmp_expr.operator, cmp_expr.expr)),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cNonClusteredNode\u003e for IndexItemNode\u003c'a\u003e {\n    fn from(non_clustered: NonClusteredNode) -\u003e Self {\n        IndexItemNode::NonClustered {\n            name: non_clustered.index_name,\n            asc: None,\n            cmp_expr: None,\n        }\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cIndexItem\u003e for IndexItemNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cIndexItem\u003e {\n        match self {\n            IndexItemNode::NonClustered {\n                name,\n                asc,\n                cmp_expr,\n            } =\u003e {\n                let (index_operator, expr) = cmp_expr.unzip();\n                let expr_result: Option\u003cExpr\u003e = expr.map(ExprNode::try_into).transpose()?;\n                let cmp_expr_result: Option\u003c(IndexOperator, Expr)\u003e =\n                    index_operator.zip(expr_result);\n\n                Ok(IndexItem::NonClustered {\n                    name,\n                    asc,\n                    cmp_expr: cmp_expr_result,\n                })\n            }\n            IndexItemNode::PrimaryKey(expr) =\u003e Ok(IndexItem::PrimaryKey(expr.try_into()?)),\n        }\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","insert.rs"],"content":"use {\n    super::{Build, ColumnList, ExprList, QueryNode},\n    crate::{ast::Statement, result::Result},\n};\n\n#[derive(Clone, Debug)]\npub struct InsertNode {\n    table_name: String,\n    columns: Option\u003cColumnList\u003e,\n}\n\nimpl InsertNode {\n    pub fn new(table_name: String) -\u003e Self {\n        Self {\n            table_name,\n            columns: None,\n        }\n    }\n\n    pub fn columns\u003cT: Into\u003cColumnList\u003e\u003e(mut self, columns: T) -\u003e Self {\n        self.columns = Some(columns.into());\n        self\n    }\n\n    pub fn values\u003c'a, T: Into\u003cExprList\u003c'a\u003e\u003e\u003e(self, values: Vec\u003cT\u003e) -\u003e InsertSourceNode\u003c'a\u003e {\n        let values: Vec\u003cExprList\u003e = values.into_iter().map(Into::into).collect();\n\n        InsertSourceNode {\n            insert_node: self,\n            source: QueryNode::Values(values),\n        }\n    }\n\n    pub fn as_select\u003c'a, T: Into\u003cQueryNode\u003c'a\u003e\u003e\u003e(self, query: T) -\u003e InsertSourceNode\u003c'a\u003e {\n        InsertSourceNode {\n            insert_node: self,\n            source: query.into(),\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct InsertSourceNode\u003c'a\u003e {\n    insert_node: InsertNode,\n    source: QueryNode\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e Build for InsertSourceNode\u003c'a\u003e {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let table_name = self.insert_node.table_name;\n        let columns = self.insert_node.columns;\n        let columns = columns.map_or_else(|| Ok(vec![]), |v| v.try_into())?;\n        let source = self.source.try_into()?;\n\n        Ok(Statement::Insert {\n            table_name,\n            columns,\n            source,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{Build, num, table, test};\n\n    #[test]\n    fn insert() {\n        let actual = table(\"Foo\").insert().values(vec![\"1, 5\", \"2, 3\"]).build();\n        let expected = r#\"INSERT INTO Foo VALUES (1, 5), (2, 3)\"#;\n        test(actual, expected);\n\n        let actual = table(\"Foo\")\n            .insert()\n            .columns(\"id, name\")\n            .values(vec![vec![num(1), num(5)], vec![num(2), num(3)]])\n            .build();\n        let expected = r#\"INSERT INTO Foo (id, name) VALUES (1, 5), (2, 3)\"#;\n        test(actual, expected);\n\n        let actual = table(\"Foo\")\n            .insert()\n            .columns(vec![\"hi\"])\n            .values(vec![vec![num(7)]])\n            .build();\n        let expected = r#\"INSERT INTO Foo (hi) VALUES (7)\"#;\n        test(actual, expected);\n\n        let actual = table(\"Foo\")\n            .insert()\n            .as_select(table(\"Bar\").select().project(\"id, name\").limit(10))\n            .build();\n        let expected = r#\"INSERT INTO Foo SELECT id, name FROM Bar LIMIT 10\"#;\n        test(actual, expected);\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","order_by_expr.rs"],"content":"use {\n    super::ExprNode,\n    crate::{\n        ast::{Expr, OrderByExpr},\n        parse_sql::parse_order_by_expr,\n        result::{Error, Result},\n        translate::translate_order_by_expr,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum OrderByExprNode\u003c'a\u003e {\n    Text(String),\n    Expr(ExprNode\u003c'a\u003e),\n}\n\nimpl\u003c'a\u003e From\u003c\u0026str\u003e for OrderByExprNode\u003c'a\u003e {\n    fn from(expr: \u0026str) -\u003e Self {\n        Self::Text(expr.to_owned())\n    }\n}\n\nimpl\u003c'a\u003e From\u003cExprNode\u003c'a\u003e\u003e for OrderByExprNode\u003c'a\u003e {\n    fn from(expr_node: ExprNode\u003c'a\u003e) -\u003e Self {\n        Self::Expr(expr_node)\n    }\n}\n\nimpl\u003c'a\u003e TryFrom\u003cOrderByExprNode\u003c'a\u003e\u003e for OrderByExpr {\n    type Error = Error;\n\n    fn try_from(node: OrderByExprNode\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        match node {\n            OrderByExprNode::Text(expr) =\u003e {\n                let expr = parse_order_by_expr(expr).and_then(|op| translate_order_by_expr(\u0026op))?;\n                Ok(expr)\n            }\n            OrderByExprNode::Expr(expr_node) =\u003e {\n                let expr = Expr::try_from(expr_node)?;\n\n                Ok(OrderByExpr { expr, asc: None })\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast_builder::OrderByExprNode, parse_sql::parse_order_by_expr,\n            translate::translate_order_by_expr,\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    fn test(actual: OrderByExprNode, expected: \u0026str) {\n        let parsed = \u0026parse_order_by_expr(expected).expect(expected);\n        let expected = translate_order_by_expr(parsed);\n        assert_eq!(actual.try_into(), expected);\n    }\n\n    #[test]\n    fn order_by_expr() {\n        let actual = OrderByExprNode::Text(\"foo\".into());\n        let expected = \"foo\";\n        test(actual, expected);\n\n        let actual = OrderByExprNode::Text(\"foo asc\".into());\n        let expected = \"foo ASC\";\n        test(actual, expected);\n\n        let actual = OrderByExprNode::Text(\"foo desc\".into());\n        let expected = \"foo DESC\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","order_by_expr_list.rs"],"content":"use {\n    super::{ExprNode, OrderByExprNode},\n    crate::{\n        ast::OrderByExpr,\n        parse_sql::parse_order_by_exprs,\n        result::{Error, Result},\n        translate::translate_order_by_expr,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum OrderByExprList\u003c'a\u003e {\n    Text(String),\n    OrderByExprs(Vec\u003cOrderByExprNode\u003c'a\u003e\u003e),\n}\n\nimpl\u003c'a\u003e From\u003c\u0026str\u003e for OrderByExprList\u003c'a\u003e {\n    fn from(exprs: \u0026str) -\u003e Self {\n        OrderByExprList::Text(exprs.to_owned())\n    }\n}\n\nimpl\u003c'a\u003e From\u003cVec\u003c\u0026str\u003e\u003e for OrderByExprList\u003c'a\u003e {\n    fn from(exprs: Vec\u003c\u0026str\u003e) -\u003e Self {\n        OrderByExprList::OrderByExprs(exprs.into_iter().map(Into::into).collect())\n    }\n}\n\nimpl\u003c'a\u003e From\u003cExprNode\u003c'a\u003e\u003e for OrderByExprList\u003c'a\u003e {\n    fn from(expr_node: ExprNode\u003c'a\u003e) -\u003e Self {\n        OrderByExprList::OrderByExprs(vec![expr_node.into()])\n    }\n}\n\nimpl\u003c'a\u003e TryFrom\u003cOrderByExprList\u003c'a\u003e\u003e for Vec\u003cOrderByExpr\u003e {\n    type Error = Error;\n\n    fn try_from(order_by_exprs: OrderByExprList\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        match order_by_exprs {\n            OrderByExprList::Text(exprs) =\u003e parse_order_by_exprs(exprs)?\n                .iter()\n                .map(translate_order_by_expr)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e(),\n            OrderByExprList::OrderByExprs(exprs) =\u003e exprs\n                .into_iter()\n                .map(TryInto::try_into)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e(),\n        }\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","query.rs"],"content":"use {\n    super::{\n        ExprList, FilterNode, GroupByNode, HashJoinNode, HavingNode, JoinConstraintNode, JoinNode,\n        LimitNode, OffsetLimitNode, OffsetNode, OrderByNode, ProjectNode, SelectNode,\n        TableFactorNode,\n        select::{Prebuild, ValuesNode},\n        table_factor::TableType,\n    },\n    crate::{\n        ast::{Expr, Query, SetExpr, Values},\n        parse_sql::parse_query,\n        result::{Error, Result},\n        translate::translate_query,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum QueryNode\u003c'a\u003e {\n    Text(String),\n    Values(Vec\u003cExprList\u003c'a\u003e\u003e),\n    SelectNode(SelectNode\u003c'a\u003e),\n    ValuesNode(ValuesNode\u003c'a\u003e),\n    JoinNode(JoinNode\u003c'a\u003e),\n    JoinConstraintNode(JoinConstraintNode\u003c'a\u003e),\n    HashJoinNode(HashJoinNode\u003c'a\u003e),\n    GroupByNode(GroupByNode\u003c'a\u003e),\n    HavingNode(HavingNode\u003c'a\u003e),\n    LimitNode(LimitNode\u003c'a\u003e),\n    OffsetNode(OffsetNode\u003c'a\u003e),\n    OffsetLimitNode(OffsetLimitNode\u003c'a\u003e),\n    FilterNode(FilterNode\u003c'a\u003e),\n    ProjectNode(ProjectNode\u003c'a\u003e),\n    OrderByNode(OrderByNode\u003c'a\u003e),\n}\n\nimpl\u003c'a\u003e QueryNode\u003c'a\u003e {\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        TableFactorNode {\n            table_name: table_alias.to_owned(),\n            table_type: TableType::Derived {\n                subquery: Box::new(self),\n                alias: table_alias.to_owned(),\n            },\n            table_alias: None,\n            index: None,\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003c\u0026str\u003e for QueryNode\u003c'a\u003e {\n    fn from(query: \u0026str) -\u003e Self {\n        Self::Text(query.to_owned())\n    }\n}\n\nimpl\u003c'a\u003e From\u003cSelectNode\u003c'a\u003e\u003e for QueryNode\u003c'a\u003e {\n    fn from(node: SelectNode\u003c'a\u003e) -\u003e Self {\n        QueryNode::SelectNode(node)\n    }\n}\n\nmacro_rules! impl_from_select_nodes {\n    ($type: ident) =\u003e {\n        impl\u003c'a\u003e From\u003c$type\u003c'a\u003e\u003e for QueryNode\u003c'a\u003e {\n            fn from(node: $type\u003c'a\u003e) -\u003e Self {\n                QueryNode::$type(node)\n            }\n        }\n    };\n}\n\nimpl_from_select_nodes!(JoinNode);\nimpl_from_select_nodes!(JoinConstraintNode);\nimpl_from_select_nodes!(HashJoinNode);\nimpl_from_select_nodes!(GroupByNode);\nimpl_from_select_nodes!(HavingNode);\nimpl_from_select_nodes!(FilterNode);\nimpl_from_select_nodes!(LimitNode);\nimpl_from_select_nodes!(OffsetNode);\nimpl_from_select_nodes!(OffsetLimitNode);\nimpl_from_select_nodes!(ProjectNode);\nimpl_from_select_nodes!(OrderByNode);\n\nimpl\u003c'a\u003e TryFrom\u003cQueryNode\u003c'a\u003e\u003e for Query {\n    type Error = Error;\n\n    fn try_from(query_node: QueryNode\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        match query_node {\n            QueryNode::Text(query_node) =\u003e {\n                parse_query(query_node).and_then(|item| translate_query(\u0026item))\n            }\n            QueryNode::Values(values) =\u003e {\n                let values: Vec\u003cVec\u003cExpr\u003e\u003e = values\n                    .into_iter()\n                    .map(TryInto::try_into)\n                    .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n                Ok(Query {\n                    body: SetExpr::Values(Values(values)),\n                    order_by: Vec::new(),\n                    limit: None,\n                    offset: None,\n                })\n            }\n            QueryNode::SelectNode(node) =\u003e node.prebuild(),\n            QueryNode::ValuesNode(node) =\u003e node.prebuild(),\n            QueryNode::JoinNode(node) =\u003e node.prebuild(),\n            QueryNode::JoinConstraintNode(node) =\u003e node.prebuild(),\n            QueryNode::HashJoinNode(node) =\u003e node.prebuild(),\n            QueryNode::GroupByNode(node) =\u003e node.prebuild(),\n            QueryNode::HavingNode(node) =\u003e node.prebuild(),\n            QueryNode::FilterNode(node) =\u003e node.prebuild(),\n            QueryNode::LimitNode(node) =\u003e node.prebuild(),\n            QueryNode::OffsetNode(node) =\u003e node.prebuild(),\n            QueryNode::OffsetLimitNode(node) =\u003e node.prebuild(),\n            QueryNode::ProjectNode(node) =\u003e node.prebuild(),\n            QueryNode::OrderByNode(node) =\u003e node.prebuild(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use {\n        super::QueryNode,\n        crate::{\n            ast::{\n                Join, JoinConstraint, JoinExecutor, JoinOperator, Query, Select, SetExpr,\n                TableFactor, TableWithJoins,\n            },\n            ast_builder::{\n                SelectItemList, col, glue_indexes, glue_objects, glue_table_columns, glue_tables,\n                series, table, test_query,\n            },\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    #[test]\n    fn query() {\n        let actual = table(\"FOO\").select().into();\n        let expected = \"SELECT * FROM FOO\";\n        test_query(actual, expected);\n\n        let actual = table(\"Bar\").select().join(\"Foo\").into();\n        let expected = \"SELECT * FROM Bar JOIN Foo\";\n        test_query(actual, expected);\n\n        let actual = table(\"Bar\")\n            .select()\n            .join(\"Foo\")\n            .on(\"Foo.id = Bar.foo_id\")\n            .into();\n        let expected = \"SELECT * FROM Bar JOIN Foo ON Foo.id = Bar.foo_id\";\n        test_query(actual, expected);\n\n        let actual: QueryNode = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .into();\n        let expected = {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"PlayerItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"PlayerItem.user_id\").try_into().unwrap(),\n                    value_expr: col(\"Player.id\").try_into().unwrap(),\n                    where_clause: None,\n                },\n            };\n            let select = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join],\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            }\n        };\n        assert_eq!(Query::try_from(actual).unwrap(), expected);\n\n        let actual = table(\"FOO\").select().group_by(\"id\").into();\n        let expected = \"SELECT * FROM FOO GROUP BY id\";\n        test_query(actual, expected);\n\n        let actual = table(\"FOO\")\n            .select()\n            .group_by(\"id\")\n            .having(\"COUNT(id) \u003e 10\")\n            .into();\n        let expected = \"SELECT * FROM FOO GROUP BY id HAVING COUNT(id) \u003e 10\";\n        test_query(actual, expected);\n\n        let actual = table(\"FOO\")\n            .select()\n            .group_by(\"city\")\n            .having(\"COUNT(name) \u003c 100\")\n            .limit(3)\n            .into();\n        let expected = \"SELECT * FROM FOO GROUP BY city HAVING COUNT(name) \u003c 100 LIMIT 3\";\n        test_query(actual, expected);\n\n        let actual = table(\"FOO\").select().offset(10).into();\n        let expected = \"SELECT * FROM FOO OFFSET 10\";\n        test_query(actual, expected);\n\n        let actual = table(\"FOO\")\n            .select()\n            .group_by(\"city\")\n            .having(\"COUNT(name) \u003c 100\")\n            .offset(1)\n            .limit(3)\n            .into();\n        let expected = \"SELECT * FROM FOO GROUP BY city HAVING COUNT(name) \u003c 100 OFFSET 1 LIMIT 3\";\n        test_query(actual, expected);\n\n        let actual = table(\"FOO\").select().project(\"id, name\").limit(10).into();\n        let expected = r#\"SELECT id, name FROM FOO LIMIT 10\"#;\n        test_query(actual, expected);\n\n        let actual = table(\"Foo\").select().order_by(\"score DESC\").into();\n        let expected = \"SELECT * FROM Foo ORDER BY score DESC\";\n        test_query(actual, expected);\n\n        let actual = glue_objects().select().into();\n        let expected = \"SELECT * FROM GLUE_OBJECTS\";\n        test_query(actual, expected);\n\n        let actual = glue_tables().select().into();\n        let expected = \"SELECT * FROM GLUE_TABLES\";\n        test_query(actual, expected);\n\n        let actual = glue_indexes().select().into();\n        let expected = \"SELECT * FROM GLUE_INDEXES\";\n        test_query(actual, expected);\n\n        let actual = glue_table_columns().select().into();\n        let expected = \"SELECT * FROM GLUE_TABLE_COLUMNS\";\n        test_query(actual, expected);\n\n        let actual = series(\"1 + 2\").select().into();\n        let expected = \"SELECT * FROM SERIES(1 + 2)\";\n        test_query(actual, expected);\n\n        let actual = table(\"Items\").select().alias_as(\"Sub\").select().into();\n        let expected = \"SELECT * FROM (SELECT * FROM Items) AS Sub\";\n        test_query(actual, expected);\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":34},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","filter.rs"],"content":"use {\n    super::Prebuild,\n    crate::{\n        ast::Select,\n        ast_builder::{\n            ExprList, ExprNode, GroupByNode, HashJoinNode, JoinConstraintNode, JoinNode, LimitNode,\n            OffsetNode, OrderByExprList, OrderByNode, ProjectNode, QueryNode, SelectItemList,\n            SelectNode, TableFactorNode,\n        },\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum PrevNode\u003c'a\u003e {\n    Select(SelectNode\u003c'a\u003e),\n    Join(Box\u003cJoinNode\u003c'a\u003e\u003e),\n    JoinConstraint(Box\u003cJoinConstraintNode\u003c'a\u003e\u003e),\n    HashJoin(Box\u003cHashJoinNode\u003c'a\u003e\u003e),\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for PrevNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        match self {\n            Self::Select(node) =\u003e node.prebuild(),\n            Self::Join(node) =\u003e node.prebuild(),\n            Self::JoinConstraint(node) =\u003e node.prebuild(),\n            Self::HashJoin(node) =\u003e node.prebuild(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Join(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinConstraintNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinConstraintNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::JoinConstraint(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cHashJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: HashJoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::HashJoin(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cSelectNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: SelectNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Select(node)\n    }\n}\n#[derive(Clone, Debug)]\npub struct FilterNode\u003c'a\u003e {\n    prev_node: PrevNode\u003c'a\u003e,\n    filter_expr: ExprNode\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e FilterNode\u003c'a\u003e {\n    pub fn new\u003cN: Into\u003cPrevNode\u003c'a\u003e\u003e, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(prev_node: N, expr: T) -\u003e Self {\n        Self {\n            prev_node: prev_node.into(),\n            filter_expr: expr.into(),\n        }\n    }\n\n    pub fn filter\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(mut self, expr: T) -\u003e Self {\n        let exprs = self.filter_expr;\n        self.filter_expr = exprs.and(expr);\n        self\n    }\n\n    pub fn offset\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e OffsetNode\u003c'a\u003e {\n        OffsetNode::new(self, expr)\n    }\n\n    pub fn limit\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e LimitNode\u003c'a\u003e {\n        LimitNode::new(self, expr)\n    }\n\n    pub fn project\u003cT: Into\u003cSelectItemList\u003c'a\u003e\u003e\u003e(self, select_items: T) -\u003e ProjectNode\u003c'a\u003e {\n        ProjectNode::new(self, select_items)\n    }\n\n    pub fn group_by\u003cT: Into\u003cExprList\u003c'a\u003e\u003e\u003e(self, expr_list: T) -\u003e GroupByNode\u003c'a\u003e {\n        GroupByNode::new(self, expr_list)\n    }\n\n    pub fn order_by\u003cT: Into\u003cOrderByExprList\u003c'a\u003e\u003e\u003e(self, order_by_exprs: T) -\u003e OrderByNode\u003c'a\u003e {\n        OrderByNode::new(self, order_by_exprs)\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::FilterNode(self).alias_as(table_alias)\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for FilterNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        let mut select: Select = self.prev_node.prebuild()?;\n        select.selection = Some(self.filter_expr.try_into()?);\n\n        Ok(select)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::{\n                BinaryOperator, Expr, Join, JoinConstraint, JoinExecutor, JoinOperator, Query,\n                Select, SetExpr, Statement, TableFactor, TableWithJoins,\n            },\n            ast_builder::{Build, SelectItemList, col, expr, table, test},\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    #[test]\n    fn filter() {\n        // select node -\u003e filter node -\u003e build\n        let actual = table(\"Bar\").select().filter(\"id IS NULL\").build();\n        let expected = \"SELECT * FROM Bar WHERE id IS NULL\";\n        test(actual, expected);\n\n        // select node -\u003e filter node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .filter(Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(\"col1\".to_owned())),\n                op: BinaryOperator::Gt,\n                right: Box::new(Expr::Identifier(\"col2\".to_owned())),\n            })\n            .build();\n        let expected = \"SELECT * FROM Foo WHERE col1 \u003e col2\";\n        test(actual, expected);\n\n        // filter node -\u003e filter node -\u003e build\n        let actual = table(\"Bar\")\n            .select()\n            .filter(\"id IS NULL\")\n            .filter(\"id \u003e 10\")\n            .filter(\"id \u003c 20\")\n            .build();\n        let expected = \"SELECT * FROM Bar WHERE id IS NULL AND id \u003e 10 AND id \u003c 20\";\n        test(actual, expected);\n\n        // join node -\u003e filter node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .filter(\"id IS NULL\")\n            .build();\n        let expected = \"SELECT * FROM Foo JOIN Bar WHERE id IS NULL\";\n        test(actual, expected);\n\n        // join node -\u003e filter node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .join_as(\"Bar\", \"b\")\n            .filter(\"id IS NULL\")\n            .build();\n        let expected = \"SELECT * FROM Foo JOIN Bar AS b WHERE id IS NULL\";\n        test(actual, expected);\n\n        // join node -\u003e filter node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .left_join(\"Bar\")\n            .filter(\"id IS NULL\")\n            .build();\n        let expected = \"SELECT * FROM Foo LEFT JOIN Bar WHERE id IS NULL\";\n        test(actual, expected);\n\n        // join node -\u003e filter node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .left_join_as(\"Bar\", \"b\")\n            .filter(\"id IS NULL\")\n            .build();\n        let expected = \"SELECT * FROM Foo LEFT JOIN Bar AS b WHERE id IS NULL\";\n        test(actual, expected);\n\n        // join constraint node -\u003e filter node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .on(\"Foo.id = Bar.id\")\n            .filter(\"id IS NULL\")\n            .build();\n        let expected = \"SELECT * FROM Foo JOIN Bar ON Foo.id = Bar.id WHERE id IS NULL\";\n        test(actual, expected);\n\n        // hash join node -\u003e filter node -\u003e build\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .filter(\"PlayerItem.amount \u003e 10\")\n            .build();\n        let expected = {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"PlayerItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"PlayerItem.user_id\").try_into().unwrap(),\n                    value_expr: col(\"Player.id\").try_into().unwrap(),\n                    where_clause: None,\n                },\n            };\n            let select = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join],\n                },\n                selection: Some(expr(\"PlayerItem.amount \u003e 10\").try_into().unwrap()),\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            Ok(Statement::Query(Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            }))\n        };\n        assert_eq!(actual, expected);\n\n        // select node -\u003e filter node -\u003e derived subquery\n        let actual = table(\"Bar\")\n            .select()\n            .filter(\"id IS NULL\")\n            .alias_as(\"Sub\")\n            .select()\n            .build();\n        let expected = \"SELECT * FROM (SELECT * FROM Bar WHERE id IS NULL) Sub\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","group_by.rs"],"content":"use {\n    super::Prebuild,\n    crate::{\n        ast::Select,\n        ast_builder::{\n            ExprList, ExprNode, FilterNode, HashJoinNode, HavingNode, JoinConstraintNode, JoinNode,\n            LimitNode, OffsetNode, OrderByExprList, OrderByNode, ProjectNode, QueryNode,\n            SelectItemList, SelectNode, TableFactorNode,\n        },\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum PrevNode\u003c'a\u003e {\n    Select(SelectNode\u003c'a\u003e),\n    Join(Box\u003cJoinNode\u003c'a\u003e\u003e),\n    JoinConstraint(Box\u003cJoinConstraintNode\u003c'a\u003e\u003e),\n    HashJoin(Box\u003cHashJoinNode\u003c'a\u003e\u003e),\n    Filter(FilterNode\u003c'a\u003e),\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for PrevNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        match self {\n            Self::Select(node) =\u003e node.prebuild(),\n            Self::Join(node) =\u003e node.prebuild(),\n            Self::JoinConstraint(node) =\u003e node.prebuild(),\n            Self::HashJoin(node) =\u003e node.prebuild(),\n            Self::Filter(node) =\u003e node.prebuild(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cSelectNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: SelectNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Select(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Join(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinConstraintNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinConstraintNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::JoinConstraint(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cHashJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: HashJoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::HashJoin(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cFilterNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: FilterNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Filter(node)\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct GroupByNode\u003c'a\u003e {\n    prev_node: PrevNode\u003c'a\u003e,\n    expr_list: ExprList\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e GroupByNode\u003c'a\u003e {\n    pub fn new\u003cN: Into\u003cPrevNode\u003c'a\u003e\u003e, T: Into\u003cExprList\u003c'a\u003e\u003e\u003e(prev_node: N, expr_list: T) -\u003e Self {\n        Self {\n            prev_node: prev_node.into(),\n            expr_list: expr_list.into(),\n        }\n    }\n\n    pub fn having\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e HavingNode\u003c'a\u003e {\n        HavingNode::new(self, expr)\n    }\n\n    pub fn offset\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e OffsetNode\u003c'a\u003e {\n        OffsetNode::new(self, expr)\n    }\n\n    pub fn limit\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e LimitNode\u003c'a\u003e {\n        LimitNode::new(self, expr)\n    }\n\n    pub fn project\u003cT: Into\u003cSelectItemList\u003c'a\u003e\u003e\u003e(self, select_items: T) -\u003e ProjectNode\u003c'a\u003e {\n        ProjectNode::new(self, select_items)\n    }\n\n    pub fn order_by\u003cT: Into\u003cOrderByExprList\u003c'a\u003e\u003e\u003e(self, expr_list: T) -\u003e OrderByNode\u003c'a\u003e {\n        OrderByNode::new(self, expr_list)\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::GroupByNode(self).alias_as(table_alias)\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for GroupByNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        let mut select: Select = self.prev_node.prebuild()?;\n        select.group_by = self.expr_list.try_into()?;\n\n        Ok(select)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::{\n                Join, JoinConstraint, JoinExecutor, JoinOperator, Query, Select, SetExpr,\n                Statement, TableFactor, TableWithJoins,\n            },\n            ast_builder::{Build, SelectItemList, col, table, test},\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    #[test]\n    fn group_by() {\n        // select node -\u003e group by node -\u003e build\n        let actual = table(\"Foo\").select().group_by(\"a\").build();\n        let expected = \"SELECT * FROM Foo GROUP BY a\";\n        test(actual, expected);\n\n        // join node -\u003e group by node -\u003e build\n        let actual = table(\"Foo\").select().join(\"Bar\").group_by(\"b\").build();\n        let expected = \"SELECT * FROM Foo JOIN Bar GROUP BY b\";\n        test(actual, expected);\n\n        // join node -\u003e group by node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .join_as(\"Bar\", \"B\")\n            .group_by(\"b\")\n            .build();\n        let expected = \"SELECT * FROM Foo JOIN Bar AS B GROUP BY b\";\n        test(actual, expected);\n\n        // join node -\u003e group by node -\u003e build\n        let actual = table(\"Foo\").select().left_join(\"Bar\").group_by(\"b\").build();\n        let expected = \"SELECT * FROM Foo LEFT JOIN Bar GROUP BY b\";\n        test(actual, expected);\n\n        // join node -\u003e group by node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .left_join_as(\"Bar\", \"B\")\n            .group_by(\"b\")\n            .build();\n        let expected = \"SELECT * FROM Foo LEFT JOIN Bar AS B GROUP BY b\";\n        test(actual, expected);\n\n        // join constraint node -\u003e group by node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .on(\"Foo.id = Bar.id\")\n            .group_by(\"b\")\n            .build();\n        let expected = \"SELECT * FROM Foo JOIN Bar ON Foo.id = Bar.id GROUP BY b\";\n        test(actual, expected);\n\n        // filter node -\u003e group by node -\u003e build\n        let actual = table(\"Bar\")\n            .select()\n            .filter(col(\"id\").is_null())\n            .group_by(\"id, (a + name)\")\n            .build();\n        let expected = \"\n                SELECT * FROM Bar\n                WHERE id IS NULL\n                GROUP BY id, (a + name)\n            \";\n        test(actual, expected);\n\n        // hash join node -\u003e group by node -\u003e build\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .group_by(\"PlayerItem.category\")\n            .build();\n        let expected = {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"PlayerItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"PlayerItem.user_id\").try_into().unwrap(),\n                    value_expr: col(\"Player.id\").try_into().unwrap(),\n                    where_clause: None,\n                },\n            };\n            let select = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join],\n                },\n                selection: None,\n                group_by: vec![col(\"PlayerItem.category\").try_into().unwrap()],\n                having: None,\n            };\n\n            Ok(Statement::Query(Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            }))\n        };\n        assert_eq!(actual, expected);\n\n        // select -\u003e group by -\u003e derived subquery\n        let actual = table(\"Foo\")\n            .select()\n            .group_by(\"a\")\n            .alias_as(\"Sub\")\n            .select()\n            .build();\n        let expected = \"SELECT * FROM (SELECT * FROM Foo GROUP BY a) Sub\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":36},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","having.rs"],"content":"use {\n    super::Prebuild,\n    crate::{\n        ast::Select,\n        ast_builder::{\n            ExprNode, GroupByNode, LimitNode, OffsetNode, OrderByExprList, OrderByNode,\n            ProjectNode, QueryNode, SelectItemList, TableFactorNode,\n        },\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum PrevNode\u003c'a\u003e {\n    GroupBy(GroupByNode\u003c'a\u003e),\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for PrevNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        match self {\n            Self::GroupBy(node) =\u003e node.prebuild(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cGroupByNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: GroupByNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::GroupBy(node)\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct HavingNode\u003c'a\u003e {\n    prev_node: PrevNode\u003c'a\u003e,\n    expr: ExprNode\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e HavingNode\u003c'a\u003e {\n    pub fn new\u003cN: Into\u003cPrevNode\u003c'a\u003e\u003e, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(prev_node: N, expr: T) -\u003e Self {\n        Self {\n            prev_node: prev_node.into(),\n            expr: expr.into(),\n        }\n    }\n\n    pub fn offset\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e OffsetNode\u003c'a\u003e {\n        OffsetNode::new(self, expr)\n    }\n\n    pub fn limit\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e LimitNode\u003c'a\u003e {\n        LimitNode::new(self, expr)\n    }\n\n    pub fn project\u003cT: Into\u003cSelectItemList\u003c'a\u003e\u003e\u003e(self, select_items: T) -\u003e ProjectNode\u003c'a\u003e {\n        ProjectNode::new(self, select_items)\n    }\n\n    pub fn order_by\u003cT: Into\u003cOrderByExprList\u003c'a\u003e\u003e\u003e(self, expr_list: T) -\u003e OrderByNode\u003c'a\u003e {\n        OrderByNode::new(self, expr_list)\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::HavingNode(self).alias_as(table_alias)\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for HavingNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        let mut select: Select = self.prev_node.prebuild()?;\n        select.having = Some(self.expr.try_into()?);\n\n        Ok(select)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{Build, table, test};\n\n    #[test]\n    fn having() {\n        // group by node -\u003e having node -\u003e offset node\n        let actual = table(\"Bar\")\n            .select()\n            .filter(\"id IS NULL\")\n            .group_by(\"id, (a + name)\")\n            .having(\"COUNT(id) \u003e 10\")\n            .offset(10)\n            .build();\n        let expected = \"\n            SELECT * FROM Bar\n            WHERE id IS NULL\n            GROUP BY id, (a + name)\n            HAVING COUNT(id) \u003e 10\n            OFFSET 10\n        \";\n        test(actual, expected);\n\n        // group by node -\u003e having node -\u003e limit node\n        let actual = table(\"Bar\")\n            .select()\n            .filter(\"id IS NULL\")\n            .group_by(\"id, (a + name)\")\n            .having(\"COUNT(id) \u003e 10\")\n            .limit(10)\n            .build();\n        let expected = \"\n            SELECT * FROM Bar\n            WHERE id IS NULL\n            GROUP BY id, (a + name)\n            HAVING COUNT(id) \u003e 10\n            LIMIT 10\n            \";\n        test(actual, expected);\n\n        // group by node -\u003e having node -\u003e project node\n        let actual = table(\"Bar\")\n            .select()\n            .filter(\"id IS NULL\")\n            .group_by(\"id, (a + name)\")\n            .having(\"COUNT(id) \u003e 10\")\n            .project(vec![\"id\", \"(a + name) AS b\", \"COUNT(id) AS c\"])\n            .build();\n        let expected = \"\n            SELECT id, (a + name) AS b, COUNT(id) AS c\n            FROM Bar\n            WHERE id IS NULL\n            GROUP BY id, (a + name)\n            HAVING COUNT(id) \u003e 10\n        \";\n        test(actual, expected);\n\n        // group by node -\u003e having node -\u003e build\n        let actual = table(\"Bar\")\n            .select()\n            .filter(\"id IS NULL\")\n            .group_by(\"id, (a + name)\")\n            .having(\"COUNT(id) \u003e 10\")\n            .build();\n        let expected = \"\n                SELECT * FROM Bar\n                WHERE id IS NULL\n                GROUP BY id, (a + name)\n                HAVING COUNT(id) \u003e 10\n            \";\n        test(actual, expected);\n\n        // select -\u003e group by -\u003e having -\u003e derived subquery\n        let actual = table(\"Foo\")\n            .select()\n            .group_by(\"a\")\n            .having(\"a \u003e 1\")\n            .alias_as(\"Sub\")\n            .select()\n            .build();\n        let expected = \"SELECT * FROM (SELECT * FROM Foo GROUP BY a HAVING a \u003e 1) Sub\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","join","hash_join.rs"],"content":"use {\n    super::{JoinConstraintData, JoinOperatorType},\n    crate::{\n        ast::{Join, JoinExecutor, Select},\n        ast_builder::{\n            ExprList, ExprNode, FilterNode, GroupByNode, JoinConstraintNode, JoinNode, LimitNode,\n            OffsetNode, OrderByExprList, OrderByNode, ProjectNode, QueryNode, SelectItemList,\n            TableFactorNode, select::Prebuild,\n        },\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub struct HashJoinNode\u003c'a\u003e {\n    join_node: JoinNode\u003c'a\u003e,\n    key_expr: ExprNode\u003c'a\u003e,\n    value_expr: ExprNode\u003c'a\u003e,\n    filter_expr: Option\u003cExprNode\u003c'a\u003e\u003e,\n}\n\nimpl\u003c'a\u003e HashJoinNode\u003c'a\u003e {\n    pub fn new\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n        join_node: JoinNode\u003c'a\u003e,\n        key_expr: T,\n        value_expr: U,\n    ) -\u003e Self {\n        Self {\n            join_node,\n            key_expr: key_expr.into(),\n            value_expr: value_expr.into(),\n            filter_expr: None,\n        }\n    }\n\n    pub fn hash_filter\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(mut self, expr: T) -\u003e Self {\n        let expr = expr.into();\n        let filter_expr = match self.filter_expr {\n            Some(filter_expr) =\u003e filter_expr.and(expr),\n            None =\u003e expr,\n        };\n\n        self.filter_expr = Some(filter_expr);\n        self\n    }\n\n    pub fn on\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e JoinConstraintNode\u003c'a\u003e {\n        JoinConstraintNode::new(self, expr)\n    }\n\n    pub fn join(self, table_name: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(self, table_name.to_owned(), None, JoinOperatorType::Inner)\n    }\n\n    pub fn join_as(self, table_name: \u0026str, alias: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(\n            self,\n            table_name.to_owned(),\n            Some(alias.to_owned()),\n            JoinOperatorType::Inner,\n        )\n    }\n\n    pub fn left_join(self, table_name: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(self, table_name.to_owned(), None, JoinOperatorType::Left)\n    }\n\n    pub fn left_join_as(self, table_name: \u0026str, alias: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(\n            self,\n            table_name.to_owned(),\n            Some(alias.to_owned()),\n            JoinOperatorType::Left,\n        )\n    }\n\n    pub fn project\u003cT: Into\u003cSelectItemList\u003c'a\u003e\u003e\u003e(self, select_items: T) -\u003e ProjectNode\u003c'a\u003e {\n        ProjectNode::new(self, select_items)\n    }\n\n    pub fn group_by\u003cT: Into\u003cExprList\u003c'a\u003e\u003e\u003e(self, expr_list: T) -\u003e GroupByNode\u003c'a\u003e {\n        GroupByNode::new(self, expr_list)\n    }\n\n    pub fn offset\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e OffsetNode\u003c'a\u003e {\n        OffsetNode::new(self, expr)\n    }\n\n    pub fn limit\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e LimitNode\u003c'a\u003e {\n        LimitNode::new(self, expr)\n    }\n\n    pub fn filter\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e FilterNode\u003c'a\u003e {\n        FilterNode::new(self, expr)\n    }\n\n    pub fn order_by\u003cT: Into\u003cOrderByExprList\u003c'a\u003e\u003e\u003e(self, order_by_exprs: T) -\u003e OrderByNode\u003c'a\u003e {\n        OrderByNode::new(self, order_by_exprs)\n    }\n\n    pub fn prebuild_for_constraint(self) -\u003e Result\u003cJoinConstraintData\u003e {\n        let mut join_constraint_data = self.join_node.prebuild_for_constraint()?;\n\n        join_constraint_data.executor =\n            build_join_executor(self.key_expr, self.value_expr, self.filter_expr)?;\n\n        Ok(join_constraint_data)\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::HashJoinNode(self).alias_as(table_alias)\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for HashJoinNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        let (mut select, relation, join_operator) = self.join_node.prebuild_for_hash_join()?;\n        let join_executor = build_join_executor(self.key_expr, self.value_expr, self.filter_expr)?;\n\n        let join = Join {\n            relation,\n            join_operator,\n            join_executor,\n        };\n\n        select.from.joins.push(join);\n\n        Ok(select)\n    }\n}\n\nfn build_join_executor(\n    key_expr: ExprNode,\n    value_expr: ExprNode,\n    filter_expr: Option\u003cExprNode\u003e,\n) -\u003e Result\u003cJoinExecutor\u003e {\n    Ok(JoinExecutor::Hash {\n        key_expr: key_expr.try_into()?,\n        value_expr: value_expr.try_into()?,\n        where_clause: filter_expr.map(ExprNode::try_into).transpose()?,\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::{\n                Join, JoinConstraint, JoinExecutor, JoinOperator, Query, Select, SetExpr,\n                Statement, TableAlias, TableFactor, TableWithJoins,\n            },\n            ast_builder::{Build, SelectItemList, col, expr, table},\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    #[test]\n    fn hash_join() {\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", col(\"Player.id\"))\n            .build();\n        let expected = {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"PlayerItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"PlayerItem.user_id\").try_into().unwrap(),\n                    value_expr: col(\"Player.id\").try_into().unwrap(),\n                    where_clause: None,\n                },\n            };\n            let select = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join],\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            Ok(Statement::Query(Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            }))\n        };\n        assert_eq!(actual, expected, \"without filter\");\n\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .hash_filter(\"PlayerItem.amount \u003e 10\")\n            .hash_filter(\"PlayerItem.amount * 3 \u003c= 2\")\n            .build();\n        let expected = {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"PlayerItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"PlayerItem.user_id\").try_into().unwrap(),\n                    value_expr: col(\"Player.id\").try_into().unwrap(),\n                    where_clause: Some(\n                        expr(\"PlayerItem.amount \u003e 10 AND PlayerItem.amount * 3 \u003c= 2\")\n                            .try_into()\n                            .unwrap(),\n                    ),\n                },\n            };\n            let select = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join],\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            Ok(Statement::Query(Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            }))\n        };\n        assert_eq!(actual, expected, \"with filter\");\n\n        // join -\u003e hash -\u003e derived subquery\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .hash_executor(\"Foo.id\", \"Bar.id\")\n            .alias_as(\"Sub\")\n            .select()\n            .build();\n\n        let expected = {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"Bar\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"Foo.id\").try_into().unwrap(),\n                    value_expr: col(\"Bar.id\").try_into().unwrap(),\n                    where_clause: None,\n                },\n            };\n\n            let subquery = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Foo\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join],\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            let select = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Derived {\n                        subquery: Query {\n                            body: SetExpr::Select(Box::new(subquery)),\n                            order_by: Vec::new(),\n                            limit: None,\n                            offset: None,\n                        },\n                        alias: TableAlias {\n                            name: \"Sub\".to_owned(),\n                            columns: Vec::new(),\n                        },\n                    },\n                    joins: Vec::new(),\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            Ok(Statement::Query(Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            }))\n        };\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":55},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","join","join_constraint.rs"],"content":"use {\n    super::{JoinConstraintData, JoinOperatorType},\n    crate::{\n        ast::{Join, JoinConstraint, JoinOperator, Select},\n        ast_builder::{\n            ExprList, ExprNode, FilterNode, GroupByNode, HashJoinNode, JoinNode, LimitNode,\n            OffsetNode, OrderByExprList, OrderByNode, ProjectNode, QueryNode, SelectItemList,\n            TableFactorNode, select::Prebuild,\n        },\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum PrevNode\u003c'a\u003e {\n    Join(Box\u003cJoinNode\u003c'a\u003e\u003e),\n    HashJoin(Box\u003cHashJoinNode\u003c'a\u003e\u003e),\n}\n\nimpl\u003c'a\u003e PrevNode\u003c'a\u003e {\n    fn prebuild_for_constraint(self) -\u003e Result\u003cJoinConstraintData\u003e {\n        match self {\n            PrevNode::Join(node) =\u003e node.prebuild_for_constraint(),\n            PrevNode::HashJoin(node) =\u003e node.prebuild_for_constraint(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Join(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cHashJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: HashJoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::HashJoin(Box::new(node))\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct JoinConstraintNode\u003c'a\u003e {\n    prev_node: PrevNode\u003c'a\u003e,\n    expr: ExprNode\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e JoinConstraintNode\u003c'a\u003e {\n    pub fn new\u003cN: Into\u003cPrevNode\u003c'a\u003e\u003e, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(prev_node: N, expr: T) -\u003e Self {\n        Self {\n            prev_node: prev_node.into(),\n            expr: expr.into(),\n        }\n    }\n\n    pub fn join(self, table_name: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(self, table_name.to_owned(), None, JoinOperatorType::Inner)\n    }\n\n    pub fn join_as(self, table_name: \u0026str, alias: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(\n            self,\n            table_name.to_owned(),\n            Some(alias.to_owned()),\n            JoinOperatorType::Inner,\n        )\n    }\n\n    pub fn left_join(self, table_name: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(self, table_name.to_owned(), None, JoinOperatorType::Left)\n    }\n\n    pub fn left_join_as(self, table_name: \u0026str, alias: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(\n            self,\n            table_name.to_owned(),\n            Some(alias.to_owned()),\n            JoinOperatorType::Left,\n        )\n    }\n\n    pub fn project\u003cT: Into\u003cSelectItemList\u003c'a\u003e\u003e\u003e(self, select_items: T) -\u003e ProjectNode\u003c'a\u003e {\n        ProjectNode::new(self, select_items)\n    }\n\n    pub fn group_by\u003cT: Into\u003cExprList\u003c'a\u003e\u003e\u003e(self, expr_list: T) -\u003e GroupByNode\u003c'a\u003e {\n        GroupByNode::new(self, expr_list)\n    }\n\n    pub fn offset\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e OffsetNode\u003c'a\u003e {\n        OffsetNode::new(self, expr)\n    }\n\n    pub fn limit\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e LimitNode\u003c'a\u003e {\n        LimitNode::new(self, expr)\n    }\n\n    pub fn filter\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e FilterNode\u003c'a\u003e {\n        FilterNode::new(self, expr)\n    }\n\n    pub fn order_by\u003cT: Into\u003cOrderByExprList\u003c'a\u003e\u003e\u003e(self, order_by_exprs: T) -\u003e OrderByNode\u003c'a\u003e {\n        OrderByNode::new(self, order_by_exprs)\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::JoinConstraintNode(self).alias_as(table_alias)\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for JoinConstraintNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        let JoinConstraintData {\n            mut select,\n            relation,\n            operator_type,\n            executor: join_executor,\n        } = self.prev_node.prebuild_for_constraint()?;\n\n        select.from.joins.push(Join {\n            relation,\n            join_operator: match operator_type {\n                JoinOperatorType::Inner =\u003e {\n                    JoinOperator::Inner(JoinConstraint::On(self.expr.try_into()?))\n                }\n                JoinOperatorType::Left =\u003e {\n                    JoinOperator::LeftOuter(JoinConstraint::On(self.expr.try_into()?))\n                }\n            },\n            join_executor,\n        });\n\n        Ok(select)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::{\n                Join, JoinConstraint, JoinExecutor, JoinOperator, Query, Select, SetExpr,\n                Statement, TableFactor, TableWithJoins,\n            },\n            ast_builder::{Build, SelectItemList, col, table, test},\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    #[test]\n    fn join_constraint() {\n        // join node -\u003e  join constarint node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .on(\"Foo.id = Bar.id\")\n            .build();\n        let expected = \"SELECT * FROM Foo INNER JOIN Bar ON Foo.id = Bar.id\";\n        test(actual, expected);\n\n        // join node -\u003e  join constraint node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .join_as(\"Bar\", \"B\")\n            .on(\"Foo.id = B.id\")\n            .build();\n        let expected = \"SELECT * FROM Foo INNER JOIN Bar B ON Foo.id = B.id\";\n        test(actual, expected);\n\n        // join node -\u003e join constraint node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .left_join(\"Bar\")\n            .on(\"Foo.id = Bar.id\")\n            .build();\n        let expected = \"SELECT * FROM Foo LEFT OUTER JOIN Bar ON Foo.id = Bar.id\";\n        test(actual, expected);\n\n        // join node -\u003e join constraint node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .left_join_as(\"Bar\", \"b\")\n            .on(\"Foo.id = b.id\")\n            .build();\n        let expected = \"SELECT * FROM Foo LEFT OUTER JOIN Bar b ON Foo.id = b.id\";\n        test(actual, expected);\n\n        // hash join node -\u003e join constraint node -\u003e build\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .on(\"PlayerItem.flag IS NOT NULL\")\n            .build();\n        let expected = {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"PlayerItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::On(\n                    col(\"PlayerItem.flag\").is_not_null().try_into().unwrap(),\n                )),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"PlayerItem.user_id\").try_into().unwrap(),\n                    value_expr: col(\"Player.id\").try_into().unwrap(),\n                    where_clause: None,\n                },\n            };\n            let select = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join],\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            Ok(Statement::Query(Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            }))\n        };\n        assert_eq!(actual, expected, \"hash join -\u003e join constraint\");\n\n        // join -\u003e on -\u003e derived subquery\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .on(\"Foo.id = Bar.id\")\n            .alias_as(\"Sub\")\n            .select()\n            .build();\n        let expected = \"\n            SELECT * FROM (\n                SELECT * FROM Foo\n                INNER JOIN Bar ON Foo.id = Bar.id\n            ) Sub\n            \";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":55},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","join","root.rs"],"content":"use {\n    super::{JoinConstraintData, JoinOperatorType},\n    crate::{\n        ast::{Join, JoinExecutor, JoinOperator, Select, TableAlias, TableFactor},\n        ast_builder::{\n            ExprList, ExprNode, FilterNode, GroupByNode, HashJoinNode, JoinConstraintNode,\n            LimitNode, OffsetNode, OrderByExprList, OrderByNode, ProjectNode, QueryNode,\n            SelectItemList, SelectNode, TableFactorNode, select::Prebuild,\n        },\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum PrevNode\u003c'a\u003e {\n    Select(SelectNode\u003c'a\u003e),\n    Join(Box\u003cJoinNode\u003c'a\u003e\u003e),\n    JoinConstraint(Box\u003cJoinConstraintNode\u003c'a\u003e\u003e),\n    HashJoin(Box\u003cHashJoinNode\u003c'a\u003e\u003e),\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for PrevNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        match self {\n            Self::Select(node) =\u003e node.prebuild(),\n            Self::Join(node) =\u003e node.prebuild(),\n            Self::JoinConstraint(node) =\u003e node.prebuild(),\n            Self::HashJoin(node) =\u003e node.prebuild(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cSelectNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: SelectNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Select(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Join(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinConstraintNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinConstraintNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::JoinConstraint(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cHashJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: HashJoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::HashJoin(Box::new(node))\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct JoinNode\u003c'a\u003e {\n    prev_node: PrevNode\u003c'a\u003e,\n    relation: TableFactor,\n    join_operator_type: JoinOperatorType,\n}\n\nimpl\u003c'a\u003e JoinNode\u003c'a\u003e {\n    pub fn new\u003cN: Into\u003cPrevNode\u003c'a\u003e\u003e\u003e(\n        prev_node: N,\n        name: String,\n        alias: Option\u003cString\u003e,\n        join_operator_type: JoinOperatorType,\n    ) -\u003e Self {\n        Self {\n            prev_node: prev_node.into(),\n            join_operator_type,\n            relation: match alias {\n                Some(alias) =\u003e TableFactor::Table {\n                    name,\n                    alias: Some(TableAlias {\n                        name: alias,\n                        columns: vec![],\n                    }),\n                    index: None,\n                },\n                None =\u003e TableFactor::Table {\n                    name,\n                    alias: None,\n                    index: None,\n                },\n            },\n        }\n    }\n\n    pub fn on\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e JoinConstraintNode\u003c'a\u003e {\n        JoinConstraintNode::new(self, expr)\n    }\n\n    pub fn join(self, table_name: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(self, table_name.to_owned(), None, JoinOperatorType::Inner)\n    }\n\n    pub fn join_as(self, table_name: \u0026str, alias: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(\n            self,\n            table_name.to_owned(),\n            Some(alias.to_owned()),\n            JoinOperatorType::Inner,\n        )\n    }\n\n    pub fn left_join(self, table_name: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(self, table_name.to_owned(), None, JoinOperatorType::Left)\n    }\n\n    pub fn left_join_as(self, table_name: \u0026str, alias: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(\n            self,\n            table_name.to_owned(),\n            Some(alias.to_owned()),\n            JoinOperatorType::Left,\n        )\n    }\n\n    pub fn hash_executor\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e, U: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n        self,\n        key_expr: T,\n        value_expr: U,\n    ) -\u003e HashJoinNode\u003c'a\u003e {\n        HashJoinNode::new(self, key_expr, value_expr)\n    }\n\n    pub fn project\u003cT: Into\u003cSelectItemList\u003c'a\u003e\u003e\u003e(self, select_items: T) -\u003e ProjectNode\u003c'a\u003e {\n        ProjectNode::new(self, select_items)\n    }\n\n    pub fn group_by\u003cT: Into\u003cExprList\u003c'a\u003e\u003e\u003e(self, expr_list: T) -\u003e GroupByNode\u003c'a\u003e {\n        GroupByNode::new(self, expr_list)\n    }\n\n    pub fn offset\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e OffsetNode\u003c'a\u003e {\n        OffsetNode::new(self, expr)\n    }\n\n    pub fn limit\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e LimitNode\u003c'a\u003e {\n        LimitNode::new(self, expr)\n    }\n\n    pub fn filter\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e FilterNode\u003c'a\u003e {\n        FilterNode::new(self, expr)\n    }\n\n    pub fn order_by\u003cT: Into\u003cOrderByExprList\u003c'a\u003e\u003e\u003e(self, order_by_exprs: T) -\u003e OrderByNode\u003c'a\u003e {\n        OrderByNode::new(self, order_by_exprs)\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::JoinNode(self).alias_as(table_alias)\n    }\n\n    pub fn prebuild_for_constraint(self) -\u003e Result\u003cJoinConstraintData\u003e {\n        Ok(JoinConstraintData {\n            select: self.prev_node.prebuild()?,\n            relation: self.relation,\n            operator_type: self.join_operator_type,\n            executor: JoinExecutor::NestedLoop,\n        })\n    }\n\n    pub fn prebuild_for_hash_join(self) -\u003e Result\u003c(Select, TableFactor, JoinOperator)\u003e {\n        let select_data = self.prev_node.prebuild()?;\n        let join_operator = JoinOperator::from(self.join_operator_type);\n\n        Ok((select_data, self.relation, join_operator))\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for JoinNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        let mut select: Select = self.prev_node.prebuild()?;\n\n        select.from.joins.push(Join {\n            relation: self.relation,\n            join_operator: JoinOperator::from(self.join_operator_type),\n            join_executor: JoinExecutor::NestedLoop,\n        });\n\n        Ok(select)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::ast_builder::{Build, table, test},\n        pretty_assertions::assert_eq,\n    };\n\n    #[test]\n    fn inner_join() {\n        // select node -\u003e join node -\u003e join constraint node\n        let actual = table(\"Item\")\n            .select()\n            .join_as(\"Player\", \"p\")\n            .on(\"p.id = Item.player_id\")\n            .filter(\"p.id = 1\")\n            .build();\n        let expected = \"\n        SELECT * FROM Item INNER JOIN Player AS p ON p.id = Item.player_id WHERE p.id = 1;\n        \";\n        test(actual, expected);\n\n        // select node -\u003e join node -\u003e  join constraint node\n        let actual = table(\"Item\")\n            .select()\n            .join_as(\"Player\", \"p\")\n            .on(\"p.id = Item.player_id\")\n            .filter(\"p.id = 1\")\n            .project(vec![\"p.id\", \"p.name\", \"Item.id\"])\n            .build();\n        let expected = \"\n        SELECT p.id, p.name, Item.id FROM Item INNER JOIN Player AS p ON p.id = Item.player_id WHERE p.id = 1;\n        \";\n        test(actual, expected);\n\n        // select node -\u003e join node -\u003e  build\n        let actual = table(\"Item\").select().join_as(\"Player\", \"p\").build();\n        let expected = \"\n        SELECT * FROM Item INNER JOIN Player AS p;\n        \";\n        test(actual, expected);\n\n        // join node -\u003e join constraint node -\u003e join node -\u003e join constraint node\n        let actual = table(\"students\")\n            .select()\n            .join(\"marks\")\n            .on(\"students.id = marks.id\")\n            .join(\"attendance\")\n            .on(\"marks.id = attendance.id\")\n            .filter(\"attendance.attendance \u003e= 75\")\n            .project(vec![\n                \"students.id\",\n                \"students.name\",\n                \"marks.rank\",\n                \"attendance.attendance\",\n            ])\n            .build();\n        let expected = \"\n            SELECT students.id, students.name, marks.rank, attendance.attendance\n            FROM students\n            INNER JOIN marks ON students.id=marks.id\n            INNER JOIN attendance on marks.id=attendance.id\n            WHERE attendance.attendance \u003e= 75;\n        \";\n        test(actual, expected);\n\n        // select node -\u003e join node -\u003e project node\n        let actual = table(\"Orders\")\n            .select()\n            .join(\"Customers\")\n            .project(vec![\n                \"Orders.OrderID\",\n                \"Customers.CustomerName\",\n                \"Orders.OrderDate\",\n            ])\n            .build();\n        let expected = \"\n            SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate\n            FROM Orders INNER JOIN Customers\n        \";\n        test(actual, expected);\n    }\n\n    #[test]\n    fn left_join() {\n        // select node -\u003e left join node -\u003e join constraint node\n        let actual = table(\"player\")\n            .select()\n            .left_join(\"item\")\n            .on(\"player.id = item.id\")\n            .project(vec![\"player.id\", \"item.id\"])\n            .build();\n        let expected = \"\n            SELECT player.id, item.id\n            FROM player\n            LEFT JOIN item\n            ON player.id = item.id\n        \";\n        test(actual, expected);\n\n        // select node -\u003e left join node -\u003e join constraint node -\u003e left join node\n        let actual = table(\"Item\")\n            .select()\n            .left_join(\"Player\")\n            .on(\"Player.id = Item.player_id\")\n            .left_join_as(\"Player\", \"p1\")\n            .on(\"p1.id = Item.player_id\")\n            .left_join_as(\"Player\", \"p2\")\n            .on(\"p2.id = Item.player_id\")\n            .left_join_as(\"Player\", \"p3\")\n            .on(\"p3.id = Item.player_id\")\n            .left_join_as(\"Player\", \"p4\")\n            .on(\"p4.id = Item.player_id\")\n            .left_join_as(\"Player\", \"p5\")\n            .on(\"p5.id = Item.player_id\")\n            .left_join_as(\"Player\", \"p6\")\n            .on(\"p6.id = Item.player_id\")\n            .left_join_as(\"Player\", \"p7\")\n            .on(\"p7.id = Item.player_id\")\n            .left_join_as(\"Player\", \"p8\")\n            .on(\"p8.id = Item.player_id\")\n            .left_join_as(\"Player\", \"p9\")\n            .on(\"p9.id = Item.player_id\")\n            .filter(\"Player.id = 1\")\n            .build();\n        let expected = \"\n            SELECT * FROM Item\n            LEFT JOIN Player ON Player.id = Item.player_id\n            LEFT JOIN Player p1 ON p1.id = Item.player_id\n            LEFT JOIN Player p2 ON p2.id = Item.player_id\n            LEFT JOIN Player p3 ON p3.id = Item.player_id\n            LEFT JOIN Player p4 ON p4.id = Item.player_id\n            LEFT JOIN Player p5 ON p5.id = Item.player_id\n            LEFT JOIN Player p6 ON p6.id = Item.player_id\n            LEFT JOIN Player p7 ON p7.id = Item.player_id\n            LEFT JOIN Player p8 ON p8.id = Item.player_id\n            LEFT JOIN Player p9 ON p9.id = Item.player_id\n            WHERE Player.id = 1;\n        \";\n        test(actual, expected);\n\n        // select node -\u003e left join node -\u003e join constraint node -\u003e left join node\n        let actual = table(\"Item\")\n            .select()\n            .left_join(\"Player\")\n            .on(\"Player.id = Item.player_id\")\n            .left_join(\"Player\")\n            .on(\"p1.id = Item.player_id\")\n            .build();\n        let expected = \"\n            SELECT * FROM Item\n            LEFT JOIN Player ON Player.id = Item.player_id\n            LEFT JOIN Player ON p1.id = Item.player_id\";\n        test(actual, expected);\n\n        let actual = table(\"Item\")\n            .select()\n            .left_join(\"Player\")\n            .on(\"Player.id = Item.player_id\")\n            .left_join_as(\"Player\", \"p1\")\n            .on(\"p1.id = Item.player_id\")\n            .left_join_as(\"Player\", \"p2\")\n            .on(\"p2.id = Item.player_id\")\n            .left_join_as(\"Player\", \"p3\")\n            .on(\"p3.id = Item.player_id\")\n            .join_as(\"Player\", \"p4\")\n            .on(\"p4.id = Item.player_id AND Item.id \u003e 101\")\n            .filter(\"Player.id = 1\")\n            .build();\n        let expected = \"\n            SELECT * FROM Item\n            LEFT JOIN Player ON Player.id = Item.player_id\n            LEFT JOIN Player p1 ON p1.id = Item.player_id\n            LEFT JOIN Player p2 ON p2.id = Item.player_id\n            LEFT JOIN Player p3 ON p3.id = Item.player_id\n            INNER JOIN Player p4 ON p4.id = Item.player_id AND Item.id \u003e 101\n            WHERE Player.id = 1;\n        \";\n        test(actual, expected);\n    }\n\n    #[test]\n    fn join_join() {\n        // join - join\n        let actual = table(\"Foo\").select().join(\"Bar\").join(\"Baz\").build();\n        let expected = \"\n            SELECT * FROM Foo\n            INNER JOIN Bar\n            INNER JOIN Baz\n            \";\n        test(actual, expected);\n\n        // join - join as\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .join_as(\"Baz\", \"B\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            INNER JOIN Bar\n            INNER JOIN Baz B\n            \";\n        test(actual, expected);\n\n        // join - left join\n        let actual = table(\"Foo\").select().join(\"Bar\").left_join(\"Baz\").build();\n        let expected = \"\n            SELECT * FROM Foo\n            INNER JOIN Bar\n            LEFT JOIN Baz\n            \";\n        test(actual, expected);\n\n        // join - left join as\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .left_join_as(\"Baz\", \"B\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            INNER JOIN Bar\n            LEFT JOIN Baz B\n            \";\n        test(actual, expected);\n\n        // join as - join\n        let actual = table(\"Foo\")\n            .select()\n            .join_as(\"Bar\", \"B\")\n            .join(\"Baz\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            INNER JOIN Bar B\n            INNER JOIN Baz\n            \";\n        test(actual, expected);\n\n        // join as - join as\n        let actual = table(\"Foo\")\n            .select()\n            .join_as(\"Bar\", \"B\")\n            .join_as(\"Baz\", \"C\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            INNER JOIN Bar B\n            INNER JOIN Baz C\n            \";\n        test(actual, expected);\n\n        // join as - left join\n        let actual = table(\"Foo\")\n            .select()\n            .join_as(\"Bar\", \"B\")\n            .left_join(\"Baz\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            INNER JOIN Bar B\n            LEFT JOIN Baz\n            \";\n        test(actual, expected);\n\n        // join as - left join as\n        let actual = table(\"Foo\")\n            .select()\n            .join_as(\"Bar\", \"B\")\n            .left_join_as(\"Baz\", \"C\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            INNER JOIN Bar B\n            LEFT JOIN Baz C\n            \";\n        test(actual, expected);\n\n        // left join - join\n        let actual = table(\"Foo\").select().left_join(\"Bar\").join(\"Baz\").build();\n        let expected = \"\n            SELECT * FROM Foo\n            LEFT JOIN Bar\n            INNER JOIN Baz\n            \";\n        test(actual, expected);\n\n        // left join - join as\n        let actual = table(\"Foo\")\n            .select()\n            .left_join(\"Bar\")\n            .join_as(\"Baz\", \"B\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            LEFT JOIN Bar\n            INNER JOIN Baz B\n            \";\n        test(actual, expected);\n\n        // left join - left join\n        let actual = table(\"Foo\")\n            .select()\n            .left_join(\"Bar\")\n            .left_join(\"Baz\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            LEFT JOIN Bar\n            LEFT JOIN Baz\n            \";\n        test(actual, expected);\n\n        // left join - left join as\n        let actual = table(\"Foo\")\n            .select()\n            .left_join(\"Bar\")\n            .left_join_as(\"Baz\", \"B\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            LEFT JOIN Bar\n            LEFT JOIN Baz B\n            \";\n        test(actual, expected);\n\n        // left join as - join\n        let actual = table(\"Foo\")\n            .select()\n            .left_join_as(\"Bar\", \"B\")\n            .join(\"Baz\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            LEFT JOIN Bar B\n            INNER JOIN Baz\n            \";\n        test(actual, expected);\n\n        // left join as - join as\n        let actual = table(\"Foo\")\n            .select()\n            .left_join_as(\"Bar\", \"B\")\n            .join_as(\"Baz\", \"C\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            LEFT JOIN Bar B\n            INNER JOIN Baz C\n            \";\n        test(actual, expected);\n\n        // left join as - left join\n        let actual = table(\"Foo\")\n            .select()\n            .left_join_as(\"Bar\", \"B\")\n            .left_join(\"Baz\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            LEFT JOIN Bar B\n            LEFT JOIN Baz\n            \";\n        test(actual, expected);\n\n        // left join as - left join as\n        let actual = table(\"Foo\")\n            .select()\n            .left_join_as(\"Bar\", \"B\")\n            .left_join_as(\"Baz\", \"C\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            LEFT JOIN Bar B\n            LEFT JOIN Baz C\n            \";\n        test(actual, expected);\n    }\n\n    #[test]\n    fn hash_join() {\n        use crate::{\n            ast::{\n                Join, JoinConstraint, JoinExecutor, JoinOperator, Query, Select, SetExpr,\n                Statement, TableAlias, TableFactor, TableWithJoins,\n            },\n            ast_builder::{SelectItemList, col},\n        };\n\n        let gen_expected = |other_join| {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"PlayerItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"PlayerItem.user_id\").try_into().unwrap(),\n                    value_expr: col(\"Player.id\").try_into().unwrap(),\n                    where_clause: None,\n                },\n            };\n            let select = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join, other_join],\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            Ok(Statement::Query(Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            }))\n        };\n\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .join(\"OtherItem\")\n            .build();\n        let expected = {\n            let other_join = Join {\n                relation: TableFactor::Table {\n                    name: \"OtherItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::NestedLoop,\n            };\n\n            gen_expected(other_join)\n        };\n        assert_eq!(actual, expected, \"inner join\");\n\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .join_as(\"OtherItem\", \"Ot\")\n            .build();\n        let expected = {\n            let other_join = Join {\n                relation: TableFactor::Table {\n                    name: \"OtherItem\".to_owned(),\n                    alias: Some(TableAlias {\n                        name: \"Ot\".to_owned(),\n                        columns: Vec::new(),\n                    }),\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::NestedLoop,\n            };\n\n            gen_expected(other_join)\n        };\n        assert_eq!(actual, expected, \"inner join with alias\");\n\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .left_join(\"OtherItem\")\n            .build();\n        let expected = {\n            let other_join = Join {\n                relation: TableFactor::Table {\n                    name: \"OtherItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::LeftOuter(JoinConstraint::None),\n                join_executor: JoinExecutor::NestedLoop,\n            };\n\n            gen_expected(other_join)\n        };\n        assert_eq!(actual, expected, \"left join\");\n\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .left_join_as(\"OtherItem\", \"Ot\")\n            .build();\n        let expected = {\n            let other_join = Join {\n                relation: TableFactor::Table {\n                    name: \"OtherItem\".to_owned(),\n                    alias: Some(TableAlias {\n                        name: \"Ot\".to_owned(),\n                        columns: Vec::new(),\n                    }),\n                    index: None,\n                },\n                join_operator: JoinOperator::LeftOuter(JoinConstraint::None),\n                join_executor: JoinExecutor::NestedLoop,\n            };\n\n            gen_expected(other_join)\n        };\n        assert_eq!(actual, expected, \"left join with alias\");\n\n        let actual = table(\"App\").select().alias_as(\"Sub\").select().build();\n        let expected = \"SELECT * FROM (SELECT * FROM App) Sub\";\n        test(actual, expected);\n\n        // join -\u003e derived subquery\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .alias_as(\"Sub\")\n            .select()\n            .build();\n        let expected = \"\n            SELECT * FROM (\n                SELECT * FROM Foo\n                INNER JOIN Bar\n            ) Sub\n            \";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":66},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","join.rs"],"content":"mod hash_join;\nmod join_constraint;\nmod root;\n\npub use {hash_join::HashJoinNode, join_constraint::JoinConstraintNode, root::JoinNode};\n\nuse crate::ast::{JoinConstraint, JoinExecutor, JoinOperator, Select, TableFactor};\n\n#[derive(Clone, Copy, Debug)]\npub enum JoinOperatorType {\n    Inner,\n    Left,\n}\n\nimpl From\u003cJoinOperatorType\u003e for JoinOperator {\n    fn from(join_operator_type: JoinOperatorType) -\u003e Self {\n        match join_operator_type {\n            JoinOperatorType::Inner =\u003e JoinOperator::Inner(JoinConstraint::None),\n            JoinOperatorType::Left =\u003e JoinOperator::LeftOuter(JoinConstraint::None),\n        }\n    }\n}\n\npub struct JoinConstraintData {\n    select: Select,\n    relation: TableFactor,\n    operator_type: JoinOperatorType,\n    executor: JoinExecutor,\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","limit.rs"],"content":"use {\n    super::{Prebuild, values::ValuesNode},\n    crate::{\n        ast::Query,\n        ast_builder::{\n            ExprNode, FilterNode, GroupByNode, HashJoinNode, HavingNode, JoinConstraintNode,\n            JoinNode, OrderByNode, ProjectNode, QueryNode, SelectNode, TableFactorNode,\n        },\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum PrevNode\u003c'a\u003e {\n    Select(SelectNode\u003c'a\u003e),\n    Values(ValuesNode\u003c'a\u003e),\n    GroupBy(GroupByNode\u003c'a\u003e),\n    Having(HavingNode\u003c'a\u003e),\n    Join(Box\u003cJoinNode\u003c'a\u003e\u003e),\n    JoinConstraint(Box\u003cJoinConstraintNode\u003c'a\u003e\u003e),\n    HashJoin(HashJoinNode\u003c'a\u003e),\n    Filter(FilterNode\u003c'a\u003e),\n    OrderBy(OrderByNode\u003c'a\u003e),\n    ProjectNode(Box\u003cProjectNode\u003c'a\u003e\u003e),\n}\n\nimpl\u003c'a\u003e Prebuild\u003cQuery\u003e for PrevNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cQuery\u003e {\n        match self {\n            Self::Select(node) =\u003e node.prebuild(),\n            Self::Values(node) =\u003e node.prebuild(),\n            Self::GroupBy(node) =\u003e node.prebuild(),\n            Self::Having(node) =\u003e node.prebuild(),\n            Self::Join(node) =\u003e node.prebuild(),\n            Self::JoinConstraint(node) =\u003e node.prebuild(),\n            Self::HashJoin(node) =\u003e node.prebuild(),\n            Self::Filter(node) =\u003e node.prebuild(),\n            Self::OrderBy(node) =\u003e node.prebuild(),\n            Self::ProjectNode(node) =\u003e node.prebuild(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cSelectNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: SelectNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Select(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cValuesNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: ValuesNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Values(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cGroupByNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: GroupByNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::GroupBy(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cHavingNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: HavingNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Having(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinConstraintNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinConstraintNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::JoinConstraint(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Join(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cHashJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: HashJoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::HashJoin(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cFilterNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: FilterNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Filter(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cOrderByNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: OrderByNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::OrderBy(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cProjectNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: ProjectNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::ProjectNode(Box::new(node))\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct LimitNode\u003c'a\u003e {\n    prev_node: PrevNode\u003c'a\u003e,\n    expr: ExprNode\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e LimitNode\u003c'a\u003e {\n    pub fn new\u003cN: Into\u003cPrevNode\u003c'a\u003e\u003e, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(prev_node: N, expr: T) -\u003e Self {\n        Self {\n            prev_node: prev_node.into(),\n            expr: expr.into(),\n        }\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::LimitNode(self).alias_as(table_alias)\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cQuery\u003e for LimitNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cQuery\u003e {\n        let mut node_data = self.prev_node.prebuild()?;\n        node_data.limit = Some(self.expr.try_into()?);\n\n        Ok(node_data)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::{\n                Join, JoinConstraint, JoinExecutor, JoinOperator, Query, Select, SetExpr,\n                Statement, TableFactor, TableWithJoins,\n            },\n            ast_builder::{Build, SelectItemList, col, num, table, test},\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    #[test]\n    fn limit() {\n        // select node -\u003e limit node -\u003e build\n        let actual = table(\"Foo\").select().limit(10).build();\n        let expected = \"SELECT * FROM Foo LIMIT 10\";\n        test(actual, expected);\n\n        // group by node -\u003e limit node -\u003e build\n        let actual = table(\"Foo\").select().group_by(\"bar\").limit(10).build();\n        let expected = \"SELECT * FROM Foo GROUP BY bar LIMIT 10\";\n        test(actual, expected);\n\n        // having node -\u003e limit node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .group_by(\"bar\")\n            .having(\"bar = 10\")\n            .limit(10)\n            .build();\n        let expected = \"SELECT * FROM Foo GROUP BY bar HAVING bar = 10 LIMIT 10\";\n        test(actual, expected);\n\n        // join node -\u003e limit node -\u003e build\n        let actual = table(\"Foo\").select().join(\"Bar\").limit(10).build();\n        let expected = \"SELECT * FROM Foo JOIN Bar LIMIT 10\";\n        test(actual, expected);\n\n        // join node -\u003e limit node -\u003e build\n        let actual = table(\"Foo\").select().join_as(\"Bar\", \"B\").limit(10).build();\n        let expected = \"SELECT * FROM Foo JOIN Bar AS B LIMIT 10\";\n        test(actual, expected);\n\n        // join node -\u003e limit node -\u003e build\n        let actual = table(\"Foo\").select().left_join(\"Bar\").limit(10).build();\n        let expected = \"SELECT * FROM Foo LEFT JOIN Bar LIMIT 10\";\n        test(actual, expected);\n\n        // join node -\u003e limit node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .left_join_as(\"Bar\", \"B\")\n            .limit(10)\n            .build();\n        let expected = \"SELECT * FROM Foo LEFT JOIN Bar AS B LIMIT 10\";\n        test(actual, expected);\n\n        // group by node -\u003e limit node -\u003e build\n        let actual = table(\"Foo\").select().group_by(\"id\").limit(10).build();\n        let expected = \"SELECT * FROM Foo GROUP BY id LIMIT 10\";\n        test(actual, expected);\n\n        // having node -\u003e limit node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .group_by(\"id\")\n            .having(col(\"id\").gt(10))\n            .limit(10)\n            .build();\n        let expected = \"SELECT * FROM Foo GROUP BY id HAVING id \u003e 10 LIMIT 10\";\n        test(actual, expected);\n\n        // join constraint node -\u003e limit node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .on(\"Foo.id = Bar.id\")\n            .limit(10)\n            .build();\n        let expected = \"SELECT * FROM Foo JOIN Bar ON Foo.id = Bar.id LIMIT 10\";\n        test(actual, expected);\n\n        // filter node -\u003e limit node -\u003e build\n        let actual = table(\"World\")\n            .select()\n            .filter(col(\"id\").gt(2))\n            .limit(100)\n            .build();\n        let expected = \"SELECT * FROM World WHERE id \u003e 2 LIMIT 100\";\n        test(actual, expected);\n\n        // order by node -\u003e limit node -\u003e build\n        let actual = table(\"Hello\").select().order_by(\"score\").limit(3).build();\n        let expected = \"SELECT * FROM Hello ORDER BY score LIMIT 3\";\n        test(actual, expected);\n\n        // project node -\u003e limit node -\u003e build\n        let actual = table(\"Item\").select().project(\"*\").limit(10).build();\n        let expected = \"SELECT * FROM Item LIMIT 10\";\n        test(actual, expected);\n\n        // hash join node -\u003e limit node -\u003e build\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .limit(100)\n            .build();\n        let expected = {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"PlayerItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"PlayerItem.user_id\").try_into().unwrap(),\n                    value_expr: col(\"Player.id\").try_into().unwrap(),\n                    where_clause: None,\n                },\n            };\n            let select = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join],\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            Ok(Statement::Query(Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: Vec::new(),\n                limit: Some(num(100).try_into().unwrap()),\n                offset: None,\n            }))\n        };\n        assert_eq!(actual, expected);\n\n        // select node -\u003e limit node -\u003e derived subquery\n        let actual = table(\"Foo\")\n            .select()\n            .limit(10)\n            .alias_as(\"Sub\")\n            .select()\n            .build();\n        let expected = \"SELECT * FROM (SELECT * FROM Foo LIMIT 10) Sub\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":41},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","offset.rs"],"content":"use {\n    super::{Prebuild, ValuesNode},\n    crate::{\n        ast::Query,\n        ast_builder::{\n            ExprNode, FilterNode, GroupByNode, HashJoinNode, HavingNode, JoinConstraintNode,\n            JoinNode, OffsetLimitNode, OrderByNode, ProjectNode, QueryNode, SelectNode,\n            TableFactorNode,\n        },\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum PrevNode\u003c'a\u003e {\n    Select(SelectNode\u003c'a\u003e),\n    Values(ValuesNode\u003c'a\u003e),\n    GroupBy(GroupByNode\u003c'a\u003e),\n    Having(HavingNode\u003c'a\u003e),\n    Join(Box\u003cJoinNode\u003c'a\u003e\u003e),\n    JoinConstraint(Box\u003cJoinConstraintNode\u003c'a\u003e\u003e),\n    HashJoin(HashJoinNode\u003c'a\u003e),\n    Filter(FilterNode\u003c'a\u003e),\n    OrderBy(OrderByNode\u003c'a\u003e),\n    ProjectNode(Box\u003cProjectNode\u003c'a\u003e\u003e),\n}\n\nimpl\u003c'a\u003e Prebuild\u003cQuery\u003e for PrevNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cQuery\u003e {\n        match self {\n            Self::Select(node) =\u003e node.prebuild(),\n            Self::Values(node) =\u003e node.prebuild(),\n            Self::GroupBy(node) =\u003e node.prebuild(),\n            Self::Having(node) =\u003e node.prebuild(),\n            Self::Join(node) =\u003e node.prebuild(),\n            Self::JoinConstraint(node) =\u003e node.prebuild(),\n            Self::HashJoin(node) =\u003e node.prebuild(),\n            Self::Filter(node) =\u003e node.prebuild(),\n            Self::OrderBy(node) =\u003e node.prebuild(),\n            Self::ProjectNode(node) =\u003e node.prebuild(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cSelectNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: SelectNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Select(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cValuesNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: ValuesNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Values(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cGroupByNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: GroupByNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::GroupBy(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cHavingNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: HavingNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Having(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinConstraintNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinConstraintNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::JoinConstraint(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Join(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cHashJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: HashJoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::HashJoin(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cFilterNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: FilterNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Filter(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cOrderByNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: OrderByNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::OrderBy(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cProjectNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: ProjectNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::ProjectNode(Box::new(node))\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct OffsetNode\u003c'a\u003e {\n    prev_node: PrevNode\u003c'a\u003e,\n    expr: ExprNode\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e OffsetNode\u003c'a\u003e {\n    pub fn new\u003cN: Into\u003cPrevNode\u003c'a\u003e\u003e, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(prev_node: N, expr: T) -\u003e Self {\n        Self {\n            prev_node: prev_node.into(),\n            expr: expr.into(),\n        }\n    }\n\n    pub fn limit\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e OffsetLimitNode\u003c'a\u003e {\n        OffsetLimitNode::new(self, expr)\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::OffsetNode(self).alias_as(table_alias)\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cQuery\u003e for OffsetNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cQuery\u003e {\n        let mut node_data = self.prev_node.prebuild()?;\n        node_data.offset = Some(self.expr.try_into()?);\n\n        Ok(node_data)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::{\n                Join, JoinConstraint, JoinExecutor, JoinOperator, Query, Select, SetExpr,\n                Statement, TableFactor, TableWithJoins,\n            },\n            ast_builder::{Build, SelectItemList, col, num, table, test},\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    #[test]\n    fn offset() {\n        // select node -\u003e offset node -\u003e build\n        let actual = table(\"Foo\").select().offset(10).build();\n        let expected = \"SELECT * FROM Foo OFFSET 10\";\n        test(actual, expected);\n\n        // group by node -\u003e offset node -\u003e build\n        let actual = table(\"Foo\").select().group_by(\"id\").offset(10).build();\n        let expected = \"SELECT * FROM Foo GROUP BY id OFFSET 10\";\n        test(actual, expected);\n\n        // having node -\u003e offset node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .group_by(\"id\")\n            .having(\"id \u003e 10\")\n            .offset(10)\n            .build();\n        let expected = \"SELECT * FROM Foo GROUP BY id HAVING id \u003e 10 OFFSET 10\";\n        test(actual, expected);\n\n        // join node -\u003e offset node -\u003e build\n        let actual = table(\"Foo\").select().join(\"Bar\").offset(10).build();\n        let expected = \"SELECT * FROM Foo JOIN Bar OFFSET 10\";\n        test(actual, expected);\n\n        // join node -\u003e offset node -\u003e build\n        let actual = table(\"Foo\").select().join_as(\"Bar\", \"B\").offset(10).build();\n        let expected = \"SELECT * FROM Foo JOIN Bar AS B OFFSET 10\";\n        test(actual, expected);\n\n        // join node -\u003e offset node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .left_join(\"Bar\")\n            .on(\"Foo.id = Bar.id\")\n            .offset(10)\n            .build();\n        let expected = \"SELECT * FROM Foo LEFT JOIN Bar ON Foo.id = Bar.id OFFSET 10\";\n        test(actual, expected);\n\n        // join node -\u003e offset node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .left_join_as(\"Bar\", \"B\")\n            .on(\"Foo.id = B.id\")\n            .offset(10)\n            .build();\n        let expected = \"SELECT * FROM Foo LEFT JOIN Bar AS B ON Foo.id = B.id OFFSET 10\";\n        test(actual, expected);\n\n        // join constraint node -\u003e offset node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .on(\"Foo.id = Bar.id\")\n            .offset(10)\n            .build();\n        let expected = \"SELECT * FROM Foo JOIN Bar ON Foo.id = Bar.id OFFSET 10\";\n        test(actual, expected);\n\n        // filter node -\u003e offset node -\u003e build\n        let actual = table(\"Bar\").select().filter(\"id \u003e 2\").offset(100).build();\n        let expected = \"SELECT * FROM Bar WHERE id \u003e 2 OFFSET 100\";\n        test(actual, expected);\n\n        // project node -\u003e offset node -\u003e build\n        let actual = table(\"Item\").select().project(\"*\").offset(10).build();\n        let expected = \"SELECT * FROM Item OFFSET 10\";\n        test(actual, expected);\n\n        // hash join node -\u003e offset node -\u003e build\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .offset(100)\n            .build();\n        let expected = {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"PlayerItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"PlayerItem.user_id\").try_into().unwrap(),\n                    value_expr: col(\"Player.id\").try_into().unwrap(),\n                    where_clause: None,\n                },\n            };\n            let select = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join],\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            Ok(Statement::Query(Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: Vec::new(),\n                limit: None,\n                offset: Some(num(100).try_into().unwrap()),\n            }))\n        };\n        assert_eq!(actual, expected);\n\n        // select -\u003e offset -\u003e derived subquery\n        let actual = table(\"Foo\")\n            .select()\n            .offset(10)\n            .alias_as(\"Sub\")\n            .select()\n            .build();\n        let expected = \"SELECT * FROM (SELECT * FROM Foo OFFSET 10) Sub\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":43},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","offset_limit.rs"],"content":"use {\n    super::Prebuild,\n    crate::{\n        ast::Query,\n        ast_builder::{ExprNode, OffsetNode, QueryNode, TableFactorNode},\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum PrevNode\u003c'a\u003e {\n    Offset(OffsetNode\u003c'a\u003e),\n}\n\nimpl\u003c'a\u003e Prebuild\u003cQuery\u003e for PrevNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cQuery\u003e {\n        match self {\n            Self::Offset(node) =\u003e node.prebuild(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cOffsetNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: OffsetNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Offset(node)\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct OffsetLimitNode\u003c'a\u003e {\n    prev_node: PrevNode\u003c'a\u003e,\n    expr: ExprNode\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e OffsetLimitNode\u003c'a\u003e {\n    pub fn new\u003cN: Into\u003cPrevNode\u003c'a\u003e\u003e, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(prev_node: N, expr: T) -\u003e Self {\n        Self {\n            prev_node: prev_node.into(),\n            expr: expr.into(),\n        }\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::OffsetLimitNode(self).alias_as(table_alias)\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cQuery\u003e for OffsetLimitNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cQuery\u003e {\n        let mut node_data = self.prev_node.prebuild()?;\n        node_data.limit = Some(self.expr.try_into()?);\n\n        Ok(node_data)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{Build, table, test};\n\n    #[test]\n    fn offset_limit() {\n        // offset node -\u003e limit node -\u003e build node\n        let actual = table(\"Bar\")\n            .select()\n            .group_by(\"city\")\n            .having(\"COUNT(name) \u003c 100\")\n            .offset(1)\n            .limit(3)\n            .build();\n        let expected = \"\n            SELECT * FROM Bar\n            GROUP BY city\n            HAVING COUNT(name) \u003c 100\n            OFFSET 1\n            LIMIT 3;\n        \";\n        test(actual, expected);\n\n        // project node -\u003e offset node -\u003e limit node\n        let actual = table(\"Bar\")\n            .select()\n            .group_by(\"city\")\n            .having(\"COUNT(name) \u003c 100\")\n            .project(\"city\")\n            .offset(1)\n            .limit(3)\n            .build();\n        let expected = \"\n            SELECT city FROM Bar\n            GROUP BY city\n            HAVING COUNT(name) \u003c 100\n            OFFSET 1\n            LIMIT 3;\n        \";\n        test(actual, expected);\n\n        // select -\u003e offset -\u003e limit -\u003e derived subquery\n        let actual = table(\"Bar\")\n            .select()\n            .group_by(\"city\")\n            .having(\"COUNT(name) \u003c 100\")\n            .offset(1)\n            .limit(3)\n            .alias_as(\"Sub\")\n            .select()\n            .build();\n        let expected = \"\n            SELECT * FROM (\n                SELECT * FROM Bar\n                GROUP BY city\n                HAVING COUNT(name) \u003c 100\n                OFFSET 1\n                LIMIT 3\n            ) Sub\n        \";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","order_by.rs"],"content":"use {\n    super::{Prebuild, ValuesNode},\n    crate::{\n        ast::Query,\n        ast_builder::{\n            ExprNode, FilterNode, GroupByNode, HashJoinNode, HavingNode, JoinConstraintNode,\n            JoinNode, LimitNode, OffsetNode, OrderByExprList, ProjectNode, QueryNode, SelectNode,\n            TableFactorNode,\n        },\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum PrevNode\u003c'a\u003e {\n    Select(SelectNode\u003c'a\u003e),\n    Having(HavingNode\u003c'a\u003e),\n    GroupBy(GroupByNode\u003c'a\u003e),\n    Filter(FilterNode\u003c'a\u003e),\n    JoinNode(JoinNode\u003c'a\u003e),\n    JoinConstraint(JoinConstraintNode\u003c'a\u003e),\n    HashJoin(Box\u003cHashJoinNode\u003c'a\u003e\u003e),\n    ProjectNode(Box\u003cProjectNode\u003c'a\u003e\u003e),\n    Values(ValuesNode\u003c'a\u003e),\n}\n\nimpl\u003c'a\u003e Prebuild\u003cQuery\u003e for PrevNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cQuery\u003e {\n        match self {\n            Self::Select(node) =\u003e node.prebuild(),\n            Self::Having(node) =\u003e node.prebuild(),\n            Self::GroupBy(node) =\u003e node.prebuild(),\n            Self::Filter(node) =\u003e node.prebuild(),\n            Self::JoinNode(node) =\u003e node.prebuild(),\n            Self::JoinConstraint(node) =\u003e node.prebuild(),\n            Self::HashJoin(node) =\u003e node.prebuild(),\n            Self::ProjectNode(node) =\u003e node.prebuild(),\n            Self::Values(node) =\u003e node.prebuild(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cSelectNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: SelectNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Select(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cHavingNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: HavingNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Having(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cGroupByNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: GroupByNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::GroupBy(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cFilterNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: FilterNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Filter(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::JoinNode(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinConstraintNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinConstraintNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::JoinConstraint(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cHashJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: HashJoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::HashJoin(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cProjectNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: ProjectNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::ProjectNode(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cValuesNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: ValuesNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Values(node)\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct OrderByNode\u003c'a\u003e {\n    prev_node: PrevNode\u003c'a\u003e,\n    expr_list: OrderByExprList\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e OrderByNode\u003c'a\u003e {\n    pub fn new\u003cN: Into\u003cPrevNode\u003c'a\u003e\u003e, T: Into\u003cOrderByExprList\u003c'a\u003e\u003e\u003e(\n        prev_node: N,\n        expr_list: T,\n    ) -\u003e Self {\n        Self {\n            prev_node: prev_node.into(),\n            expr_list: expr_list.into(),\n        }\n    }\n\n    pub fn offset\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e OffsetNode\u003c'a\u003e {\n        OffsetNode::new(self, expr)\n    }\n\n    pub fn limit\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e LimitNode\u003c'a\u003e {\n        LimitNode::new(self, expr)\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::OrderByNode(self).alias_as(table_alias)\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cQuery\u003e for OrderByNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cQuery\u003e {\n        let mut node_data = self.prev_node.prebuild()?;\n        node_data.order_by = self.expr_list.try_into()?;\n\n        Ok(node_data)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::{\n                Join, JoinConstraint, JoinExecutor, JoinOperator, Query, Select, SetExpr,\n                Statement, TableFactor, TableWithJoins,\n            },\n            ast_builder::{Build, ExprNode, OrderByExprList, SelectItemList, col, table, test},\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    #[test]\n    fn order_by() {\n        // select node -\u003e order by node(exprs vec) -\u003e build\n        let actual = table(\"Foo\").select().order_by(vec![\"name desc\"]).build();\n        let expected = \"\n            SELECT * FROM Foo\n            ORDER BY name DESC\n        \";\n        test(actual, expected);\n\n        // select node -\u003e order by node(exprs string) -\u003e build\n        let actual = table(\"Bar\")\n            .select()\n            .order_by(\"name asc, id desc, country\")\n            .offset(10)\n            .build();\n        let expected = \"\n                SELECT * FROM Bar\n                ORDER BY name asc, id desc, country\n                OFFSET 10\n            \";\n        test(actual, expected);\n\n        // group by node -\u003e order by node -\u003e build\n        let actual = table(\"Bar\")\n            .select()\n            .group_by(\"name\")\n            .order_by(vec![\"id desc\"])\n            .build();\n        let expected = \"\n                SELECT * FROM Bar\n                GROUP BY name\n                ORDER BY id desc\n            \";\n        test(actual, expected);\n\n        // having node -\u003e order by node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .group_by(\"city\")\n            .having(\"COUNT(name) \u003c 100\")\n            .order_by(ExprNode::Identifier(\"name\".into()))\n            .offset(2)\n            .limit(3)\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            GROUP BY city\n            HAVING COUNT(name) \u003c 100\n            ORDER BY name\n            OFFSET 2\n            LIMIT 3\n        \";\n        test(actual, expected);\n\n        // filter node -\u003e order by node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .filter(\"id \u003e 10\")\n            .filter(\"id \u003c 20\")\n            .order_by(\"id asc\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            WHERE id \u003e 10 AND id \u003c 20\n            ORDER BY id ASC\";\n        test(actual, expected);\n\n        // project node -\u003e order by node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .project(\"id\")\n            .order_by(\"id asc\")\n            .build();\n        let expected = \"SELECT id FROM Foo ORDER BY id asc\";\n        test(actual, expected);\n\n        // join node -\u003e order by node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .order_by(\"Foo.id desc\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            JOIN Bar\n            ORDER BY Foo.id desc\n        \";\n        test(actual, expected);\n\n        // join constraint node -\u003e order by node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .join(\"Bar\")\n            .on(\"Foo.id = Bar.id\")\n            .order_by(\"Foo.id desc\")\n            .build();\n        let expected = \"\n            SELECT * FROM Foo\n            JOIN Bar ON Foo.id = Bar.id\n            ORDER BY Foo.id desc\n        \";\n        test(actual, expected);\n\n        // hash join node -\u003e order by node -\u003e build\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .order_by(\"Player.score DESC\")\n            .build();\n        let expected = {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"PlayerItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"PlayerItem.user_id\").try_into().unwrap(),\n                    value_expr: col(\"Player.id\").try_into().unwrap(),\n                    where_clause: None,\n                },\n            };\n            let select = Select {\n                projection: SelectItemList::from(\"*\").try_into().unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join],\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            Ok(Statement::Query(Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: OrderByExprList::from(\"Player.score DESC\")\n                    .try_into()\n                    .unwrap(),\n                limit: None,\n                offset: None,\n            }))\n        };\n        assert_eq!(actual, expected);\n\n        // select -\u003e order by node -\u003e derived subquery\n        let actual = table(\"Foo\")\n            .select()\n            .order_by(vec![\"name desc\"])\n            .alias_as(\"Sub\")\n            .select()\n            .build();\n        let expected = \"\n            SELECT * FROM (\n                SELECT * FROM Foo\n                ORDER BY name DESC\n            ) Sub\n        \";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":42},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","project.rs"],"content":"use {\n    super::Prebuild,\n    crate::{\n        ast::Select,\n        ast_builder::{\n            ExprNode, FilterNode, GroupByNode, HashJoinNode, HavingNode, JoinConstraintNode,\n            JoinNode, LimitNode, OffsetNode, OrderByExprList, OrderByNode, QueryNode,\n            SelectItemList, SelectNode, TableFactorNode,\n        },\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum PrevNode\u003c'a\u003e {\n    Select(SelectNode\u003c'a\u003e),\n    GroupBy(GroupByNode\u003c'a\u003e),\n    Having(HavingNode\u003c'a\u003e),\n    Join(Box\u003cJoinNode\u003c'a\u003e\u003e),\n    JoinConstraint(Box\u003cJoinConstraintNode\u003c'a\u003e\u003e),\n    HashJoin(Box\u003cHashJoinNode\u003c'a\u003e\u003e),\n    Filter(FilterNode\u003c'a\u003e),\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for PrevNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        match self {\n            Self::Select(node) =\u003e node.prebuild(),\n            Self::GroupBy(node) =\u003e node.prebuild(),\n            Self::Having(node) =\u003e node.prebuild(),\n            Self::Join(node) =\u003e node.prebuild(),\n            Self::JoinConstraint(node) =\u003e node.prebuild(),\n            Self::HashJoin(node) =\u003e node.prebuild(),\n            Self::Filter(node) =\u003e node.prebuild(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cSelectNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: SelectNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Select(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cGroupByNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: GroupByNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::GroupBy(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cHavingNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: HavingNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Having(node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Join(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cJoinConstraintNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: JoinConstraintNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::JoinConstraint(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cHashJoinNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: HashJoinNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::HashJoin(Box::new(node))\n    }\n}\n\nimpl\u003c'a\u003e From\u003cFilterNode\u003c'a\u003e\u003e for PrevNode\u003c'a\u003e {\n    fn from(node: FilterNode\u003c'a\u003e) -\u003e Self {\n        PrevNode::Filter(node)\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct ProjectNode\u003c'a\u003e {\n    prev_node: PrevNode\u003c'a\u003e,\n    select_items_list: Vec\u003cSelectItemList\u003c'a\u003e\u003e,\n}\n\nimpl\u003c'a\u003e ProjectNode\u003c'a\u003e {\n    pub fn new\u003cN: Into\u003cPrevNode\u003c'a\u003e\u003e, T: Into\u003cSelectItemList\u003c'a\u003e\u003e\u003e(\n        prev_node: N,\n        select_items: T,\n    ) -\u003e Self {\n        Self {\n            prev_node: prev_node.into(),\n            select_items_list: vec![select_items.into()],\n        }\n    }\n\n    pub fn project\u003cT: Into\u003cSelectItemList\u003c'a\u003e\u003e\u003e(mut self, select_items: T) -\u003e Self {\n        self.select_items_list.push(select_items.into());\n\n        self\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::ProjectNode(self).alias_as(table_alias)\n    }\n\n    pub fn order_by\u003cT: Into\u003cOrderByExprList\u003c'a\u003e\u003e\u003e(self, order_by_exprs: T) -\u003e OrderByNode\u003c'a\u003e {\n        OrderByNode::new(self, order_by_exprs)\n    }\n\n    pub fn offset\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e OffsetNode\u003c'a\u003e {\n        OffsetNode::new(self, expr)\n    }\n\n    pub fn limit\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e LimitNode\u003c'a\u003e {\n        LimitNode::new(self, expr)\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for ProjectNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        let mut query: Select = self.prev_node.prebuild()?;\n        query.projection = self\n            .select_items_list\n            .into_iter()\n            .map(TryInto::try_into)\n            .collect::\u003cResult\u003cVec\u003cVec\u003c_\u003e\u003e\u003e\u003e()?\n            .into_iter()\n            .flatten()\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        Ok(query)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::{\n                Join, JoinConstraint, JoinExecutor, JoinOperator, Query, Select, SetExpr,\n                Statement, TableFactor, TableWithJoins,\n            },\n            ast_builder::{Build, SelectItemList, col, table, test},\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    #[test]\n    fn project() {\n        // select node -\u003e project node -\u003e build\n        let actual = table(\"Good\").select().project(\"id\").build();\n        let expected = \"SELECT id FROM Good\";\n        test(actual, expected);\n\n        // select node -\u003e project node -\u003e build\n        let actual = table(\"Group\").select().project(\"*, Group.*, name\").build();\n        let expected = \"SELECT *, Group.*, name FROM Group\";\n        test(actual, expected);\n\n        // project node -\u003e project node -\u003e build\n        let actual = table(\"Foo\")\n            .select()\n            .project(vec![\"col1\", \"col2\"])\n            .project(\"col3\")\n            .project(vec![\"col4\".into(), col(\"col5\")])\n            .project(col(\"col6\"))\n            .project(\"col7 as hello\")\n            .build();\n        let expected = \"\n            SELECT\n                col1, col2, col3,\n                col4, col5, col6,\n                col7 as hello\n            FROM\n                Foo\n        \";\n        test(actual, expected);\n\n        // select node -\u003e project node -\u003e build\n        let actual = table(\"Aliased\")\n            .select()\n            .project(\"1 + 1 as col1, col2\")\n            .build();\n        let expected = \"SELECT 1 + 1 as col1, col2 FROM Aliased\";\n        test(actual, expected);\n    }\n\n    #[test]\n    fn prev_nodes() {\n        // select node -\u003e project node -\u003e build\n        let actual = table(\"Foo\").select().project(\"*\").build();\n        let expected = \"SELECT * FROM Foo\";\n        test(actual, expected);\n\n        // group by node -\u003e project node -\u003e build\n        let actual = table(\"Bar\")\n            .select()\n            .group_by(\"city\")\n            .project(\"city, COUNT(name) as num\")\n            .build();\n        let expected = \"\n            SELECT\n              city, COUNT(name) as num\n            FROM Bar\n            GROUP BY city\n        \";\n        test(actual, expected);\n\n        // having node -\u003e project node -\u003e build\n        let actual = table(\"Cat\")\n            .select()\n            .filter(r#\"type = \"cute\"\"#)\n            .group_by(\"age\")\n            .having(\"SUM(length) \u003c 1000\")\n            .project(col(\"age\"))\n            .project(\"SUM(length)\")\n            .build();\n        let expected = r#\"\n            SELECT age, SUM(length)\n            FROM Cat\n            WHERE type = \"cute\"\n            GROUP BY age\n            HAVING SUM(length) \u003c 1000;\n        \"#;\n        test(actual, expected);\n\n        // hash join node -\u003e project node -\u003e build\n        let actual = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .project(\"Player.name, PlayerItem.name\")\n            .build();\n        let expected = {\n            let join = Join {\n                relation: TableFactor::Table {\n                    name: \"PlayerItem\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                join_operator: JoinOperator::Inner(JoinConstraint::None),\n                join_executor: JoinExecutor::Hash {\n                    key_expr: col(\"PlayerItem.user_id\").try_into().unwrap(),\n                    value_expr: col(\"Player.id\").try_into().unwrap(),\n                    where_clause: None,\n                },\n            };\n            let select = Select {\n                projection: SelectItemList::from(\"Player.name, PlayerItem.name\")\n                    .try_into()\n                    .unwrap(),\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: vec![join],\n                },\n                selection: None,\n                group_by: Vec::new(),\n                having: None,\n            };\n\n            Ok(Statement::Query(Query {\n                body: SetExpr::Select(Box::new(select)),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            }))\n        };\n        assert_eq!(actual, expected);\n\n        // select -\u003e project -\u003e derived subquery\n        let actual = table(\"Foo\")\n            .select()\n            .project(\"id\")\n            .alias_as(\"Sub\")\n            .select()\n            .build();\n        let expected = \"SELECT * FROM (SELECT id FROM Foo) Sub\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":48},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","root.rs"],"content":"use {\n    super::{Prebuild, join::JoinOperatorType},\n    crate::{\n        ast::{\n            AstLiteral, Expr, Query, Select, SelectItem, TableAlias, TableFactor, TableWithJoins,\n        },\n        ast_builder::{\n            ExprList, ExprNode, FilterNode, GroupByNode, JoinNode, LimitNode, OffsetNode,\n            OrderByExprList, OrderByNode, ProjectNode, QueryNode, SelectItemList, TableFactorNode,\n            table_factor::TableType,\n        },\n        result::Result,\n        translate::alias_or_name,\n    },\n};\n\n#[derive(Clone, Debug)]\npub struct SelectNode\u003c'a\u003e {\n    table_node: TableFactorNode\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e SelectNode\u003c'a\u003e {\n    pub fn new(table_node: TableFactorNode\u003c'a\u003e) -\u003e Self {\n        Self { table_node }\n    }\n\n    pub fn filter\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e FilterNode\u003c'a\u003e {\n        FilterNode::new(self, expr)\n    }\n\n    pub fn group_by\u003cT: Into\u003cExprList\u003c'a\u003e\u003e\u003e(self, expr_list: T) -\u003e GroupByNode\u003c'a\u003e {\n        GroupByNode::new(self, expr_list)\n    }\n\n    pub fn offset\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e OffsetNode\u003c'a\u003e {\n        OffsetNode::new(self, expr)\n    }\n\n    pub fn limit\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e LimitNode\u003c'a\u003e {\n        LimitNode::new(self, expr)\n    }\n\n    pub fn project\u003cT: Into\u003cSelectItemList\u003c'a\u003e\u003e\u003e(self, select_items: T) -\u003e ProjectNode\u003c'a\u003e {\n        ProjectNode::new(self, select_items)\n    }\n\n    pub fn order_by\u003cT: Into\u003cOrderByExprList\u003c'a\u003e\u003e\u003e(self, order_by_exprs: T) -\u003e OrderByNode\u003c'a\u003e {\n        OrderByNode::new(self, order_by_exprs)\n    }\n\n    pub fn join(self, table_name: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(self, table_name.to_owned(), None, JoinOperatorType::Inner)\n    }\n\n    pub fn join_as(self, table_name: \u0026str, alias: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(\n            self,\n            table_name.to_owned(),\n            Some(alias.to_owned()),\n            JoinOperatorType::Inner,\n        )\n    }\n\n    pub fn left_join(self, table_name: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(self, table_name.to_owned(), None, JoinOperatorType::Left)\n    }\n\n    pub fn left_join_as(self, table_name: \u0026str, alias: \u0026str) -\u003e JoinNode\u003c'a\u003e {\n        JoinNode::new(\n            self,\n            table_name.to_owned(),\n            Some(alias.to_owned()),\n            JoinOperatorType::Left,\n        )\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::SelectNode(self).alias_as(table_alias)\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cSelect\u003e for SelectNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cSelect\u003e {\n        let alias = self.table_node.table_alias.map(|name| TableAlias {\n            name,\n            columns: Vec::new(),\n        });\n\n        let index = match self.table_node.index {\n            Some(index) =\u003e Some(index.prebuild()?),\n            None =\u003e None,\n        };\n\n        let relation = match self.table_node.table_type {\n            TableType::Table =\u003e TableFactor::Table {\n                name: self.table_node.table_name,\n                alias,\n                index,\n            },\n            TableType::Dictionary(dict) =\u003e TableFactor::Dictionary {\n                dict,\n                alias: alias_or_name(alias, self.table_node.table_name),\n            },\n            TableType::Series(args) =\u003e TableFactor::Series {\n                alias: alias_or_name(alias, self.table_node.table_name),\n                size: args.try_into()?,\n            },\n            TableType::Derived { subquery, alias } =\u003e TableFactor::Derived {\n                subquery: Query::try_from(*subquery)?,\n                alias: TableAlias {\n                    name: alias,\n                    columns: Vec::new(),\n                },\n            },\n        };\n\n        let from = TableWithJoins {\n            relation,\n            joins: Vec::new(),\n        };\n\n        Ok(Select {\n            projection: vec![SelectItem::Wildcard],\n            from,\n            selection: None,\n            group_by: Vec::new(),\n            having: None,\n        })\n    }\n}\n\npub fn select\u003c'a\u003e() -\u003e SelectNode\u003c'a\u003e {\n    SelectNode {\n        table_node: TableFactorNode {\n            table_name: \"Series\".to_owned(),\n            table_type: TableType::Series(Expr::Literal(AstLiteral::Number(1.into())).into()),\n            table_alias: None,\n            index: None,\n        },\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{Build, select, table, test};\n\n    #[test]\n    fn select_root() {\n        // select node -\u003e build\n        let actual = table(\"App\").select().build();\n        let expected = \"SELECT * FROM App\";\n        test(actual, expected);\n\n        let actual = table(\"Item\").alias_as(\"i\").select().build();\n        let expected = \"SELECT * FROM Item i\";\n        test(actual, expected);\n\n        // select -\u003e derived subquery\n        let actual = table(\"App\").select().alias_as(\"Sub\").select().build();\n        let expected = \"SELECT * FROM (SELECT * FROM App) Sub\";\n        test(actual, expected);\n\n        // select without table\n        let actual = select().project(\"1 + 1\").build();\n        let expected = \"SELECT 1 + 1\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":52},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select","values.rs"],"content":"use crate::{\n    ast::{Expr, Query, SetExpr, Values},\n    ast_builder::{\n        ExprList, ExprNode, LimitNode, OffsetNode, OrderByExprList, OrderByNode, QueryNode,\n        TableFactorNode, select::Prebuild,\n    },\n    result::Result,\n};\n\n#[derive(Clone, Debug)]\npub struct ValuesNode\u003c'a\u003e {\n    pub values: Vec\u003cExprList\u003c'a\u003e\u003e,\n}\n\nimpl\u003c'a\u003e ValuesNode\u003c'a\u003e {\n    pub fn order_by\u003cT: Into\u003cOrderByExprList\u003c'a\u003e\u003e\u003e(self, order_by_exprs: T) -\u003e OrderByNode\u003c'a\u003e {\n        OrderByNode::new(self, order_by_exprs)\n    }\n\n    pub fn offset\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e OffsetNode\u003c'a\u003e {\n        OffsetNode::new(self, expr)\n    }\n\n    pub fn limit\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e LimitNode\u003c'a\u003e {\n        LimitNode::new(self, expr)\n    }\n\n    pub fn alias_as(self, table_alias: \u0026'a str) -\u003e TableFactorNode\u003c'a\u003e {\n        QueryNode::ValuesNode(self).alias_as(table_alias)\n    }\n}\n\nimpl\u003c'a\u003e Prebuild\u003cQuery\u003e for ValuesNode\u003c'a\u003e {\n    fn prebuild(self) -\u003e Result\u003cQuery\u003e {\n        let values = self\n            .values\n            .into_iter()\n            .map(TryInto::try_into)\n            .collect::\u003cResult\u003cVec\u003cVec\u003cExpr\u003e\u003e\u003e\u003e()?;\n\n        let body = SetExpr::Values(Values(values));\n\n        Ok(Query {\n            body,\n            order_by: Vec::new(),\n            limit: None,\n            offset: None,\n        })\n    }\n}\n\npub fn values\u003c'a, T: Into\u003cExprList\u003c'a\u003e\u003e\u003e(values: Vec\u003cT\u003e) -\u003e ValuesNode\u003c'a\u003e {\n    let values: Vec\u003cExprList\u003e = values.into_iter().map(Into::into).collect();\n\n    ValuesNode { values }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{Build, num, test};\n\n    #[test]\n    fn values() {\n        use crate::ast_builder::values;\n\n        let actual = values(vec![vec![num(7)]]).build();\n        let expected = \"VALUES(7)\";\n        test(actual, expected);\n\n        let actual = values(vec![\"1, 'a'\", \"2, 'b'\"]).build();\n        let expected = \"VALUES(1, 'a'), (2, 'b')\";\n        test(actual, expected);\n\n        let actual = values(vec![\"1, 'a'\", \"2, 'b'\"])\n            .order_by(vec![\"column1 desc\"])\n            .build();\n        let expected = \"VALUES(1, 'a'), (2, 'b') ORDER BY column1 desc\";\n        test(actual, expected);\n\n        let actual = values(vec![\"1, 'a'\", \"2, 'b'\"]).offset(1).build();\n        let expected = \"VALUES(1, 'a'), (2, 'b') offset 1\";\n        test(actual, expected);\n\n        let actual = values(vec![\"1, 'a'\", \"2, 'b'\"]).limit(1).build();\n        let expected = \"VALUES(1, 'a'), (2, 'b') limit 1\";\n        test(actual, expected);\n\n        let actual = values(vec![\"1, 'a'\", \"2, 'b'\"]).offset(1).limit(1).build();\n        let expected = \"VALUES(1, 'a'), (2, 'b') offset 1 limit 1\";\n        test(actual, expected);\n\n        let actual = values(vec![\"1, 'a'\", \"2, 'b'\"])\n            .alias_as(\"Sub\")\n            .select()\n            .build();\n        let expected = \"SELECT * FROM (VALUES(1, 'a'), (2, 'b')) AS Sub\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select.rs"],"content":"mod filter;\nmod group_by;\nmod having;\nmod join;\nmod limit;\nmod offset;\nmod offset_limit;\nmod order_by;\nmod project;\nmod root;\nmod values;\n\nuse {\n    super::Build,\n    crate::{\n        ast::{Query, Select, SetExpr, Statement},\n        result::Result,\n    },\n};\npub use {\n    filter::FilterNode,\n    group_by::GroupByNode,\n    having::HavingNode,\n    join::{HashJoinNode, JoinConstraintNode, JoinNode},\n    limit::LimitNode,\n    offset::OffsetNode,\n    offset_limit::OffsetLimitNode,\n    order_by::OrderByNode,\n    project::ProjectNode,\n    root::{SelectNode, select},\n    values::{ValuesNode, values},\n};\n\npub trait Prebuild\u003cT\u003e {\n    fn prebuild(self) -\u003e Result\u003cT\u003e;\n}\n\nimpl\u003cT: Prebuild\u003cSelect\u003e\u003e Prebuild\u003cQuery\u003e for T {\n    fn prebuild(self) -\u003e Result\u003cQuery\u003e {\n        let select = self.prebuild()?;\n        let body = SetExpr::Select(Box::new(select));\n        let query = Query {\n            body,\n            order_by: Vec::new(),\n            limit: None,\n            offset: None,\n        };\n\n        Ok(query)\n    }\n}\n\nimpl\u003cT: Prebuild\u003cQuery\u003e\u003e Build for T {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let query = self.prebuild()?;\n\n        Ok(Statement::Query(query))\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select_item.rs"],"content":"use {\n    super::ExprNode,\n    crate::{\n        ast::{Expr, SelectItem, ToSqlUnquoted},\n        ast_builder::ExprWithAliasNode,\n        parse_sql::parse_select_item,\n        result::{Error, Result},\n        translate::translate_select_item,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum SelectItemNode\u003c'a\u003e {\n    SelectItem(SelectItem),\n    Expr(ExprNode\u003c'a\u003e),\n    Text(String),\n    ExprWithAliasNode(ExprWithAliasNode\u003c'a\u003e),\n}\n\nimpl\u003c'a\u003e From\u003cSelectItem\u003e for SelectItemNode\u003c'a\u003e {\n    fn from(select_item: SelectItem) -\u003e Self {\n        Self::SelectItem(select_item)\n    }\n}\n\nimpl\u003c'a\u003e From\u003cExprNode\u003c'a\u003e\u003e for SelectItemNode\u003c'a\u003e {\n    fn from(expr_node: ExprNode\u003c'a\u003e) -\u003e Self {\n        Self::Expr(expr_node)\n    }\n}\n\nimpl\u003c'a\u003e From\u003c\u0026str\u003e for SelectItemNode\u003c'a\u003e {\n    fn from(select_item: \u0026str) -\u003e Self {\n        Self::Text(select_item.to_owned())\n    }\n}\n\nimpl\u003c'a\u003e From\u003cExprWithAliasNode\u003c'a\u003e\u003e for SelectItemNode\u003c'a\u003e {\n    fn from(expr_node: ExprWithAliasNode\u003c'a\u003e) -\u003e Self {\n        Self::ExprWithAliasNode(expr_node)\n    }\n}\n\nimpl\u003c'a\u003e TryFrom\u003cSelectItemNode\u003c'a\u003e\u003e for SelectItem {\n    type Error = Error;\n\n    fn try_from(select_item_node: SelectItemNode\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        match select_item_node {\n            SelectItemNode::SelectItem(select_item) =\u003e Ok(select_item),\n            SelectItemNode::Text(select_item) =\u003e {\n                parse_select_item(select_item).and_then(|item| translate_select_item(\u0026item))\n            }\n            SelectItemNode::Expr(expr_node) =\u003e {\n                let expr = Expr::try_from(expr_node)?;\n                let label = expr.to_sql_unquoted();\n\n                Ok(SelectItem::Expr { expr, label })\n            }\n            SelectItemNode::ExprWithAliasNode(alias_node) =\u003e {\n                let (expr, label) = alias_node.try_into()?;\n\n                Ok(SelectItem::Expr { expr, label })\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::SelectItem,\n            ast_builder::{SelectItemNode, col},\n            parse_sql::parse_select_item,\n            translate::translate_select_item,\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    fn test(actual: SelectItemNode, expected: \u0026str) {\n        let parsed = \u0026parse_select_item(expected).expect(expected);\n        let expected = translate_select_item(parsed);\n        assert_eq!(actual.try_into(), expected);\n    }\n\n    #[test]\n    fn select_item() {\n        let actual = SelectItem::Wildcard.into();\n        let expected = \"*\";\n        test(actual, expected);\n\n        let actual = \"Foo.*\".into();\n        let expected = \"Foo.*\";\n        test(actual, expected);\n\n        let actual = \"id as hello\".into();\n        let expected = \"id as hello\";\n        test(actual, expected);\n\n        let actual = col(\"id\").into();\n        let expected = \"id\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","select_item_list.rs"],"content":"use {\n    super::{ExprNode, SelectItemNode},\n    crate::{\n        ast::SelectItem,\n        ast_builder::ExprWithAliasNode,\n        parse_sql::parse_select_items,\n        result::{Error, Result},\n        translate::translate_select_item,\n    },\n};\n\n#[derive(Clone, Debug)]\npub enum SelectItemList\u003c'a\u003e {\n    Text(String),\n    SelectItems(Vec\u003cSelectItemNode\u003c'a\u003e\u003e),\n}\n\nimpl\u003c'a\u003e From\u003c\u0026str\u003e for SelectItemList\u003c'a\u003e {\n    fn from(exprs: \u0026str) -\u003e Self {\n        SelectItemList::Text(exprs.to_owned())\n    }\n}\n\nimpl\u003c'a\u003e From\u003cVec\u003c\u0026str\u003e\u003e for SelectItemList\u003c'a\u003e {\n    fn from(select_items: Vec\u003c\u0026str\u003e) -\u003e Self {\n        SelectItemList::SelectItems(select_items.into_iter().map(Into::into).collect())\n    }\n}\n\nimpl\u003c'a\u003e From\u003cExprNode\u003c'a\u003e\u003e for SelectItemList\u003c'a\u003e {\n    fn from(expr_node: ExprNode\u003c'a\u003e) -\u003e Self {\n        SelectItemList::SelectItems(vec![expr_node.into()])\n    }\n}\n\nimpl\u003c'a\u003e From\u003cVec\u003cExprNode\u003c'a\u003e\u003e\u003e for SelectItemList\u003c'a\u003e {\n    fn from(expr_nodes: Vec\u003cExprNode\u003c'a\u003e\u003e) -\u003e Self {\n        SelectItemList::SelectItems(expr_nodes.into_iter().map(Into::into).collect())\n    }\n}\n\nimpl\u003c'a\u003e From\u003cExprWithAliasNode\u003c'a\u003e\u003e for SelectItemList\u003c'a\u003e {\n    fn from(expr_node: ExprWithAliasNode\u003c'a\u003e) -\u003e Self {\n        SelectItemList::SelectItems(vec![expr_node.into()])\n    }\n}\n\nimpl\u003c'a\u003e From\u003cVec\u003cExprWithAliasNode\u003c'a\u003e\u003e\u003e for SelectItemList\u003c'a\u003e {\n    fn from(expr_nodes: Vec\u003cExprWithAliasNode\u003c'a\u003e\u003e) -\u003e Self {\n        SelectItemList::SelectItems(expr_nodes.into_iter().map(Into::into).collect())\n    }\n}\n\nimpl\u003c'a\u003e TryFrom\u003cSelectItemList\u003c'a\u003e\u003e for Vec\u003cSelectItem\u003e {\n    type Error = Error;\n\n    fn try_from(select_items: SelectItemList\u003c'a\u003e) -\u003e Result\u003cSelf\u003e {\n        match select_items {\n            SelectItemList::Text(items) =\u003e parse_select_items(items)?\n                .iter()\n                .map(translate_select_item)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e(),\n            SelectItemList::SelectItems(items) =\u003e items\n                .into_iter()\n                .map(TryInto::try_into)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::SelectItem,\n            ast_builder::{SelectItemList, col, expr},\n            parse_sql::parse_select_items,\n            result::Result,\n            translate::translate_select_item,\n        },\n        pretty_assertions::assert_eq,\n    };\n\n    fn test(actual: SelectItemList, expected: \u0026str) {\n        let parsed = parse_select_items(expected).expect(expected);\n        let expected = parsed\n            .iter()\n            .map(translate_select_item)\n            .collect::\u003cResult\u003cVec\u003cSelectItem\u003e\u003e\u003e();\n\n        assert_eq!(actual.try_into(), expected);\n    }\n\n    #[test]\n    fn select_item_list() {\n        let actual = \"id, name\".into();\n        let expected = \"id, name\";\n        test(actual, expected);\n\n        let actual = vec![\"id\", \"name\"].into();\n        let expected = \"id, name\";\n        test(actual, expected);\n\n        let actual = col(\"id\").into();\n        let expected = \"id\";\n        test(actual, expected);\n\n        let actual = vec![col(\"id\"), \"name\".into()].into();\n        let expected = \"id, name\";\n        test(actual, expected);\n\n        let actual = col(\"id\").sub(1).alias_as(\"new_id\").into();\n        let expected = \"id - 1 AS new_id\";\n        test(actual, expected);\n\n        let actual = vec![\n            col(\"age\").avg().alias_as(\"avg_age\"),\n            expr(\"name || ':foo'\").alias_as(\"res\"),\n        ]\n        .into();\n        let expected = \"AVG(age) AS avg_age, name || ':foo' AS res\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","show_columns.rs"],"content":"use {\n    super::Build,\n    crate::{ast::Statement, result::Result},\n};\n\n#[derive(Clone, Debug)]\npub struct ShowColumnsNode {\n    table_name: String,\n}\n\nimpl ShowColumnsNode {\n    pub fn new(table_name: String) -\u003e Self {\n        Self { table_name }\n    }\n}\n\nimpl Build for ShowColumnsNode {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let table_name = self.table_name;\n        Ok(Statement::ShowColumns { table_name })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{Build, table, test};\n\n    #[test]\n    fn show_columns() {\n        let actual = table(\"Foo\").show_columns().build();\n        let expected = \"SHOW COLUMNS FROM Foo\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","table_factor.rs"],"content":"use {\n    super::{ExprNode, IndexItemNode, QueryNode, SelectNode},\n    crate::ast::Dictionary,\n};\n\n#[derive(Clone, Debug)]\npub enum TableType\u003c'a\u003e {\n    Table,\n    Series(ExprNode\u003c'a\u003e),\n    Dictionary(Dictionary),\n    Derived {\n        subquery: Box\u003cQueryNode\u003c'a\u003e\u003e,\n        alias: String,\n    },\n}\n\n#[derive(Clone, Debug)]\npub struct TableFactorNode\u003c'a\u003e {\n    pub table_name: String,\n    pub table_type: TableType\u003c'a\u003e,\n    pub table_alias: Option\u003cString\u003e,\n    pub index: Option\u003cIndexItemNode\u003c'a\u003e\u003e,\n}\n\nimpl\u003c'a\u003e TableFactorNode\u003c'a\u003e {\n    pub fn select(self) -\u003e SelectNode\u003c'a\u003e {\n        SelectNode::new(self)\n    }\n}\n\npub fn glue_objects() -\u003e TableFactorNode\u003c'static\u003e {\n    TableFactorNode {\n        table_name: \"GLUE_OBJECTS\".to_owned(),\n        table_type: TableType::Dictionary(Dictionary::GlueObjects),\n        table_alias: None,\n        index: None,\n    }\n}\n\npub fn glue_tables() -\u003e TableFactorNode\u003c'static\u003e {\n    TableFactorNode {\n        table_name: \"GLUE_TABLES\".to_owned(),\n        table_type: TableType::Dictionary(Dictionary::GlueTables),\n        table_alias: None,\n        index: None,\n    }\n}\n\npub fn glue_indexes() -\u003e TableFactorNode\u003c'static\u003e {\n    TableFactorNode {\n        table_name: \"GLUE_INDEXES\".to_owned(),\n        table_type: TableType::Dictionary(Dictionary::GlueIndexes),\n        table_alias: None,\n        index: None,\n    }\n}\n\npub fn glue_table_columns() -\u003e TableFactorNode\u003c'static\u003e {\n    TableFactorNode {\n        table_name: \"GLUE_TABLE_COLUMNS\".to_owned(),\n        table_type: TableType::Dictionary(Dictionary::GlueTableColumns),\n        table_alias: None,\n        index: None,\n    }\n}\n\npub fn series\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(args: T) -\u003e TableFactorNode\u003c'a\u003e {\n    TableFactorNode {\n        table_name: \"SERIES\".to_owned(),\n        table_type: TableType::Series(args.into()),\n        table_alias: None,\n        index: None,\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","table_name.rs"],"content":"use super::{\n    AlterTableNode, CreateIndexNode, CreateTableNode, DeleteNode, DropIndexNode, DropTableNode,\n    IndexItemNode, InsertNode, OrderByExprNode, SelectNode, ShowColumnsNode, TableFactorNode,\n    UpdateNode, table_factor::TableType,\n};\n#[derive(Clone, Debug)]\npub struct TableNameNode {\n    pub table_name: String,\n}\n\nimpl\u003c'a\u003e TableNameNode {\n    pub fn select(self) -\u003e SelectNode\u003c'a\u003e {\n        let table_factor = TableFactorNode {\n            table_name: self.table_name,\n            table_type: TableType::Table,\n            table_alias: None,\n            index: None,\n        };\n\n        SelectNode::new(table_factor)\n    }\n\n    pub fn delete(self) -\u003e DeleteNode\u003c'static\u003e {\n        DeleteNode::new(self.table_name)\n    }\n\n    pub fn update(self) -\u003e UpdateNode {\n        UpdateNode::new(self.table_name)\n    }\n\n    pub fn insert(self) -\u003e InsertNode {\n        InsertNode::new(self.table_name)\n    }\n\n    pub fn show_columns(self) -\u003e ShowColumnsNode {\n        ShowColumnsNode::new(self.table_name)\n    }\n\n    pub fn alias_as(self, table_alias: \u0026str) -\u003e TableFactorNode\u003c'a\u003e {\n        TableFactorNode {\n            table_name: self.table_name,\n            table_type: TableType::Table,\n            table_alias: Some(table_alias.to_owned()),\n            index: None,\n        }\n    }\n\n    pub fn create_table(self) -\u003e CreateTableNode {\n        CreateTableNode::new(self.table_name, false)\n    }\n\n    pub fn create_table_if_not_exists(self) -\u003e CreateTableNode {\n        CreateTableNode::new(self.table_name, true)\n    }\n\n    pub fn drop_table(self) -\u003e DropTableNode {\n        DropTableNode::new(self.table_name, false, false)\n    }\n\n    pub fn drop_table_if_exists(self) -\u003e DropTableNode {\n        DropTableNode::new(self.table_name, true, false)\n    }\n\n    pub fn drop_table_cascade(self) -\u003e DropTableNode {\n        DropTableNode::new(self.table_name, false, true)\n    }\n\n    pub fn drop_table_if_exists_cascade(self) -\u003e DropTableNode {\n        DropTableNode::new(self.table_name, true, true)\n    }\n\n    pub fn drop_index(self, name: \u0026str) -\u003e DropIndexNode {\n        DropIndexNode::new(self.table_name, name.to_owned())\n    }\n\n    pub fn create_index\u003cT: Into\u003cOrderByExprNode\u003c'a\u003e\u003e\u003e(\n        self,\n        name: \u0026str,\n        column: T,\n    ) -\u003e CreateIndexNode\u003c'a\u003e {\n        CreateIndexNode::new(self.table_name, name.to_owned(), column.into())\n    }\n\n    pub fn alter_table(self) -\u003e AlterTableNode {\n        AlterTableNode::new(self.table_name)\n    }\n\n    pub fn index_by\u003cT: Into\u003cIndexItemNode\u003c'a\u003e\u003e\u003e(self, index_item: T) -\u003e TableFactorNode\u003c'a\u003e {\n        TableFactorNode {\n            table_name: self.table_name,\n            table_type: TableType::Table,\n            table_alias: None,\n            index: Some(index_item.into()),\n        }\n    }\n}\n\n/// Entry point function to build statement\npub fn table(table_name: \u0026str) -\u003e TableNameNode {\n    let table_name = table_name.to_owned();\n\n    TableNameNode { table_name }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","transaction.rs"],"content":"use crate::ast::Statement;\n\npub fn begin() -\u003e Statement {\n    Statement::StartTransaction\n}\npub fn commit() -\u003e Statement {\n    Statement::Commit\n}\npub fn rollback() -\u003e Statement {\n    Statement::Rollback\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{begin, commit, rollback, test};\n\n    #[test]\n    fn transaction() {\n        let actual = begin();\n        let expected = \"START TRANSACTION\";\n        test(Ok(actual), expected);\n\n        let actual = commit();\n        let expected = \"COMMIT\";\n        test(Ok(actual), expected);\n\n        let actual = rollback();\n        let expected = \"ROLLBACK\";\n        test(Ok(actual), expected);\n    }\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":0}},{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder","update.rs"],"content":"use {\n    super::{AssignmentNode, Build, ExprNode},\n    crate::{\n        ast::{Assignment, Expr, Statement},\n        result::Result,\n    },\n};\n\n#[derive(Clone, Debug)]\npub struct UpdateNode {\n    table_name: String,\n}\n\nimpl UpdateNode {\n    pub fn new(table_name: String) -\u003e Self {\n        Self { table_name }\n    }\n\n    pub fn filter\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, expr: T) -\u003e UpdateFilterNode\u003c'a\u003e {\n        UpdateFilterNode::new(self.table_name, expr)\n    }\n\n    pub fn set\u003c'a, T: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, id: \u0026str, value: T) -\u003e UpdateSetNode\u003c'a\u003e {\n        UpdateSetNode::new(self.table_name, None, id, value)\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct UpdateFilterNode\u003c'a\u003e {\n    table_name: String,\n    selection: ExprNode\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e UpdateFilterNode\u003c'a\u003e {\n    pub fn new\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(table_name: String, expr: T) -\u003e Self {\n        Self {\n            table_name,\n            selection: expr.into(),\n        }\n    }\n\n    pub fn filter\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(mut self, expr: T) -\u003e Self {\n        self.selection = self.selection.and(expr.into());\n        self\n    }\n\n    pub fn set\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(self, id: \u0026str, value: T) -\u003e UpdateSetNode\u003c'a\u003e {\n        UpdateSetNode::new(self.table_name, Some(self.selection), id, value)\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct UpdateSetNode\u003c'a\u003e {\n    table_name: String,\n    selection: Option\u003cExprNode\u003c'a\u003e\u003e,\n    assignments: Vec\u003cAssignmentNode\u003c'a\u003e\u003e,\n}\n\nimpl\u003c'a\u003e UpdateSetNode\u003c'a\u003e {\n    pub fn new\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(\n        table_name: String,\n        selection: Option\u003cExprNode\u003c'a\u003e\u003e,\n        id: \u0026str,\n        value: T,\n    ) -\u003e Self {\n        let assignments = vec![AssignmentNode::Expr(id.to_owned(), value.into())];\n\n        Self {\n            table_name,\n            selection,\n            assignments,\n        }\n    }\n\n    pub fn set\u003cT: Into\u003cExprNode\u003c'a\u003e\u003e\u003e(mut self, id: \u0026str, value: T) -\u003e Self {\n        self.assignments\n            .push(AssignmentNode::Expr(id.to_owned(), value.into()));\n        self\n    }\n}\n\nimpl\u003c'a\u003e Build for UpdateSetNode\u003c'a\u003e {\n    fn build(self) -\u003e Result\u003cStatement\u003e {\n        let table_name = self.table_name;\n        let selection = self.selection.map(Expr::try_from).transpose()?;\n        let assignments = self\n            .assignments\n            .into_iter()\n            .map(Assignment::try_from)\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n        Ok(Statement::Update {\n            table_name,\n            assignments,\n            selection,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast_builder::{Build, col, num, table, test, text};\n\n    #[test]\n    fn update() {\n        let actual = table(\"Foo\").update().set(\"id\", \"2\").build();\n        let expected = \"UPDATE Foo SET id = 2\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\")\n            .update()\n            .set(\"id\", \"2\")\n            .set(\"name\", \"Bar\")\n            .build();\n        let expected = \"UPDATE Foo SET id = 2, name=Bar\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\")\n            .update()\n            .filter(\"Bar = 1\")\n            .set(\"id\", \"2\")\n            .set(\"name\", \"americano\")\n            .build();\n        let expected = \"UPDATE Foo SET id = 2, name = americano WHERE Bar = 1\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\")\n            .update()\n            .filter(col(\"id\").gt(num(1)))\n            .filter(\"name = 'americano'\")\n            .set(\"name\", text(\"espresso\"))\n            .build();\n        let expected = \"\n            UPDATE Foo\n            SET name = 'espresso'\n            WHERE id \u003e 1 AND name = 'americano'\";\n        test(actual, expected);\n\n        let actual = table(\"Foo\")\n            .update()\n            .filter(\"body_item = 1\")\n            .set(\"id\", \"2\")\n            .set(\n                \"head_item\",\n                \"(SELECT id FROM head_item WHERE level = 3 LIMIT 1)\",\n            )\n            .build();\n        let expected = \"UPDATE Foo SET id = 2, head_item = (SELECT id FROM head_item WHERE level = 3 LIMIT 1) WHERE body_item = 1\";\n        test(actual, expected);\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","ast_builder.rs"],"content":"mod alter_table;\nmod assignment;\nmod build;\nmod column_def;\nmod column_list;\nmod create_table;\nmod data_type;\nmod delete;\nmod drop_table;\nmod error;\nmod execute;\nmod expr;\nmod expr_list;\nmod expr_with_alias;\nmod index;\nmod index_item;\nmod insert;\nmod order_by_expr;\nmod order_by_expr_list;\nmod query;\nmod select;\nmod select_item;\nmod select_item_list;\nmod show_columns;\nmod table_factor;\nmod table_name;\nmod transaction;\nmod update;\n\n/// Available expression builder functions\npub use expr::{\n    ExprNode, bitwise_not, bytea, case, col, date, exists, expr, factorial, minus, nested, not,\n    not_exists, null, num, numeric::NumericNode, plus, subquery, text, time, timestamp, uuid,\n};\n/// Available aggregate or normal SQL functions\npub use expr::{\n    aggregate::{AggregateNode, avg, count, max, min, stdev, sum, variance},\n    function,\n};\n/// Functions for building transaction statements\npub use transaction::{begin, commit, rollback};\npub use {\n    alter_table::{\n        AddColumnNode, AlterTableNode, DropColumnNode, RenameColumnNode, RenameTableNode,\n    },\n    assignment::AssignmentNode,\n    build::Build,\n    column_def::ColumnDefNode,\n    column_list::ColumnList,\n    create_table::CreateTableNode,\n    data_type::DataTypeNode,\n    delete::DeleteNode,\n    drop_table::DropTableNode,\n    error::AstBuilderError,\n    execute::Execute,\n    expr_list::ExprList,\n    expr_with_alias::ExprWithAliasNode,\n    index::{CreateIndexNode, DropIndexNode},\n    index_item::{\n        CmpExprNode, IndexItemNode, NonClusteredNode, PrimaryKeyNode, non_clustered, primary_key,\n    },\n    insert::InsertNode,\n    order_by_expr::OrderByExprNode,\n    order_by_expr_list::OrderByExprList,\n    query::QueryNode,\n    select::{\n        FilterNode, GroupByNode, HashJoinNode, HavingNode, JoinConstraintNode, JoinNode, LimitNode,\n        OffsetLimitNode, OffsetNode, OrderByNode, ProjectNode, SelectNode, select, values,\n    },\n    select_item::SelectItemNode,\n    select_item_list::SelectItemList,\n    show_columns::ShowColumnsNode,\n    table_factor::{\n        TableFactorNode, glue_indexes, glue_objects, glue_table_columns, glue_tables, series,\n    },\n    table_name::table,\n    update::UpdateNode,\n};\n\n#[cfg(test)]\nfn test(actual: crate::result::Result\u003ccrate::ast::Statement\u003e, expected: \u0026str) {\n    use crate::{parse_sql::parse, translate::translate};\n\n    let parsed = \u0026parse(expected).expect(expected)[0];\n    let expected = translate(parsed);\n    pretty_assertions::assert_eq!(actual, expected);\n}\n\n#[cfg(test)]\nfn test_expr(actual: crate::ast_builder::ExprNode, expected: \u0026str) {\n    use crate::{parse_sql::parse_expr, translate::translate_expr};\n\n    let parsed = \u0026parse_expr(expected).expect(expected);\n    let expected = translate_expr(parsed);\n    pretty_assertions::assert_eq!(actual.try_into(), expected);\n}\n\n#[cfg(test)]\nfn test_query(actual: crate::ast_builder::QueryNode, expected: \u0026str) {\n    use crate::{parse_sql::parse_query, translate::translate_query};\n\n    let parsed = \u0026parse_query(expected).expect(expected);\n    let expected = translate_query(parsed);\n    pretty_assertions::assert_eq!(actual.try_into(), expected);\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","bigdecimal_ext.rs"],"content":"use bigdecimal::BigDecimal;\n\npub trait BigDecimalExt {\n    fn to_i8(\u0026self) -\u003e Option\u003ci8\u003e;\n    fn to_i16(\u0026self) -\u003e Option\u003ci16\u003e;\n    fn to_i32(\u0026self) -\u003e Option\u003ci32\u003e;\n    fn to_i64(\u0026self) -\u003e Option\u003ci64\u003e;\n    fn to_i128(\u0026self) -\u003e Option\u003ci128\u003e;\n    fn to_u8(\u0026self) -\u003e Option\u003cu8\u003e;\n    fn to_u16(\u0026self) -\u003e Option\u003cu16\u003e;\n    fn to_u32(\u0026self) -\u003e Option\u003cu32\u003e;\n    fn to_u128(\u0026self) -\u003e Option\u003cu128\u003e;\n    fn to_u64(\u0026self) -\u003e Option\u003cu64\u003e;\n    fn to_f32(\u0026self) -\u003e Option\u003cf32\u003e;\n    fn to_f64(\u0026self) -\u003e Option\u003cf64\u003e;\n    fn is_integer_representation(\u0026self) -\u003e bool;\n}\n\nimpl BigDecimalExt for BigDecimal {\n    fn to_i8(\u0026self) -\u003e Option\u003ci8\u003e {\n        self.is_integer_representation()\n            .then(|| bigdecimal::ToPrimitive::to_i8(self))?\n    }\n    fn to_i16(\u0026self) -\u003e Option\u003ci16\u003e {\n        self.is_integer_representation()\n            .then(|| bigdecimal::ToPrimitive::to_i16(self))?\n    }\n    fn to_i32(\u0026self) -\u003e Option\u003ci32\u003e {\n        self.is_integer_representation()\n            .then(|| bigdecimal::ToPrimitive::to_i32(self))?\n    }\n    fn to_i64(\u0026self) -\u003e Option\u003ci64\u003e {\n        self.is_integer_representation()\n            .then(|| bigdecimal::ToPrimitive::to_i64(self))?\n    }\n    fn to_i128(\u0026self) -\u003e Option\u003ci128\u003e {\n        self.is_integer_representation()\n            .then(|| bigdecimal::ToPrimitive::to_i128(self))?\n    }\n    fn to_u8(\u0026self) -\u003e Option\u003cu8\u003e {\n        self.is_integer_representation()\n            .then(|| bigdecimal::ToPrimitive::to_u8(self))?\n    }\n    fn to_u16(\u0026self) -\u003e Option\u003cu16\u003e {\n        self.is_integer_representation()\n            .then(|| bigdecimal::ToPrimitive::to_u16(self))?\n    }\n    fn to_u32(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.is_integer_representation()\n            .then(|| bigdecimal::ToPrimitive::to_u32(self))?\n    }\n    fn to_u64(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.is_integer_representation()\n            .then(|| bigdecimal::ToPrimitive::to_u64(self))?\n    }\n    fn to_u128(\u0026self) -\u003e Option\u003cu128\u003e {\n        self.is_integer_representation()\n            .then(|| bigdecimal::ToPrimitive::to_u128(self))?\n    }\n    fn to_f32(\u0026self) -\u003e Option\u003cf32\u003e {\n        bigdecimal::ToPrimitive::to_f32(self)\n    }\n    fn to_f64(\u0026self) -\u003e Option\u003cf64\u003e {\n        bigdecimal::ToPrimitive::to_f64(self)\n    }\n    fn is_integer_representation(\u0026self) -\u003e bool {\n        self.fractional_digit_count() == 0\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":36},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","function.rs"],"content":"use {\n    crate::ast::{Expr, OperateFunctionArg},\n    serde::{Deserialize, Serialize},\n};\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct CustomFunction {\n    pub func_name: String,\n    pub args: Vec\u003cOperateFunctionArg\u003e,\n    pub body: Expr,\n}\n\nimpl CustomFunction {\n    pub fn to_str(\u0026self) -\u003e String {\n        let name = \u0026self.func_name;\n        let args = self\n            .args\n            .iter()\n            .map(|arg| format!(\"{}: {}\", arg.name, arg.data_type))\n            .collect::\u003cVec\u003cString\u003e\u003e()\n            .join(\", \");\n        format!(\"{name}({args})\")\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","interval","error.rs"],"content":"use {\n    super::Interval,\n    crate::ast::{Expr, ToSql},\n    chrono::NaiveTime,\n    serde::Serialize,\n    std::fmt::Debug,\n    thiserror::Error,\n};\n\n#[derive(Error, Serialize, Debug, PartialEq, Eq)]\npub enum IntervalError {\n    #[error(\"unsupported interval range: {0} to {1}\")]\n    UnsupportedRange(String, String),\n\n    #[error(\"cannot add between YEAR TO MONTH and HOUR TO SECOND\")]\n    AddBetweenYearToMonthAndHourToSecond,\n\n    #[error(\"cannot subtract between YEAR TO MONTH and HOUR TO SECOND\")]\n    SubtractBetweenYearToMonthAndHourToSecond,\n\n    #[error(\"cannot add year or month to TIME: {time} + {interval}\", time = time.to_string(), interval = interval.to_sql_str())]\n    AddYearOrMonthToTime { time: NaiveTime, interval: Interval },\n\n    #[error(\"cannot subtract year or month to TIME: {time} - {interval}\", time = time.to_string(), interval = interval.to_sql_str())]\n    SubtractYearOrMonthToTime { time: NaiveTime, interval: Interval },\n\n    #[error(\"failed to parse integer: {0}\")]\n    FailedToParseInteger(String),\n\n    #[error(\"failed to parse decimal: {0}\")]\n    FailedToParseDecimal(String),\n\n    #[error(\"failed to parse time: {0}\")]\n    FailedToParseTime(String),\n\n    #[error(\"failed to parse YEAR TO MONTH (year-month, ex. 2-8): {0}\")]\n    FailedToParseYearToMonth(String),\n\n    #[error(\"failed to parse DAY TO HOUR (day hour, ex. 1 23): {0}\")]\n    FailedToParseDayToHour(String),\n\n    #[error(\"failed to parse DAY TO MINUTE (day hh:mm, ex. 1 12:34): {0}\")]\n    FailedToParseDayToMinute(String),\n\n    #[error(\"failed to parse DAY TO SECOND (day hh:mm:ss, ex. 1 12:34:55): {0}\")]\n    FailedToParseDayToSecond(String),\n\n    #[error(\"date overflow: {year}-{month}\")]\n    DateOverflow { year: i32, month: i32 },\n\n    #[error(\"failed to get extract from interval\")]\n    FailedToExtract,\n\n    #[error(\"parse supported only literal, expected: \\\"'1 1' DAY TO HOUR\\\", but got: {expr}\", expr = expr.to_sql())]\n    ParseSupportedOnlyLiteral { expr: Expr },\n\n    #[error(\"unreachable\")]\n    Unreachable,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","interval","primitive.rs"],"content":"use {\n    super::Interval,\n    std::ops::{Div, Mul},\n};\n\nimpl Mul\u003ci8\u003e for Interval {\n    type Output = Self;\n\n    fn mul(self, rhs: i8) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(v * rhs as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(v * rhs as i64),\n        }\n    }\n}\n\nimpl Mul\u003ci16\u003e for Interval {\n    type Output = Self;\n\n    fn mul(self, rhs: i16) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(v * rhs as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(v * rhs as i64),\n        }\n    }\n}\n\nimpl Mul\u003ci32\u003e for Interval {\n    type Output = Self;\n\n    fn mul(self, rhs: i32) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(v * rhs),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(v * rhs as i64),\n        }\n    }\n}\n\nimpl Mul\u003ci64\u003e for Interval {\n    type Output = Self;\n\n    fn mul(self, rhs: i64) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as i64) * rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(v * rhs),\n        }\n    }\n}\n\nimpl Mul\u003ci128\u003e for Interval {\n    type Output = Self;\n\n    fn mul(self, rhs: i128) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as i128) * rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(((v as i128) * rhs) as i64),\n        }\n    }\n}\n\nimpl Mul\u003cu8\u003e for Interval {\n    type Output = Self;\n\n    fn mul(self, rhs: u8) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as u8) * rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(((v as u8) * rhs) as i64),\n        }\n    }\n}\n\nimpl Mul\u003cu16\u003e for Interval {\n    type Output = Self;\n\n    fn mul(self, rhs: u16) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as u16) * rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(((v as u16) * rhs) as i64),\n        }\n    }\n}\n\nimpl Mul\u003cu32\u003e for Interval {\n    type Output = Self;\n\n    fn mul(self, rhs: u32) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as u32) * rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(((v as u32) * rhs) as i64),\n        }\n    }\n}\n\nimpl Mul\u003cu64\u003e for Interval {\n    type Output = Self;\n\n    fn mul(self, rhs: u64) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as u64) * rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(((v as u64) * rhs) as i64),\n        }\n    }\n}\n\nimpl Mul\u003cu128\u003e for Interval {\n    type Output = Self;\n\n    fn mul(self, rhs: u128) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as u128) * rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(((v as u128) * rhs) as i64),\n        }\n    }\n}\n\nimpl Mul\u003cf32\u003e for Interval {\n    type Output = Self;\n\n    fn mul(self, rhs: f32) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month((v as f32 * rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond((v as f32 * rhs) as i64),\n        }\n    }\n}\n\nimpl Mul\u003cf64\u003e for Interval {\n    type Output = Self;\n\n    fn mul(self, rhs: f64) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month((v as f64 * rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond((v as f64 * rhs) as i64),\n        }\n    }\n}\n\nimpl Mul\u003cInterval\u003e for i8 {\n    type Output = Interval;\n\n    fn mul(self, rhs: Interval) -\u003e Interval {\n        rhs * self\n    }\n}\n\nimpl Mul\u003cInterval\u003e for i16 {\n    type Output = Interval;\n\n    fn mul(self, rhs: Interval) -\u003e Interval {\n        rhs * self\n    }\n}\n\nimpl Mul\u003cInterval\u003e for i32 {\n    type Output = Interval;\n\n    fn mul(self, rhs: Interval) -\u003e Interval {\n        rhs * self\n    }\n}\n\nimpl Mul\u003cInterval\u003e for i64 {\n    type Output = Interval;\n\n    fn mul(self, rhs: Interval) -\u003e Interval {\n        rhs * self\n    }\n}\n\nimpl Mul\u003cInterval\u003e for i128 {\n    type Output = Interval;\n\n    fn mul(self, rhs: Interval) -\u003e Interval {\n        rhs * self\n    }\n}\n\nimpl Mul\u003cInterval\u003e for u8 {\n    type Output = Interval;\n\n    fn mul(self, rhs: Interval) -\u003e Interval {\n        rhs * self\n    }\n}\n\nimpl Mul\u003cInterval\u003e for u16 {\n    type Output = Interval;\n\n    fn mul(self, rhs: Interval) -\u003e Interval {\n        rhs * self\n    }\n}\n\nimpl Mul\u003cInterval\u003e for u32 {\n    type Output = Interval;\n\n    fn mul(self, rhs: Interval) -\u003e Interval {\n        rhs * self\n    }\n}\n\nimpl Mul\u003cInterval\u003e for u64 {\n    type Output = Interval;\n\n    fn mul(self, rhs: Interval) -\u003e Interval {\n        rhs * self\n    }\n}\n\nimpl Mul\u003cInterval\u003e for u128 {\n    type Output = Interval;\n\n    fn mul(self, rhs: Interval) -\u003e Interval {\n        rhs * self\n    }\n}\n\nimpl Mul\u003cInterval\u003e for f32 {\n    type Output = Interval;\n\n    fn mul(self, rhs: Interval) -\u003e Interval {\n        rhs * self\n    }\n}\n\nimpl Mul\u003cInterval\u003e for f64 {\n    type Output = Interval;\n\n    fn mul(self, rhs: Interval) -\u003e Interval {\n        rhs * self\n    }\n}\n\nimpl Div\u003ci8\u003e for Interval {\n    type Output = Self;\n\n    fn div(self, rhs: i8) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(v / rhs as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(v / rhs as i64),\n        }\n    }\n}\n\nimpl Div\u003ci16\u003e for Interval {\n    type Output = Self;\n\n    fn div(self, rhs: i16) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(v / rhs as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(v / rhs as i64),\n        }\n    }\n}\n\nimpl Div\u003ci32\u003e for Interval {\n    type Output = Self;\n\n    fn div(self, rhs: i32) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(v / rhs),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(v / rhs as i64),\n        }\n    }\n}\n\nimpl Div\u003ci64\u003e for Interval {\n    type Output = Self;\n\n    fn div(self, rhs: i64) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as i64) / rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(v / rhs),\n        }\n    }\n}\n\nimpl Div\u003ci128\u003e for Interval {\n    type Output = Self;\n\n    fn div(self, rhs: i128) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as i128) / rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(((v as i128) / rhs) as i64),\n        }\n    }\n}\n\nimpl Div\u003cu8\u003e for Interval {\n    type Output = Self;\n\n    fn div(self, rhs: u8) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as u8) / rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(((v as u8) / rhs) as i64),\n        }\n    }\n}\n\nimpl Div\u003cu16\u003e for Interval {\n    type Output = Self;\n\n    fn div(self, rhs: u16) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as u16) / rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(((v as u16) / rhs) as i64),\n        }\n    }\n}\n\nimpl Div\u003cu32\u003e for Interval {\n    type Output = Self;\n\n    fn div(self, rhs: u32) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as u32) / rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(((v as u32) / rhs) as i64),\n        }\n    }\n}\n\nimpl Div\u003cu64\u003e for Interval {\n    type Output = Self;\n\n    fn div(self, rhs: u64) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as u64) / rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(((v as u64) / rhs) as i64),\n        }\n    }\n}\n\nimpl Div\u003cu128\u003e for Interval {\n    type Output = Self;\n\n    fn div(self, rhs: u128) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(((v as u128) / rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(((v as u128) / rhs) as i64),\n        }\n    }\n}\n\nimpl Div\u003cf32\u003e for Interval {\n    type Output = Self;\n\n    fn div(self, rhs: f32) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month((v as f32 / rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond((v as f32 / rhs) as i64),\n        }\n    }\n}\n\nimpl Div\u003cf64\u003e for Interval {\n    type Output = Self;\n\n    fn div(self, rhs: f64) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month((v as f64 / rhs) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond((v as f64 / rhs) as i64),\n        }\n    }\n}\n\nimpl Div\u003cInterval\u003e for i8 {\n    type Output = Interval;\n\n    fn div(self, rhs: Interval) -\u003e Interval {\n        match rhs {\n            Interval::Month(v) =\u003e Interval::Month(self as i32 / v),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(self as i64 / v),\n        }\n    }\n}\n\nimpl Div\u003cInterval\u003e for i16 {\n    type Output = Interval;\n\n    fn div(self, rhs: Interval) -\u003e Interval {\n        match rhs {\n            Interval::Month(v) =\u003e Interval::Month(self as i32 / v),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(self as i64 / v),\n        }\n    }\n}\n\nimpl Div\u003cInterval\u003e for i32 {\n    type Output = Interval;\n\n    fn div(self, rhs: Interval) -\u003e Interval {\n        match rhs {\n            Interval::Month(v) =\u003e Interval::Month(self / v),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(self as i64 / v),\n        }\n    }\n}\n\nimpl Div\u003cInterval\u003e for i64 {\n    type Output = Interval;\n\n    fn div(self, rhs: Interval) -\u003e Interval {\n        match rhs {\n            Interval::Month(v) =\u003e Interval::Month((self / (v as i64)) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(self / v),\n        }\n    }\n}\n\nimpl Div\u003cInterval\u003e for i128 {\n    type Output = Interval;\n\n    fn div(self, rhs: Interval) -\u003e Interval {\n        match rhs {\n            Interval::Month(v) =\u003e Interval::Month((self / (v as i128)) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond((self / (v as i128)) as i64),\n        }\n    }\n}\n\nimpl Div\u003cInterval\u003e for u8 {\n    type Output = Interval;\n\n    fn div(self, rhs: Interval) -\u003e Interval {\n        match rhs {\n            Interval::Month(v) =\u003e Interval::Month((self / (v as u8)) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond((self / (v as u8)) as i64),\n        }\n    }\n}\n\nimpl Div\u003cInterval\u003e for u16 {\n    type Output = Interval;\n\n    fn div(self, rhs: Interval) -\u003e Interval {\n        match rhs {\n            Interval::Month(v) =\u003e Interval::Month((self / (v as u16)) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond((self / (v as u16)) as i64),\n        }\n    }\n}\n\nimpl Div\u003cInterval\u003e for u32 {\n    type Output = Interval;\n\n    fn div(self, rhs: Interval) -\u003e Interval {\n        match rhs {\n            Interval::Month(v) =\u003e Interval::Month((self / (v as u32)) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond((self / (v as u32)) as i64),\n        }\n    }\n}\n\nimpl Div\u003cInterval\u003e for u64 {\n    type Output = Interval;\n\n    fn div(self, rhs: Interval) -\u003e Interval {\n        match rhs {\n            Interval::Month(v) =\u003e Interval::Month((self / (v as u64)) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond((self / (v as u64)) as i64),\n        }\n    }\n}\n\nimpl Div\u003cInterval\u003e for u128 {\n    type Output = Interval;\n\n    fn div(self, rhs: Interval) -\u003e Interval {\n        match rhs {\n            Interval::Month(v) =\u003e Interval::Month((self / (v as u128)) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond((self / (v as u128)) as i64),\n        }\n    }\n}\n\nimpl Div\u003cInterval\u003e for f32 {\n    type Output = Interval;\n\n    fn div(self, rhs: Interval) -\u003e Interval {\n        match rhs {\n            Interval::Month(v) =\u003e Interval::Month((self / v as f32) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond((self / v as f32) as i64),\n        }\n    }\n}\n\nimpl Div\u003cInterval\u003e for f64 {\n    type Output = Interval;\n\n    fn div(self, rhs: Interval) -\u003e Interval {\n        match rhs {\n            Interval::Month(v) =\u003e Interval::Month((self / v as f64) as i32),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond((self / v as f64) as i64),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Interval;\n\n    #[test]\n    fn arithmetic() {\n        use Interval::*;\n\n        assert_eq!(Month(2) * 3_i8, Month(6));\n        assert_eq!(2_i8 * Month(3), Month(6));\n\n        assert_eq!(Month(2) * 3_i16, Month(6));\n        assert_eq!(2_i16 * Month(3), Month(6));\n\n        assert_eq!(Month(2) * 3_i32, Month(6));\n        assert_eq!(2_i32 * Month(3), Month(6));\n\n        assert_eq!(Month(2) * 3_i64, Month(6));\n        assert_eq!(2_i64 * Month(3), Month(6));\n\n        assert_eq!(Month(2) * 3_i128, Month(6));\n        assert_eq!(2_i128 * Month(3), Month(6));\n\n        assert_eq!(Month(2) * 3_u8, Month(6));\n        assert_eq!(2_u8 * Month(3), Month(6));\n\n        assert_eq!(Month(2) * 3_u16, Month(6));\n        assert_eq!(2_u16 * Month(3), Month(6));\n\n        assert_eq!(Month(2) * 3_u32, Month(6));\n        assert_eq!(2_u32 * Month(3), Month(6));\n\n        assert_eq!(Month(2) * 3_u64, Month(6));\n        assert_eq!(2_u64 * Month(3), Month(6));\n\n        assert_eq!(Month(2) * 3_u128, Month(6));\n        assert_eq!(2_u128 * Month(3), Month(6));\n\n        assert_eq!(Month(2) * 3_f32, Month(6));\n        assert_eq!(2_f32 * Month(3), Month(6));\n\n        assert_eq!(Month(2) * 3_f64, Month(6));\n        assert_eq!(2_f64 * Month(3), Month(6));\n\n        assert_eq!(Month(2) * 3.0, Month(6));\n        assert_eq!(2.0 * Month(3), Month(6));\n\n        assert_eq!(Month(6) / 3_i8, Month(2));\n        assert_eq!(6_i8 / Month(2), Month(3));\n\n        assert_eq!(Month(6) / 3_i16, Month(2));\n        assert_eq!(6_i16 / Month(2), Month(3));\n\n        assert_eq!(Month(6) / 3_i32, Month(2));\n        assert_eq!(6_i32 / Month(2), Month(3));\n\n        assert_eq!(Month(6) / 3_i64, Month(2));\n        assert_eq!(6_i64 / Month(2), Month(3));\n\n        assert_eq!(Month(6) / 3_i128, Month(2));\n        assert_eq!(6_i128 / Month(2), Month(3));\n\n        assert_eq!(Month(6) / 3_u8, Month(2));\n        assert_eq!(6_u8 / Month(2), Month(3));\n\n        assert_eq!(Month(6) / 3_u16, Month(2));\n        assert_eq!(6_u16 / Month(2), Month(3));\n\n        assert_eq!(Month(6) / 3_u32, Month(2));\n        assert_eq!(6_u32 / Month(2), Month(3));\n\n        assert_eq!(Month(6) / 3_u64, Month(2));\n        assert_eq!(6_u64 / Month(2), Month(3));\n\n        assert_eq!(Month(6) / 3_u128, Month(2));\n        assert_eq!(6_u128 / Month(2), Month(3));\n\n        assert_eq!(Month(8) / 4.0_f32, Month(2));\n        assert_eq!(8.0_f32 / Month(4), Month(2));\n\n        assert_eq!(Month(8) / 4.0, Month(2));\n        assert_eq!(8.0 / Month(4), Month(2));\n\n        assert_eq!(Microsecond(2) * 3_i8, Microsecond(6));\n        assert_eq!(2_i8 * Microsecond(3), Microsecond(6));\n\n        assert_eq!(Microsecond(2) * 3_i16, Microsecond(6));\n        assert_eq!(2_i16 * Microsecond(3), Microsecond(6));\n\n        assert_eq!(Microsecond(2) * 3_i32, Microsecond(6));\n        assert_eq!(2_i32 * Microsecond(3), Microsecond(6));\n\n        assert_eq!(Microsecond(2) * 3_i64, Microsecond(6));\n        assert_eq!(2_i64 * Microsecond(3), Microsecond(6));\n\n        assert_eq!(Microsecond(2) * 3_i128, Microsecond(6));\n        assert_eq!(2_i128 * Microsecond(3), Microsecond(6));\n\n        assert_eq!(Microsecond(2) * 3_u8, Microsecond(6));\n        assert_eq!(2_u8 * Microsecond(3), Microsecond(6));\n\n        assert_eq!(Microsecond(2) * 3_u16, Microsecond(6));\n        assert_eq!(2_u16 * Microsecond(3), Microsecond(6));\n\n        assert_eq!(Microsecond(2) * 3_u32, Microsecond(6));\n        assert_eq!(2_u32 * Microsecond(3), Microsecond(6));\n\n        assert_eq!(Microsecond(2) * 3_u64, Microsecond(6));\n        assert_eq!(2_u64 * Microsecond(3), Microsecond(6));\n\n        assert_eq!(Microsecond(2) * 3_u128, Microsecond(6));\n        assert_eq!(2_u128 * Microsecond(3), Microsecond(6));\n\n        assert_eq!(Microsecond(2) * 3.0_f32, Microsecond(6));\n        assert_eq!(2.0_f32 * Microsecond(3), Microsecond(6));\n\n        assert_eq!(Microsecond(2) * 3.0, Microsecond(6));\n        assert_eq!(2.0 * Microsecond(3), Microsecond(6));\n\n        assert_eq!(Microsecond(6) / 3_i8, Microsecond(2));\n        assert_eq!(6_i8 / Microsecond(2), Microsecond(3));\n\n        assert_eq!(Microsecond(6) / 3_i16, Microsecond(2));\n        assert_eq!(6_i16 / Microsecond(2), Microsecond(3));\n\n        assert_eq!(Microsecond(6) / 3_i32, Microsecond(2));\n        assert_eq!(6_i32 / Microsecond(2), Microsecond(3));\n\n        assert_eq!(Microsecond(6) / 3_i64, Microsecond(2));\n        assert_eq!(6_i64 / Microsecond(2), Microsecond(3));\n\n        assert_eq!(Microsecond(6) / 3_i128, Microsecond(2));\n        assert_eq!(6_i128 / Microsecond(2), Microsecond(3));\n\n        assert_eq!(Microsecond(6) / 3_u8, Microsecond(2));\n        assert_eq!(6_u8 / Microsecond(2), Microsecond(3));\n\n        assert_eq!(Microsecond(6) / 3_u16, Microsecond(2));\n        assert_eq!(6_u16 / Microsecond(2), Microsecond(3));\n\n        assert_eq!(Microsecond(6) / 3_u32, Microsecond(2));\n        assert_eq!(6_u32 / Microsecond(2), Microsecond(3));\n\n        assert_eq!(Microsecond(6) / 3_u64, Microsecond(2));\n        assert_eq!(6_u64 / Microsecond(2), Microsecond(3));\n\n        assert_eq!(Microsecond(6) / 3_u128, Microsecond(2));\n        assert_eq!(6_u128 / Microsecond(2), Microsecond(3));\n\n        assert_eq!(Microsecond(6) / 3_f32, Microsecond(2));\n        assert_eq!(6_f32 / Microsecond(2), Microsecond(3));\n\n        assert_eq!(Microsecond(6) / 3_f64, Microsecond(2));\n        assert_eq!(6_f64 / Microsecond(2), Microsecond(3));\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":168},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","interval","string.rs"],"content":"use {\n    super::{DAY, HOUR, Interval, IntervalError, MINUTE, SECOND},\n    crate::{\n        ast::{Expr, ToSql},\n        parse_sql::parse_interval,\n        result::Result,\n        translate::translate_expr,\n    },\n};\n\nimpl Interval {\n    pub fn parse(s: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let parsed = parse_interval(s)?;\n\n        match translate_expr(\u0026parsed)? {\n            Expr::Interval {\n                expr,\n                leading_field,\n                last_field,\n            } =\u003e {\n                let literal = match expr.as_ref() {\n                    Expr::Literal(literal) =\u003e literal.to_sql(),\n                    _ =\u003e {\n                        return Err(IntervalError::ParseSupportedOnlyLiteral { expr: *expr }.into());\n                    }\n                };\n\n                Interval::try_from_str(\u0026literal, leading_field, last_field)\n            }\n            _ =\u003e Err(IntervalError::Unreachable.into()),\n        }\n    }\n\n    pub fn to_sql_str(\u0026self) -\u003e String {\n        match self {\n            Interval::Month(v) =\u003e {\n                let v = *v;\n                let (sign, v) = if v \u003c 0 { (\"-\", -v) } else { (\"\", v) };\n\n                let year = v / 12;\n                let month = v % 12;\n\n                match (year, month) {\n                    (_, 0) if year != 0 =\u003e format!(\"'{}{}' YEAR\", sign, year),\n                    (0, _) =\u003e format!(\"'{}{}' MONTH\", sign, month),\n                    _ =\u003e format!(\"'{}{}-{}' YEAR TO MONTH\", sign, year, month),\n                }\n            }\n            Interval::Microsecond(v) =\u003e {\n                let v = *v;\n                let (sign, v) = if v \u003c 0 { (\"-\", -v) } else { (\"\", v) };\n\n                let day = v / DAY;\n                let hour = (v % DAY) / HOUR;\n                let minute = (v % HOUR) / MINUTE;\n                let second = (v % MINUTE) / SECOND;\n                let microsecond = v % SECOND;\n\n                macro_rules! micro {\n                    () =\u003e {\n                        format!(\"{:06}\", microsecond).trim_end_matches('0')\n                    };\n                }\n\n                macro_rules! f {\n                    ($template: literal; $( $value: expr )*; $from_to: literal) =\u003e {\n                        format!(\"'{}{}' {}\", sign, format!($template, $( $value ),*), $from_to)\n                    };\n\n                    (DAY $template: literal) =\u003e {\n                        f!($template; day; \"DAY\")\n                    };\n                    (HOUR $template: literal) =\u003e {\n                        f!($template; hour; \"HOUR\")\n                    };\n                    (MINUTE $template: literal) =\u003e {\n                        f!($template; minute; \"MINUTE\")\n                    };\n                    (SECOND $template: literal) =\u003e {\n                        f!($template; second; \"SECOND\")\n                    };\n                    (MICRO $template: literal) =\u003e {\n                        f!($template; second micro!(); \"SECOND\")\n                    };\n\n                    // MINUTE TO ..\n                    (MINUTE TO SECOND $template: literal) =\u003e {\n                        f!($template; minute second; \"MINUTE TO SECOND\")\n                    };\n                    (MINUTE TO MICRO $template: literal) =\u003e {\n                        f!($template; minute second micro!(); \"MINUTE TO SECOND\")\n                    };\n\n                    // HOUR TO ..\n                    (HOUR TO MINUTE $template: literal) =\u003e {\n                        f!($template; hour minute; \"HOUR TO MINUTE\")\n                    };\n                    (HOUR TO SECOND $template: literal) =\u003e {\n                        f!($template; hour minute second; \"HOUR TO SECOND\")\n                    };\n                    (HOUR TO MICRO $template: literal) =\u003e {\n                        f!($template; hour minute second micro!(); \"HOUR TO SECOND\")\n                    };\n\n                    // DAY TO ..\n                    (DAY TO HOUR $template: literal) =\u003e {\n                        f!($template; day hour; \"DAY TO HOUR\")\n                    };\n                    (DAY TO MINUTE $template: literal) =\u003e {\n                        f!($template; day hour minute; \"DAY TO MINUTE\")\n                    };\n                    (DAY TO SECOND $template: literal) =\u003e {\n                        f!($template; day hour minute second; \"DAY TO SECOND\")\n                    };\n                    (DAY TO MICRO $template: literal) =\u003e {\n                        f!($template; day hour minute second micro!(); \"DAY TO SECOND\")\n                    };\n                }\n\n                match (day, hour, minute, second, microsecond) {\n                    (_, 0, 0, 0, 0) if day != 0 =\u003e f!(DAY \"{}\"),\n                    (0, _, 0, 0, 0) if hour != 0 =\u003e f!(HOUR \"{}\"),\n                    (0, 0, _, 0, 0) if minute != 0 =\u003e f!(MINUTE \"{}\"),\n                    (0, 0, 0, _, 0) if second != 0 =\u003e f!(SECOND \"{}\"),\n                    (0, 0, 0, _, _) if microsecond != 0 =\u003e f!(MICRO \"{}.{}\"),\n\n                    // MINUTE TO ..\n                    (0, 0, _, _, 0) =\u003e f!(MINUTE TO SECOND \"{:02}:{:02}\"),\n                    (0, 0, _, _, _) =\u003e f!(MINUTE TO MICRO  \"{:02}:{:02}.{}\"),\n\n                    // HOUR TO ..\n                    (0, _, _, 0, 0) =\u003e f!(HOUR TO MINUTE \"{:02}:{:02}\"),\n                    (0, _, _, _, 0) =\u003e f!(HOUR TO SECOND \"{:02}:{:02}:{:02}\"),\n                    (0, _, _, _, _) =\u003e f!(HOUR TO MICRO  \"{:02}:{:02}:{:02}.{}\"),\n\n                    // DAY TO ..\n                    (_, _, 0, 0, 0) =\u003e f!(DAY TO HOUR   \"{} {}\"),\n                    (_, _, _, 0, 0) =\u003e f!(DAY TO MINUTE \"{} {:02}:{:02}\"),\n                    (_, _, _, _, 0) =\u003e f!(DAY TO SECOND \"{} {:02}:{:02}:{:02}\"),\n                    (_, _, _, _, _) =\u003e f!(DAY TO MICRO  \"{} {:02}:{:02}:{:02}.{}\"),\n                }\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Interval;\n\n    #[test]\n    fn parse() {\n        macro_rules! test {\n            ($( $value: literal $duration: ident ),* =\u003e $result: literal $from_to: tt) =\u003e {\n                let interval = interval!($( $value $duration ),*);\n                let interval_str = format!(\"'{}' {}\", $result, stringify!($from_to));\n\n                let expected = Interval::parse(interval_str.as_str());\n                assert_eq!(Ok(interval), expected);\n                assert_eq!(interval.to_sql_str(), interval_str);\n            };\n            ($( $value: literal $duration: ident ),* =\u003e $result: literal $from: tt TO $to: tt) =\u003e {\n                let interval = interval!($( $value $duration ),*);\n                let interval_str = format!(\n                    \"'{}' {} TO {}\",\n                    $result,\n                    stringify!($from),\n                    stringify!($to),\n                );\n\n                let expected = Interval::parse(interval_str.as_str());\n                assert_eq!(Ok(interval), expected);\n                assert_eq!(interval.to_sql_str(), interval_str);\n            };\n        }\n\n        macro_rules! interval {\n            ($value: literal $duration:ident) =\u003e {\n                Interval::$duration($value)\n            };\n            ($interval: expr ; $value: literal $duration:ident) =\u003e {\n                $interval.add(\u0026Interval::$duration($value)).unwrap()\n            };\n            ($v0: literal $d0: ident, $( $v1: literal $d1: ident ),*) =\u003e {\n                interval!(\n                    Interval::$d0($v0) ;\n                    $( $v1 $d1 ),*\n                )\n            };\n            ($interval: expr ; $v0: literal $d0: ident, $( $v1: literal $d1: ident ),*) =\u003e {\n                interval!(\n                    $interval.add(\u0026Interval::$d0($v0)).unwrap() ;\n                    $( $v1 $d1 ),*\n                )\n            };\n        }\n\n        // YEAR and MONTH\n        test!(33 years            =\u003e \"33\" YEAR);\n        test!(-33 years           =\u003e \"-33\" YEAR);\n        test!(14 months           =\u003e \"1-2\" YEAR TO MONTH);\n        test!(-33 months          =\u003e \"-2-9\" YEAR TO MONTH);\n        test!(12 months           =\u003e \"1\" YEAR);\n        test!(11 months           =\u003e \"11\" MONTH);\n        test!(-3 months           =\u003e \"-3\" MONTH);\n        test!(33 years, 11 months =\u003e \"33-11\" YEAR TO MONTH);\n        test!(1 years, 100 months =\u003e \"9-4\" YEAR TO MONTH);\n\n        // DAY, HOUR, MINUTE and SECOND\n        test!(102 days          =\u003e \"102\" DAY);\n        test!(-20 days          =\u003e \"-20\" DAY);\n        test!(30 hours          =\u003e \"1 6\" DAY TO HOUR);\n        test!(24 hours          =\u003e \"1\" DAY);\n        test!(3 hours           =\u003e \"3\" HOUR);\n        test!(-5 hours          =\u003e \"-5\" HOUR);\n        test!(350 minutes       =\u003e \"05:50\" HOUR TO MINUTE);\n        test!(600 minutes       =\u003e \"10\" HOUR);\n        test!(59 minutes        =\u003e \"59\" MINUTE);\n        test!(3 minutes         =\u003e \"3\" MINUTE);\n        test!(-9 minutes        =\u003e \"-9\" MINUTE);\n        test!(7298 seconds      =\u003e \"02:01:38\" HOUR TO SECOND);\n        test!(98 seconds        =\u003e \"01:38\" MINUTE TO SECOND);\n        test!(120 seconds       =\u003e \"2\" MINUTE);\n        test!(30 seconds        =\u003e \"30\" SECOND);\n        test!(3 seconds         =\u003e \"3\" SECOND);\n        test!(-37 seconds       =\u003e \"-37\" SECOND);\n        test!(1234 milliseconds =\u003e \"1.234\" SECOND);\n        test!(-234 milliseconds  =\u003e \"-0.234\" SECOND);\n        test!(1234 microseconds =\u003e \"0.001234\" SECOND);\n\n        // MINUTE TO ..\n        test!(11 minutes, 30 seconds                     =\u003e \"11:30\" MINUTE TO SECOND);\n        test!(-11 minutes, -39 seconds                   =\u003e \"-11:39\" MINUTE TO SECOND);\n        test!(11 minutes, 36540 microseconds             =\u003e \"11:00.03654\" MINUTE TO SECOND);\n        test!(-30 minutes, -9876 microseconds            =\u003e \"-30:00.009876\" MINUTE TO SECOND);\n        test!(11 minutes, 30 seconds, 36540 microseconds =\u003e \"11:30.03654\" MINUTE TO SECOND);\n\n        // HOUR TO ..\n        test!(11 hours, 50 minutes                   =\u003e \"11:50\" HOUR TO MINUTE);\n        test!(-20 hours, -39 minutes                 =\u003e \"-20:39\" HOUR TO MINUTE);\n        test!(23 hours, 59 seconds                   =\u003e \"23:00:59\" HOUR TO SECOND);\n        test!(-23 hours, -59 seconds                 =\u003e \"-23:00:59\" HOUR TO SECOND);\n        test!(7 hours, 30040 microseconds            =\u003e \"07:00:00.03004\" HOUR TO SECOND);\n        test!(-7 hours, -30040 microseconds          =\u003e \"-07:00:00.03004\" HOUR TO SECOND);\n        test!(23 hours, 12 minutes, 59 seconds       =\u003e \"23:12:59\" HOUR TO SECOND);\n        test!(23 hours, 12 minutes, 300 microseconds =\u003e \"23:12:00.0003\" HOUR TO SECOND);\n        test!(\n            23 hours, 12 minutes, 9 seconds, 300 microseconds =\u003e\n            \"23:12:09.0003\" HOUR TO SECOND\n        );\n\n        // DAY TO ..\n        test!(1 days, 1 hours                    =\u003e \"1 1\" DAY TO HOUR);\n        test!(-1 days, -7 hours                  =\u003e \"-1 7\" DAY TO HOUR);\n        test!(30 days, 5 minutes                 =\u003e \"30 00:05\" DAY TO MINUTE);\n        test!(-1 days, -130 minutes              =\u003e \"-1 02:10\" DAY TO MINUTE);\n        test!(30 days, 100 seconds               =\u003e \"30 00:01:40\" DAY TO SECOND);\n        test!(-5 days, -3800 seconds             =\u003e \"-5 01:03:20\" DAY TO SECOND);\n        test!(1 days, 1 microseconds             =\u003e \"1 00:00:00.000001\" DAY TO SECOND);\n        test!(-1 days, -1 microseconds           =\u003e \"-1 00:00:00.000001\" DAY TO SECOND);\n        test!(100 days, 2 hours, 3 minutes       =\u003e \"100 02:03\" DAY TO MINUTE);\n        test!(2 days, 20 hours, 3 seconds        =\u003e \"2 20:00:03\" DAY TO SECOND);\n        test!(2 days, 20 hours, 234 milliseconds =\u003e \"2 20:00:00.234\" DAY TO SECOND);\n        test!(\n            30 days, 30 hours, 100 seconds, 3 microseconds =\u003e\n            \"31 06:01:40.000003\" DAY TO SECOND\n        );\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":40},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","interval.rs"],"content":"mod error;\nmod primitive;\nmod string;\n\npub use error::IntervalError;\nuse {\n    super::Value,\n    crate::{ast::DateTimeField, result::Result},\n    chrono::{Datelike, Duration, NaiveDate, NaiveDateTime, NaiveTime, Timelike},\n    core::str::FromStr,\n    rust_decimal::{Decimal, prelude::ToPrimitive},\n    serde::{Deserialize, Serialize},\n    std::{cmp::Ordering, fmt::Debug},\n};\n\n/// Represents a time interval, which can be either in months or microseconds.\n///\n/// The [`Interval`] type is divided into two variants: [`Interval::Month`] and [`Interval::Microsecond`].\n/// This distinction is made because the conversion between months and days is not consistent.\n/// While a year can be clearly calculated as 12 months in the solar calendar,\n/// a month can vary in the number of days (28, 30, or 31 days).\n///\n/// To ensure precise calculations and comparisons, intervals are represented in the smallest\n/// unambiguous units: `Month` for month-based intervals and `Microsecond` for microsecond-based intervals.\n/// Comparisons are only allowed within the same unit type to avoid ambiguity.\n///\n/// For more details on how comparisons are implemented, refer to the [`Interval::partial_cmp`] trait.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Interval {\n    Month(i32),\n    Microsecond(i64),\n}\n\nimpl PartialOrd\u003cInterval\u003e for Interval {\n    fn partial_cmp(\u0026self, other: \u0026Interval) -\u003e Option\u003cOrdering\u003e {\n        match (self, other) {\n            (Interval::Month(l), Interval::Month(r)) =\u003e Some(l.cmp(r)),\n            (Interval::Microsecond(l), Interval::Microsecond(r)) =\u003e Some(l.cmp(r)),\n            _ =\u003e None,\n        }\n    }\n}\n\nconst SECOND: i64 = 1_000_000;\nconst MINUTE: i64 = 60 * SECOND;\nconst HOUR: i64 = 3600 * SECOND;\nconst DAY: i64 = 24 * HOUR;\n\nimpl Interval {\n    pub fn unary_minus(\u0026self) -\u003e Self {\n        match self {\n            Interval::Month(v) =\u003e Interval::Month(-v),\n            Interval::Microsecond(v) =\u003e Interval::Microsecond(-v),\n        }\n    }\n\n    pub fn add(\u0026self, other: \u0026Interval) -\u003e Result\u003cSelf\u003e {\n        use Interval::*;\n\n        match (self, other) {\n            (Month(l), Month(r)) =\u003e Ok(Month(l + r)),\n            (Microsecond(l), Microsecond(r)) =\u003e Ok(Microsecond(l + r)),\n            _ =\u003e Err(IntervalError::AddBetweenYearToMonthAndHourToSecond.into()),\n        }\n    }\n\n    pub fn subtract(\u0026self, other: \u0026Interval) -\u003e Result\u003cSelf\u003e {\n        use Interval::*;\n\n        match (self, other) {\n            (Month(l), Month(r)) =\u003e Ok(Month(l - r)),\n            (Microsecond(l), Microsecond(r)) =\u003e Ok(Microsecond(l - r)),\n            _ =\u003e Err(IntervalError::SubtractBetweenYearToMonthAndHourToSecond.into()),\n        }\n    }\n\n    pub fn add_date(\u0026self, date: \u0026NaiveDate) -\u003e Result\u003cNaiveDateTime\u003e {\n        self.add_timestamp(\n            \u0026date\n                .and_hms_opt(0, 0, 0)\n                .ok_or_else(|| IntervalError::FailedToParseTime(date.to_string()))?,\n        )\n    }\n\n    pub fn subtract_from_date(\u0026self, date: \u0026NaiveDate) -\u003e Result\u003cNaiveDateTime\u003e {\n        self.subtract_from_timestamp(\n            \u0026date\n                .and_hms_opt(0, 0, 0)\n                .ok_or_else(|| IntervalError::FailedToParseTime(date.to_string()))?,\n        )\n    }\n\n    pub fn add_timestamp(\u0026self, timestamp: \u0026NaiveDateTime) -\u003e Result\u003cNaiveDateTime\u003e {\n        match self {\n            Interval::Month(n) =\u003e {\n                let month = timestamp.month() as i32 + n;\n\n                let year = timestamp.year() + month / 12;\n                let month = month % 12;\n\n                timestamp\n                    .with_year(year)\n                    .and_then(|d| d.with_month(month as u32))\n                    .ok_or_else(|| IntervalError::DateOverflow { year, month }.into())\n            }\n            Interval::Microsecond(n) =\u003e Ok(*timestamp + Duration::microseconds(*n)),\n        }\n    }\n\n    pub fn subtract_from_timestamp(\u0026self, timestamp: \u0026NaiveDateTime) -\u003e Result\u003cNaiveDateTime\u003e {\n        match self {\n            Interval::Month(n) =\u003e {\n                let months = timestamp.year() * 12 + timestamp.month() as i32 - n;\n\n                let year = months / 12;\n                let month = months % 12;\n\n                timestamp\n                    .with_year(year)\n                    .and_then(|d| d.with_month(month as u32))\n                    .ok_or_else(|| IntervalError::DateOverflow { year, month }.into())\n            }\n            Interval::Microsecond(n) =\u003e Ok(*timestamp - Duration::microseconds(*n)),\n        }\n    }\n\n    pub fn add_time(\u0026self, time: \u0026NaiveTime) -\u003e Result\u003cNaiveTime\u003e {\n        match self {\n            Interval::Month(_) =\u003e Err(IntervalError::AddYearOrMonthToTime {\n                time: *time,\n                interval: *self,\n            }\n            .into()),\n            Interval::Microsecond(n) =\u003e Ok(*time + Duration::microseconds(*n)),\n        }\n    }\n\n    pub fn subtract_from_time(\u0026self, time: \u0026NaiveTime) -\u003e Result\u003cNaiveTime\u003e {\n        match self {\n            Interval::Month(_) =\u003e Err(IntervalError::SubtractYearOrMonthToTime {\n                time: *time,\n                interval: *self,\n            }\n            .into()),\n            Interval::Microsecond(n) =\u003e Ok(*time - Duration::microseconds(*n)),\n        }\n    }\n\n    pub fn years(years: i32) -\u003e Self {\n        Interval::Month(12 * years)\n    }\n\n    pub fn months(months: i32) -\u003e Self {\n        Interval::Month(months)\n    }\n\n    pub fn extract(\u0026self, field: \u0026DateTimeField) -\u003e Result\u003cValue\u003e {\n        let value = match (field, *self) {\n            (DateTimeField::Year, Interval::Month(i)) =\u003e i as i64 / 12,\n            (DateTimeField::Month, Interval::Month(i)) =\u003e i as i64,\n            (DateTimeField::Day, Interval::Microsecond(i)) =\u003e i / DAY,\n            (DateTimeField::Hour, Interval::Microsecond(i)) =\u003e i / HOUR,\n            (DateTimeField::Minute, Interval::Microsecond(i)) =\u003e i / MINUTE,\n            (DateTimeField::Second, Interval::Microsecond(i)) =\u003e i / SECOND,\n            _ =\u003e {\n                return Err(IntervalError::FailedToExtract.into());\n            }\n        };\n\n        Ok(Value::I64(value))\n    }\n\n    pub fn days(days: i32) -\u003e Self {\n        Interval::Microsecond(days as i64 * DAY)\n    }\n\n    pub fn hours(hours: i32) -\u003e Self {\n        Interval::Microsecond(hours as i64 * HOUR)\n    }\n\n    pub fn minutes(minutes: i32) -\u003e Self {\n        Interval::Microsecond(minutes as i64 * MINUTE)\n    }\n\n    pub fn seconds(seconds: i64) -\u003e Self {\n        Interval::Microsecond(seconds * SECOND)\n    }\n\n    pub fn milliseconds(milliseconds: i64) -\u003e Self {\n        Interval::Microsecond(milliseconds * 1_000)\n    }\n\n    pub fn microseconds(microseconds: i64) -\u003e Self {\n        Interval::Microsecond(microseconds)\n    }\n\n    pub fn try_from_str(\n        value: \u0026str,\n        leading_field: Option\u003cDateTimeField\u003e,\n        last_field: Option\u003cDateTimeField\u003e,\n    ) -\u003e Result\u003cSelf\u003e {\n        use DateTimeField::*;\n\n        let value = value.trim_matches('\\'');\n\n        let sign = if value.get(0..1) == Some(\"-\") { -1 } else { 1 };\n\n        let parse_integer = |v: \u0026str| {\n            v.parse::\u003ci32\u003e()\n                .map_err(|_| IntervalError::FailedToParseInteger(value.to_owned()).into())\n        };\n\n        let parse_decimal = |duration: i64| {\n            let parsed = Decimal::from_str(value)\n                .map_err(|_| IntervalError::FailedToParseDecimal(value.to_owned()))?;\n\n            (parsed * Decimal::from(duration))\n                .to_i64()\n                .ok_or_else(|| IntervalError::FailedToParseDecimal(value.to_owned()).into())\n                .map(Interval::Microsecond)\n        };\n\n        let parse_time = |v: \u0026str| {\n            let sign = if v.get(0..1) == Some(\"-\") { -1 } else { 1 };\n            let v = v.trim_start_matches('-');\n            let time = NaiveTime::from_str(v)\n                .map_err(|_| IntervalError::FailedToParseTime(value.to_owned()))?;\n\n            let msec = time.hour() as i64 * HOUR\n                + time.minute() as i64 * MINUTE\n                + time.second() as i64 * SECOND\n                + time.nanosecond() as i64 / 1000;\n\n            Ok(Interval::Microsecond(sign as i64 * msec))\n        };\n\n        match (leading_field, last_field) {\n            (Some(Year), None) =\u003e parse_integer(value).map(Interval::years),\n            (Some(Month), None) =\u003e parse_integer(value).map(Interval::months),\n            (Some(Day), None) =\u003e parse_decimal(DAY),\n            (Some(Hour), None) =\u003e parse_decimal(HOUR),\n            (Some(Minute), None) =\u003e parse_decimal(MINUTE),\n            (Some(Second), None) =\u003e parse_decimal(SECOND),\n            (Some(Year), Some(Month)) =\u003e {\n                let nums = value\n                    .trim_start_matches('-')\n                    .split('-')\n                    .map(parse_integer)\n                    .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n                match (nums.first(), nums.get(1)) {\n                    (Some(years), Some(months)) =\u003e {\n                        Ok(Interval::months(sign * (12 * years + months)))\n                    }\n                    _ =\u003e Err(IntervalError::FailedToParseYearToMonth(value.to_owned()).into()),\n                }\n            }\n            (Some(Day), Some(Hour)) =\u003e {\n                let nums = value\n                    .trim_start_matches('-')\n                    .split(' ')\n                    .map(parse_integer)\n                    .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n                match (nums.first(), nums.get(1)) {\n                    (Some(days), Some(hours)) =\u003e Ok(Interval::hours(sign * (24 * days + hours))),\n                    _ =\u003e Err(IntervalError::FailedToParseDayToHour(value.to_owned()).into()),\n                }\n            }\n            (Some(Day), Some(Minute)) =\u003e {\n                let nums = value.trim_start_matches('-').split(' ').collect::\u003cVec\u003c_\u003e\u003e();\n\n                match (nums.first(), nums.get(1)) {\n                    (Some(days), Some(time)) =\u003e {\n                        let days = parse_integer(days)?;\n                        let time = format!(\"{}:00\", time);\n\n                        Interval::days(days)\n                            .add(\u0026parse_time(\u0026time)?)\n                            .map(|interval| sign * interval)\n                    }\n                    _ =\u003e Err(IntervalError::FailedToParseDayToMinute(value.to_owned()).into()),\n                }\n            }\n            (Some(Day), Some(Second)) =\u003e {\n                let nums = value.trim_start_matches('-').split(' ').collect::\u003cVec\u003c_\u003e\u003e();\n\n                match (nums.first(), nums.get(1)) {\n                    (Some(days), Some(time)) =\u003e {\n                        let days = parse_integer(days)?;\n\n                        Interval::days(days)\n                            .add(\u0026parse_time(time)?)\n                            .map(|interval| sign * interval)\n                    }\n                    _ =\u003e Err(IntervalError::FailedToParseDayToSecond(value.to_owned()).into()),\n                }\n            }\n            (Some(Hour), Some(Minute)) =\u003e parse_time(\u0026format!(\"{}:00\", value)),\n            (Some(Hour), Some(Second)) =\u003e parse_time(value),\n            (Some(Minute), Some(Second)) =\u003e {\n                let time = value.trim_start_matches('-');\n\n                parse_time(\u0026format!(\"00:{}\", time)).map(|v| sign * v)\n            }\n            (Some(from), Some(to)) =\u003e Err(IntervalError::UnsupportedRange(\n                format!(\"{:?}\", from),\n                format!(\"{:?}\", to),\n            )\n            .into()),\n            (None, _) =\u003e Err(IntervalError::Unreachable.into()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::{Interval, IntervalError},\n        crate::ast::DateTimeField,\n        chrono::{NaiveDate, NaiveTime},\n    };\n\n    #[test]\n    fn cmp() {\n        assert!(Interval::Month(12) \u003e Interval::Month(1));\n        assert!(Interval::Microsecond(300) \u003e Interval::Microsecond(1));\n\n        // NOTE: Month and Microsecond are incomparable\n        assert!(\n            Interval::Month(1)\n                .partial_cmp(\u0026Interval::Microsecond(1000))\n                .is_none()\n        );\n        assert!(\n            Interval::Microsecond(1000)\n                .partial_cmp(\u0026Interval::Month(1))\n                .is_none()\n        );\n    }\n\n    fn date(year: i32, month: u32, day: u32) -\u003e NaiveDate {\n        NaiveDate::from_ymd_opt(year, month, day).unwrap()\n    }\n\n    fn time(hour: u32, min: u32, sec: u32) -\u003e NaiveTime {\n        NaiveTime::from_hms_opt(hour, min, sec).unwrap()\n    }\n\n    #[test]\n    fn arithmetic() {\n        use Interval::*;\n\n        macro_rules! test {\n            ($op: ident $a: expr, $b: expr =\u003e $c: expr) =\u003e {\n                assert_eq!($a.$op(\u0026$b), Ok($c));\n            };\n        }\n\n        assert_eq!(Month(1).unary_minus(), Month(-1));\n        assert_eq!(Microsecond(1).unary_minus(), Microsecond(-1));\n\n        // date\n        assert_eq!(\n            Month(2).add_date(\u0026date(2021, 11, 11)),\n            Ok(date(2022, 1, 11).and_hms_opt(0, 0, 0).unwrap())\n        );\n        assert_eq!(\n            Interval::hours(30).add_date(\u0026date(2021, 11, 11)),\n            Ok(date(2021, 11, 12).and_hms_opt(6, 0, 0).unwrap())\n        );\n        assert_eq!(\n            Interval::years(999_999).add_date(\u0026date(2021, 11, 11)),\n            Err(IntervalError::DateOverflow {\n                year: 1_002_020,\n                month: 11,\n            }\n            .into())\n        );\n        assert_eq!(\n            Month(2).subtract_from_date(\u0026date(2021, 11, 11)),\n            Ok(date(2021, 9, 11).and_hms_opt(0, 0, 0).unwrap())\n        );\n        assert_eq!(\n            Month(14).subtract_from_date(\u0026date(2021, 11, 11)),\n            Ok(date(2020, 9, 11).and_hms_opt(0, 0, 0).unwrap())\n        );\n        assert_eq!(\n            Interval::hours(30).subtract_from_date(\u0026date(2021, 11, 11)),\n            Ok(date(2021, 11, 9).and_hms_opt(18, 0, 0).unwrap())\n        );\n        assert_eq!(\n            Interval::years(999_999).subtract_from_date(\u0026date(2021, 11, 11)),\n            Err(IntervalError::DateOverflow {\n                year: -997977,\n                month: -1,\n            }\n            .into())\n        );\n\n        // timestamp\n        assert_eq!(\n            Interval::minutes(2).add_timestamp(\u0026date(2021, 11, 11).and_hms_opt(12, 3, 1).unwrap()),\n            Ok(date(2021, 11, 11).and_hms_opt(12, 5, 1).unwrap())\n        );\n        assert_eq!(\n            Interval::hours(30).add_timestamp(\u0026date(2021, 11, 11).and_hms_opt(0, 30, 0).unwrap()),\n            Ok(date(2021, 11, 12).and_hms_opt(6, 30, 0).unwrap())\n        );\n        assert_eq!(\n            Interval::years(999_999)\n                .add_timestamp(\u0026date(2021, 11, 11).and_hms_opt(1, 1, 1).unwrap()),\n            Err(IntervalError::DateOverflow {\n                year: 1_002_020,\n                month: 11,\n            }\n            .into())\n        );\n        assert_eq!(\n            Month(2).subtract_from_timestamp(\u0026date(2021, 11, 11).and_hms_opt(1, 3, 59).unwrap()),\n            Ok(date(2021, 9, 11).and_hms_opt(1, 3, 59).unwrap())\n        );\n        assert_eq!(\n            Month(14).subtract_from_timestamp(\u0026date(2021, 11, 11).and_hms_opt(23, 1, 1).unwrap()),\n            Ok(date(2020, 9, 11).and_hms_opt(23, 1, 1).unwrap())\n        );\n        assert_eq!(\n            Interval::seconds(30)\n                .subtract_from_timestamp(\u0026date(2021, 11, 11).and_hms_opt(0, 0, 0).unwrap()),\n            Ok(date(2021, 11, 10).and_hms_opt(23, 59, 30).unwrap())\n        );\n        assert_eq!(\n            Interval::years(999_999)\n                .subtract_from_timestamp(\u0026date(2021, 11, 11).and_hms_opt(0, 0, 0).unwrap()),\n            Err(IntervalError::DateOverflow {\n                year: -997977,\n                month: -1,\n            }\n            .into())\n        );\n\n        // time\n        assert_eq!(\n            Interval::minutes(30).add_time(\u0026time(23, 0, 1)),\n            Ok(time(23, 30, 1))\n        );\n        assert_eq!(\n            Interval::hours(20).add_time(\u0026time(5, 30, 0)),\n            Ok(time(1, 30, 0))\n        );\n        assert_eq!(\n            Interval::years(1).add_time(\u0026time(23, 0, 1)),\n            Err(IntervalError::AddYearOrMonthToTime {\n                time: time(23, 0, 1),\n                interval: Interval::years(1),\n            }\n            .into())\n        );\n        assert_eq!(\n            Interval::minutes(30).subtract_from_time(\u0026time(23, 0, 1)),\n            Ok(time(22, 30, 1))\n        );\n        assert_eq!(\n            Interval::hours(20).subtract_from_time(\u0026time(5, 30, 0)),\n            Ok(time(9, 30, 0))\n        );\n        assert_eq!(\n            Interval::months(3).subtract_from_time(\u0026time(23, 0, 1)),\n            Err(IntervalError::SubtractYearOrMonthToTime {\n                time: time(23, 0, 1),\n                interval: Interval::months(3),\n            }\n            .into())\n        );\n\n        test!(add      Month(1), Month(2) =\u003e Month(3));\n        test!(subtract Month(1), Month(2) =\u003e Month(-1));\n\n        test!(add      Microsecond(1), Microsecond(2) =\u003e Microsecond(3));\n        test!(subtract Microsecond(1), Microsecond(2) =\u003e Microsecond(-1));\n    }\n\n    #[test]\n    fn try_from_literal() {\n        macro_rules! test {\n            ($value: expr, $datetime: ident =\u003e $expected_value: expr, $duration: ident) =\u003e {\n                let interval = Interval::try_from_str($value, Some(DateTimeField::$datetime), None);\n\n                assert_eq!(interval, Ok(Interval::$duration($expected_value)));\n            };\n            ($value: expr, $from: ident to $to: ident =\u003e $expected_value: expr, $duration: ident) =\u003e {\n                let interval = Interval::try_from_str(\n                    $value,\n                    Some(DateTimeField::$from),\n                    Some(DateTimeField::$to),\n                );\n\n                assert_eq!(interval, Ok(Interval::$duration($expected_value)));\n            };\n        }\n\n        test!(\"11\",   Year   =\u003e 11,  years);\n        test!(\"-11\",  Year   =\u003e -11, years);\n        test!(\"18\",   Month  =\u003e 18,  months);\n        test!(\"-19\",  Month  =\u003e -19, months);\n        test!(\"2\",    Day    =\u003e 2,   days);\n        test!(\"1.5\",  Day    =\u003e 36,  hours);\n        test!(\"-1.5\", Day    =\u003e -36, hours);\n        test!(\"2.5\",  Hour   =\u003e 150, minutes);\n        test!(\"1\",    Hour   =\u003e 60,  minutes);\n        test!(\"-1\",   Hour   =\u003e -60, minutes);\n        test!(\"35\",   Minute =\u003e 35,  minutes);\n        test!(\"-35\",  Minute =\u003e -35, minutes);\n        test!(\"10.5\", Minute =\u003e 630, seconds);\n        test!(\"10\",   Second =\u003e 10,  seconds);\n        test!(\"-10\",  Second =\u003e -10, seconds);\n        test!(\"10.5\", Second =\u003e 10_500_000, microseconds);\n        test!(\"-1.5\", Second =\u003e -1_500_000, microseconds);\n\n        test!(\"10-2\", Year to Month =\u003e 122, months);\n        test!(\"2 12\", Day to Hour =\u003e 60, hours);\n        test!(\"1 01:30\", Day to Minute =\u003e 60 * 24 + 90, minutes);\n        test!(\"1 01:30:40\", Day to Second =\u003e (60 * 24 + 90) * 60 + 40, seconds);\n        test!(\"3 02:30:40.1234\", Day to Second =\u003e\n            (((3 * 24 + 2) * 60 + 30) * 60 + 40) * 1_000_000 + 123_400, microseconds);\n        test!(\"12:34\", Hour to Minute =\u003e 12 * 60 + 34, minutes);\n        test!(\"12:34:56\", Hour to Second =\u003e (12 * 60 + 34) * 60 + 56, seconds);\n        test!(\"12:34:56.1234\", Hour to Second =\u003e ((12 * 60 + 34) * 60 + 56) * 1_000_000 + 123_400, microseconds);\n        test!(\"34:56.1234\", Minute to Second =\u003e (34 * 60 + 56) * 1_000_000 + 123_400, microseconds);\n\n        test!(\"-1-4\", Year to Month =\u003e -16, months);\n        test!(\"-2 10\", Day to Hour =\u003e -58, hours);\n        test!(\"-1 00:01\", Day to Minute =\u003e -(24 * 60 + 1), minutes);\n        test!(\"-1 00:00:01\", Day to Second =\u003e -(24 * 3600 + 1), seconds);\n        test!(\"-1 00:00:01.1\", Day to Second =\u003e -((24 * 3600 + 1) * 1000 + 100), milliseconds);\n        test!(\"-21:10\", Hour to Minute =\u003e -(21 * 60 + 10), minutes);\n        test!(\"-05:12:03\", Hour to Second =\u003e -(5 * 3600 + 12 * 60 + 3), seconds);\n        test!(\"-03:59:22.372\", Hour to Second =\u003e -((3 * 3600 + 59 * 60 + 22) * 1000 + 372), milliseconds);\n        test!(\"-09:33\", Minute to Second =\u003e -(9 * 60 + 33), seconds);\n        test!(\"-09:33.192\", Minute to Second =\u003e -((9 * 60 + 33) * 1000 + 192), milliseconds);\n    }\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":144},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","key.rs"],"content":"use {\n    crate::{\n        data::{Interval, Value},\n        result::{Error, Result},\n    },\n    chrono::{Datelike, NaiveDate, NaiveDateTime, NaiveTime, Timelike},\n    ordered_float::OrderedFloat,\n    rust_decimal::Decimal,\n    serde::{Deserialize, Serialize},\n    std::{cmp::Ordering, fmt::Debug, net::IpAddr},\n    thiserror::Error as ThisError,\n};\n\n#[derive(ThisError, Debug, PartialEq, Eq, Serialize)]\npub enum KeyError {\n    #[error(\"FLOAT data type cannot be converted to Big-Endian bytes for comparison\")]\n    FloatToCmpBigEndianNotSupported,\n\n    #[error(\"MAP data type cannot be used as Key\")]\n    MapTypeKeyNotSupported,\n\n    #[error(\"LIST data type cannot be used as Key\")]\n    ListTypeKeyNotSupported,\n\n    #[error(\"POINT data type cannot be used as Key\")]\n    PointTypeKeyNotSupported,\n}\n\n#[derive(PartialEq, Eq, Hash, Clone, Debug, Serialize, Deserialize)]\npub enum Key {\n    I8(i8),\n    I16(i16),\n    I32(i32),\n    I64(i64),\n    I128(i128),\n    U8(u8),\n    U16(u16),\n    U32(u32),\n    U64(u64),\n    U128(u128),\n    F32(OrderedFloat\u003cf32\u003e),\n    F64(OrderedFloat\u003cf64\u003e),\n    Decimal(Decimal),\n    Bool(bool),\n    Str(String),\n    Bytea(Vec\u003cu8\u003e),\n    Date(NaiveDate),\n    Timestamp(NaiveDateTime),\n    Time(NaiveTime),\n    Interval(Interval),\n    Uuid(u128),\n    Inet(IpAddr),\n    None,\n}\n\nimpl Ord for Key {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        match (self, other) {\n            (Key::I8(l), Key::I8(r)) =\u003e l.cmp(r),\n            (Key::I16(l), Key::I16(r)) =\u003e l.cmp(r),\n            (Key::I32(l), Key::I32(r)) =\u003e l.cmp(r),\n            (Key::I64(l), Key::I64(r)) =\u003e l.cmp(r),\n            (Key::I128(l), Key::I128(r)) =\u003e l.cmp(r),\n            (Key::U8(l), Key::U8(r)) =\u003e l.cmp(r),\n            (Key::U16(l), Key::U16(r)) =\u003e l.cmp(r),\n            (Key::U32(l), Key::U32(r)) =\u003e l.cmp(r),\n            (Key::U64(l), Key::U64(r)) =\u003e l.cmp(r),\n            (Key::U128(l), Key::U128(r)) =\u003e l.cmp(r),\n            (Key::F32(l), Key::F32(r)) =\u003e l.total_cmp(\u0026r.0),\n            (Key::F64(l), Key::F64(r)) =\u003e l.total_cmp(\u0026r.0),\n            (Key::Decimal(l), Key::Decimal(r)) =\u003e l.cmp(r),\n            (Key::Bool(l), Key::Bool(r)) =\u003e l.cmp(r),\n            (Key::Str(l), Key::Str(r)) =\u003e l.cmp(r),\n            (Key::Bytea(l), Key::Bytea(r)) =\u003e l.cmp(r),\n            (Key::Date(l), Key::Date(r)) =\u003e l.cmp(r),\n            (Key::Timestamp(l), Key::Timestamp(r)) =\u003e l.cmp(r),\n            (Key::Time(l), Key::Time(r)) =\u003e l.cmp(r),\n            (Key::Interval(l), Key::Interval(r)) =\u003e l.partial_cmp(r).unwrap_or(match (l, r) {\n                (Interval::Month(_), Interval::Microsecond(_)) =\u003e Ordering::Greater,\n                _ =\u003e Ordering::Less,\n            }),\n            (Key::Uuid(l), Key::Uuid(r)) =\u003e l.cmp(r),\n            (Key::Inet(l), Key::Inet(r)) =\u003e l.cmp(r),\n            (Key::None, Key::None) =\u003e Ordering::Equal,\n            (Key::None, _) =\u003e Ordering::Greater,\n            (_, Key::None) =\u003e Ordering::Less,\n\n            (left, right) =\u003e {\n                if left.to_order() \u003c= right.to_order() {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            }\n        }\n    }\n}\n\nimpl PartialOrd for Key {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl TryFrom\u003cValue\u003e for Key {\n    type Error = Error;\n\n    fn try_from(value: Value) -\u003e Result\u003cSelf\u003e {\n        use Value::*;\n\n        match value {\n            Bool(v) =\u003e Ok(Key::Bool(v)),\n            I8(v) =\u003e Ok(Key::I8(v)),\n            I16(v) =\u003e Ok(Key::I16(v)),\n            I32(v) =\u003e Ok(Key::I32(v)),\n            I64(v) =\u003e Ok(Key::I64(v)),\n            I128(v) =\u003e Ok(Key::I128(v)),\n            U8(v) =\u003e Ok(Key::U8(v)),\n            U16(v) =\u003e Ok(Key::U16(v)),\n            U32(v) =\u003e Ok(Key::U32(v)),\n            U64(v) =\u003e Ok(Key::U64(v)),\n            U128(v) =\u003e Ok(Key::U128(v)),\n            F32(v) =\u003e Ok(Key::F32(OrderedFloat(v))),\n            F64(v) =\u003e Ok(Key::F64(OrderedFloat(v))),\n            Decimal(v) =\u003e Ok(Key::Decimal(v)),\n            Str(v) =\u003e Ok(Key::Str(v)),\n            Bytea(v) =\u003e Ok(Key::Bytea(v)),\n            Inet(v) =\u003e Ok(Key::Inet(v)),\n            Date(v) =\u003e Ok(Key::Date(v)),\n            Timestamp(v) =\u003e Ok(Key::Timestamp(v)),\n            Time(v) =\u003e Ok(Key::Time(v)),\n            Interval(v) =\u003e Ok(Key::Interval(v)),\n            Uuid(v) =\u003e Ok(Key::Uuid(v)),\n            Null =\u003e Ok(Key::None),\n            Map(_) =\u003e Err(KeyError::MapTypeKeyNotSupported.into()),\n            List(_) =\u003e Err(KeyError::ListTypeKeyNotSupported.into()),\n            Point(_) =\u003e Err(KeyError::PointTypeKeyNotSupported.into()),\n        }\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for Key {\n    type Error = Error;\n\n    fn try_from(value: \u0026Value) -\u003e Result\u003cSelf\u003e {\n        value.clone().try_into()\n    }\n}\n\nimpl From\u003cKey\u003e for Value {\n    fn from(key: Key) -\u003e Self {\n        match key {\n            Key::Bool(v) =\u003e Value::Bool(v),\n            Key::I8(v) =\u003e Value::I8(v),\n            Key::I16(v) =\u003e Value::I16(v),\n            Key::I32(v) =\u003e Value::I32(v),\n            Key::I64(v) =\u003e Value::I64(v),\n            Key::I128(v) =\u003e Value::I128(v),\n            Key::U8(v) =\u003e Value::U8(v),\n            Key::U16(v) =\u003e Value::U16(v),\n            Key::U32(v) =\u003e Value::U32(v),\n            Key::U64(v) =\u003e Value::U64(v),\n            Key::U128(v) =\u003e Value::U128(v),\n            Key::F32(v) =\u003e Value::F32(v.0),\n            Key::F64(v) =\u003e Value::F64(v.0),\n            Key::Decimal(v) =\u003e Value::Decimal(v),\n            Key::Str(v) =\u003e Value::Str(v),\n            Key::Bytea(v) =\u003e Value::Bytea(v),\n            Key::Inet(v) =\u003e Value::Inet(v),\n            Key::Date(v) =\u003e Value::Date(v),\n            Key::Timestamp(v) =\u003e Value::Timestamp(v),\n            Key::Time(v) =\u003e Value::Time(v),\n            Key::Interval(v) =\u003e Value::Interval(v),\n            Key::Uuid(v) =\u003e Value::Uuid(v),\n            Key::None =\u003e Value::Null,\n        }\n    }\n}\n\nconst VALUE: u8 = 0;\nconst NONE: u8 = 1;\n\nimpl Key {\n    /// Key to Big-Endian for comparison purpose\n    pub fn to_cmp_be_bytes(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n        Ok(match self {\n            Key::Bool(v) =\u003e {\n                if *v {\n                    vec![VALUE, 1]\n                } else {\n                    vec![VALUE, 0]\n                }\n            }\n            Key::I8(v) =\u003e {\n                let sign = u8::from(*v \u003e= 0);\n\n                [VALUE, sign]\n                    .iter()\n                    .chain(v.to_be_bytes().iter())\n                    .copied()\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            }\n            Key::I16(v) =\u003e {\n                let sign = u8::from(*v \u003e= 0);\n\n                [VALUE, sign]\n                    .iter()\n                    .chain(v.to_be_bytes().iter())\n                    .copied()\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            }\n            Key::I32(v) =\u003e {\n                let sign = u8::from(*v \u003e= 0);\n\n                [VALUE, sign]\n                    .iter()\n                    .chain(v.to_be_bytes().iter())\n                    .copied()\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            }\n            Key::I64(v) =\u003e {\n                let sign = u8::from(*v \u003e= 0);\n\n                [VALUE, sign]\n                    .iter()\n                    .chain(v.to_be_bytes().iter())\n                    .copied()\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            }\n            Key::I128(v) =\u003e {\n                let sign = u8::from(*v \u003e= 0);\n\n                [VALUE, sign]\n                    .iter()\n                    .chain(v.to_be_bytes().iter())\n                    .copied()\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            }\n            Key::U8(v) =\u003e [VALUE, 1]\n                .iter()\n                .chain(v.to_be_bytes().iter())\n                .copied()\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            Key::U16(v) =\u003e [VALUE, 1]\n                .iter()\n                .chain(v.to_be_bytes().iter())\n                .copied()\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            Key::U32(v) =\u003e [VALUE, 1]\n                .iter()\n                .chain(v.to_be_bytes().iter())\n                .copied()\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            Key::U64(v) =\u003e [VALUE, 1]\n                .iter()\n                .chain(v.to_be_bytes().iter())\n                .copied()\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            Key::U128(v) =\u003e [VALUE, 1]\n                .iter()\n                .chain(v.to_be_bytes().iter())\n                .copied()\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            Key::F32(_) | Key::F64(_) =\u003e {\n                return Err(KeyError::FloatToCmpBigEndianNotSupported.into());\n            }\n            Key::Decimal(v) =\u003e {\n                let sign = u8::from(v.is_sign_positive());\n                let convert = |v: Decimal| {\n                    let v = v.unpack();\n                    let v = v.lo as i128 + ((v.mid as i128) \u003c\u003c 32) + ((v.hi as i128) \u003c\u003c 64);\n\n                    if sign == 0 { -v } else { v }\n                };\n\n                [VALUE, sign]\n                    .into_iter()\n                    .chain(convert(v.trunc()).to_be_bytes())\n                    .chain(convert(v.fract()).to_be_bytes())\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            }\n            Key::Str(v) =\u003e [VALUE]\n                .iter()\n                .chain(v.as_bytes().iter())\n                .copied()\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            Key::Bytea(v) =\u003e v.to_vec(),\n            Key::Inet(v) =\u003e match v {\n                IpAddr::V4(v) =\u003e v.octets().to_vec(),\n                IpAddr::V6(v) =\u003e v.octets().to_vec(),\n            },\n            Key::Date(date) =\u003e [VALUE]\n                .iter()\n                .chain(date.num_days_from_ce().to_be_bytes().iter())\n                .copied()\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            Key::Time(time) =\u003e {\n                let secs = time.num_seconds_from_midnight();\n                let frac = time.nanosecond();\n\n                [VALUE]\n                    .iter()\n                    .chain(secs.to_be_bytes().iter())\n                    .chain(frac.to_be_bytes().iter())\n                    .copied()\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            }\n            Key::Timestamp(datetime) =\u003e {\n                let date = datetime.num_days_from_ce();\n                let secs = datetime.num_seconds_from_midnight();\n                let frac = datetime.nanosecond();\n\n                [VALUE]\n                    .iter()\n                    .chain(date.to_be_bytes().iter())\n                    .chain(secs.to_be_bytes().iter())\n                    .chain(frac.to_be_bytes().iter())\n                    .copied()\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            }\n            Key::Interval(interval) =\u003e {\n                let (month, microsec) = match interval {\n                    Interval::Month(month) =\u003e (*month, 0),\n                    Interval::Microsecond(microsec) =\u003e (0, *microsec),\n                };\n\n                [VALUE]\n                    .iter()\n                    .chain(month.to_be_bytes().iter())\n                    .chain(microsec.to_be_bytes().iter())\n                    .copied()\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            }\n            Key::Uuid(v) =\u003e [VALUE]\n                .iter()\n                .chain(v.to_be_bytes().iter())\n                .copied()\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            Key::None =\u003e vec![NONE],\n        })\n    }\n\n    fn to_order(\u0026self) -\u003e u8 {\n        match self {\n            Key::I8(_) =\u003e 1,\n            Key::I16(_) =\u003e 2,\n            Key::I32(_) =\u003e 3,\n            Key::I64(_) =\u003e 4,\n            Key::I128(_) =\u003e 5,\n            Key::U8(_) =\u003e 6,\n            Key::U16(_) =\u003e 7,\n            Key::U32(_) =\u003e 8,\n            Key::U64(_) =\u003e 9,\n            Key::U128(_) =\u003e 10,\n            Key::F32(_) =\u003e 11,\n            Key::F64(_) =\u003e 12,\n            Key::Decimal(_) =\u003e 13,\n            Key::Bool(_) =\u003e 14,\n            Key::Str(_) =\u003e 15,\n            Key::Bytea(_) =\u003e 16,\n            Key::Date(_) =\u003e 17,\n            Key::Timestamp(_) =\u003e 18,\n            Key::Time(_) =\u003e 19,\n            Key::Interval(_) =\u003e 20,\n            Key::Uuid(_) =\u003e 21,\n            Key::Inet(_) =\u003e 22,\n            Key::None =\u003e 23,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            data::{Interval, Key, KeyError, Point, Value},\n            executor::evaluate_stateless,\n            parse_sql::parse_expr,\n            result::Result,\n            translate::translate_expr,\n        },\n        chrono::{DateTime, NaiveDate, NaiveTime},\n        futures::executor::block_on,\n        rust_decimal::Decimal,\n        std::{cmp::Ordering, collections::HashMap, net::IpAddr, str::FromStr},\n    };\n\n    fn convert(sql: \u0026str) -\u003e Result\u003cKey\u003e {\n        let parsed = parse_expr(sql).expect(sql);\n        let expr = translate_expr(\u0026parsed).expect(sql);\n\n        block_on(evaluate_stateless(None, \u0026expr))\n            .expect(sql)\n            .try_into()\n    }\n\n    #[test]\n    fn evaluated_to_key() {\n        // Some\n        assert_eq!(convert(\"True\"), Ok(Key::Bool(true)));\n        assert_eq!(convert(\"CAST(11 AS INT8)\"), Ok(Key::I8(11)));\n        assert_eq!(convert(\"CAST(11 AS INT16)\"), Ok(Key::I16(11)));\n        assert_eq!(convert(\"CAST(11 AS INT32)\"), Ok(Key::I32(11)));\n        assert_eq!(convert(\"2048\"), Ok(Key::I64(2048)));\n        assert_eq!(convert(\"CAST(1024 AS INT128)\"), Ok(Key::I128(1024)));\n        assert_eq!(convert(\"CAST(11 AS UINT8)\"), Ok(Key::U8(11)));\n        assert_eq!(convert(\"CAST(11 AS UINT16)\"), Ok(Key::U16(11)));\n        assert_eq!(convert(\"CAST(11 AS UINT32)\"), Ok(Key::U32(11)));\n        assert_eq!(convert(\"CAST(11 AS UINT64)\"), Ok(Key::U64(11)));\n        assert_eq!(convert(\"CAST(11 AS UINT128)\"), Ok(Key::U128(11)));\n        assert!(matches!(convert(\"CAST(12.03 AS FLOAT32)\"), Ok(Key::F32(_))));\n        assert!(matches!(convert(\"12.03\"), Ok(Key::F64(_))));\n\n        assert_eq!(\n            convert(\"CAST(123.45 AS DECIMAL)\"),\n            Ok(Key::Decimal(Decimal::from_str(\"123.45\").unwrap()))\n        );\n        assert_eq!(\n            convert(\"CAST(0 AS INET)\"),\n            Ok(Key::Inet(IpAddr::from_str(\"0.0.0.0\").unwrap()))\n        );\n\n        assert_eq!(\n            convert(\"'Hello World'\"),\n            Ok(Key::Str(\"Hello World\".to_owned()))\n        );\n        assert_eq!(\n            convert(\"X'1234'\"),\n            Ok(Key::Bytea(hex::decode(\"1234\").unwrap())),\n        );\n        assert!(matches!(convert(\"DATE '2022-03-03'\"), Ok(Key::Date(_))));\n        assert!(matches!(convert(\"TIME '12:30:00'\"), Ok(Key::Time(_))));\n        assert!(matches!(\n            convert(\"TIMESTAMP '2022-03-03 12:30:00Z'\"),\n            Ok(Key::Timestamp(_))\n        ));\n        assert!(matches!(convert(\"INTERVAL '1' DAY\"), Ok(Key::Interval(_))));\n        assert!(matches!(convert(\"GENERATE_UUID()\"), Ok(Key::Uuid(_))));\n\n        // None\n        assert_eq!(convert(\"NULL\"), Ok(Key::None));\n\n        // Error\n        assert_eq!(\n            Key::try_from(Value::Map(HashMap::default())),\n            Err(KeyError::MapTypeKeyNotSupported.into())\n        );\n        assert_eq!(\n            Key::try_from(Value::List(Vec::default())),\n            Err(KeyError::ListTypeKeyNotSupported.into())\n        );\n        assert_eq!(\n            convert(\"SUBSTR('BEEF', 2, 3)\"),\n            Ok(Key::Str(\"EEF\".to_owned()))\n        );\n        assert_eq!(convert(\"POSITION('PORK' IN 'MEAT')\"), Ok(Key::I64(0)));\n        assert_eq!(convert(\"FIND_IDX('Calzone', 'zone')\"), Ok(Key::I64(4)));\n        assert_eq!(\n            convert(\"EXTRACT(SECOND FROM INTERVAL '8' SECOND)\"),\n            Ok(Key::I64(8))\n        );\n        assert_eq!(\n            Key::try_from(Value::Point(Point::new(1.0, 2.0))),\n            Err(KeyError::PointTypeKeyNotSupported.into())\n        );\n    }\n\n    #[test]\n    fn cmp() {\n        use {\n            std::{net::IpAddr, str::FromStr},\n            uuid::Uuid,\n        };\n\n        let dec = |v| Decimal::from_str(v).unwrap();\n        let date = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n        let timestamp = |v| DateTime::from_timestamp_millis(v).unwrap().naive_utc();\n        let time = |h, m, s| NaiveTime::from_hms_milli_opt(h, m, s, 0).unwrap();\n        let uuid = |v| Uuid::parse_str(v).unwrap().as_u128();\n        let inet = |v| IpAddr::from_str(v).unwrap();\n\n        assert!(Key::I8(10) \u003e Key::I8(3));\n        assert!(Key::I8(1) \u003e Key::I16(1));\n\n        assert!(Key::I16(10) \u003e Key::I16(3));\n        assert!(Key::I16(1) \u003e Key::I32(1));\n\n        assert!(Key::I32(10) \u003e Key::I32(3));\n        assert!(Key::I32(1) \u003e Key::I64(1));\n\n        assert!(Key::I64(10) \u003e Key::I64(3));\n        assert!(Key::I64(1) \u003e Key::I128(1));\n\n        assert!(Key::I128(10) \u003e Key::I128(3));\n        assert!(Key::I128(1) \u003e Key::U8(1));\n\n        assert!(Key::U8(10) \u003e Key::U8(3));\n        assert!(Key::U8(1) \u003e Key::U16(1));\n\n        assert!(Key::U16(10) \u003e Key::U16(3));\n        assert!(Key::U16(1) \u003e Key::Decimal(dec(\"1\")));\n\n        assert!(Key::U32(10) \u003e Key::U32(3));\n        assert!(Key::U32(1) \u003e Key::Decimal(dec(\"1\")));\n\n        assert!(Key::U64(10) \u003e Key::U64(3));\n        assert!(Key::U64(1) \u003e Key::Decimal(dec(\"1\")));\n\n        assert!(Key::U128(10) \u003e Key::U128(3));\n        assert!(Key::U128(1) \u003e Key::Decimal(dec(\"1\")));\n\n        assert!(Key::F32(10.0_f32.into()) \u003e Key::F32(3.0_f32.into()));\n        assert!(Key::F32(1.0_f32.into()) \u003e Key::F64(1.0.into()));\n\n        assert!(Key::F64(10.0.into()) \u003e Key::F64(3.0.into()));\n        assert!(Key::F64(1.0.into()) \u003e Key::Decimal(dec(\"1\")));\n\n        assert!(Key::Decimal(dec(\"123.45\")) \u003e Key::Decimal(dec(\"0.11\")));\n        assert!(Key::Decimal(dec(\"1\")) \u003e Key::Bool(true));\n\n        assert!(Key::Bool(true) \u003e Key::Bool(false));\n        assert!(Key::Bool(true) \u003e Key::Str(\"zzz\".to_owned()));\n\n        assert!(Key::Str(\"def\".to_owned()) \u003e Key::Str(\"abcd\".to_owned()));\n        assert!(Key::Str(\"hi\".to_owned()) \u003e Key::Bytea(vec![101]));\n\n        assert!(Key::Bytea(vec![100]) \u003e Key::Bytea(vec![3]));\n        assert!(Key::Bytea(vec![0]) \u003e Key::Date(date(2023, 1, 1)));\n\n        assert!(Key::Date(date(2023, 3, 1)) \u003e Key::Date(date(1999, 6, 11)));\n        assert!(Key::Date(date(2022, 6, 1)) \u003e Key::Timestamp(timestamp(1669000003)));\n\n        assert!(Key::Timestamp(timestamp(1662921288)) \u003e Key::Timestamp(timestamp(1661000000)));\n        assert!(Key::Timestamp(timestamp(1668919293)) \u003e Key::Time(time(23, 1, 59)));\n\n        assert!(Key::Time(time(20, 1, 9)) \u003e Key::Time(time(10, 0, 3)));\n        assert!(Key::Time(time(1, 2, 3)) \u003e Key::Interval(Interval::Month(12)));\n\n        assert!(Key::Interval(Interval::Month(3)) \u003e Key::Interval(Interval::Month(1)));\n        assert!(\n            Key::Interval(Interval::microseconds(1))\n                \u003e Key::Uuid(uuid(\"dc98e386-a4d0-45c7-babe-b4238de4b139\"))\n        );\n\n        assert!(\n            Key::Uuid(uuid(\"dc98e386-a4d0-45c7-babe-b4238de4b139\"))\n                \u003e Key::Uuid(uuid(\"550e8400-e29b-41d4-a716-446655440000\"))\n        );\n        assert!(\n            Key::Uuid(uuid(\"dc98e386-a4d0-45c7-babe-b4238de4b139\")) \u003e Key::Inet(inet(\"127.0.0.1\"))\n        );\n\n        assert!(Key::Inet(inet(\"127.0.0.1\")) \u003e Key::Inet(inet(\"0.0.0.1\")));\n        assert!(Key::Inet(inet(\"192.168.1.19\")) \u003c Key::None);\n\n        assert_eq!(Key::None.partial_cmp(\u0026Key::None), Some(Ordering::Equal));\n        assert!(Key::None \u003e Key::I8(100));\n    }\n\n    #[test]\n    fn cmp_big_endian() {\n        use crate::data::{Interval as I, Key::*};\n\n        fn cmp(ls: \u0026Result\u003cVec\u003cu8\u003e\u003e, rs: \u0026Result\u003cVec\u003cu8\u003e\u003e) -\u003e Ordering {\n            let ls = ls.as_ref().unwrap();\n            let rs = rs.as_ref().unwrap();\n\n            for (l, r) in ls.iter().zip(rs.iter()) {\n                match l.cmp(r) {\n                    Ordering::Equal =\u003e continue,\n                    ordering =\u003e return ordering,\n                }\n            }\n\n            let size_l = ls.len();\n            let size_r = rs.len();\n\n            size_l.cmp(\u0026size_r)\n        }\n\n        let null = None.to_cmp_be_bytes();\n\n        let n1 = Bool(true).to_cmp_be_bytes();\n        let n2 = Bool(false).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n2, \u0026n2), Ordering::Equal);\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n2, \u0026n1), Ordering::Less);\n        assert_eq!(cmp(\u0026n1, \u0026null), Ordering::Less);\n\n        let n1 = I8(-100).to_cmp_be_bytes();\n        let n2 = I8(-10).to_cmp_be_bytes();\n        let n3 = I8(0).to_cmp_be_bytes();\n        let n4 = I8(3).to_cmp_be_bytes();\n        let n5 = I8(20).to_cmp_be_bytes();\n        let n6 = I8(100).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026n6), Ordering::Less);\n        assert_eq!(cmp(\u0026n5, \u0026n5), Ordering::Equal);\n        assert_eq!(cmp(\u0026n4, \u0026n5), Ordering::Less);\n        assert_eq!(cmp(\u0026n6, \u0026n4), Ordering::Greater);\n        assert_eq!(cmp(\u0026n4, \u0026null), Ordering::Less);\n\n        let n1 = I16(-100).to_cmp_be_bytes();\n        let n2 = I16(-10).to_cmp_be_bytes();\n        let n3 = I16(0).to_cmp_be_bytes();\n        let n4 = I16(3).to_cmp_be_bytes();\n        let n5 = I16(20).to_cmp_be_bytes();\n        let n6 = I16(100).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026n6), Ordering::Less);\n        assert_eq!(cmp(\u0026n5, \u0026n5), Ordering::Equal);\n        assert_eq!(cmp(\u0026n4, \u0026n5), Ordering::Less);\n        assert_eq!(cmp(\u0026n6, \u0026n4), Ordering::Greater);\n        assert_eq!(cmp(\u0026n4, \u0026null), Ordering::Less);\n\n        let n1 = I32(-100).to_cmp_be_bytes();\n        let n2 = I32(-10).to_cmp_be_bytes();\n        let n3 = I32(0).to_cmp_be_bytes();\n        let n4 = I32(3).to_cmp_be_bytes();\n        let n5 = I32(20).to_cmp_be_bytes();\n        let n6 = I32(100).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026n6), Ordering::Less);\n        assert_eq!(cmp(\u0026n5, \u0026n5), Ordering::Equal);\n        assert_eq!(cmp(\u0026n4, \u0026n5), Ordering::Less);\n        assert_eq!(cmp(\u0026n6, \u0026n4), Ordering::Greater);\n        assert_eq!(cmp(\u0026n4, \u0026null), Ordering::Less);\n\n        let n1 = I64(-123).to_cmp_be_bytes();\n        let n2 = I64(-11).to_cmp_be_bytes();\n        let n3 = I64(0).to_cmp_be_bytes();\n        let n4 = I64(3).to_cmp_be_bytes();\n        let n5 = I64(20).to_cmp_be_bytes();\n        let n6 = I64(100).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026n6), Ordering::Less);\n        assert_eq!(cmp(\u0026n5, \u0026n5), Ordering::Equal);\n        assert_eq!(cmp(\u0026n4, \u0026n5), Ordering::Less);\n        assert_eq!(cmp(\u0026n6, \u0026n4), Ordering::Greater);\n        assert_eq!(cmp(\u0026n4, \u0026null), Ordering::Less);\n\n        let n1 = I128(-123).to_cmp_be_bytes();\n        let n2 = I128(-11).to_cmp_be_bytes();\n        let n3 = I128(0).to_cmp_be_bytes();\n        let n4 = I128(3).to_cmp_be_bytes();\n        let n5 = I128(20).to_cmp_be_bytes();\n        let n6 = I128(100).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026n6), Ordering::Less);\n        assert_eq!(cmp(\u0026n5, \u0026n5), Ordering::Equal);\n        assert_eq!(cmp(\u0026n4, \u0026n5), Ordering::Less);\n        assert_eq!(cmp(\u0026n6, \u0026n4), Ordering::Greater);\n        assert_eq!(cmp(\u0026n4, \u0026null), Ordering::Less);\n\n        let n1 = U8(0).to_cmp_be_bytes();\n        let n2 = U8(3).to_cmp_be_bytes();\n        let n3 = U8(20).to_cmp_be_bytes();\n        let n4 = U8(20).to_cmp_be_bytes();\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026n4), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n4), Ordering::Equal);\n\n        let n1 = U16(0).to_cmp_be_bytes();\n        let n2 = U16(3).to_cmp_be_bytes();\n        let n3 = U16(20).to_cmp_be_bytes();\n        let n4 = U16(20).to_cmp_be_bytes();\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026n4), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n4), Ordering::Equal);\n\n        let n1 = U32(0).to_cmp_be_bytes();\n        let n2 = U32(3).to_cmp_be_bytes();\n        let n3 = U32(20).to_cmp_be_bytes();\n        let n4 = U32(20).to_cmp_be_bytes();\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026n4), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n4), Ordering::Equal);\n\n        let n1 = U64(0).to_cmp_be_bytes();\n        let n2 = U64(3).to_cmp_be_bytes();\n        let n3 = U64(20).to_cmp_be_bytes();\n        let n4 = U64(20).to_cmp_be_bytes();\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026n4), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n4), Ordering::Equal);\n\n        let n1 = U128(0).to_cmp_be_bytes();\n        let n2 = U128(3).to_cmp_be_bytes();\n        let n3 = U128(20).to_cmp_be_bytes();\n        let n4 = U128(20).to_cmp_be_bytes();\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026n4), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n4), Ordering::Equal);\n\n        let dec = |n| Decimal(rust_decimal::Decimal::from_str(n).unwrap());\n        let n1 = dec(\"-1200.345678\").to_cmp_be_bytes();\n        let n2 = dec(\"-1.01\").to_cmp_be_bytes();\n        let n3 = dec(\"0\").to_cmp_be_bytes();\n        let n4 = dec(\"3.9\").to_cmp_be_bytes();\n        let n5 = dec(\"300.0\").to_cmp_be_bytes();\n        let n6 = dec(\"3000\").to_cmp_be_bytes();\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026n6), Ordering::Less);\n        assert_eq!(cmp(\u0026n5, \u0026n5), Ordering::Equal);\n        assert_eq!(cmp(\u0026n4, \u0026n5), Ordering::Less);\n        assert_eq!(cmp(\u0026n6, \u0026n4), Ordering::Greater);\n        assert_eq!(cmp(\u0026n4, \u0026null), Ordering::Less);\n\n        let n1 = Str(\"a\".to_owned()).to_cmp_be_bytes();\n        let n2 = Str(\"ab\".to_owned()).to_cmp_be_bytes();\n        let n3 = Str(\"aaa\".to_owned()).to_cmp_be_bytes();\n        let n4 = Str(\"aaz\".to_owned()).to_cmp_be_bytes();\n        let n5 = Str(\"c\".to_owned()).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n2, \u0026n2), Ordering::Equal);\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n1), Ordering::Greater);\n        assert_eq!(cmp(\u0026n2, \u0026n3), Ordering::Greater);\n        assert_eq!(cmp(\u0026n3, \u0026n4), Ordering::Less);\n        assert_eq!(cmp(\u0026n5, \u0026n4), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026null), Ordering::Less);\n\n        let n1 = Bytea(n1.unwrap()).to_cmp_be_bytes();\n        let n2 = Bytea(n2.unwrap()).to_cmp_be_bytes();\n        let n3 = Bytea(n3.unwrap()).to_cmp_be_bytes();\n        let n4 = Bytea(n4.unwrap()).to_cmp_be_bytes();\n        let n5 = Bytea(n5.unwrap()).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n2, \u0026n2), Ordering::Equal);\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n3, \u0026n1), Ordering::Greater);\n        assert_eq!(cmp(\u0026n2, \u0026n3), Ordering::Greater);\n        assert_eq!(cmp(\u0026n3, \u0026n4), Ordering::Less);\n        assert_eq!(cmp(\u0026n5, \u0026n4), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026null), Ordering::Less);\n\n        let n1 = Inet(IpAddr::from_str(\"192.168.0.1\").unwrap()).to_cmp_be_bytes();\n        let n2 = Inet(IpAddr::from_str(\"127.0.0.1\").unwrap()).to_cmp_be_bytes();\n        let n3 = Inet(IpAddr::from_str(\"10.0.0.1\").unwrap()).to_cmp_be_bytes();\n        let n4 = Inet(IpAddr::from_str(\"0.0.0.0\").unwrap()).to_cmp_be_bytes();\n        let n5 = Inet(IpAddr::from_str(\"0:0:0:0:0:0:0:1\").unwrap()).to_cmp_be_bytes();\n        let n6 = Inet(IpAddr::from_str(\"::1\").unwrap()).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n1, \u0026n1), Ordering::Equal);\n        assert_eq!(cmp(\u0026n2, \u0026n1), Ordering::Less);\n        assert_eq!(cmp(\u0026n2, \u0026n3), Ordering::Greater);\n        assert_eq!(cmp(\u0026n3, \u0026n4), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026null), Ordering::Greater);\n        assert_eq!(cmp(\u0026n5, \u0026n6), Ordering::Equal);\n\n        let n1 = Date(NaiveDate::from_ymd_opt(2021, 1, 1).unwrap()).to_cmp_be_bytes();\n        let n2 = Date(NaiveDate::from_ymd_opt(1989, 3, 20).unwrap()).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n2, \u0026n2), Ordering::Equal);\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026null), Ordering::Less);\n\n        let n1 = Time(NaiveTime::from_hms_milli_opt(20, 1, 9, 100).unwrap()).to_cmp_be_bytes();\n        let n2 = Time(NaiveTime::from_hms_milli_opt(3, 10, 30, 0).unwrap()).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n2, \u0026n2), Ordering::Equal);\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026null), Ordering::Less);\n\n        let n1 = Timestamp(\n            NaiveDate::from_ymd_opt(2021, 1, 1)\n                .unwrap()\n                .and_hms_milli_opt(1, 2, 3, 0)\n                .unwrap(),\n        )\n        .to_cmp_be_bytes();\n        let n2 = Timestamp(\n            NaiveDate::from_ymd_opt(1989, 3, 20)\n                .unwrap()\n                .and_hms_milli_opt(10, 0, 0, 999)\n                .unwrap(),\n        )\n        .to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n2, \u0026n2), Ordering::Equal);\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026null), Ordering::Less);\n\n        let n1 = Interval(I::Month(30)).to_cmp_be_bytes();\n        let n2 = Interval(I::Month(2)).to_cmp_be_bytes();\n        let n3 = Interval(I::Microsecond(1000)).to_cmp_be_bytes();\n        let n4 = Interval(I::Microsecond(30)).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n1, \u0026n1), Ordering::Equal);\n        assert_eq!(cmp(\u0026n2, \u0026n1), Ordering::Less);\n        assert_eq!(cmp(\u0026n2, \u0026n3), Ordering::Greater);\n        assert_eq!(cmp(\u0026n3, \u0026n4), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026null), Ordering::Less);\n\n        let n1 = Uuid(100).to_cmp_be_bytes();\n        let n2 = Uuid(101).to_cmp_be_bytes();\n\n        assert_eq!(cmp(\u0026n1, \u0026n1), Ordering::Equal);\n        assert_eq!(cmp(\u0026n1, \u0026n2), Ordering::Less);\n        assert_eq!(cmp(\u0026n2, \u0026n1), Ordering::Greater);\n        assert_eq!(cmp(\u0026n1, \u0026null), Ordering::Less);\n\n        assert_eq!(\n            F64(12.34.into()).to_cmp_be_bytes(),\n            Err(KeyError::FloatToCmpBigEndianNotSupported.into())\n        );\n    }\n\n    #[test]\n    fn from_key_to_value() {\n        use {crate::data::Interval as I, uuid::Uuid};\n\n        assert_eq!(Value::from(Key::I8(2)), Value::I8(2));\n        assert_eq!(Value::from(Key::I16(4)), Value::I16(4));\n        assert_eq!(Value::from(Key::I32(8)), Value::I32(8));\n        assert_eq!(Value::from(Key::I64(16)), Value::I64(16));\n        assert_eq!(Value::from(Key::I128(32)), Value::I128(32));\n        assert_eq!(Value::from(Key::U8(64)), Value::U8(64));\n        assert_eq!(Value::from(Key::U16(128)), Value::U16(128));\n        assert_eq!(Value::from(Key::U32(128)), Value::U32(128));\n        assert_eq!(Value::from(Key::U64(128)), Value::U64(128));\n        assert_eq!(Value::from(Key::U128(128)), Value::U128(128));\n        assert_eq!(Value::from(Key::F32(1.0.into())), Value::F32(1.0_f32));\n        assert_eq!(Value::from(Key::F64(1.0.into())), Value::F64(1.0));\n        assert_eq!(\n            Value::from(Key::Decimal(Decimal::from_str(\"123.45\").unwrap())),\n            Value::Decimal(Decimal::from_str(\"123.45\").unwrap())\n        );\n        assert_eq!(Value::from(Key::Bool(true)), Value::Bool(true));\n        assert_eq!(\n            Value::from(Key::Str(\"abc\".to_owned())),\n            Value::Str(\"abc\".to_owned())\n        );\n        assert_eq!(Value::from(Key::Bytea(vec![])), Value::Bytea(vec![]));\n        assert_eq!(\n            Value::from(Key::Inet(IpAddr::from_str(\"::1\").unwrap())),\n            Value::Inet(IpAddr::from_str(\"::1\").unwrap())\n        );\n        assert_eq!(\n            Value::from(Key::Date(NaiveDate::from_ymd_opt(2023, 1, 23).unwrap())),\n            Value::Date(NaiveDate::from_ymd_opt(2023, 1, 23).unwrap())\n        );\n        assert_eq!(\n            Value::from(Key::Timestamp(\n                DateTime::from_timestamp_millis(1662921288)\n                    .unwrap()\n                    .naive_utc()\n            )),\n            Value::Timestamp(\n                DateTime::from_timestamp_millis(1662921288)\n                    .unwrap()\n                    .naive_utc()\n            )\n        );\n        assert_eq!(\n            Value::from(Key::Time(\n                NaiveTime::from_hms_milli_opt(20, 20, 1, 452).unwrap()\n            )),\n            Value::Time(NaiveTime::from_hms_milli_opt(20, 20, 1, 452).unwrap())\n        );\n        assert_eq!(\n            Value::from(Key::Interval(I::Month(11))),\n            Value::Interval(I::Month(11))\n        );\n        assert_eq!(\n            Value::from(Key::Uuid(\n                Uuid::parse_str(\"550e8400-e29b-41d4-a716-446655440000\")\n                    .unwrap()\n                    .as_u128()\n            )),\n            Value::Uuid(\n                Uuid::parse_str(\"550e8400-e29b-41d4-a716-446655440000\")\n                    .unwrap()\n                    .as_u128()\n            )\n        );\n        matches!(Value::from(Key::None), Value::Null);\n    }\n}\n","traces":[{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":243},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","literal.rs"],"content":"use {\n    super::{BigDecimalExt, StringExt},\n    crate::{\n        ast::{AstLiteral, BinaryOperator, ToSql},\n        result::{Error, Result},\n    },\n    Literal::*,\n    bigdecimal::BigDecimal,\n    serde::Serialize,\n    std::{borrow::Cow, cmp::Ordering, convert::TryFrom, fmt::Debug},\n    thiserror::Error,\n};\n\n#[derive(Error, Serialize, Debug, PartialEq, Eq)]\npub enum LiteralError {\n    #[error(\"unsupported literal binary operation {} {} {}\", .left, .op.to_sql(), .right)]\n    UnsupportedBinaryOperation {\n        left: String,\n        op: BinaryOperator,\n        right: String,\n    },\n\n    #[error(\"a operand '{0}' is not integer type\")]\n    BitwiseNonIntegerOperand(String),\n\n    #[error(\"given operands is not Number literal type\")]\n    BitwiseNonNumberLiteral,\n\n    #[error(\"overflow occured while running bitwise operation\")]\n    BitwiseOperationOverflow,\n\n    #[error(\"impossible conversion from {0} to {1} type\")]\n    ImpossibleConversion(String, String),\n\n    #[error(\"the divisor should not be zero\")]\n    DivisorShouldNotBeZero,\n\n    #[error(\"literal unary operation on non-numeric\")]\n    UnaryOperationOnNonNumeric,\n\n    #[error(\"unreachable literal binary arithmetic\")]\n    UnreachableBinaryArithmetic,\n\n    #[error(\"unreachable literal unary operation\")]\n    UnreachableUnaryOperation,\n\n    #[error(\"failed to decode hex string: {0}\")]\n    FailedToDecodeHexString(String),\n\n    #[error(\"operator doesn't exist: {base:?} {case} {pattern:?}\", case = if *case_sensitive { \"LIKE\" } else { \"ILIKE\" })]\n    LikeOnNonString {\n        base: String,\n        pattern: String,\n        case_sensitive: bool,\n    },\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum Literal\u003c'a\u003e {\n    Boolean(bool),\n    Number(Cow\u003c'a, BigDecimal\u003e),\n    Text(Cow\u003c'a, str\u003e),\n    Bytea(Vec\u003cu8\u003e),\n    Null,\n}\n\nimpl\u003c'a\u003e TryFrom\u003c\u0026'a AstLiteral\u003e for Literal\u003c'a\u003e {\n    type Error = Error;\n\n    fn try_from(ast_literal: \u0026'a AstLiteral) -\u003e Result\u003cSelf\u003e {\n        let literal = match ast_literal {\n            AstLiteral::Boolean(v) =\u003e Boolean(*v),\n            AstLiteral::Number(v) =\u003e Number(Cow::Borrowed(v)),\n            AstLiteral::QuotedString(v) =\u003e Text(Cow::Borrowed(v)),\n            AstLiteral::HexString(v) =\u003e {\n                Bytea(hex::decode(v).map_err(|_| LiteralError::FailedToDecodeHexString(v.clone()))?)\n            }\n            AstLiteral::Null =\u003e Null,\n        };\n\n        Ok(literal)\n    }\n}\n\nfn unsupported_binary_op(left: \u0026Literal, op: BinaryOperator, right: \u0026Literal) -\u003e LiteralError {\n    LiteralError::UnsupportedBinaryOperation {\n        left: format!(\"{:?}\", left),\n        op,\n        right: format!(\"{:?}\", right),\n    }\n}\n\nimpl\u003c'a\u003e Literal\u003c'a\u003e {\n    pub fn evaluate_eq(\u0026self, other: \u0026Literal\u003c'_\u003e) -\u003e bool {\n        match (self, other) {\n            (Null, Null) =\u003e false,\n            _ =\u003e self == other,\n        }\n    }\n\n    pub fn evaluate_cmp(\u0026self, other: \u0026Literal\u003c'a\u003e) -\u003e Option\u003cOrdering\u003e {\n        match (self, other) {\n            (Boolean(l), Boolean(r)) =\u003e Some(l.cmp(r)),\n            (Number(l), Number(r)) =\u003e Some(l.cmp(r)),\n            (Text(l), Text(r)) =\u003e Some(l.cmp(r)),\n            (Bytea(l), Bytea(r)) =\u003e Some(l.cmp(r)),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn unary_plus(\u0026self) -\u003e Result\u003cSelf\u003e {\n        match self {\n            Number(v) =\u003e Ok(Number(v.clone())),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(LiteralError::UnaryOperationOnNonNumeric.into()),\n        }\n    }\n\n    pub fn unary_minus(\u0026self) -\u003e Result\u003cSelf\u003e {\n        match self {\n            Number(v) =\u003e Ok(Number(Cow::Owned(-v.as_ref()))),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(LiteralError::UnaryOperationOnNonNumeric.into()),\n        }\n    }\n\n    pub fn concat(self, other: Literal\u003c'_\u003e) -\u003e Self {\n        let convert = |literal| match literal {\n            Boolean(v) =\u003e Some(if v {\n                \"TRUE\".to_owned()\n            } else {\n                \"FALSE\".to_owned()\n            }),\n            Number(v) =\u003e Some(v.to_string()),\n            Text(v) =\u003e Some(v.into_owned()),\n            Bytea(_) | Null =\u003e None,\n        };\n\n        match (convert(self), convert(other)) {\n            (Some(l), Some(r)) =\u003e Literal::Text(Cow::Owned(l + \u0026r)),\n            _ =\u003e Literal::Null,\n        }\n    }\n\n    pub fn add(\u0026self, other: \u0026Literal\u003c'a\u003e) -\u003e Result\u003cLiteral\u003c'static\u003e\u003e {\n        match (self, other) {\n            (Number(l), Number(r)) =\u003e Ok(Number(Cow::Owned(l.as_ref() + r.as_ref()))),\n            (Null, Number(_)) | (Number(_), Null) | (Null, Null) =\u003e Ok(Literal::Null),\n            _ =\u003e Err(unsupported_binary_op(self, BinaryOperator::Plus, other).into()),\n        }\n    }\n\n    pub fn subtract(\u0026self, other: \u0026Literal\u003c'a\u003e) -\u003e Result\u003cLiteral\u003c'static\u003e\u003e {\n        match (self, other) {\n            (Number(l), Number(r)) =\u003e Ok(Number(Cow::Owned(l.as_ref() - r.as_ref()))),\n            (Null, Number(_)) | (Number(_), Null) | (Null, Null) =\u003e Ok(Literal::Null),\n            _ =\u003e Err(unsupported_binary_op(self, BinaryOperator::Minus, other).into()),\n        }\n    }\n\n    pub fn multiply(\u0026self, other: \u0026Literal\u003c'a\u003e) -\u003e Result\u003cLiteral\u003c'static\u003e\u003e {\n        match (self, other) {\n            (Number(l), Number(r)) =\u003e Ok(Number(Cow::Owned(l.as_ref() * r.as_ref()))),\n            (Null, Number(_)) | (Number(_), Null) | (Null, Null) =\u003e Ok(Literal::Null),\n            _ =\u003e Err(unsupported_binary_op(self, BinaryOperator::Multiply, other).into()),\n        }\n    }\n\n    pub fn divide(\u0026self, other: \u0026Literal\u003c'a\u003e) -\u003e Result\u003cLiteral\u003c'static\u003e\u003e {\n        match (self, other) {\n            (Number(l), Number(r)) =\u003e {\n                if *r.as_ref() == 0.into() {\n                    Err(LiteralError::DivisorShouldNotBeZero.into())\n                } else {\n                    Ok(Number(Cow::Owned(l.as_ref() / r.as_ref())))\n                }\n            }\n            (Null, Number(_)) | (Number(_), Null) | (Null, Null) =\u003e Ok(Literal::Null),\n            _ =\u003e Err(unsupported_binary_op(self, BinaryOperator::Divide, other).into()),\n        }\n    }\n\n    pub fn bitwise_and(\u0026self, other: \u0026Literal\u003c'a\u003e) -\u003e Result\u003cLiteral\u003c'static\u003e\u003e {\n        match (self, other) {\n            (Number(l), Number(r)) =\u003e match (l.to_i64(), r.to_i64()) {\n                (Some(l), Some(r)) =\u003e Ok(Number(Cow::Owned(BigDecimal::from(l \u0026 r)))),\n                _ =\u003e Err(LiteralError::UnsupportedBinaryOperation {\n                    left: format!(\"{:?}\", self),\n                    op: BinaryOperator::BitwiseAnd,\n                    right: format!(\"{:?}\", other),\n                }\n                .into()),\n            },\n            (Null, Number(_)) | (Number(_), Null) | (Null, Null) =\u003e Ok(Literal::Null),\n            _ =\u003e Err(unsupported_binary_op(self, BinaryOperator::BitwiseAnd, other).into()),\n        }\n    }\n\n    pub fn modulo(\u0026self, other: \u0026Literal\u003c'a\u003e) -\u003e Result\u003cLiteral\u003c'static\u003e\u003e {\n        match (self, other) {\n            (Number(l), Number(r)) =\u003e {\n                if *r.as_ref() == 0.into() {\n                    Err(LiteralError::DivisorShouldNotBeZero.into())\n                } else {\n                    Ok(Number(Cow::Owned(l.as_ref() % r.as_ref())))\n                }\n            }\n            (Null, Number(_)) | (Number(_), Null) | (Null, Null) =\u003e Ok(Literal::Null),\n            _ =\u003e Err(unsupported_binary_op(self, BinaryOperator::Modulo, other).into()),\n        }\n    }\n\n    pub fn bitwise_shift_left(\u0026self, other: \u0026Literal\u003c'a\u003e) -\u003e Result\u003cLiteral\u003c'static\u003e\u003e {\n        match (self, other) {\n            (Number(l), Number(r)) =\u003e {\n                let l = l\n                    .to_i64()\n                    .ok_or(LiteralError::BitwiseNonIntegerOperand(l.to_string()))?;\n                if !r.is_integer_representation() {\n                    return Err(LiteralError::BitwiseNonIntegerOperand(r.to_string()).into());\n                }\n                let r = r.to_u32().ok_or(LiteralError::ImpossibleConversion(\n                    r.to_string(),\n                    \"u32\".to_owned(),\n                ))?;\n                let res = l\n                    .checked_shl(r)\n                    .ok_or(LiteralError::BitwiseOperationOverflow)?;\n                Ok(Number(Cow::Owned(BigDecimal::from(res))))\n            }\n            (Null, Number(_)) | (Number(_), Null) | (Null, Null) =\u003e Ok(Literal::Null),\n            _ =\u003e Err(LiteralError::BitwiseNonNumberLiteral.into()),\n        }\n    }\n\n    pub fn bitwise_shift_right(\u0026self, other: \u0026Literal\u003c'a\u003e) -\u003e Result\u003cLiteral\u003c'static\u003e\u003e {\n        match (self, other) {\n            (Number(l), Number(r)) =\u003e {\n                let l = l\n                    .to_i64()\n                    .ok_or(LiteralError::BitwiseNonIntegerOperand(l.to_string()))?;\n                if !r.is_integer_representation() {\n                    return Err(LiteralError::BitwiseNonIntegerOperand(r.to_string()).into());\n                }\n                let r = r.to_u32().ok_or(LiteralError::ImpossibleConversion(\n                    r.to_string(),\n                    \"u32\".to_owned(),\n                ))?;\n                let res = l\n                    .checked_shr(r)\n                    .ok_or(LiteralError::BitwiseOperationOverflow)?;\n                Ok(Number(Cow::Owned(BigDecimal::from(res))))\n            }\n            (Null, Number(_)) | (Number(_), Null) | (Null, Null) =\u003e Ok(Literal::Null),\n            _ =\u003e Err(LiteralError::BitwiseNonNumberLiteral.into()),\n        }\n    }\n\n    pub fn like(\u0026self, other: \u0026Literal\u003c'a\u003e, case_sensitive: bool) -\u003e Result\u003cSelf\u003e {\n        match (self, other) {\n            (Text(l), Text(r)) =\u003e l.like(r, case_sensitive).map(Boolean),\n            _ =\u003e Err(LiteralError::LikeOnNonString {\n                base: format!(\"{:?}\", self),\n                pattern: format!(\"{:?}\", other),\n                case_sensitive,\n            }\n            .into()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::Literal::*,\n        crate::ast::BinaryOperator,\n        bigdecimal::BigDecimal,\n        std::{borrow::Cow, str::FromStr},\n    };\n\n    #[test]\n    fn try_from_ast_literal() {\n        use {\n            super::{Literal, LiteralError},\n            crate::{ast::AstLiteral, result::Result},\n        };\n\n        fn test(ast_literal: AstLiteral, literal: Result\u003cLiteral\u003e) {\n            assert_eq!((\u0026ast_literal).try_into(), literal);\n        }\n\n        test(AstLiteral::Boolean(true), Ok(Boolean(true)));\n        test(\n            AstLiteral::Number(BigDecimal::from(123)),\n            Ok(Number(Cow::Borrowed(\u0026BigDecimal::from(123)))),\n        );\n        test(\n            AstLiteral::QuotedString(\"abc\".to_owned()),\n            Ok(Text(Cow::Borrowed(\"abc\"))),\n        );\n        test(\n            AstLiteral::HexString(\"1A2B\".to_owned()),\n            Ok(Bytea(hex::decode(\"1A2B\").unwrap())),\n        );\n        test(\n            AstLiteral::HexString(\"!*@Q\".to_owned()),\n            Err(LiteralError::FailedToDecodeHexString(\"!*@Q\".to_owned()).into()),\n        );\n        assert_eq!(Literal::try_from(\u0026AstLiteral::Null).unwrap(), Null);\n    }\n\n    #[test]\n    fn arithmetic() {\n        use crate::data::LiteralError;\n\n        let num = |n: i32| Number(Cow::Owned(BigDecimal::from(n)));\n\n        assert_eq!(Null.add(\u0026num(1)), Ok(Null));\n        assert_eq!(num(1).add(\u0026Null), Ok(Null));\n\n        // subtract test\n        assert_eq!(Null.subtract(\u0026num(2)), Ok(Null));\n        assert_eq!(num(2).subtract(\u0026Null), Ok(Null));\n        assert_eq!(Null.subtract(\u0026Null), Ok(Null));\n        assert_eq!(\n            Boolean(true).subtract(\u0026num(3)),\n            Err(LiteralError::UnsupportedBinaryOperation {\n                left: format!(\"{:?}\", Boolean(true)),\n                op: BinaryOperator::Minus,\n                right: format!(\"{:?}\", num(3)),\n            }\n            .into()),\n        );\n\n        // multiply test\n        assert_eq!(Null.multiply(\u0026num(2)), Ok(Null));\n        assert_eq!(num(2).multiply(\u0026Null), Ok(Null));\n        assert_eq!(Null.multiply(\u0026Null), Ok(Null));\n        assert_eq!(\n            Boolean(true).multiply(\u0026num(3)),\n            Err(LiteralError::UnsupportedBinaryOperation {\n                left: format!(\"{:?}\", Boolean(true)),\n                op: BinaryOperator::Multiply,\n                right: format!(\"{:?}\", num(3))\n            }\n            .into()),\n        );\n\n        assert_eq!(num(2).unary_plus(), Ok(num(2)));\n        assert_eq!(Null.unary_plus(), Ok(Null));\n        assert_eq!(num(1).unary_minus(), Ok(num(-1)));\n        assert_eq!(Null.unary_minus(), Ok(Null));\n    }\n\n    #[test]\n    fn bitwise_shift_left() {\n        use crate::data::LiteralError;\n\n        let num = |n: i32| Number(Cow::Owned(BigDecimal::from(n)));\n        macro_rules! num {\n            ($num: expr) =\u003e {\n                Number(Cow::Owned(BigDecimal::from_str($num).unwrap()))\n            };\n        }\n\n        assert_eq!(\n            num(1).bitwise_shift_left(\u0026num(2)),\n            Ok(Number(Cow::Borrowed(\u0026BigDecimal::from(4))))\n        );\n\n        assert_eq!(\n            num(1).bitwise_shift_left(\u0026num(65)),\n            Err(LiteralError::BitwiseOperationOverflow.into())\n        );\n\n        assert_eq!(num(2).bitwise_shift_left(\u0026Null), Ok(Null));\n        assert_eq!(Null.bitwise_shift_left(\u0026num(2)), Ok(Null));\n        assert_eq!(Null.bitwise_shift_left(\u0026Null), Ok(Null));\n\n        assert_eq!(\n            Boolean(true).bitwise_shift_left(\u0026num(2)),\n            Err(LiteralError::BitwiseNonNumberLiteral.into())\n        );\n        assert_eq!(\n            num(1).bitwise_shift_left(\u0026num(-1)),\n            Err(LiteralError::ImpossibleConversion(\"-1\".to_owned(), \"u32\".to_owned()).into())\n        );\n        assert_eq!(\n            num!(\"1.1\").bitwise_shift_left(\u0026num(2)),\n            Err(LiteralError::BitwiseNonIntegerOperand(\"1.1\".to_owned()).into())\n        );\n        assert_eq!(\n            num(1).bitwise_shift_left(\u0026num!(\"2.1\")),\n            Err(LiteralError::BitwiseNonIntegerOperand(\"2.1\".to_owned()).into())\n        );\n    }\n\n    #[test]\n    fn bitwise_shift_right() {\n        use crate::data::LiteralError;\n\n        let num = |n: i32| Number(Cow::Owned(BigDecimal::from(n)));\n        macro_rules! num {\n            ($num: expr) =\u003e {\n                Number(Cow::Owned(BigDecimal::from_str($num).unwrap()))\n            };\n        }\n\n        assert_eq!(\n            num(4).bitwise_shift_right(\u0026num(2)),\n            Ok(Number(Cow::Borrowed(\u0026BigDecimal::from(1))))\n        );\n\n        assert_eq!(\n            num(1).bitwise_shift_right(\u0026num(65)),\n            Err(LiteralError::BitwiseOperationOverflow.into())\n        );\n\n        assert_eq!(num(2).bitwise_shift_right(\u0026Null), Ok(Null));\n        assert_eq!(Null.bitwise_shift_right(\u0026num(2)), Ok(Null));\n        assert_eq!(Null.bitwise_shift_right(\u0026Null), Ok(Null));\n\n        assert_eq!(\n            Boolean(true).bitwise_shift_right(\u0026num(2)),\n            Err(LiteralError::BitwiseNonNumberLiteral.into())\n        );\n        assert_eq!(\n            num(1).bitwise_shift_right(\u0026num(-1)),\n            Err(LiteralError::ImpossibleConversion(\"-1\".to_owned(), \"u32\".to_owned()).into())\n        );\n        assert_eq!(\n            num!(\"1.1\").bitwise_shift_right(\u0026num(2)),\n            Err(LiteralError::BitwiseNonIntegerOperand(\"1.1\".to_owned()).into())\n        );\n        assert_eq!(\n            num(1).bitwise_shift_right(\u0026num!(\"2.1\")),\n            Err(LiteralError::BitwiseNonIntegerOperand(\"2.1\".to_owned()).into())\n        );\n    }\n\n    #[test]\n    fn concat() {\n        macro_rules! text {\n            ($text: expr) =\u003e {\n                Text(Cow::Owned($text.to_owned()))\n            };\n        }\n\n        let num = || Number(Cow::Owned(BigDecimal::from(123)));\n        let text = || text!(\"Foo\");\n\n        assert_eq!(Boolean(true).concat(num()), text!(\"TRUE123\"));\n        assert_eq!(Boolean(false).concat(text()), text!(\"FALSEFoo\"));\n        assert_eq!(num().concat(num()), text!(\"123123\"));\n        assert_eq!(text().concat(num()), text!(\"Foo123\"));\n        assert_eq!(text().concat(Null), Null);\n        assert_eq!(Null.concat(Boolean(true)), Null);\n        assert_eq!(Null.concat(Null), Null);\n    }\n\n    #[test]\n    fn div_mod() {\n        use crate::data::LiteralError;\n\n        macro_rules! num {\n            ($num: expr) =\u003e {\n                Number(Cow::Owned(BigDecimal::from_str($num).unwrap()))\n            };\n        }\n\n        let num_divisor = |x| Number(Cow::Owned(BigDecimal::from_str(x).unwrap()));\n\n        // Divide Test\n        assert_eq!(num!(\"12\").divide(\u0026num_divisor(\"2\")).unwrap(), num!(\"6\"));\n        assert_eq!(num!(\"12\").divide(\u0026num_divisor(\"2.0\")).unwrap(), num!(\"6\"));\n        assert_eq!(num!(\"12.0\").divide(\u0026num_divisor(\"2\")).unwrap(), num!(\"6\"));\n        assert_eq!(num!(\"12.0\").divide(\u0026num_divisor(\"2.0\")).unwrap(), num!(\"6\"));\n        assert_eq!(num!(\"12\").divide(\u0026Null).unwrap(), Null);\n        assert_eq!(num!(\"12.5\").divide(\u0026Null).unwrap(), Null);\n        assert_eq!(Null.divide(\u0026num_divisor(\"2\")).unwrap(), Null);\n        assert_eq!(Null.divide(\u0026num_divisor(\"2.5\")).unwrap(), Null);\n        assert_eq!(Null.divide(\u0026Null).unwrap(), Null);\n        assert_eq!(\n            Boolean(true).divide(\u0026num!(\"3\")),\n            Err(LiteralError::UnsupportedBinaryOperation {\n                left: format!(\"{:?}\", Boolean(true)),\n                op: BinaryOperator::Divide,\n                right: format!(\"{:?}\", num!(\"3\"))\n            }\n            .into()),\n        );\n\n        // Modulo Test\n        assert_eq!(num!(\"12\").modulo(\u0026num_divisor(\"2\")).unwrap(), num!(\"0\"));\n        assert_eq!(num!(\"12\").modulo(\u0026num_divisor(\"2.0\")).unwrap(), num!(\"0\"));\n        assert_eq!(num!(\"12.0\").modulo(\u0026num_divisor(\"2\")).unwrap(), num!(\"0\"));\n        assert_eq!(num!(\"12.0\").modulo(\u0026num_divisor(\"2.0\")).unwrap(), num!(\"0\"));\n        assert_eq!(num!(\"12\").modulo(\u0026Null).unwrap(), Null);\n        assert_eq!(Null.modulo(\u0026num_divisor(\"2\")).unwrap(), Null);\n        assert_eq!(Null.modulo(\u0026Null).unwrap(), Null);\n\n        let text = Text(Cow::Owned(\"some\".to_owned()));\n        assert_eq!(\n            num!(\"12\").modulo(\u0026text),\n            Err(LiteralError::UnsupportedBinaryOperation {\n                left: format!(\"{:?}\", num!(\"12\")),\n                op: BinaryOperator::Modulo,\n                right: format!(\"{:?}\", text)\n            }\n            .into())\n        )\n    }\n\n    #[test]\n    fn evaluate_eq() {\n        macro_rules! text {\n            ($text: expr) =\u003e {\n                Text(Cow::Owned($text.to_owned()))\n            };\n        }\n        macro_rules! num {\n            ($num: expr) =\u003e {\n                Number(Cow::Owned(BigDecimal::from_str($num).unwrap()))\n            };\n        }\n        macro_rules! bytea {\n            ($val: expr) =\u003e {\n                Bytea(hex::decode($val).unwrap())\n            };\n        }\n\n        //Boolean\n        assert!(Boolean(true).evaluate_eq(\u0026Boolean(true)));\n        assert!(!Boolean(true).evaluate_eq(\u0026Boolean(false)));\n        //Number\n        assert!(num!(\"123\").evaluate_eq(\u0026num!(\"123\")));\n        assert!(num!(\"12.0\").evaluate_eq(\u0026num!(\"12.0\")));\n        assert!(num!(\"12.0\").evaluate_eq(\u0026num!(\"12\")));\n        assert!(!num!(\"12.0\").evaluate_eq(\u0026num!(\"12.123\")));\n        assert!(!num!(\"123\").evaluate_eq(\u0026num!(\"12.3\")));\n        assert!(!num!(\"123\").evaluate_eq(\u0026text!(\"Foo\")));\n        assert!(!num!(\"123\").evaluate_eq(\u0026Null));\n        //Text\n        assert!(text!(\"Foo\").evaluate_eq(\u0026text!(\"Foo\")));\n        assert!(!text!(\"Foo\").evaluate_eq(\u0026text!(\"Bar\")));\n        assert!(!text!(\"Foo\").evaluate_eq(\u0026Null));\n        //Bytea\n        assert!(bytea!(\"12A456\").evaluate_eq(\u0026bytea!(\"12A456\")));\n        assert!(!bytea!(\"1230\").evaluate_eq(\u0026num!(\"1230\")));\n        assert!(!bytea!(\"12\").evaluate_eq(\u0026Null));\n        // Null\n        assert!(!Null.evaluate_eq(\u0026Null));\n    }\n\n    #[test]\n    fn evaluate_cmp() {\n        use std::cmp::Ordering;\n        macro_rules! text {\n            ($text: expr) =\u003e {\n                Text(Cow::Owned($text.to_owned()))\n            };\n        }\n        macro_rules! num {\n            ($num: expr) =\u003e {\n                Number(Cow::Owned(BigDecimal::from_str($num).unwrap()))\n            };\n        }\n        macro_rules! bytea {\n            ($val: expr) =\u003e {\n                Bytea(hex::decode($val).unwrap())\n            };\n        }\n\n        //Boolean\n        assert_eq!(\n            Boolean(false).evaluate_cmp(\u0026Boolean(true)),\n            Some(Ordering::Less)\n        );\n        assert_eq!(\n            Boolean(true).evaluate_cmp(\u0026Boolean(true)),\n            Some(Ordering::Equal)\n        );\n        assert_eq!(\n            Boolean(true).evaluate_cmp(\u0026Boolean(false)),\n            Some(Ordering::Greater)\n        );\n        assert_eq!(Boolean(true).evaluate_cmp(\u0026num!(\"1\")), None);\n        assert_eq!(Boolean(true).evaluate_cmp(\u0026text!(\"Foo\")), None);\n        assert_eq!(Boolean(true).evaluate_cmp(\u0026Null), None);\n        //Number - valid format -\u003e (int, int), (float, int), (int, float), (float, float)\n        assert_eq!(\n            num!(\"123\").evaluate_cmp(\u0026num!(\"1234\")),\n            Some(Ordering::Less)\n        );\n        assert_eq!(\n            num!(\"12.0\").evaluate_cmp(\u0026num!(\"123\")),\n            Some(Ordering::Less)\n        );\n        assert_eq!(\n            num!(\"123\").evaluate_cmp(\u0026num!(\"123.1\")),\n            Some(Ordering::Less)\n        );\n        assert_eq!(\n            num!(\"12.0\").evaluate_cmp(\u0026num!(\"12.1\")),\n            Some(Ordering::Less)\n        );\n        assert_eq!(\n            num!(\"123\").evaluate_cmp(\u0026num!(\"123\")),\n            Some(Ordering::Equal)\n        );\n        assert_eq!(\n            num!(\"1234\").evaluate_cmp(\u0026num!(\"123\")),\n            Some(Ordering::Greater)\n        );\n        assert_eq!(num!(\"123\").evaluate_cmp(\u0026text!(\"123\")), None);\n        assert_eq!(num!(\"123\").evaluate_cmp(\u0026Null), None);\n        //text\n        assert_eq!(text!(\"a\").evaluate_cmp(\u0026text!(\"b\")), Some(Ordering::Less));\n        assert_eq!(text!(\"a\").evaluate_cmp(\u0026text!(\"a\")), Some(Ordering::Equal));\n        assert_eq!(\n            text!(\"b\").evaluate_cmp(\u0026text!(\"a\")),\n            Some(Ordering::Greater)\n        );\n        assert_eq!(text!(\"a\").evaluate_cmp(\u0026Null), None);\n        //Bytea\n        assert_eq!(\n            bytea!(\"12\").evaluate_cmp(\u0026bytea!(\"20\")),\n            Some(Ordering::Less)\n        );\n        assert_eq!(\n            bytea!(\"31\").evaluate_cmp(\u0026bytea!(\"31\")),\n            Some(Ordering::Equal)\n        );\n        assert_eq!(\n            bytea!(\"9A\").evaluate_cmp(\u0026bytea!(\"2A\")),\n            Some(Ordering::Greater)\n        );\n        assert_eq!(bytea!(\"345D\").evaluate_cmp(\u0026Null), None);\n        assert_eq!(Null.evaluate_cmp(\u0026Null), None);\n    }\n\n    #[test]\n    fn bitwise_and() {\n        use crate::data::LiteralError;\n\n        let num = |val: i32| Number(Cow::Owned(BigDecimal::from(val)));\n        let text = |val: \u0026str| Text(Cow::Owned(String::from(val)));\n\n        macro_rules! ok {\n            ($left: expr, $right: expr, $expected: expr) =\u003e {\n                assert_eq!(($left).bitwise_and(\u0026$right), Ok($expected))\n            };\n        }\n\n        macro_rules! err {\n            ($left: expr, $right: expr) =\u003e {\n                assert_eq!(\n                    ($left).bitwise_and(\u0026$right),\n                    Err(LiteralError::UnsupportedBinaryOperation {\n                        left: format!(\"{:?}\", $left),\n                        op: BinaryOperator::BitwiseAnd,\n                        right: format!(\"{:?}\", $right)\n                    }\n                    .into())\n                )\n            };\n        }\n\n        ok!(num(11), num(12), num(8));\n        err!(text(\"11\"), num(12));\n        err!(num(11), text(\"12\"));\n        err!(text(\"11\"), text(\"12\"));\n    }\n}\n","traces":[{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":126},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","point.rs"],"content":"use {\n    super::ValueError,\n    crate::result::Result,\n    regex::Regex,\n    serde::{Deserialize, Serialize},\n    std::fmt,\n};\n\n#[derive(Copy, Debug, Clone, Serialize, Deserialize)]\npub struct Point {\n    pub x: f64,\n    pub y: f64,\n}\n\nimpl Point {\n    pub fn new(x: f64, y: f64) -\u003e Self {\n        Self { x, y }\n    }\n\n    pub fn from_wkt(v: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let re = Regex::new(r\"POINT\\s*\\(\\s*(-?\\d*\\.?\\d+)\\s+(-?\\d*\\.?\\d+)\\s*\\)\").unwrap();\n\n        if let Some(captures) = re.captures(v) {\n            let x = captures[1]\n                .parse::\u003cf64\u003e()\n                .map_err(|_| ValueError::FailedToParsePoint(v.to_owned()))?;\n            let y = captures[2]\n                .parse::\u003cf64\u003e()\n                .map_err(|_| ValueError::FailedToParsePoint(v.to_owned()))?;\n            Ok(Self { x, y })\n        } else {\n            Err(ValueError::FailedToParsePoint(v.to_owned()).into())\n        }\n    }\n\n    pub fn calc_distance(\u0026self, other: \u0026Point) -\u003e f64 {\n        let dx = self.x - other.x;\n        let dy = self.y - other.y;\n        f64::sqrt(dx * dx + dy * dy)\n    }\n}\n\nimpl PartialEq for Point {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.x == other.x \u0026\u0026 self.y == other.y\n    }\n}\n\nimpl Eq for Point {}\n\nimpl fmt::Display for Point {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"POINT({} {})\", self.x, self.y)\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","row.rs"],"content":"use {\n    crate::{data::Value, executor::RowContext, result::Result},\n    serde::Serialize,\n    std::{collections::HashMap, fmt::Debug, rc::Rc},\n    thiserror::Error,\n};\n\n#[derive(Error, Serialize, Debug, PartialEq, Eq)]\npub enum RowError {\n    #[error(\"conflict - vec expected but map row found\")]\n    ConflictOnUnexpectedMapRowFound,\n\n    #[error(\"conflict - map expected but vec row found\")]\n    ConflictOnUnexpectedVecRowFound,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum Row {\n    Vec {\n        columns: Rc\u003c[String]\u003e,\n        values: Vec\u003cValue\u003e,\n    },\n    Map(HashMap\u003cString, Value\u003e),\n}\n\nimpl Row {\n    pub fn get_value(\u0026self, ident: \u0026str) -\u003e Option\u003c\u0026Value\u003e {\n        match self {\n            Self::Vec { columns, values } =\u003e columns\n                .iter()\n                .position(|column| column == ident)\n                .and_then(|index| values.get(index)),\n            Self::Map(values) =\u003e Some(values.get(ident).unwrap_or(\u0026Value::Null)),\n        }\n    }\n\n    pub fn iter(\u0026self) -\u003e impl Iterator\u003cItem = (\u0026String, \u0026Value)\u003e {\n        #[derive(iter_enum::Iterator)]\n        enum Entries\u003cI1, I2\u003e {\n            Vec(I1),\n            Map(I2),\n        }\n\n        match self {\n            Self::Vec { columns, values } =\u003e Entries::Vec(columns.iter().zip(values.iter())),\n            Self::Map(values) =\u003e Entries::Map(values.iter()),\n        }\n    }\n\n    pub fn try_into_vec(self) -\u003e Result\u003cVec\u003cValue\u003e\u003e {\n        match self {\n            Self::Vec { values, .. } =\u003e Ok(values),\n            Self::Map(_) =\u003e Err(RowError::ConflictOnUnexpectedMapRowFound.into()),\n        }\n    }\n\n    pub fn try_into_map(self) -\u003e Result\u003cHashMap\u003cString, Value\u003e\u003e {\n        match self {\n            Self::Vec { .. } =\u003e Err(RowError::ConflictOnUnexpectedVecRowFound.into()),\n            Self::Map(values) =\u003e Ok(values),\n        }\n    }\n\n    pub fn as_context(\u0026self) -\u003e RowContext\u003c'_\u003e {\n        match self {\n            Self::Vec { columns, values } =\u003e RowContext::RefVecData { columns, values },\n            Self::Map(values) =\u003e RowContext::RefMapData(values),\n        }\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","schema.rs"],"content":"use {\n    crate::{\n        ast::{ColumnDef, Expr, ForeignKey, OrderByExpr, Statement, ToSql},\n        prelude::{parse, translate},\n        result::Result,\n    },\n    chrono::{NaiveDateTime, Utc},\n    serde::{Deserialize, Serialize},\n    std::{fmt::Debug, iter},\n    strum_macros::Display,\n    thiserror::Error as ThisError,\n};\n\n#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq, Display)]\n#[strum(serialize_all = \"SCREAMING_SNAKE_CASE\")]\npub enum SchemaIndexOrd {\n    Asc,\n    Desc,\n    Both,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]\npub struct SchemaIndex {\n    pub name: String,\n    pub expr: Expr,\n    pub order: SchemaIndexOrd,\n    pub created: NaiveDateTime,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]\npub struct Schema {\n    pub table_name: String,\n    pub column_defs: Option\u003cVec\u003cColumnDef\u003e\u003e,\n    pub indexes: Vec\u003cSchemaIndex\u003e,\n    pub engine: Option\u003cString\u003e,\n    pub foreign_keys: Vec\u003cForeignKey\u003e,\n    pub comment: Option\u003cString\u003e,\n}\n\nimpl Schema {\n    pub fn to_ddl(\u0026self) -\u003e String {\n        let Schema {\n            table_name,\n            column_defs,\n            indexes,\n            engine,\n            foreign_keys,\n            comment,\n        } = self;\n\n        let create_table = Statement::CreateTable {\n            if_not_exists: false,\n            name: table_name.to_owned(),\n            columns: column_defs.to_owned(),\n            engine: engine.to_owned(),\n            comment: comment.to_owned(),\n            source: None,\n            foreign_keys: foreign_keys.to_owned(),\n        }\n        .to_sql();\n\n        let create_indexes = indexes.iter().map(|SchemaIndex { name, expr, .. }| {\n            let expr = expr.to_sql();\n\n            format!(r#\"CREATE INDEX \"{name}\" ON \"{table_name}\" ({expr});\"#)\n        });\n\n        iter::once(create_table)\n            .chain(create_indexes)\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\\n\")\n    }\n\n    pub fn from_ddl(ddl: \u0026str) -\u003e Result\u003cSchema\u003e {\n        let created = Utc::now().naive_utc();\n        let statements = parse(ddl)?;\n\n        let indexes = statements\n            .iter()\n            .skip(1)\n            .map(|create_index| {\n                let create_index = translate(create_index)?;\n                match create_index {\n                    Statement::CreateIndex {\n                        name,\n                        column: OrderByExpr { expr, asc },\n                        ..\n                    } =\u003e {\n                        let order = asc\n                            .and_then(|bool| bool.then_some(SchemaIndexOrd::Asc))\n                            .unwrap_or(SchemaIndexOrd::Both);\n\n                        let index = SchemaIndex {\n                            name,\n                            expr,\n                            order,\n                            created,\n                        };\n\n                        Ok(index)\n                    }\n                    _ =\u003e Err(SchemaParseError::CannotParseDDL.into()),\n                }\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        let create_table = statements.first().ok_or(SchemaParseError::CannotParseDDL)?;\n        let create_table = translate(create_table)?;\n\n        match create_table {\n            Statement::CreateTable {\n                name,\n                columns,\n                engine,\n                foreign_keys,\n                comment,\n                ..\n            } =\u003e Ok(Schema {\n                table_name: name,\n                column_defs: columns,\n                indexes,\n                engine,\n                foreign_keys,\n                comment,\n            }),\n            _ =\u003e Err(SchemaParseError::CannotParseDDL.into()),\n        }\n    }\n}\n\n#[derive(ThisError, Debug, PartialEq, Serialize)]\npub enum SchemaParseError {\n    #[error(\"cannot parse ddl\")]\n    CannotParseDDL,\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::SchemaParseError,\n        crate::{\n            ast::{AstLiteral, ColumnDef, ColumnUniqueOption, Expr},\n            chrono::Utc,\n            data::{Schema, SchemaIndex, SchemaIndexOrd},\n            prelude::DataType,\n        },\n    };\n\n    fn assert_schema(actual: Schema, expected: Schema) {\n        let Schema {\n            table_name,\n            column_defs,\n            indexes,\n            engine,\n            foreign_keys,\n            comment,\n        } = actual;\n\n        let Schema {\n            table_name: table_name_e,\n            column_defs: column_defs_e,\n            indexes: indexes_e,\n            engine: engine_e,\n            foreign_keys: foreign_keys_e,\n            comment: comment_e,\n        } = expected;\n\n        assert_eq!(table_name, table_name_e);\n        assert_eq!(column_defs, column_defs_e);\n        assert_eq!(engine, engine_e);\n        assert_eq!(foreign_keys, foreign_keys_e);\n        assert_eq!(comment, comment_e);\n        indexes\n            .into_iter()\n            .zip(indexes_e)\n            .for_each(|(actual, expected)| assert_index(actual, expected));\n    }\n\n    fn assert_index(actual: SchemaIndex, expected: SchemaIndex) {\n        let SchemaIndex {\n            name, expr, order, ..\n        } = actual;\n        let SchemaIndex {\n            name: name_e,\n            expr: expr_e,\n            order: order_e,\n            ..\n        } = expected;\n\n        assert_eq!(name, name_e);\n        assert_eq!(expr, expr_e);\n        assert_eq!(order, order_e);\n    }\n\n    #[test]\n    fn table_basic() {\n        let schema = Schema {\n            table_name: \"User\".to_owned(),\n            column_defs: Some(vec![\n                ColumnDef {\n                    name: \"id\".to_owned(),\n                    data_type: DataType::Int,\n                    nullable: false,\n                    default: None,\n                    unique: None,\n                    comment: None,\n                },\n                ColumnDef {\n                    name: \"name\".to_owned(),\n                    data_type: DataType::Text,\n                    nullable: true,\n                    default: Some(Expr::Literal(AstLiteral::QuotedString(\"glue\".to_owned()))),\n                    unique: None,\n                    comment: None,\n                },\n            ]),\n            indexes: Vec::new(),\n            engine: None,\n            foreign_keys: Vec::new(),\n            comment: None,\n        };\n\n        let ddl = r#\"CREATE TABLE \"User\" (\"id\" INT NOT NULL, \"name\" TEXT NULL DEFAULT 'glue');\"#;\n        assert_eq!(schema.to_ddl(), ddl);\n\n        let actual = Schema::from_ddl(ddl).unwrap();\n        assert_schema(actual, schema);\n\n        let schema = Schema {\n            table_name: \"Test\".to_owned(),\n            column_defs: None,\n            indexes: Vec::new(),\n            engine: None,\n            foreign_keys: Vec::new(),\n            comment: None,\n        };\n        let ddl = r#\"CREATE TABLE \"Test\";\"#;\n        assert_eq!(schema.to_ddl(), ddl);\n\n        let actual = Schema::from_ddl(ddl).unwrap();\n        assert_schema(actual, schema);\n    }\n\n    #[test]\n    fn table_primary() {\n        let schema = Schema {\n            table_name: \"User\".to_owned(),\n            column_defs: Some(vec![ColumnDef {\n                name: \"id\".to_owned(),\n                data_type: DataType::Int,\n                nullable: false,\n                default: None,\n                unique: Some(ColumnUniqueOption { is_primary: true }),\n                comment: None,\n            }]),\n            indexes: Vec::new(),\n            engine: None,\n            foreign_keys: Vec::new(),\n            comment: None,\n        };\n\n        let ddl = r#\"CREATE TABLE \"User\" (\"id\" INT NOT NULL PRIMARY KEY);\"#;\n        assert_eq!(schema.to_ddl(), ddl);\n\n        let actual = Schema::from_ddl(ddl).unwrap();\n        assert_schema(actual, schema);\n    }\n\n    #[test]\n    fn invalid_ddl() {\n        // Only Statement::CreateTable is supported\n        let invalid_ddl = r#\"DROP TABLE \"Users\";\"#;\n        let actual = Schema::from_ddl(invalid_ddl);\n        assert_eq!(actual, Err(SchemaParseError::CannotParseDDL.into()));\n    }\n\n    #[test]\n    fn table_with_index() {\n        let schema = Schema {\n            table_name: \"User\".to_owned(),\n            column_defs: Some(vec![\n                ColumnDef {\n                    name: \"id\".to_owned(),\n                    data_type: DataType::Int,\n                    nullable: false,\n                    default: None,\n                    unique: None,\n                    comment: None,\n                },\n                ColumnDef {\n                    name: \"name\".to_owned(),\n                    data_type: DataType::Text,\n                    nullable: false,\n                    default: None,\n                    unique: None,\n                    comment: None,\n                },\n            ]),\n            indexes: vec![\n                SchemaIndex {\n                    name: \"User_id\".to_owned(),\n                    expr: Expr::Identifier(\"id\".to_owned()),\n                    order: SchemaIndexOrd::Both,\n                    created: Utc::now().naive_utc(),\n                },\n                SchemaIndex {\n                    name: \"User_name\".to_owned(),\n                    expr: Expr::Identifier(\"name\".to_owned()),\n                    order: SchemaIndexOrd::Both,\n                    created: Utc::now().naive_utc(),\n                },\n            ],\n            engine: None,\n            foreign_keys: Vec::new(),\n            comment: None,\n        };\n        let ddl = r#\"CREATE TABLE \"User\" (\"id\" INT NOT NULL, \"name\" TEXT NOT NULL);\nCREATE INDEX \"User_id\" ON \"User\" (\"id\");\nCREATE INDEX \"User_name\" ON \"User\" (\"name\");\"#;\n        assert_eq!(schema.to_ddl(), ddl);\n\n        let actual = Schema::from_ddl(ddl).unwrap();\n        assert_schema(actual, schema);\n\n        let index_should_not_be_first = r#\"CREATE INDEX \"User_id\" ON \"User\" (\"id\");\nCREATE TABLE \"User\" (\"id\" INT NOT NULL, \"name\" TEXT NOT NULL);\"#;\n        let actual = Schema::from_ddl(index_should_not_be_first);\n        assert_eq!(actual, Err(SchemaParseError::CannotParseDDL.into()));\n    }\n\n    #[test]\n    fn non_word_identifier() {\n        let schema = Schema {\n            table_name: 1.to_string(),\n            column_defs: Some(vec![\n                ColumnDef {\n                    name: 2.to_string(),\n                    data_type: DataType::Int,\n                    nullable: true,\n                    default: None,\n                    unique: None,\n                    comment: None,\n                },\n                ColumnDef {\n                    name: \";\".to_owned(),\n                    data_type: DataType::Int,\n                    nullable: true,\n                    default: None,\n                    unique: None,\n                    comment: None,\n                },\n            ]),\n            indexes: vec![SchemaIndex {\n                name: \".\".to_owned(),\n                expr: Expr::Identifier(\";\".to_owned()),\n                order: SchemaIndexOrd::Both,\n                created: Utc::now().naive_utc(),\n            }],\n            engine: None,\n            foreign_keys: Vec::new(),\n            comment: None,\n        };\n        let ddl = r#\"CREATE TABLE \"1\" (\"2\" INT NULL, \";\" INT NULL);\nCREATE INDEX \".\" ON \"1\" (\";\");\"#;\n        assert_eq!(schema.to_ddl(), ddl);\n\n        let actual = Schema::from_ddl(ddl).unwrap();\n        assert_schema(actual, schema);\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":48},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","string_ext.rs"],"content":"use {crate::result::Result, regex::Regex, serde::Serialize, thiserror::Error};\n\n#[derive(Error, Serialize, Debug, PartialEq, Eq)]\npub enum StringExtError {\n    #[error(\"unreachable literal unary operation\")]\n    UnreachablePatternParsing,\n}\n\npub trait StringExt {\n    fn like(\u0026self, pattern: \u0026str, case_sensitive: bool) -\u003e Result\u003cbool\u003e;\n}\n\nimpl StringExt for str {\n    fn like(\u0026self, pattern: \u0026str, case_sensitive: bool) -\u003e Result\u003cbool\u003e {\n        let (match_string, match_pattern) = match case_sensitive {\n            true =\u003e (self.to_owned(), pattern.to_owned()),\n            false =\u003e {\n                let lowercase_string = self.to_lowercase();\n                let lowercase_pattern = pattern.to_lowercase();\n\n                (lowercase_string, lowercase_pattern)\n            }\n        };\n\n        Ok(Regex::new(\u0026format!(\n            \"^{}$\",\n            regex::escape(match_pattern.as_str())\n                .replace('%', \".*\")\n                .replace('_', \".\")\n        ))\n        .map_err(|_| StringExtError::UnreachablePatternParsing)?\n        .is_match(match_string.as_str()))\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","table.rs"],"content":"use {\n    crate::ast::{IndexItem, TableAlias, TableFactor},\n    serde::Serialize,\n    std::fmt::Debug,\n    thiserror::Error,\n};\n\n#[derive(Error, Serialize, Debug, PartialEq, Eq)]\npub enum TableError {\n    #[error(\"unreachable\")]\n    Unreachable,\n}\n\npub fn get_alias(table_factor: \u0026TableFactor) -\u003e \u0026String {\n    match table_factor {\n        TableFactor::Table {\n            name, alias: None, ..\n        }\n        | TableFactor::Table {\n            alias: Some(TableAlias { name, .. }),\n            ..\n        }\n        | TableFactor::Derived {\n            alias: TableAlias { name, .. },\n            ..\n        }\n        | TableFactor::Series {\n            alias: TableAlias { name, .. },\n            ..\n        }\n        | TableFactor::Dictionary {\n            alias: TableAlias { name, .. },\n            ..\n        } =\u003e name,\n    }\n}\n\npub fn get_index(table_factor: \u0026TableFactor) -\u003e Option\u003c\u0026IndexItem\u003e {\n    match table_factor {\n        TableFactor::Table { index, .. } =\u003e index.as_ref(),\n        TableFactor::Derived { .. }\n        | TableFactor::Series { .. }\n        | TableFactor::Dictionary { .. } =\u003e None,\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","decimal.rs"],"content":"use {\n    super::TryBinaryOperator,\n    crate::{\n        data::{NumericBinaryOperator, ValueError},\n        prelude::Value,\n        result::Result,\n    },\n    Value::*,\n    rust_decimal::prelude::Decimal,\n    std::cmp::Ordering,\n};\n\nimpl PartialEq\u003cValue\u003e for Decimal {\n    fn eq(\u0026self, other: \u0026Value) -\u003e bool {\n        match other {\n            I8(other) =\u003e *self == Decimal::from(*other),\n            I32(other) =\u003e *self == Decimal::from(*other),\n            I64(other) =\u003e *self == Decimal::from(*other),\n            I128(other) =\u003e *self == Decimal::from(*other),\n            U8(other) =\u003e *self == Decimal::from(*other),\n            U16(other) =\u003e *self == Decimal::from(*other),\n            U32(other) =\u003e *self == Decimal::from(*other),\n            U64(other) =\u003e *self == Decimal::from(*other),\n            U128(other) =\u003e *self == Decimal::from(*other),\n            F32(other) =\u003e Decimal::from_f32_retain(*other)\n                .map(|x| *self == x)\n                .unwrap_or(false),\n            F64(other) =\u003e Decimal::from_f64_retain(*other)\n                .map(|x| *self == x)\n                .unwrap_or(false),\n            Decimal(other) =\u003e *self == *other,\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl PartialOrd\u003cValue\u003e for Decimal {\n    fn partial_cmp(\u0026self, other: \u0026Value) -\u003e Option\u003cOrdering\u003e {\n        match *other {\n            I8(rhs) =\u003e self.partial_cmp(\u0026(Decimal::from(rhs))),\n            I32(rhs) =\u003e self.partial_cmp(\u0026(Decimal::from(rhs))),\n            I64(rhs) =\u003e self.partial_cmp(\u0026(Decimal::from(rhs))),\n            I128(rhs) =\u003e self.partial_cmp(\u0026(Decimal::from(rhs))),\n            U8(rhs) =\u003e self.partial_cmp(\u0026(Decimal::from(rhs))),\n            U16(rhs) =\u003e self.partial_cmp(\u0026(Decimal::from(rhs))),\n            U32(rhs) =\u003e self.partial_cmp(\u0026(Decimal::from(rhs))),\n            U64(rhs) =\u003e self.partial_cmp(\u0026(Decimal::from(rhs))),\n            U128(rhs) =\u003e self.partial_cmp(\u0026(Decimal::from(rhs))),\n            F32(rhs) =\u003e Decimal::from_f32_retain(rhs)\n                .map(|x| self.partial_cmp(\u0026x))\n                .unwrap_or(None),\n            F64(rhs) =\u003e Decimal::from_f64_retain(rhs)\n                .map(|x| self.partial_cmp(\u0026x))\n                .unwrap_or(None),\n            Decimal(rhs) =\u003e self.partial_cmp(\u0026rhs),\n            _ =\u003e None,\n        }\n    }\n}\n\nimpl TryBinaryOperator for Decimal {\n    type Rhs = Value;\n\n    fn try_add(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e lhs\n                .checked_add(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I8(rhs),\n                        operator: NumericBinaryOperator::Add,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            I32(rhs) =\u003e lhs\n                .checked_add(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I32(rhs),\n                        operator: NumericBinaryOperator::Add,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            I64(rhs) =\u003e lhs\n                .checked_add(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I64(rhs),\n                        operator: NumericBinaryOperator::Add,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            I128(rhs) =\u003e lhs\n                .checked_add(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I128(rhs),\n                        operator: NumericBinaryOperator::Add,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U8(rhs) =\u003e lhs\n                .checked_add(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U8(rhs),\n                        operator: NumericBinaryOperator::Add,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U16(rhs) =\u003e lhs\n                .checked_add(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U16(rhs),\n                        operator: NumericBinaryOperator::Add,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U32(rhs) =\u003e lhs\n                .checked_add(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U32(rhs),\n                        operator: NumericBinaryOperator::Add,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U64(rhs) =\u003e lhs\n                .checked_add(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U64(rhs),\n                        operator: NumericBinaryOperator::Add,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U128(rhs) =\u003e lhs\n                .checked_add(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U128(rhs),\n                        operator: NumericBinaryOperator::Add,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n\n            F32(rhs) =\u003e Decimal::from_f32_retain(rhs)\n                .map(|x| {\n                    lhs.checked_add(x)\n                        .ok_or_else(|| {\n                            ValueError::BinaryOperationOverflow {\n                                lhs: Decimal(lhs),\n                                rhs: F32(rhs),\n                                operator: NumericBinaryOperator::Add,\n                            }\n                            .into()\n                        })\n                        .map(Decimal)\n                })\n                .unwrap_or_else(|| {\n                    Err(ValueError::FloatToDecimalConversionFailure(rhs.into()).into())\n                }),\n            F64(rhs) =\u003e Decimal::from_f64_retain(rhs)\n                .map(|x| {\n                    lhs.checked_add(x)\n                        .ok_or_else(|| {\n                            ValueError::BinaryOperationOverflow {\n                                lhs: Decimal(lhs),\n                                rhs: F64(rhs),\n                                operator: NumericBinaryOperator::Add,\n                            }\n                            .into()\n                        })\n                        .map(Decimal)\n                })\n                .unwrap_or_else(|| Err(ValueError::FloatToDecimalConversionFailure(rhs).into())),\n            Decimal(rhs) =\u003e lhs\n                .checked_add(rhs)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: Decimal(rhs),\n                        operator: NumericBinaryOperator::Add,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: Decimal(lhs),\n                operator: NumericBinaryOperator::Add,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n\n    fn try_subtract(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e lhs\n                .checked_sub(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I8(rhs),\n                        operator: NumericBinaryOperator::Subtract,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            I32(rhs) =\u003e lhs\n                .checked_sub(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I32(rhs),\n                        operator: NumericBinaryOperator::Subtract,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            I64(rhs) =\u003e lhs\n                .checked_sub(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I64(rhs),\n                        operator: NumericBinaryOperator::Subtract,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            I128(rhs) =\u003e lhs\n                .checked_sub(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I128(rhs),\n                        operator: NumericBinaryOperator::Subtract,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U8(rhs) =\u003e lhs\n                .checked_sub(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U8(rhs),\n                        operator: NumericBinaryOperator::Subtract,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U16(rhs) =\u003e lhs\n                .checked_sub(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U16(rhs),\n                        operator: NumericBinaryOperator::Subtract,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U32(rhs) =\u003e lhs\n                .checked_sub(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U32(rhs),\n                        operator: NumericBinaryOperator::Subtract,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U64(rhs) =\u003e lhs\n                .checked_sub(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U64(rhs),\n                        operator: NumericBinaryOperator::Subtract,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U128(rhs) =\u003e lhs\n                .checked_sub(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U128(rhs),\n                        operator: NumericBinaryOperator::Subtract,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n\n            F32(rhs) =\u003e Decimal::from_f32_retain(rhs)\n                .map(|x| {\n                    lhs.checked_sub(x)\n                        .ok_or_else(|| {\n                            ValueError::BinaryOperationOverflow {\n                                lhs: Decimal(lhs),\n                                rhs: F32(rhs),\n                                operator: NumericBinaryOperator::Subtract,\n                            }\n                            .into()\n                        })\n                        .map(Decimal)\n                })\n                .unwrap_or_else(|| {\n                    Err(ValueError::FloatToDecimalConversionFailure(rhs.into()).into())\n                }),\n            F64(rhs) =\u003e Decimal::from_f64_retain(rhs)\n                .map(|x| {\n                    lhs.checked_sub(x)\n                        .ok_or_else(|| {\n                            ValueError::BinaryOperationOverflow {\n                                lhs: Decimal(lhs),\n                                rhs: F64(rhs),\n                                operator: NumericBinaryOperator::Subtract,\n                            }\n                            .into()\n                        })\n                        .map(Decimal)\n                })\n                .unwrap_or_else(|| Err(ValueError::FloatToDecimalConversionFailure(rhs).into())),\n            Decimal(rhs) =\u003e lhs\n                .checked_sub(rhs)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        operator: NumericBinaryOperator::Subtract,\n                        rhs: Decimal(rhs),\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: Decimal(lhs),\n                operator: NumericBinaryOperator::Subtract,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n\n    fn try_multiply(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e lhs\n                .checked_mul(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I8(rhs),\n                        operator: NumericBinaryOperator::Multiply,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            I32(rhs) =\u003e lhs\n                .checked_mul(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I32(rhs),\n                        operator: NumericBinaryOperator::Multiply,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            I64(rhs) =\u003e lhs\n                .checked_mul(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I64(rhs),\n                        operator: NumericBinaryOperator::Multiply,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            I128(rhs) =\u003e lhs\n                .checked_mul(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I128(rhs),\n                        operator: NumericBinaryOperator::Multiply,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U8(rhs) =\u003e lhs\n                .checked_mul(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U8(rhs),\n                        operator: NumericBinaryOperator::Multiply,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U16(rhs) =\u003e lhs\n                .checked_mul(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U16(rhs),\n                        operator: NumericBinaryOperator::Multiply,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U32(rhs) =\u003e lhs\n                .checked_mul(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U32(rhs),\n                        operator: NumericBinaryOperator::Multiply,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U64(rhs) =\u003e lhs\n                .checked_mul(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U64(rhs),\n                        operator: NumericBinaryOperator::Multiply,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U128(rhs) =\u003e lhs\n                .checked_mul(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U128(rhs),\n                        operator: NumericBinaryOperator::Multiply,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n\n            F32(rhs) =\u003e Decimal::from_f32_retain(rhs)\n                .map(|x| {\n                    lhs.checked_mul(x)\n                        .ok_or_else(|| {\n                            ValueError::BinaryOperationOverflow {\n                                lhs: Decimal(lhs),\n                                rhs: F32(rhs),\n                                operator: NumericBinaryOperator::Multiply,\n                            }\n                            .into()\n                        })\n                        .map(Decimal)\n                })\n                .unwrap_or_else(|| {\n                    Err(ValueError::FloatToDecimalConversionFailure(rhs.into()).into())\n                }),\n            F64(rhs) =\u003e Decimal::from_f64_retain(rhs)\n                .map(|x| {\n                    lhs.checked_mul(x)\n                        .ok_or_else(|| {\n                            ValueError::BinaryOperationOverflow {\n                                lhs: Decimal(lhs),\n                                rhs: F64(rhs),\n                                operator: NumericBinaryOperator::Multiply,\n                            }\n                            .into()\n                        })\n                        .map(Decimal)\n                })\n                .unwrap_or_else(|| Err(ValueError::FloatToDecimalConversionFailure(rhs).into())),\n            Decimal(rhs) =\u003e lhs\n                .checked_mul(rhs)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        operator: NumericBinaryOperator::Multiply,\n                        rhs: Decimal(rhs),\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: Decimal(lhs),\n                operator: NumericBinaryOperator::Multiply,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n\n    fn try_divide(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e lhs\n                .checked_div(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I8(rhs),\n                        operator: NumericBinaryOperator::Divide,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            I32(rhs) =\u003e lhs\n                .checked_div(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I32(rhs),\n                        operator: NumericBinaryOperator::Divide,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            I64(rhs) =\u003e lhs\n                .checked_div(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I64(rhs),\n                        operator: NumericBinaryOperator::Divide,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            I128(rhs) =\u003e lhs\n                .checked_div(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: I128(rhs),\n                        operator: NumericBinaryOperator::Divide,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U8(rhs) =\u003e lhs\n                .checked_div(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U8(rhs),\n                        operator: NumericBinaryOperator::Divide,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U16(rhs) =\u003e lhs\n                .checked_div(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U16(rhs),\n                        operator: NumericBinaryOperator::Divide,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U32(rhs) =\u003e lhs\n                .checked_div(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U32(rhs),\n                        operator: NumericBinaryOperator::Divide,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U64(rhs) =\u003e lhs\n                .checked_div(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U64(rhs),\n                        operator: NumericBinaryOperator::Divide,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U128(rhs) =\u003e lhs\n                .checked_div(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U128(rhs),\n                        operator: NumericBinaryOperator::Divide,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n\n            F32(rhs) =\u003e Decimal::from_f32_retain(rhs)\n                .map(|x| {\n                    lhs.checked_div(x)\n                        .ok_or_else(|| {\n                            ValueError::BinaryOperationOverflow {\n                                lhs: Decimal(lhs),\n                                rhs: F32(rhs),\n                                operator: NumericBinaryOperator::Divide,\n                            }\n                            .into()\n                        })\n                        .map(Decimal)\n                })\n                .unwrap_or_else(|| {\n                    Err(ValueError::FloatToDecimalConversionFailure(rhs.into()).into())\n                }),\n            F64(rhs) =\u003e Decimal::from_f64_retain(rhs)\n                .map(|x| {\n                    lhs.checked_div(x)\n                        .ok_or_else(|| {\n                            ValueError::BinaryOperationOverflow {\n                                lhs: Decimal(lhs),\n                                rhs: F64(rhs),\n                                operator: NumericBinaryOperator::Divide,\n                            }\n                            .into()\n                        })\n                        .map(Decimal)\n                })\n                .unwrap_or_else(|| Err(ValueError::FloatToDecimalConversionFailure(rhs).into())),\n            Decimal(rhs) =\u003e lhs\n                .checked_div(rhs)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        operator: NumericBinaryOperator::Divide,\n                        rhs: Decimal(rhs),\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: Decimal(lhs),\n                operator: NumericBinaryOperator::Divide,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n\n    fn try_modulo(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e lhs\n                .checked_rem(Decimal::from(rhs))\n                .map(|x| Ok(Decimal(x)))\n                .unwrap_or_else(|| {\n                    Err(ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        operator: NumericBinaryOperator::Modulo,\n                        rhs: I8(rhs),\n                    }\n                    .into())\n                }),\n            I32(rhs) =\u003e lhs\n                .checked_rem(Decimal::from(rhs))\n                .map(|x| Ok(Decimal(x)))\n                .unwrap_or_else(|| {\n                    Err(ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        operator: NumericBinaryOperator::Modulo,\n                        rhs: I32(rhs),\n                    }\n                    .into())\n                }),\n            I64(rhs) =\u003e lhs\n                .checked_rem(Decimal::from(rhs))\n                .map(|x| Ok(Decimal(x)))\n                .unwrap_or_else(|| {\n                    Err(ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        operator: NumericBinaryOperator::Modulo,\n                        rhs: I64(rhs),\n                    }\n                    .into())\n                }),\n            I128(rhs) =\u003e lhs\n                .checked_rem(Decimal::from(rhs))\n                .map(|x| Ok(Decimal(x)))\n                .unwrap_or_else(|| {\n                    Err(ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        operator: NumericBinaryOperator::Modulo,\n                        rhs: I128(rhs),\n                    }\n                    .into())\n                }),\n            U8(rhs) =\u003e lhs\n                .checked_rem(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U8(rhs),\n                        operator: NumericBinaryOperator::Modulo,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U16(rhs) =\u003e lhs\n                .checked_rem(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U16(rhs),\n                        operator: NumericBinaryOperator::Modulo,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U32(rhs) =\u003e lhs\n                .checked_rem(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U32(rhs),\n                        operator: NumericBinaryOperator::Modulo,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U64(rhs) =\u003e lhs\n                .checked_rem(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U64(rhs),\n                        operator: NumericBinaryOperator::Modulo,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            U128(rhs) =\u003e lhs\n                .checked_rem(Decimal::from(rhs))\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        rhs: U128(rhs),\n                        operator: NumericBinaryOperator::Modulo,\n                    }\n                    .into()\n                })\n                .map(Decimal),\n\n            F32(rhs) =\u003e match Decimal::from_f32_retain(rhs) {\n                Some(x) =\u003e lhs\n                    .checked_rem(x)\n                    .map(|y| Ok(Decimal(y)))\n                    .unwrap_or_else(|| {\n                        Err(ValueError::BinaryOperationOverflow {\n                            lhs: Decimal(lhs),\n                            operator: NumericBinaryOperator::Modulo,\n                            rhs: F32(rhs),\n                        }\n                        .into())\n                    }),\n                _ =\u003e Err(ValueError::FloatToDecimalConversionFailure(rhs.into()).into()),\n            },\n            F64(rhs) =\u003e match Decimal::from_f64_retain(rhs) {\n                Some(x) =\u003e lhs\n                    .checked_rem(x)\n                    .map(|y| Ok(Decimal(y)))\n                    .unwrap_or_else(|| {\n                        Err(ValueError::BinaryOperationOverflow {\n                            lhs: Decimal(lhs),\n                            operator: NumericBinaryOperator::Modulo,\n                            rhs: F64(rhs),\n                        }\n                        .into())\n                    }),\n                _ =\u003e Err(ValueError::FloatToDecimalConversionFailure(rhs).into()),\n            },\n            Decimal(rhs) =\u003e lhs\n                .checked_rem(rhs)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: Decimal(lhs),\n                        operator: NumericBinaryOperator::Modulo,\n                        rhs: Decimal(rhs),\n                    }\n                    .into()\n                })\n                .map(Decimal),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: Decimal(lhs),\n                operator: NumericBinaryOperator::Modulo,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::{TryBinaryOperator, Value::*},\n        crate::data::{NumericBinaryOperator, ValueError},\n        rust_decimal::prelude::Decimal,\n        std::cmp::Ordering,\n    };\n\n    #[test]\n    fn test_extremes() {\n        let base = Decimal::ONE;\n\n        assert_eq!(\n            Decimal::MAX.try_add(\u0026Decimal(Decimal::ONE)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: Decimal(Decimal::ONE),\n                operator: NumericBinaryOperator::Add,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            Decimal::MAX.try_add(\u0026I8(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: I8(1),\n                operator: NumericBinaryOperator::Add,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_add(\u0026I32(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: I32(1),\n                operator: NumericBinaryOperator::Add,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_add(\u0026I64(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: I64(1),\n                operator: NumericBinaryOperator::Add,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_add(\u0026I128(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: I128(1),\n                operator: NumericBinaryOperator::Add,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_add(\u0026U8(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: U8(1),\n                operator: NumericBinaryOperator::Add,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            Decimal::MAX.try_add(\u0026U16(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: U16(1),\n                operator: NumericBinaryOperator::Add,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_add(\u0026U32(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: U32(1),\n                operator: NumericBinaryOperator::Add,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_add(\u0026U64(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: U64(1),\n                operator: NumericBinaryOperator::Add,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_add(\u0026U128(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: U128(1),\n                operator: NumericBinaryOperator::Add,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_add(\u0026F32(1.0_f32)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: F32(1.0_f32),\n                operator: NumericBinaryOperator::Add,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_add(\u0026F64(1.0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: F64(1.0),\n                operator: NumericBinaryOperator::Add,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            Decimal::MIN.try_subtract(\u0026I8(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MIN),\n                rhs: I8(1),\n                operator: NumericBinaryOperator::Subtract,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MIN.try_subtract(\u0026I32(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MIN),\n                rhs: I32(1),\n                operator: NumericBinaryOperator::Subtract,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MIN.try_subtract(\u0026I64(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MIN),\n                rhs: I64(1),\n                operator: NumericBinaryOperator::Subtract,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MIN.try_subtract(\u0026I128(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MIN),\n                rhs: I128(1),\n                operator: NumericBinaryOperator::Subtract,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MIN.try_subtract(\u0026U8(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MIN),\n                rhs: U8(1),\n                operator: NumericBinaryOperator::Subtract,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MIN.try_subtract(\u0026U16(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MIN),\n                rhs: U16(1),\n                operator: NumericBinaryOperator::Subtract,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MIN.try_subtract(\u0026U32(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MIN),\n                rhs: U32(1),\n                operator: NumericBinaryOperator::Subtract,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MIN.try_subtract(\u0026U64(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MIN),\n                rhs: U64(1),\n                operator: NumericBinaryOperator::Subtract,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MIN.try_subtract(\u0026U128(1)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MIN),\n                rhs: U128(1),\n                operator: NumericBinaryOperator::Subtract,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MIN.try_subtract(\u0026F32(1.0_f32)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MIN),\n                rhs: F32(1.0_f32),\n                operator: NumericBinaryOperator::Subtract,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MIN.try_subtract(\u0026F64(1.0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MIN),\n                rhs: F64(1.0),\n                operator: NumericBinaryOperator::Subtract,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            Decimal::MIN.try_subtract(\u0026Decimal(Decimal::ONE)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MIN),\n                rhs: Decimal(Decimal::ONE),\n                operator: NumericBinaryOperator::Subtract,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            Decimal::MAX.try_multiply(\u0026I8(2)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: I8(2),\n                operator: NumericBinaryOperator::Multiply,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_multiply(\u0026I32(2)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: I32(2),\n                operator: NumericBinaryOperator::Multiply,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_multiply(\u0026I64(2)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: I64(2),\n                operator: NumericBinaryOperator::Multiply,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_multiply(\u0026I128(2)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: I128(2),\n                operator: NumericBinaryOperator::Multiply,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_multiply(\u0026U8(2)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: U8(2),\n                operator: NumericBinaryOperator::Multiply,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_multiply(\u0026U16(2)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: U16(2),\n                operator: NumericBinaryOperator::Multiply,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            Decimal::MAX.try_multiply(\u0026U32(2)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: U32(2),\n                operator: NumericBinaryOperator::Multiply,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_multiply(\u0026U64(2)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: U64(2),\n                operator: NumericBinaryOperator::Multiply,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_multiply(\u0026U128(2)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: U128(2),\n                operator: NumericBinaryOperator::Multiply,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_multiply(\u0026F32(2.0_f32)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: F32(2.0_f32),\n                operator: NumericBinaryOperator::Multiply,\n            }\n            .into())\n        );\n        assert_eq!(\n            Decimal::MAX.try_multiply(\u0026F64(2.0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: F64(2.0),\n                operator: NumericBinaryOperator::Multiply,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            Decimal::MAX.try_multiply(\u0026Decimal(Decimal::TWO)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(Decimal::MAX),\n                rhs: Decimal(Decimal::TWO),\n                operator: NumericBinaryOperator::Multiply,\n            }\n            .into())\n        );\n\n        // try divide overflow\n        assert_eq!(\n            base.try_divide(\u0026I8(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: I8(0),\n                operator: NumericBinaryOperator::Divide,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_divide(\u0026I32(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: I32(0),\n                operator: NumericBinaryOperator::Divide,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_divide(\u0026I64(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: I64(0),\n                operator: NumericBinaryOperator::Divide,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            base.try_divide(\u0026I128(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: I128(0),\n                operator: NumericBinaryOperator::Divide,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_divide(\u0026U8(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: U8(0),\n                operator: NumericBinaryOperator::Divide,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            base.try_divide(\u0026U16(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: U16(0),\n                operator: NumericBinaryOperator::Divide,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_divide(\u0026U32(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: U32(0),\n                operator: NumericBinaryOperator::Divide,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_divide(\u0026U64(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: U64(0),\n                operator: NumericBinaryOperator::Divide,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_divide(\u0026U128(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: U128(0),\n                operator: NumericBinaryOperator::Divide,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_divide(\u0026F32(0.0_f32)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: F32(0.0_f32),\n                operator: NumericBinaryOperator::Divide,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_divide(\u0026F64(0.0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: F64(0.0),\n                operator: NumericBinaryOperator::Divide,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            base.try_divide(\u0026Decimal(Decimal::ZERO)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: Decimal(Decimal::ZERO),\n                operator: NumericBinaryOperator::Divide,\n            }\n            .into())\n        );\n\n        // try modulo overflow\n        assert_eq!(\n            base.try_modulo(\u0026I8(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: I8(0),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_modulo(\u0026I32(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: I32(0),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_modulo(\u0026I64(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: I64(0),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            base.try_modulo(\u0026I128(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: I128(0),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_modulo(\u0026U8(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: U8(0),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            base.try_modulo(\u0026U16(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: U16(0),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_modulo(\u0026U32(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: U32(0),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_modulo(\u0026U64(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: U64(0),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_modulo(\u0026U128(0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: U128(0),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_modulo(\u0026F32(0.0_f32)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: F32(0.0_f32),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n        assert_eq!(\n            base.try_modulo(\u0026F64(0.0)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: F64(0.0),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            base.try_modulo(\u0026Decimal(Decimal::ZERO)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: Decimal(base),\n                rhs: Decimal(Decimal::ZERO),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n    }\n\n    #[test]\n    fn eq() {\n        let base = Decimal::ONE;\n\n        assert_eq!(base, I8(1));\n        assert_eq!(base, I32(1));\n        assert_eq!(base, I64(1));\n        assert_eq!(base, I128(1));\n        assert_eq!(base, U8(1));\n        assert_eq!(base, U16(1));\n        assert_eq!(base, U32(1));\n        assert_eq!(base, U64(1));\n        assert_eq!(base, U128(1));\n        assert_eq!(base, F32(1.0_f32));\n        assert_eq!(base, F64(1.0));\n        assert_eq!(base, Decimal(Decimal::ONE));\n\n        assert_ne!(base, Bool(true));\n    }\n\n    #[test]\n    fn partial_cmp() {\n        let base = Decimal::ONE;\n\n        assert_eq!(base.partial_cmp(\u0026I8(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026I32(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026I64(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026I128(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U8(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U16(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U32(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U64(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U128(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026F32(1.0_f32)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026F64(1.0)), Some(Ordering::Equal));\n        assert_eq!(\n            base.partial_cmp(\u0026Decimal(Decimal::ONE)),\n            Some(Ordering::Equal)\n        );\n\n        assert_eq!(base.partial_cmp(\u0026Bool(true)), None);\n    }\n\n    #[test]\n    fn try_add() {\n        let base = Decimal::ONE;\n\n        assert_eq!(base.try_add(\u0026I8(1)), Ok(Decimal(Decimal::TWO)));\n        assert_eq!(base.try_add(\u0026I32(1)), Ok(Decimal(Decimal::TWO)));\n        assert_eq!(base.try_add(\u0026I64(1)), Ok(Decimal(Decimal::TWO)));\n        assert_eq!(base.try_add(\u0026I128(1)), Ok(Decimal(Decimal::TWO)));\n        assert_eq!(base.try_add(\u0026U8(1)), Ok(Decimal(Decimal::TWO)));\n        assert_eq!(base.try_add(\u0026U16(1)), Ok(Decimal(Decimal::TWO)));\n        assert_eq!(base.try_add(\u0026U32(1)), Ok(Decimal(Decimal::TWO)));\n        assert_eq!(base.try_add(\u0026U64(1)), Ok(Decimal(Decimal::TWO)));\n        assert_eq!(base.try_add(\u0026U128(1)), Ok(Decimal(Decimal::TWO)));\n        assert_eq!(base.try_add(\u0026F32(1.0_f32)), Ok(Decimal(Decimal::TWO)));\n        assert_eq!(base.try_add(\u0026F64(1.0)), Ok(Decimal(Decimal::TWO)));\n        assert_eq!(\n            base.try_add(\u0026Decimal(Decimal::ONE)),\n            Ok(Decimal(Decimal::TWO))\n        );\n        assert_eq!(\n            base.try_add(\u0026F32(f32::MAX)),\n            Err(ValueError::FloatToDecimalConversionFailure(f32::MAX.into()).into())\n        );\n\n        assert_eq!(\n            base.try_add(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: Decimal(base),\n                operator: NumericBinaryOperator::Add,\n                rhs: Bool(true),\n            }\n            .into()),\n        );\n    }\n\n    #[test]\n    fn try_subtract() {\n        let base = Decimal::ONE;\n\n        assert_eq!(base.try_subtract(\u0026I8(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_subtract(\u0026I32(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_subtract(\u0026I64(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_subtract(\u0026I128(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_subtract(\u0026U8(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_subtract(\u0026U16(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_subtract(\u0026U32(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_subtract(\u0026U64(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_subtract(\u0026U128(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_subtract(\u0026F32(1.0_f32)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_subtract(\u0026F64(1.0)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(\n            base.try_subtract(\u0026Decimal(Decimal::ONE)),\n            Ok(Decimal(Decimal::ZERO))\n        );\n        assert_eq!(\n            (-base).try_subtract(\u0026F32(f32::MIN)),\n            Err(ValueError::FloatToDecimalConversionFailure(f32::MIN.into()).into())\n        );\n\n        assert_eq!(\n            base.try_subtract(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: Decimal(base),\n                operator: NumericBinaryOperator::Subtract,\n                rhs: Bool(true),\n            }\n            .into()),\n        );\n    }\n\n    #[test]\n    fn try_multiply() {\n        let base = Decimal::ONE;\n\n        assert_eq!(base.try_multiply(\u0026I8(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_multiply(\u0026I32(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_multiply(\u0026I64(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_multiply(\u0026I128(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_multiply(\u0026U8(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_multiply(\u0026U16(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_multiply(\u0026U32(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_multiply(\u0026U64(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_multiply(\u0026U128(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_multiply(\u0026F32(1.0_f32)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_multiply(\u0026F64(1.0)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(\n            base.try_multiply(\u0026Decimal(Decimal::ONE)),\n            Ok(Decimal(Decimal::ONE))\n        );\n        assert_eq!(\n            Decimal::TWO.try_multiply(\u0026F32(f32::MAX)),\n            Err(ValueError::FloatToDecimalConversionFailure(f32::MAX.into()).into())\n        );\n\n        assert_eq!(\n            base.try_multiply(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: Decimal(base),\n                operator: NumericBinaryOperator::Multiply,\n                rhs: Bool(true),\n            }\n            .into()),\n        );\n    }\n\n    #[test]\n    fn try_divide() {\n        let base = Decimal::ONE;\n\n        assert_eq!(base.try_divide(\u0026I8(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_divide(\u0026I32(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_divide(\u0026I64(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_divide(\u0026I128(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_divide(\u0026U8(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_divide(\u0026U16(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_divide(\u0026U32(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_divide(\u0026U64(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_divide(\u0026U128(1)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_divide(\u0026F32(1.0_f32)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(base.try_divide(\u0026F64(1.0)), Ok(Decimal(Decimal::ONE)));\n        assert_eq!(\n            base.try_divide(\u0026Decimal(Decimal::ONE)),\n            Ok(Decimal(Decimal::ONE))\n        );\n        assert_eq!(\n            base.try_divide(\u0026F32(f32::MAX)),\n            Err(ValueError::FloatToDecimalConversionFailure(f32::MAX.into()).into())\n        );\n\n        assert_eq!(\n            base.try_divide(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: Decimal(base),\n                operator: NumericBinaryOperator::Divide,\n                rhs: Bool(true),\n            }\n            .into()),\n        );\n    }\n\n    #[test]\n    fn try_modulo() {\n        let base = Decimal::ONE;\n\n        assert_eq!(base.try_modulo(\u0026I8(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_modulo(\u0026I32(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_modulo(\u0026I64(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_modulo(\u0026I128(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_modulo(\u0026U8(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_modulo(\u0026U16(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_modulo(\u0026U32(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_modulo(\u0026U64(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_modulo(\u0026U128(1)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_modulo(\u0026F32(1.0_f32)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(base.try_modulo(\u0026F64(1.0)), Ok(Decimal(Decimal::ZERO)));\n        assert_eq!(\n            base.try_modulo(\u0026Decimal(Decimal::ONE)),\n            Ok(Decimal(Decimal::ZERO))\n        );\n        assert_eq!(\n            base.try_modulo(\u0026F32(f32::INFINITY)),\n            Err(ValueError::FloatToDecimalConversionFailure(f64::INFINITY).into())\n        );\n        assert_eq!(\n            base.try_modulo(\u0026F64(f64::INFINITY)),\n            Err(ValueError::FloatToDecimalConversionFailure(f64::INFINITY).into())\n        );\n\n        assert_eq!(\n            base.try_modulo(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: Decimal(base),\n                operator: NumericBinaryOperator::Modulo,\n                rhs: Bool(true),\n            }\n            .into()),\n        );\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":641},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","f32.rs"],"content":"use {\n    super::TryBinaryOperator,\n    crate::{\n        data::{NumericBinaryOperator, ValueError},\n        prelude::Value,\n        result::Result,\n    },\n    Value::*,\n    rust_decimal::prelude::Decimal,\n    std::cmp::Ordering,\n};\n\nimpl PartialEq\u003cValue\u003e for f32 {\n    fn eq(\u0026self, other: \u0026Value) -\u003e bool {\n        let lhs = *self;\n\n        match *other {\n            I8(rhs) =\u003e (lhs - (rhs as f32)).abs() \u003c f32::EPSILON,\n            I16(rhs) =\u003e (lhs - (rhs as f32)).abs() \u003c f32::EPSILON,\n            I32(rhs) =\u003e (lhs - (rhs as f32)).abs() \u003c f32::EPSILON,\n            I64(rhs) =\u003e (lhs - (rhs as f32)).abs() \u003c f32::EPSILON,\n            I128(rhs) =\u003e (lhs - (rhs as f32)).abs() \u003c f32::EPSILON,\n            U8(rhs) =\u003e (lhs - (rhs as f32)).abs() \u003c f32::EPSILON,\n            U16(rhs) =\u003e (lhs - (rhs as f32)).abs() \u003c f32::EPSILON,\n            U32(rhs) =\u003e (lhs - (rhs as f32)).abs() \u003c f32::EPSILON,\n            U64(rhs) =\u003e (lhs - (rhs as f32)).abs() \u003c f32::EPSILON,\n            U128(rhs) =\u003e (lhs - (rhs as f32)).abs() \u003c f32::EPSILON,\n            F32(rhs) =\u003e (lhs - rhs).abs() \u003c f32::EPSILON,\n            F64(rhs) =\u003e (lhs - rhs as f32).abs() \u003c f32::EPSILON,\n            Decimal(rhs) =\u003e Decimal::from_f32_retain(lhs)\n                .map(|x| rhs == x)\n                .unwrap_or(false),\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl PartialOrd\u003cValue\u003e for f32 {\n    fn partial_cmp(\u0026self, other: \u0026Value) -\u003e Option\u003cOrdering\u003e {\n        match *other {\n            I8(rhs) =\u003e self.partial_cmp(\u0026(rhs as f32)),\n            I16(rhs) =\u003e self.partial_cmp(\u0026(rhs as f32)),\n            I32(rhs) =\u003e self.partial_cmp(\u0026(rhs as f32)),\n            I64(rhs) =\u003e self.partial_cmp(\u0026(rhs as f32)),\n            I128(rhs) =\u003e self.partial_cmp(\u0026(rhs as f32)),\n            U8(rhs) =\u003e self.partial_cmp(\u0026(rhs as f32)),\n            U16(rhs) =\u003e self.partial_cmp(\u0026(rhs as f32)),\n            U32(rhs) =\u003e self.partial_cmp(\u0026(rhs as f32)),\n            U64(rhs) =\u003e self.partial_cmp(\u0026(rhs as f32)),\n            U128(rhs) =\u003e self.partial_cmp(\u0026(rhs as f32)),\n            F64(rhs) =\u003e self.partial_cmp(\u0026(rhs as f32)),\n            F32(rhs) =\u003e self.partial_cmp(\u0026rhs),\n            Decimal(rhs) =\u003e Decimal::from_f32_retain(*self)\n                .map(|x| x.partial_cmp(\u0026rhs))\n                .unwrap_or(None),\n            _ =\u003e None,\n        }\n    }\n}\n\nimpl TryBinaryOperator for f32 {\n    type Rhs = Value;\n\n    fn try_add(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e Ok(F32(lhs + rhs as f32)),\n            I16(rhs) =\u003e Ok(F32(lhs + rhs as f32)),\n            I32(rhs) =\u003e Ok(F32(lhs + rhs as f32)),\n            I64(rhs) =\u003e Ok(F32(lhs + rhs as f32)),\n            I128(rhs) =\u003e Ok(F32(lhs + rhs as f32)),\n            U8(rhs) =\u003e Ok(F32(lhs + rhs as f32)),\n            U16(rhs) =\u003e Ok(F32(lhs + rhs as f32)),\n            U32(rhs) =\u003e Ok(F32(lhs + rhs as f32)),\n            U64(rhs) =\u003e Ok(F32(lhs + rhs as f32)),\n            U128(rhs) =\u003e Ok(F32(lhs + rhs as f32)),\n            F64(rhs) =\u003e Ok(F32(lhs + rhs as f32)),\n            F32(rhs) =\u003e Ok(F32(lhs + rhs)),\n            Decimal(rhs) =\u003e Decimal::from_f32_retain(lhs)\n                .map(|x| Ok(Decimal(x + rhs)))\n                .unwrap_or_else(|| {\n                    Err(ValueError::FloatToDecimalConversionFailure(lhs.into()).into())\n                }),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: F32(lhs),\n                operator: NumericBinaryOperator::Add,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n\n    fn try_subtract(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e Ok(F32(lhs - rhs as f32)),\n            I16(rhs) =\u003e Ok(F32(lhs - rhs as f32)),\n            I32(rhs) =\u003e Ok(F32(lhs - rhs as f32)),\n            I64(rhs) =\u003e Ok(F32(lhs - rhs as f32)),\n            I128(rhs) =\u003e Ok(F32(lhs - rhs as f32)),\n            U8(rhs) =\u003e Ok(F32(lhs - rhs as f32)),\n            U16(rhs) =\u003e Ok(F32(lhs - rhs as f32)),\n            U32(rhs) =\u003e Ok(F32(lhs - rhs as f32)),\n            U64(rhs) =\u003e Ok(F32(lhs - rhs as f32)),\n            U128(rhs) =\u003e Ok(F32(lhs - rhs as f32)),\n            F64(rhs) =\u003e Ok(F32(lhs - rhs as f32)),\n            F32(rhs) =\u003e Ok(F32(lhs - rhs)),\n            Decimal(rhs) =\u003e Decimal::from_f32_retain(lhs)\n                .map(|x| Ok(Decimal(x - rhs)))\n                .unwrap_or_else(|| {\n                    Err(ValueError::FloatToDecimalConversionFailure(lhs.into()).into())\n                }),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: F32(lhs),\n                operator: NumericBinaryOperator::Subtract,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n\n    fn try_multiply(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e Ok(F32(lhs * rhs as f32)),\n            I16(rhs) =\u003e Ok(F32(lhs * rhs as f32)),\n            I32(rhs) =\u003e Ok(F32(lhs * rhs as f32)),\n            I64(rhs) =\u003e Ok(F32(lhs * rhs as f32)),\n            I128(rhs) =\u003e Ok(F32(lhs * rhs as f32)),\n            U8(rhs) =\u003e Ok(F32(lhs * rhs as f32)),\n            U16(rhs) =\u003e Ok(F32(lhs * rhs as f32)),\n            U32(rhs) =\u003e Ok(F32(lhs * rhs as f32)),\n            U64(rhs) =\u003e Ok(F32(lhs * rhs as f32)),\n            U128(rhs) =\u003e Ok(F32(lhs * rhs as f32)),\n            F64(rhs) =\u003e Ok(F32(lhs * rhs as f32)),\n            F32(rhs) =\u003e Ok(F32(lhs * rhs)),\n            Interval(rhs) =\u003e Ok(Interval(lhs * rhs)),\n            Decimal(rhs) =\u003e Decimal::from_f32_retain(lhs)\n                .map(|x| Ok(Decimal(x * rhs)))\n                .unwrap_or_else(|| {\n                    Err(ValueError::FloatToDecimalConversionFailure(lhs.into()).into())\n                }),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: F32(lhs),\n                operator: NumericBinaryOperator::Multiply,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n\n    fn try_divide(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e Ok(F32(lhs / rhs as f32)),\n            I16(rhs) =\u003e Ok(F32(lhs / rhs as f32)),\n            I32(rhs) =\u003e Ok(F32(lhs / rhs as f32)),\n            I64(rhs) =\u003e Ok(F32(lhs / rhs as f32)),\n            I128(rhs) =\u003e Ok(F32(lhs / rhs as f32)),\n            U8(rhs) =\u003e Ok(F32(lhs / rhs as f32)),\n            U16(rhs) =\u003e Ok(F32(lhs / rhs as f32)),\n            U32(rhs) =\u003e Ok(F32(lhs / rhs as f32)),\n            U64(rhs) =\u003e Ok(F32(lhs / rhs as f32)),\n            U128(rhs) =\u003e Ok(F32(lhs / rhs as f32)),\n            F64(rhs) =\u003e Ok(F32(lhs / rhs as f32)),\n            F32(rhs) =\u003e Ok(F32(lhs / rhs)),\n            Decimal(rhs) =\u003e Decimal::from_f32_retain(lhs)\n                .map(|x| Ok(Decimal(x * rhs)))\n                .unwrap_or_else(|| {\n                    Err(ValueError::FloatToDecimalConversionFailure(lhs.into()).into())\n                }),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: F32(lhs),\n                operator: NumericBinaryOperator::Divide,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n\n    fn try_modulo(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e Ok(F32(lhs % rhs as f32)),\n            I16(rhs) =\u003e Ok(F32(lhs % rhs as f32)),\n            I32(rhs) =\u003e Ok(F32(lhs % rhs as f32)),\n            I64(rhs) =\u003e Ok(F32(lhs % rhs as f32)),\n            I128(rhs) =\u003e Ok(F32(lhs % rhs as f32)),\n            U8(rhs) =\u003e Ok(F32(lhs % rhs as f32)),\n            U16(rhs) =\u003e Ok(F32(lhs % rhs as f32)),\n            U32(rhs) =\u003e Ok(F32(lhs % rhs as f32)),\n            U64(rhs) =\u003e Ok(F32(lhs % rhs as f32)),\n            U128(rhs) =\u003e Ok(F32(lhs % rhs as f32)),\n            F64(rhs) =\u003e Ok(F32(lhs % rhs as f32)),\n            F32(rhs) =\u003e Ok(F32(lhs % rhs)),\n            Decimal(rhs) =\u003e match Decimal::from_f32_retain(lhs) {\n                Some(x) =\u003e x\n                    .checked_rem(rhs)\n                    .map(|y| Ok(Decimal(y)))\n                    .unwrap_or_else(|| {\n                        Err(ValueError::BinaryOperationOverflow {\n                            lhs: F32(lhs),\n                            operator: NumericBinaryOperator::Modulo,\n                            rhs: Decimal(rhs),\n                        }\n                        .into())\n                    }),\n                _ =\u003e Err(ValueError::FloatToDecimalConversionFailure(lhs.into()).into()),\n            },\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: F32(lhs),\n                operator: NumericBinaryOperator::Modulo,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::{TryBinaryOperator, Value::*},\n        crate::data::{NumericBinaryOperator, ValueError},\n        rust_decimal::prelude::Decimal,\n        std::cmp::Ordering,\n    };\n\n    #[test]\n    fn eq() {\n        let base = 1.0_f32;\n\n        assert_eq!(base, I8(1));\n        assert_eq!(base, I16(1));\n        assert_eq!(base, I32(1));\n        assert_eq!(base, I64(1));\n        assert_eq!(base, I128(1));\n        assert_eq!(base, U8(1));\n        assert_eq!(base, U16(1));\n        assert_eq!(base, U32(1));\n        assert_eq!(base, U64(1));\n        assert_eq!(base, U128(1));\n        assert_eq!(base, F64(1.0));\n        assert_eq!(base, F32(1.0_f32));\n        assert_eq!(base, Decimal(Decimal::from(1)));\n\n        assert_ne!(base, Bool(true));\n    }\n\n    #[test]\n    fn partial_cmp() {\n        let base = 1.0_f32;\n\n        assert_eq!(base.partial_cmp(\u0026I8(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026I16(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026I32(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026I64(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026I128(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U8(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U16(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U32(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U64(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U128(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026F64(1.0)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026F32(1.0_f32)), Some(Ordering::Equal));\n        assert_eq!(\n            base.partial_cmp(\u0026Decimal(Decimal::ONE)),\n            Some(Ordering::Equal)\n        );\n\n        assert_eq!(base.partial_cmp(\u0026Bool(true)), None);\n    }\n\n    #[test]\n    fn try_add() {\n        let base = 1.0_f32;\n\n        assert!(matches!(base.try_add(\u0026I8(1)), Ok(F32(x)) if (x - 2.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_add(\u0026I16(1)), Ok(F32(x)) if (x - 2.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_add(\u0026I32(1)), Ok(F32(x)) if (x - 2.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_add(\u0026I64(1)), Ok(F32(x)) if (x - 2.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_add(\u0026I128(1)), Ok(F32(x)) if (x - 2.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_add(\u0026U8(1)), Ok(F32(x)) if (x - 2.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_add(\u0026U16(1)), Ok(F32(x)) if (x - 2.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_add(\u0026U32(1)),Ok(F32(x)) if (x-2.0).abs() \u003c f32::EPSILON));\n        assert!(matches!(base.try_add(\u0026U64(1)),Ok(F32(x)) if (x-2.0).abs() \u003c f32::EPSILON));\n        assert!(matches!(base.try_add(\u0026U128(1)),Ok(F32(x)) if (x-2.0).abs()\u003cf32::EPSILON));\n        assert!(matches!(base.try_add(\u0026F64(1.0)), Ok(F32(x)) if (x - 2.0).abs() \u003c f32::EPSILON ));\n        assert!(\n            matches!(base.try_add(\u0026F32(1.0_f32)), Ok(F32(x)) if (x - 2.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_add(\u0026Decimal(Decimal::ONE)), Ok(Decimal(x)) if x == Decimal::TWO)\n        );\n        assert_eq!(\n            f32::MAX.try_add(\u0026Decimal(Decimal::ONE)),\n            Err(ValueError::FloatToDecimalConversionFailure(f32::MAX.into()).into())\n        );\n\n        assert_eq!(\n            base.try_add(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: F32(1.0_f32),\n                operator: NumericBinaryOperator::Add,\n                rhs: Bool(true)\n            }\n            .into())\n        );\n    }\n\n    #[test]\n    fn try_subtract() {\n        let base = 1.0_f32;\n\n        assert!(matches!(base.try_subtract(\u0026I8(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON ));\n        assert!(\n            matches!(base.try_subtract(\u0026I16(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026I32(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026I64(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026I128(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(matches!(base.try_subtract(\u0026U8(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON ));\n        assert!(\n            matches!(base.try_subtract(\u0026U16(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026U32(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON )\n        );\n\n        assert!(\n            matches!(base.try_subtract(\u0026U64(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026U128(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON )\n        );\n\n        assert!(\n            matches!(base.try_subtract(\u0026F64(1.0)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026F32(1.0_f32)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026Decimal(Decimal::ONE)), Ok(Decimal(x)) if x == Decimal::ZERO)\n        );\n        assert_eq!(\n            f32::MIN.try_subtract(\u0026Decimal(Decimal::ONE)),\n            Err(ValueError::FloatToDecimalConversionFailure(f32::MIN.into()).into())\n        );\n\n        assert_eq!(\n            base.try_subtract(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: F32(1.0_f32),\n                operator: NumericBinaryOperator::Subtract,\n                rhs: Bool(true)\n            }\n            .into())\n        );\n    }\n\n    #[test]\n    fn try_multiply() {\n        let base = 1.0_f32;\n\n        assert!(matches!(base.try_multiply(\u0026I8(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON ));\n        assert!(\n            matches!(base.try_multiply(\u0026I16(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026I32(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026I64(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026I128(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(matches!(base.try_multiply(\u0026U8(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON ));\n        assert!(\n            matches!(base.try_multiply(\u0026U16(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026U32(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026U64(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026U128(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026F64(1.0)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026F32(1.0_f32)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026Decimal(Decimal::ONE)), Ok(Decimal(x)) if x == Decimal::ONE)\n        );\n        assert_eq!(\n            f32::MAX.try_multiply(\u0026Decimal(Decimal::TWO)),\n            Err(ValueError::FloatToDecimalConversionFailure(f32::MAX.into()).into())\n        );\n\n        assert_eq!(\n            base.try_multiply(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: F32(1.0_f32),\n                operator: NumericBinaryOperator::Multiply,\n                rhs: Bool(true)\n            }\n            .into())\n        );\n    }\n\n    #[test]\n    fn try_divide() {\n        let base = 1.0_f32;\n\n        assert!(matches!(base.try_divide(\u0026I8(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026I16(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026I32(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026I64(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026I128(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026U8(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026U16(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026U32(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026U64(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026U128(1)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON ));\n\n        assert!(\n            matches!(base.try_divide(\u0026F64(1.0)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_divide(\u0026F32(1.0_f32)), Ok(F32(x)) if (x - 1.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_divide(\u0026Decimal(Decimal::ONE)), Ok(Decimal(x)) if x == Decimal::ONE)\n        );\n        assert_eq!(\n            f32::MIN.try_divide(\u0026Decimal(Decimal::TWO)),\n            Err(ValueError::FloatToDecimalConversionFailure(f32::MIN.into()).into())\n        );\n\n        assert_eq!(\n            base.try_divide(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: F32(1.0_f32),\n                operator: NumericBinaryOperator::Divide,\n                rhs: Bool(true)\n            }\n            .into())\n        );\n    }\n\n    #[test]\n    fn try_modulo() {\n        let base = 1.0_f32;\n\n        assert!(matches!(base.try_modulo(\u0026I8(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026I16(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026I32(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026I64(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026I128(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026U8(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026U16(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026U32(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026U64(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026U128(1)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON ));\n\n        assert!(\n            matches!(base.try_modulo(\u0026F64(1.0)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_modulo(\u0026F32(1.0_f32)), Ok(F32(x)) if (x - 0.0).abs() \u003c f32::EPSILON )\n        );\n        assert!(\n            matches!(base.try_modulo(\u0026Decimal(Decimal::ONE)), Ok(Decimal(x)) if x == Decimal::ZERO)\n        );\n        assert_eq!(\n            f32::MAX.try_modulo(\u0026Decimal(Decimal::TWO)),\n            Err(ValueError::FloatToDecimalConversionFailure(f32::MAX.into()).into())\n        );\n        assert_eq!(\n            base.try_modulo(\u0026Decimal(Decimal::ZERO)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: F32(base),\n                rhs: Decimal(Decimal::ZERO),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            base.try_modulo(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: F32(1.0_f32),\n                operator: NumericBinaryOperator::Modulo,\n                rhs: Bool(true)\n            }\n            .into())\n        );\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":169},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","f64.rs"],"content":"use {\n    super::TryBinaryOperator,\n    crate::{\n        data::{NumericBinaryOperator, ValueError},\n        prelude::Value,\n        result::Result,\n    },\n    Value::*,\n    rust_decimal::prelude::Decimal,\n    std::cmp::Ordering,\n};\n\nimpl PartialEq\u003cValue\u003e for f64 {\n    fn eq(\u0026self, other: \u0026Value) -\u003e bool {\n        let lhs = *self;\n\n        match *other {\n            I8(rhs) =\u003e (lhs - (rhs as f64)).abs() \u003c f64::EPSILON,\n            I16(rhs) =\u003e (lhs - (rhs as f64)).abs() \u003c f64::EPSILON,\n            I32(rhs) =\u003e (lhs - (rhs as f64)).abs() \u003c f64::EPSILON,\n            I64(rhs) =\u003e (lhs - (rhs as f64)).abs() \u003c f64::EPSILON,\n            I128(rhs) =\u003e (lhs - (rhs as f64)).abs() \u003c f64::EPSILON,\n            U8(rhs) =\u003e (lhs - (rhs as f64)).abs() \u003c f64::EPSILON,\n            U16(rhs) =\u003e (lhs - (rhs as f64)).abs() \u003c f64::EPSILON,\n            U32(rhs) =\u003e (lhs - (rhs as f64)).abs() \u003c f64::EPSILON,\n            U64(rhs) =\u003e (lhs - (rhs as f64)).abs() \u003c f64::EPSILON,\n            U128(rhs) =\u003e (lhs - (rhs as f64)).abs() \u003c f64::EPSILON,\n            F32(rhs) =\u003e (lhs - rhs as f64).abs() \u003c f64::EPSILON,\n            F64(rhs) =\u003e (lhs - rhs).abs() \u003c f64::EPSILON,\n            Decimal(rhs) =\u003e Decimal::from_f64_retain(lhs)\n                .map(|x| rhs == x)\n                .unwrap_or(false),\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl PartialOrd\u003cValue\u003e for f64 {\n    fn partial_cmp(\u0026self, other: \u0026Value) -\u003e Option\u003cOrdering\u003e {\n        match *other {\n            I8(rhs) =\u003e self.partial_cmp(\u0026(rhs as f64)),\n            I16(rhs) =\u003e self.partial_cmp(\u0026(rhs as f64)),\n            I32(rhs) =\u003e self.partial_cmp(\u0026(rhs as f64)),\n            I64(rhs) =\u003e self.partial_cmp(\u0026(rhs as f64)),\n            I128(rhs) =\u003e self.partial_cmp(\u0026(rhs as f64)),\n            U8(rhs) =\u003e self.partial_cmp(\u0026(rhs as f64)),\n            U16(rhs) =\u003e self.partial_cmp(\u0026(rhs as f64)),\n            U32(rhs) =\u003e self.partial_cmp(\u0026(rhs as f64)),\n            U64(rhs) =\u003e self.partial_cmp(\u0026(rhs as f64)),\n            U128(rhs) =\u003e self.partial_cmp(\u0026(rhs as f64)),\n            F32(rhs) =\u003e self.partial_cmp(\u0026(rhs as f64)),\n            F64(rhs) =\u003e self.partial_cmp(\u0026rhs),\n            Decimal(rhs) =\u003e Decimal::from_f64_retain(*self)\n                .map(|x| x.partial_cmp(\u0026rhs))\n                .unwrap_or(None),\n            _ =\u003e None,\n        }\n    }\n}\n\nimpl TryBinaryOperator for f64 {\n    type Rhs = Value;\n\n    fn try_add(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e Ok(F64(lhs + rhs as f64)),\n            I16(rhs) =\u003e Ok(F64(lhs + rhs as f64)),\n            I32(rhs) =\u003e Ok(F64(lhs + rhs as f64)),\n            I64(rhs) =\u003e Ok(F64(lhs + rhs as f64)),\n            I128(rhs) =\u003e Ok(F64(lhs + rhs as f64)),\n            U8(rhs) =\u003e Ok(F64(lhs + rhs as f64)),\n            U16(rhs) =\u003e Ok(F64(lhs + rhs as f64)),\n            U32(rhs) =\u003e Ok(F64(lhs + rhs as f64)),\n            U64(rhs) =\u003e Ok(F64(lhs + rhs as f64)),\n            U128(rhs) =\u003e Ok(F64(lhs + rhs as f64)),\n            F32(rhs) =\u003e Ok(F64(lhs + rhs as f64)),\n            F64(rhs) =\u003e Ok(F64(lhs + rhs)),\n            Decimal(rhs) =\u003e Decimal::from_f64_retain(lhs)\n                .map(|x| Ok(Decimal(x + rhs)))\n                .unwrap_or_else(|| Err(ValueError::FloatToDecimalConversionFailure(lhs).into())),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: F64(lhs),\n                operator: NumericBinaryOperator::Add,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n\n    fn try_subtract(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e Ok(F64(lhs - rhs as f64)),\n            I16(rhs) =\u003e Ok(F64(lhs - rhs as f64)),\n            I32(rhs) =\u003e Ok(F64(lhs - rhs as f64)),\n            I64(rhs) =\u003e Ok(F64(lhs - rhs as f64)),\n            I128(rhs) =\u003e Ok(F64(lhs - rhs as f64)),\n            U8(rhs) =\u003e Ok(F64(lhs - rhs as f64)),\n            U16(rhs) =\u003e Ok(F64(lhs - rhs as f64)),\n            U32(rhs) =\u003e Ok(F64(lhs - rhs as f64)),\n            U64(rhs) =\u003e Ok(F64(lhs - rhs as f64)),\n            U128(rhs) =\u003e Ok(F64(lhs - rhs as f64)),\n            F32(rhs) =\u003e Ok(F64(lhs - rhs as f64)),\n            F64(rhs) =\u003e Ok(F64(lhs - rhs)),\n            Decimal(rhs) =\u003e Decimal::from_f64_retain(lhs)\n                .map(|x| Ok(Decimal(x - rhs)))\n                .unwrap_or_else(|| Err(ValueError::FloatToDecimalConversionFailure(lhs).into())),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: F64(lhs),\n                operator: NumericBinaryOperator::Subtract,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n\n    fn try_multiply(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e Ok(F64(lhs * rhs as f64)),\n            I16(rhs) =\u003e Ok(F64(lhs * rhs as f64)),\n            I32(rhs) =\u003e Ok(F64(lhs * rhs as f64)),\n            I64(rhs) =\u003e Ok(F64(lhs * rhs as f64)),\n            I128(rhs) =\u003e Ok(F64(lhs * rhs as f64)),\n            U8(rhs) =\u003e Ok(F64(lhs * rhs as f64)),\n            U16(rhs) =\u003e Ok(F64(lhs * rhs as f64)),\n            U32(rhs) =\u003e Ok(F64(lhs * rhs as f64)),\n            U64(rhs) =\u003e Ok(F64(lhs * rhs as f64)),\n            U128(rhs) =\u003e Ok(F64(lhs * rhs as f64)),\n            F32(rhs) =\u003e Ok(F64(lhs * rhs as f64)),\n            F64(rhs) =\u003e Ok(F64(lhs * rhs)),\n            Interval(rhs) =\u003e Ok(Interval(lhs * rhs)),\n            Decimal(rhs) =\u003e Decimal::from_f64_retain(lhs)\n                .map(|x| Ok(Decimal(x * rhs)))\n                .unwrap_or_else(|| Err(ValueError::FloatToDecimalConversionFailure(lhs).into())),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: F64(lhs),\n                operator: NumericBinaryOperator::Multiply,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n\n    fn try_divide(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e Ok(F64(lhs / rhs as f64)),\n            I16(rhs) =\u003e Ok(F64(lhs / rhs as f64)),\n            I32(rhs) =\u003e Ok(F64(lhs / rhs as f64)),\n            I64(rhs) =\u003e Ok(F64(lhs / rhs as f64)),\n            I128(rhs) =\u003e Ok(F64(lhs / rhs as f64)),\n            U8(rhs) =\u003e Ok(F64(lhs / rhs as f64)),\n            U16(rhs) =\u003e Ok(F64(lhs / rhs as f64)),\n            U32(rhs) =\u003e Ok(F64(lhs / rhs as f64)),\n            U64(rhs) =\u003e Ok(F64(lhs / rhs as f64)),\n            U128(rhs) =\u003e Ok(F64(lhs / rhs as f64)),\n            F32(rhs) =\u003e Ok(F64(lhs / rhs as f64)),\n            F64(rhs) =\u003e Ok(F64(lhs / rhs)),\n            Decimal(rhs) =\u003e Decimal::from_f64_retain(lhs)\n                .map(|x| Ok(Decimal(x * rhs)))\n                .unwrap_or_else(|| Err(ValueError::FloatToDecimalConversionFailure(lhs).into())),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: F64(lhs),\n                operator: NumericBinaryOperator::Divide,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n\n    fn try_modulo(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n        let lhs = *self;\n\n        match *rhs {\n            I8(rhs) =\u003e Ok(F64(lhs % rhs as f64)),\n            I16(rhs) =\u003e Ok(F64(lhs % rhs as f64)),\n            I32(rhs) =\u003e Ok(F64(lhs % rhs as f64)),\n            I64(rhs) =\u003e Ok(F64(lhs % rhs as f64)),\n            I128(rhs) =\u003e Ok(F64(lhs % rhs as f64)),\n            U8(rhs) =\u003e Ok(F64(lhs % rhs as f64)),\n            U16(rhs) =\u003e Ok(F64(lhs % rhs as f64)),\n            U32(rhs) =\u003e Ok(F64(lhs % rhs as f64)),\n            U64(rhs) =\u003e Ok(F64(lhs % rhs as f64)),\n            U128(rhs) =\u003e Ok(F64(lhs % rhs as f64)),\n            F32(rhs) =\u003e Ok(F64(lhs % rhs as f64)),\n            F64(rhs) =\u003e Ok(F64(lhs % rhs)),\n            Decimal(rhs) =\u003e match Decimal::from_f64_retain(lhs) {\n                Some(x) =\u003e x\n                    .checked_rem(rhs)\n                    .map(|y| Ok(Decimal(y)))\n                    .unwrap_or_else(|| {\n                        Err(ValueError::BinaryOperationOverflow {\n                            lhs: F64(lhs),\n                            operator: NumericBinaryOperator::Modulo,\n                            rhs: Decimal(rhs),\n                        }\n                        .into())\n                    }),\n                _ =\u003e Err(ValueError::FloatToDecimalConversionFailure(lhs).into()),\n            },\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: F64(lhs),\n                operator: NumericBinaryOperator::Modulo,\n                rhs: rhs.clone(),\n            }\n            .into()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::{TryBinaryOperator, Value::*},\n        crate::data::{NumericBinaryOperator, ValueError},\n        rust_decimal::prelude::Decimal,\n        std::cmp::Ordering,\n    };\n\n    #[test]\n    fn eq() {\n        let base = 1.0_f64;\n\n        assert_eq!(base, I8(1));\n        assert_eq!(base, I16(1));\n        assert_eq!(base, I32(1));\n        assert_eq!(base, I64(1));\n        assert_eq!(base, I128(1));\n        assert_eq!(base, U8(1));\n        assert_eq!(base, U16(1));\n        assert_eq!(base, U32(1));\n        assert_eq!(base, U64(1));\n        assert_eq!(base, U128(1));\n        assert_eq!(base, F32(1.0_f32));\n        assert_eq!(base, F64(1.0));\n        assert_eq!(base, Decimal(Decimal::from(1)));\n\n        assert_ne!(base, Bool(true));\n    }\n\n    #[test]\n    fn partial_cmp() {\n        let base = 1.0_f64;\n\n        assert_eq!(base.partial_cmp(\u0026I8(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026I16(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026I32(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026I64(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026I128(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U8(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U16(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U32(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U64(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026U128(1)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026F32(1.0_f32)), Some(Ordering::Equal));\n        assert_eq!(base.partial_cmp(\u0026F64(1.0)), Some(Ordering::Equal));\n        assert_eq!(\n            base.partial_cmp(\u0026Decimal(Decimal::ONE)),\n            Some(Ordering::Equal)\n        );\n\n        assert_eq!(base.partial_cmp(\u0026Bool(true)), None);\n    }\n\n    #[test]\n    fn try_add() {\n        let base = 1.0_f64;\n\n        assert!(matches!(base.try_add(\u0026I8(1)), Ok(F64(x)) if (x - 2.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_add(\u0026I16(1)), Ok(F64(x)) if (x - 2.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_add(\u0026I32(1)), Ok(F64(x)) if (x - 2.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_add(\u0026I64(1)), Ok(F64(x)) if (x - 2.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_add(\u0026I128(1)), Ok(F64(x)) if (x - 2.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_add(\u0026U8(1)), Ok(F64(x)) if (x - 2.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_add(\u0026U16(1)), Ok(F64(x)) if (x - 2.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_add(\u0026U32(1)),Ok(F64(x)) if (x-2.0).abs() \u003c f64::EPSILON));\n        assert!(matches!(base.try_add(\u0026U64(1)),Ok(F64(x)) if (x-2.0).abs() \u003c f64::EPSILON));\n        assert!(matches!(base.try_add(\u0026U128(1)),Ok(F64(x)) if (x-2.0).abs()\u003cf64::EPSILON));\n        assert!(\n            matches!(base.try_add(\u0026F32(1.0_f32)), Ok(F64(x)) if (x - 2.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(matches!(base.try_add(\u0026F64(1.0)), Ok(F64(x)) if (x - 2.0).abs() \u003c f64::EPSILON ));\n        assert!(\n            matches!(base.try_add(\u0026Decimal(Decimal::ONE)), Ok(Decimal(x)) if x == Decimal::TWO)\n        );\n\n        assert_eq!(\n            base.try_add(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: F64(1.0),\n                operator: NumericBinaryOperator::Add,\n                rhs: Bool(true)\n            }\n            .into())\n        );\n    }\n\n    #[test]\n    fn try_subtract() {\n        let base = 1.0_f64;\n\n        assert!(matches!(base.try_subtract(\u0026I8(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON ));\n        assert!(\n            matches!(base.try_subtract(\u0026I16(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026I32(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026I64(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026I128(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(matches!(base.try_subtract(\u0026U8(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON ));\n        assert!(\n            matches!(base.try_subtract(\u0026U16(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026U32(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON )\n        );\n\n        assert!(\n            matches!(base.try_subtract(\u0026U64(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026U128(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON )\n        );\n\n        assert!(\n            matches!(base.try_subtract(\u0026F32(1.0_f32)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026F64(1.0)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_subtract(\u0026Decimal(Decimal::ONE)), Ok(Decimal(x)) if x == Decimal::ZERO)\n        );\n\n        assert_eq!(\n            base.try_subtract(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: F64(1.0),\n                operator: NumericBinaryOperator::Subtract,\n                rhs: Bool(true)\n            }\n            .into())\n        );\n    }\n\n    #[test]\n    fn try_multiply() {\n        let base = 1.0_f64;\n\n        assert!(matches!(base.try_multiply(\u0026I8(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON ));\n        assert!(\n            matches!(base.try_multiply(\u0026I16(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026I32(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026I64(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026I128(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(matches!(base.try_multiply(\u0026U8(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON ));\n        assert!(\n            matches!(base.try_multiply(\u0026U16(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026U32(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026U64(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026U128(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026F32(1.0_f32)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026F64(1.0)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_multiply(\u0026Decimal(Decimal::ONE)), Ok(Decimal(x)) if x == Decimal::ONE)\n        );\n\n        assert_eq!(\n            base.try_multiply(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: F64(1.0),\n                operator: NumericBinaryOperator::Multiply,\n                rhs: Bool(true)\n            }\n            .into())\n        );\n    }\n\n    #[test]\n    fn try_divide() {\n        let base = 1.0_f64;\n\n        assert!(matches!(base.try_divide(\u0026I8(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026I16(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026I32(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026I64(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026I128(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026U8(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026U16(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026U32(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026U64(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_divide(\u0026U128(1)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON ));\n\n        assert!(\n            matches!(base.try_divide(\u0026F32(1.0_f32)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_divide(\u0026F64(1.0)), Ok(F64(x)) if (x - 1.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_divide(\u0026Decimal(Decimal::ONE)), Ok(Decimal(x)) if x == Decimal::ONE)\n        );\n\n        assert_eq!(\n            base.try_divide(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: F64(1.0),\n                operator: NumericBinaryOperator::Divide,\n                rhs: Bool(true)\n            }\n            .into())\n        );\n    }\n\n    #[test]\n    fn try_modulo() {\n        let base = 1.0_f64;\n\n        assert!(matches!(base.try_modulo(\u0026I8(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026I16(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026I32(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026I64(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026I128(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026U8(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026U16(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026U32(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026U64(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON ));\n        assert!(matches!(base.try_modulo(\u0026U128(1)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON ));\n\n        assert!(\n            matches!(base.try_modulo(\u0026F32(1.0_f32)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_modulo(\u0026F64(1.0)), Ok(F64(x)) if (x - 0.0).abs() \u003c f64::EPSILON )\n        );\n        assert!(\n            matches!(base.try_modulo(\u0026Decimal(Decimal::ONE)), Ok(Decimal(x)) if x == Decimal::ZERO)\n        );\n        assert_eq!(\n            f64::MAX.try_modulo(\u0026Decimal(Decimal::TWO)),\n            Err(ValueError::FloatToDecimalConversionFailure(f64::MAX).into())\n        );\n        assert_eq!(\n            base.try_modulo(\u0026Decimal(Decimal::ZERO)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: F64(base),\n                rhs: Decimal(Decimal::ZERO),\n                operator: NumericBinaryOperator::Modulo,\n            }\n            .into())\n        );\n\n        assert_eq!(\n            base.try_modulo(\u0026Bool(true)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: F64(1.0),\n                operator: NumericBinaryOperator::Modulo,\n                rhs: Bool(true)\n            }\n            .into())\n        );\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":165},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","integer","i128.rs"],"content":"use {crate::prelude::Value, std::cmp::Ordering};\n\nsuper::macros::impl_try_binary_op!(I128, i128);\n#[cfg(test)]\nsuper::macros::generate_binary_op_tests!(I128, i128);\n\nsuper::macros::impl_partial_cmp_ord_method!(i128);\n#[cfg(test)]\nsuper::macros::generate_cmp_ord_tests!(i128);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","integer","i16.rs"],"content":"use {crate::prelude::Value, std::cmp::Ordering};\n\nsuper::macros::impl_try_binary_op!(I16, i16);\n#[cfg(test)]\nsuper::macros::generate_binary_op_tests!(I16, i16);\n\nsuper::macros::impl_partial_cmp_ord_method!(i16);\n#[cfg(test)]\nsuper::macros::generate_cmp_ord_tests!(i16);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","integer","i32.rs"],"content":"use {crate::prelude::Value, std::cmp::Ordering};\n\nsuper::macros::impl_try_binary_op!(I32, i32);\n#[cfg(test)]\nsuper::macros::generate_binary_op_tests!(I32, i32);\n\nsuper::macros::impl_partial_cmp_ord_method!(i32);\n#[cfg(test)]\nsuper::macros::generate_cmp_ord_tests!(i32);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","integer","i64.rs"],"content":"use {crate::prelude::Value, std::cmp::Ordering};\n\nsuper::macros::impl_try_binary_op!(I64, i64);\n#[cfg(test)]\nsuper::macros::generate_binary_op_tests!(I64, i64);\n\nsuper::macros::impl_partial_cmp_ord_method!(i64);\n#[cfg(test)]\nsuper::macros::generate_cmp_ord_tests!(i64);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","integer","i8.rs"],"content":"use {crate::prelude::Value, std::cmp::Ordering};\n\nsuper::macros::impl_try_binary_op!(I8, i8);\n#[cfg(test)]\nsuper::macros::generate_binary_op_tests!(I8, i8);\n\nsuper::macros::impl_partial_cmp_ord_method!(i8);\n#[cfg(test)]\nsuper::macros::generate_cmp_ord_tests!(i8);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","integer","macros.rs"],"content":"macro_rules! impl_interval_method {\n    (checked_mul, $lhs_variant: ident, $op: ident, $lhs: ident, $rhs: ident) =\u003e {\n        return Ok(Value::Interval($lhs * $rhs))\n    };\n    ($other: ident, $lhs_variant: ident, $op: ident, $lhs: ident, $rhs: ident) =\u003e {\n        return Err(ValueError::NonNumericMathOperation {\n            lhs: $lhs_variant($lhs),\n            operator: $op,\n            rhs: Value::Interval($rhs),\n        }\n        .into())\n    };\n}\n\nmacro_rules! impl_method {\n    ($lhs_variant: ident, $lhs_primitive: ident, $lhs: ident, $method: ident, $op: ident, $rhs: ident) =\u003e {{\n        match *$rhs {\n            I8(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: I8(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            I16(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: I16(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            I32(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: I32(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            I64(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: I64(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            I128(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: I128(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            U8(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: U8(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            U16(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: U16(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            U32(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: U32(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            U64(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: U64(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            U128(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: U128(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            F32(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: F32(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            F64(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: F64(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            Decimal(rhs) =\u003e $lhs\n                .$method($lhs_primitive::try_from($rhs)?)\n                .ok_or_else(|| {\n                    ValueError::BinaryOperationOverflow {\n                        lhs: $lhs_variant($lhs),\n                        rhs: Decimal(rhs),\n                        operator: $op,\n                    }\n                    .into()\n                }),\n            Null =\u003e return Ok(Null),\n            Interval(rhs) =\u003e {\n                super::macros::impl_interval_method!($method, $lhs_variant, $op, $lhs, rhs);\n            }\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: $lhs_variant($lhs),\n                operator: $op,\n                rhs: $rhs.clone(),\n            }\n            .into()),\n        }\n        .map($lhs_variant)\n    }};\n}\n\nmacro_rules! impl_try_binary_op {\n    ($variant: ident, $primitive: ident) =\u003e {\n        use $crate::{\n            data::value::{\n                TryBinaryOperator,\n                Value::*,\n                error::{NumericBinaryOperator::*, ValueError},\n            },\n            result::Result,\n        };\n\n        impl TryBinaryOperator for $primitive {\n            type Rhs = Value;\n\n            fn try_add(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n                let lhs = *self;\n                super::macros::impl_method!($variant, $primitive, lhs, checked_add, Add, rhs)\n            }\n\n            fn try_subtract(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n                let lhs = *self;\n                super::macros::impl_method!($variant, $primitive, lhs, checked_sub, Subtract, rhs)\n            }\n\n            fn try_multiply(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n                let lhs = *self;\n                super::macros::impl_method!($variant, $primitive, lhs, checked_mul, Multiply, rhs)\n            }\n\n            fn try_divide(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n                let lhs = *self;\n                super::macros::impl_method!($variant, $primitive, lhs, checked_div, Divide, rhs)\n            }\n\n            fn try_modulo(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e {\n                let lhs = *self;\n                super::macros::impl_method!($variant, $primitive, lhs, checked_rem, Modulo, rhs)\n            }\n        }\n    };\n}\n\n#[cfg(test)]\nmacro_rules! generate_binary_op_tests {\n    ($variant: ident, $primitive: ident) =\u003e {\n        mod try_binary_op_tests {\n            use {\n                rust_decimal::prelude::Decimal,\n                $crate::data::{\n                    NumericBinaryOperator::{self, *},\n                    ValueError,\n                    value::{\n                        TryBinaryOperator,\n                        Value::{self, *},\n                    },\n                },\n            };\n\n            fn overflow_err(\n                lhs: Value,\n                rhs: Value,\n                op: NumericBinaryOperator,\n            ) -\u003e Result\u003cValue, $crate::result::Error\u003e {\n                Err(ValueError::BinaryOperationOverflow {\n                    lhs,\n                    rhs,\n                    operator: op,\n                }\n                .into())\n            }\n\n            #[test]\n            fn add_overflow() {\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026Decimal(Decimal::from(1))),\n                    overflow_err($variant($primitive::MAX), Decimal(Decimal::from(1)), Add)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026F32(1.0_f32)),\n                    overflow_err($variant($primitive::MAX), F32(1.0_f32), Add)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026F64(1.0)),\n                    overflow_err($variant($primitive::MAX), F64(1.0), Add)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026I8(1)),\n                    overflow_err($variant($primitive::MAX), I8(1), Add)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026I16(1)),\n                    overflow_err($variant($primitive::MAX), I16(1), Add)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026I32(1)),\n                    overflow_err($variant($primitive::MAX), I32(1), Add)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026I64(1)),\n                    overflow_err($variant($primitive::MAX), I64(1), Add)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026I128(1)),\n                    overflow_err($variant($primitive::MAX), I128(1), Add)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026U8(1)),\n                    overflow_err($variant($primitive::MAX), U8(1), Add)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026U16(1)),\n                    overflow_err($variant($primitive::MAX), U16(1), Add)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026U32(1)),\n                    overflow_err($variant($primitive::MAX), U32(1), Add)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026U64(1)),\n                    overflow_err($variant($primitive::MAX), U64(1), Add)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_add(\u0026U128(1)),\n                    overflow_err($variant($primitive::MAX), U128(1), Add)\n                );\n            }\n\n            #[test]\n            fn sub_overflow() {\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026Decimal(Decimal::from(1))),\n                    overflow_err(\n                        $variant($primitive::MIN),\n                        Decimal(Decimal::from(1)),\n                        Subtract\n                    )\n                );\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026F32(1.0_f32)),\n                    overflow_err($variant($primitive::MIN), F32(1.0_f32), Subtract)\n                );\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026F64(1.0)),\n                    overflow_err($variant($primitive::MIN), F64(1.0), Subtract)\n                );\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026I8(1)),\n                    overflow_err($variant($primitive::MIN), I8(1), Subtract)\n                );\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026I16(1)),\n                    overflow_err($variant($primitive::MIN), I16(1), Subtract)\n                );\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026I32(1)),\n                    overflow_err($variant($primitive::MIN), I32(1), Subtract)\n                );\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026I64(1)),\n                    overflow_err($variant($primitive::MIN), I64(1), Subtract)\n                );\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026I128(1)),\n                    overflow_err($variant($primitive::MIN), I128(1), Subtract)\n                );\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026U8(1)),\n                    overflow_err($variant($primitive::MIN), U8(1), Subtract)\n                );\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026U16(1)),\n                    overflow_err($variant($primitive::MIN), U16(1), Subtract)\n                );\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026U32(1)),\n                    overflow_err($variant($primitive::MIN), U32(1), Subtract)\n                );\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026U64(1)),\n                    overflow_err($variant($primitive::MIN), U64(1), Subtract)\n                );\n                assert_eq!(\n                    $primitive::MIN.try_subtract(\u0026U128(1)),\n                    overflow_err($variant($primitive::MIN), U128(1), Subtract)\n                );\n            }\n\n            #[test]\n            fn mul_overflow() {\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026Decimal(Decimal::from(2))),\n                    overflow_err(\n                        $variant($primitive::MAX),\n                        Decimal(Decimal::from(2)),\n                        Multiply\n                    )\n                );\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026F32(2.0_f32)),\n                    overflow_err($variant($primitive::MAX), F32(2.0_f32), Multiply)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026F64(2.0)),\n                    overflow_err($variant($primitive::MAX), F64(2.0), Multiply)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026I8(2)),\n                    overflow_err($variant($primitive::MAX), I8(2), Multiply)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026I16(2)),\n                    overflow_err($variant($primitive::MAX), I16(2), Multiply)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026I32(2)),\n                    overflow_err($variant($primitive::MAX), I32(2), Multiply)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026I64(2)),\n                    overflow_err($variant($primitive::MAX), I64(2), Multiply)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026I128(2)),\n                    overflow_err($variant($primitive::MAX), I128(2), Multiply)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026U8(2)),\n                    overflow_err($variant($primitive::MAX), U8(2), Multiply)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026U16(2)),\n                    overflow_err($variant($primitive::MAX), U16(2), Multiply)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026U32(2)),\n                    overflow_err($variant($primitive::MAX), U32(2), Multiply)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026U64(2)),\n                    overflow_err($variant($primitive::MAX), U64(2), Multiply)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_multiply(\u0026U128(2)),\n                    overflow_err($variant($primitive::MAX), U128(2), Multiply)\n                );\n            }\n\n            #[test]\n            fn div_overflow() {\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026Decimal(Decimal::from(0))),\n                    overflow_err($variant($primitive::MAX), Decimal(Decimal::from(0)), Divide)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026F32(0.0_f32)),\n                    overflow_err($variant($primitive::MAX), F32(0.0_f32), Divide)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026F64(0.0)),\n                    overflow_err($variant($primitive::MAX), F64(0.0), Divide)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026I8(0)),\n                    overflow_err($variant($primitive::MAX), I8(0), Divide)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026I16(0)),\n                    overflow_err($variant($primitive::MAX), I16(0), Divide)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026I32(0)),\n                    overflow_err($variant($primitive::MAX), I32(0), Divide)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026I64(0)),\n                    overflow_err($variant($primitive::MAX), I64(0), Divide)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026I128(0)),\n                    overflow_err($variant($primitive::MAX), I128(0), Divide)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026U8(0)),\n                    overflow_err($variant($primitive::MAX), U8(0), Divide)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026U16(0)),\n                    overflow_err($variant($primitive::MAX), U16(0), Divide)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026U32(0)),\n                    overflow_err($variant($primitive::MAX), U32(0), Divide)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026U64(0)),\n                    overflow_err($variant($primitive::MAX), U64(0), Divide)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_divide(\u0026U128(0)),\n                    overflow_err($variant($primitive::MAX), U128(0), Divide)\n                );\n            }\n\n            #[test]\n            fn mod_overflow() {\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026Decimal(Decimal::from(0))),\n                    overflow_err($variant($primitive::MAX), Decimal(Decimal::from(0)), Modulo)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026F32(0.0_f32)),\n                    overflow_err($variant($primitive::MAX), F32(0.0_f32), Modulo)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026F64(0.0)),\n                    overflow_err($variant($primitive::MAX), F64(0.0), Modulo)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026I8(0)),\n                    overflow_err($variant($primitive::MAX), I8(0), Modulo)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026I16(0)),\n                    overflow_err($variant($primitive::MAX), I16(0), Modulo)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026I32(0)),\n                    overflow_err($variant($primitive::MAX), I32(0), Modulo)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026I64(0)),\n                    overflow_err($variant($primitive::MAX), I64(0), Modulo)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026I128(0)),\n                    overflow_err($variant($primitive::MAX), I128(0), Modulo)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026U8(0)),\n                    overflow_err($variant($primitive::MAX), U8(0), Modulo)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026U16(0)),\n                    overflow_err($variant($primitive::MAX), U16(0), Modulo)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026U32(0)),\n                    overflow_err($variant($primitive::MAX), U32(0), Modulo)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026U64(0)),\n                    overflow_err($variant($primitive::MAX), U64(0), Modulo)\n                );\n                assert_eq!(\n                    $primitive::MAX.try_modulo(\u0026U128(0)),\n                    overflow_err($variant($primitive::MAX), U128(0), Modulo)\n                );\n            }\n\n            #[test]\n            fn try_add() {\n                let base: $primitive = 1;\n\n                assert_eq!(base.try_add(\u0026Decimal(Decimal::ONE)), Ok($variant(2)));\n                assert_eq!(base.try_add(\u0026F32(1.0_f32)), Ok($variant(2)));\n                assert_eq!(base.try_add(\u0026F64(1.0)), Ok($variant(2)));\n                assert_eq!(base.try_add(\u0026I8(1)), Ok($variant(2)));\n                assert_eq!(base.try_add(\u0026I16(1)), Ok($variant(2)));\n                assert_eq!(base.try_add(\u0026I32(1)), Ok($variant(2)));\n                assert_eq!(base.try_add(\u0026I64(1)), Ok($variant(2)));\n                assert_eq!(base.try_add(\u0026I128(1)), Ok($variant(2)));\n                assert_eq!(base.try_add(\u0026U8(1)), Ok($variant(2)));\n                assert_eq!(base.try_add(\u0026U16(1)), Ok($variant(2)));\n                assert_eq!(base.try_add(\u0026U32(1)), Ok($variant(2)));\n                assert_eq!(base.try_add(\u0026U64(1)), Ok($variant(2)));\n                assert_eq!(base.try_add(\u0026U128(1)), Ok($variant(2)));\n\n                assert_eq!(\n                    base.try_add(\u0026Bool(true)),\n                    Err(ValueError::NonNumericMathOperation {\n                        lhs: $variant(base),\n                        operator: NumericBinaryOperator::Add,\n                        rhs: Bool(true)\n                    }\n                    .into())\n                );\n            }\n\n            #[test]\n            fn try_subtract() {\n                let base: $primitive = 1;\n\n                assert_eq!(base.try_subtract(\u0026Decimal(Decimal::ONE)), Ok($variant(0)));\n                assert_eq!(base.try_subtract(\u0026F32(1.0_f32)), Ok($variant(0)));\n                assert_eq!(base.try_subtract(\u0026F64(1.0)), Ok($variant(0)));\n                assert_eq!(base.try_subtract(\u0026I8(1)), Ok($variant(0)));\n                assert_eq!(base.try_subtract(\u0026I16(1)), Ok($variant(0)));\n                assert_eq!(base.try_subtract(\u0026I32(1)), Ok($variant(0)));\n                assert_eq!(base.try_subtract(\u0026I64(1)), Ok($variant(0)));\n                assert_eq!(base.try_subtract(\u0026I128(1)), Ok($variant(0)));\n                assert_eq!(base.try_subtract(\u0026U8(1)), Ok($variant(0)));\n                assert_eq!(base.try_subtract(\u0026U16(1)), Ok($variant(0)));\n                assert_eq!(base.try_subtract(\u0026U32(1)), Ok($variant(0)));\n                assert_eq!(base.try_subtract(\u0026U64(1)), Ok($variant(0)));\n                assert_eq!(base.try_subtract(\u0026U128(1)), Ok($variant(0)));\n\n                assert_eq!(\n                    base.try_subtract(\u0026Bool(true)),\n                    Err(ValueError::NonNumericMathOperation {\n                        lhs: $variant(base),\n                        operator: NumericBinaryOperator::Subtract,\n                        rhs: Bool(true)\n                    }\n                    .into())\n                );\n            }\n\n            #[test]\n            fn try_multiply() {\n                let base: $primitive = 3;\n\n                assert_eq!(base.try_multiply(\u0026Decimal(Decimal::TWO)), Ok($variant(6)));\n                assert_eq!(base.try_multiply(\u0026F32(2.0_f32)), Ok($variant(6)));\n                assert_eq!(base.try_multiply(\u0026F64(2.0)), Ok($variant(6)));\n                assert_eq!(base.try_multiply(\u0026I8(2)), Ok($variant(6)));\n                assert_eq!(base.try_multiply(\u0026I16(2)), Ok($variant(6)));\n                assert_eq!(base.try_multiply(\u0026I32(2)), Ok($variant(6)));\n                assert_eq!(base.try_multiply(\u0026I64(2)), Ok($variant(6)));\n                assert_eq!(base.try_multiply(\u0026I128(2)), Ok($variant(6)));\n                assert_eq!(base.try_multiply(\u0026U8(2)), Ok($variant(6)));\n                assert_eq!(base.try_multiply(\u0026U16(2)), Ok($variant(6)));\n                assert_eq!(base.try_multiply(\u0026U32(2)), Ok($variant(6)));\n                assert_eq!(base.try_multiply(\u0026U64(2)), Ok($variant(6)));\n                assert_eq!(base.try_multiply(\u0026U128(2)), Ok($variant(6)));\n\n                assert_eq!(\n                    base.try_multiply(\u0026Bool(true)),\n                    Err(ValueError::NonNumericMathOperation {\n                        lhs: $variant(base),\n                        operator: NumericBinaryOperator::Multiply,\n                        rhs: Bool(true)\n                    }\n                    .into())\n                );\n            }\n\n            #[test]\n            fn try_divide() {\n                let base: $primitive = 6;\n\n                assert_eq!(base.try_divide(\u0026Decimal(Decimal::TWO)), Ok($variant(3)));\n                assert_eq!(base.try_divide(\u0026F32(2.0_f32)), Ok($variant(3)));\n                assert_eq!(base.try_divide(\u0026F64(2.0)), Ok($variant(3)));\n                assert_eq!(base.try_divide(\u0026I8(2)), Ok($variant(3)));\n                assert_eq!(base.try_divide(\u0026I16(2)), Ok($variant(3)));\n                assert_eq!(base.try_divide(\u0026I32(2)), Ok($variant(3)));\n                assert_eq!(base.try_divide(\u0026I64(2)), Ok($variant(3)));\n                assert_eq!(base.try_divide(\u0026I128(2)), Ok($variant(3)));\n                assert_eq!(base.try_divide(\u0026U8(2)), Ok($variant(3)));\n                assert_eq!(base.try_divide(\u0026U16(2)), Ok($variant(3)));\n                assert_eq!(base.try_divide(\u0026U32(2)), Ok($variant(3)));\n                assert_eq!(base.try_divide(\u0026U64(2)), Ok($variant(3)));\n                assert_eq!(base.try_divide(\u0026U128(2)), Ok($variant(3)));\n\n                assert_eq!(\n                    base.try_divide(\u0026Bool(true)),\n                    Err(ValueError::NonNumericMathOperation {\n                        lhs: $variant(base),\n                        operator: NumericBinaryOperator::Divide,\n                        rhs: Bool(true)\n                    }\n                    .into())\n                );\n            }\n\n            #[test]\n            fn try_modulo() {\n                let base: $primitive = 9;\n\n                assert_eq!(base.try_modulo(\u0026Decimal(Decimal::ONE)), Ok($variant(0)));\n                assert_eq!(base.try_modulo(\u0026F32(1.0_f32)), Ok($variant(0)));\n                assert_eq!(base.try_modulo(\u0026F64(1.0)), Ok($variant(0)));\n                assert_eq!(base.try_modulo(\u0026I8(1)), Ok($variant(0)));\n                assert_eq!(base.try_modulo(\u0026I16(1)), Ok($variant(0)));\n                assert_eq!(base.try_modulo(\u0026I32(1)), Ok($variant(0)));\n                assert_eq!(base.try_modulo(\u0026I64(1)), Ok($variant(0)));\n                assert_eq!(base.try_modulo(\u0026I128(1)), Ok($variant(0)));\n                assert_eq!(base.try_modulo(\u0026U8(1)), Ok($variant(0)));\n                assert_eq!(base.try_modulo(\u0026U16(1)), Ok($variant(0)));\n                assert_eq!(base.try_modulo(\u0026U32(1)), Ok($variant(0)));\n                assert_eq!(base.try_modulo(\u0026U64(1)), Ok($variant(0)));\n                assert_eq!(base.try_modulo(\u0026U128(1)), Ok($variant(0)));\n\n                assert_eq!(\n                    base.try_modulo(\u0026Bool(true)),\n                    Err(ValueError::NonNumericMathOperation {\n                        lhs: $variant(base),\n                        operator: NumericBinaryOperator::Modulo,\n                        rhs: Bool(true)\n                    }\n                    .into())\n                );\n            }\n        }\n    };\n}\n\nmacro_rules! impl_partial_cmp_ord_method {\n    ($primitive: ident) =\u003e {\n        impl PartialEq\u003cValue\u003e for $primitive {\n            fn eq(\u0026self, other: \u0026Value) -\u003e bool {\n                if matches!(other, Value::Bool(_)) {\n                    return false;\n                }\n\n                let lhs = *self;\n                let rhs = match $primitive::try_from(other) {\n                    Ok(rhs) =\u003e rhs,\n                    Err(_) =\u003e return false,\n                };\n\n                lhs == rhs\n            }\n        }\n\n        impl PartialOrd\u003cValue\u003e for $primitive {\n            fn partial_cmp(\u0026self, other: \u0026Value) -\u003e Option\u003cOrdering\u003e {\n                if matches!(other, Value::Bool(_)) {\n                    return None;\n                }\n\n                let lhs = self;\n                let rhs = match $primitive::try_from(other) {\n                    Ok(rhs) =\u003e rhs,\n                    Err(_) =\u003e return None,\n                };\n\n                lhs.partial_cmp(\u0026rhs)\n            }\n        }\n    };\n}\n\n#[cfg(test)]\nmacro_rules! generate_cmp_ord_tests {\n    ($primitive: ident) =\u003e {\n        mod cmp_ord_tests {\n            use {\n                rust_decimal::prelude::Decimal, std::cmp::Ordering, $crate::data::value::Value::*,\n            };\n\n            #[test]\n            fn eq() {\n                let base: $primitive = 1;\n\n                assert_eq!(base, Decimal(Decimal::ONE));\n                assert_eq!(base, F32(1.0_f32));\n                assert_eq!(base, F64(1.0));\n                assert_eq!(base, I8(1));\n                assert_eq!(base, I16(1));\n                assert_eq!(base, I32(1));\n                assert_eq!(base, I64(1));\n                assert_eq!(base, I128(1));\n                assert_eq!(base, U8(1));\n                assert_eq!(base, U16(1));\n                assert_eq!(base, U32(1));\n                assert_eq!(base, U64(1));\n                assert_eq!(base, U128(1));\n\n                assert_ne!(base, Bool(true));\n            }\n\n            #[test]\n            fn partial_cmp() {\n                let base: $primitive = 1;\n\n                assert_eq!(\n                    base.partial_cmp(\u0026Decimal(Decimal::ZERO)),\n                    Some(Ordering::Greater)\n                );\n                assert_eq!(base.partial_cmp(\u0026F32(0.0_f32)), Some(Ordering::Greater));\n                assert_eq!(base.partial_cmp(\u0026F64(0.0)), Some(Ordering::Greater));\n                assert_eq!(base.partial_cmp(\u0026I8(0)), Some(Ordering::Greater));\n                assert_eq!(base.partial_cmp(\u0026I16(0)), Some(Ordering::Greater));\n                assert_eq!(base.partial_cmp(\u0026I32(0)), Some(Ordering::Greater));\n                assert_eq!(base.partial_cmp(\u0026I64(0)), Some(Ordering::Greater));\n                assert_eq!(base.partial_cmp(\u0026I128(0)), Some(Ordering::Greater));\n                assert_eq!(base.partial_cmp(\u0026U8(0)), Some(Ordering::Greater));\n                assert_eq!(base.partial_cmp(\u0026U16(0)), Some(Ordering::Greater));\n                assert_eq!(base.partial_cmp(\u0026U32(0)), Some(Ordering::Greater));\n                assert_eq!(base.partial_cmp(\u0026U64(0)), Some(Ordering::Greater));\n                assert_eq!(base.partial_cmp(\u0026U128(0)), Some(Ordering::Greater));\n\n                assert_eq!(\n                    base.partial_cmp(\u0026Decimal(Decimal::ONE)),\n                    Some(Ordering::Equal)\n                );\n                assert_eq!(base.partial_cmp(\u0026F32(1.0_f32)), Some(Ordering::Equal));\n                assert_eq!(base.partial_cmp(\u0026F64(1.0)), Some(Ordering::Equal));\n                assert_eq!(base.partial_cmp(\u0026I8(1)), Some(Ordering::Equal));\n                assert_eq!(base.partial_cmp(\u0026I16(1)), Some(Ordering::Equal));\n                assert_eq!(base.partial_cmp(\u0026I32(1)), Some(Ordering::Equal));\n                assert_eq!(base.partial_cmp(\u0026I64(1)), Some(Ordering::Equal));\n                assert_eq!(base.partial_cmp(\u0026I128(1)), Some(Ordering::Equal));\n                assert_eq!(base.partial_cmp(\u0026U8(1)), Some(Ordering::Equal));\n                assert_eq!(base.partial_cmp(\u0026U16(1)), Some(Ordering::Equal));\n                assert_eq!(base.partial_cmp(\u0026U32(1)), Some(Ordering::Equal));\n                assert_eq!(base.partial_cmp(\u0026U64(1)), Some(Ordering::Equal));\n                assert_eq!(base.partial_cmp(\u0026U128(1)), Some(Ordering::Equal));\n\n                assert_eq!(\n                    base.partial_cmp(\u0026Decimal(Decimal::TWO)),\n                    Some(Ordering::Less)\n                );\n                assert_eq!(base.partial_cmp(\u0026F32(2.0_f32)), Some(Ordering::Less));\n                assert_eq!(base.partial_cmp(\u0026F64(2.0)), Some(Ordering::Less));\n                assert_eq!(base.partial_cmp(\u0026I8(2)), Some(Ordering::Less));\n                assert_eq!(base.partial_cmp(\u0026I16(2)), Some(Ordering::Less));\n                assert_eq!(base.partial_cmp(\u0026I32(2)), Some(Ordering::Less));\n                assert_eq!(base.partial_cmp(\u0026I64(2)), Some(Ordering::Less));\n                assert_eq!(base.partial_cmp(\u0026I128(2)), Some(Ordering::Less));\n                assert_eq!(base.partial_cmp(\u0026U8(2)), Some(Ordering::Less));\n                assert_eq!(base.partial_cmp(\u0026U16(2)), Some(Ordering::Less));\n                assert_eq!(base.partial_cmp(\u0026U32(2)), Some(Ordering::Less));\n                assert_eq!(base.partial_cmp(\u0026U64(2)), Some(Ordering::Less));\n                assert_eq!(base.partial_cmp(\u0026U128(2)), Some(Ordering::Less));\n\n                assert_eq!(base.partial_cmp(\u0026Bool(true)), None);\n            }\n        }\n    };\n}\n\n#[cfg(test)]\npub(crate) use {generate_binary_op_tests, generate_cmp_ord_tests};\npub(crate) use {\n    impl_interval_method, impl_method, impl_partial_cmp_ord_method, impl_try_binary_op,\n};\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":495},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","integer","u128.rs"],"content":"use {crate::prelude::Value, std::cmp::Ordering};\n\nsuper::macros::impl_try_binary_op!(U128, u128);\n#[cfg(test)]\nsuper::macros::generate_binary_op_tests!(U128, u128);\n\nsuper::macros::impl_partial_cmp_ord_method!(u128);\n#[cfg(test)]\nsuper::macros::generate_cmp_ord_tests!(u128);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","integer","u16.rs"],"content":"use {crate::prelude::Value, std::cmp::Ordering};\n\nsuper::macros::impl_try_binary_op!(U16, u16);\n#[cfg(test)]\nsuper::macros::generate_binary_op_tests!(U16, u16);\n\nsuper::macros::impl_partial_cmp_ord_method!(u16);\n#[cfg(test)]\nsuper::macros::generate_cmp_ord_tests!(u16);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","integer","u32.rs"],"content":"use {crate::prelude::Value, std::cmp::Ordering};\n\nsuper::macros::impl_try_binary_op!(U32, u32);\n#[cfg(test)]\nsuper::macros::generate_binary_op_tests!(U32, u32);\n\nsuper::macros::impl_partial_cmp_ord_method!(u32);\n#[cfg(test)]\nsuper::macros::generate_cmp_ord_tests!(u32);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","integer","u64.rs"],"content":"use {crate::prelude::Value, std::cmp::Ordering};\n\nsuper::macros::impl_try_binary_op!(U64, u64);\n#[cfg(test)]\nsuper::macros::generate_binary_op_tests!(U64, u64);\n\nsuper::macros::impl_partial_cmp_ord_method!(u64);\n#[cfg(test)]\nsuper::macros::generate_cmp_ord_tests!(u64);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","integer","u8.rs"],"content":"use {crate::prelude::Value, std::cmp::Ordering};\n\nsuper::macros::impl_try_binary_op!(U8, u8);\n#[cfg(test)]\nsuper::macros::generate_binary_op_tests!(U8, u8);\n\nsuper::macros::impl_partial_cmp_ord_method!(u8);\n#[cfg(test)]\nsuper::macros::generate_cmp_ord_tests!(u8);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op","integer.rs"],"content":"mod i128;\nmod i16;\nmod i32;\nmod i64;\nmod i8;\nmod u128;\nmod u16;\nmod u32;\nmod u64;\nmod u8;\n\nmod macros;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","binary_op.rs"],"content":"use crate::{prelude::Value, result::Result};\n\nmod decimal;\nmod f32;\nmod f64;\n\nmod integer;\n\npub trait TryBinaryOperator {\n    type Rhs;\n\n    fn try_add(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e;\n    fn try_subtract(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e;\n    fn try_multiply(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e;\n    fn try_divide(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e;\n    fn try_modulo(\u0026self, rhs: \u0026Self::Rhs) -\u003e Result\u003cValue\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","convert.rs"],"content":"use {\n    super::{\n        Value,\n        date::{parse_date, parse_time, parse_timestamp},\n    },\n    crate::{ast::DataType, data::Point},\n    chrono::{NaiveDate, NaiveDateTime, NaiveTime},\n    rust_decimal::prelude::{Decimal, FromPrimitive, FromStr, ToPrimitive},\n    serde::Serialize,\n    std::net::IpAddr,\n    uuid::Uuid,\n};\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, ConvertError\u003e;\n\n#[derive(Debug, Serialize, thiserror::Error, PartialEq)]\n#[error(\"failed to convert value({value:?}) to data type({data_type})\")]\npub struct ConvertError {\n    pub value: Value,\n    pub data_type: DataType,\n}\n\n// implies `TryFrom\u003cValue\u003e for T` from `TryFrom\u003c\u0026Value\u003e for T`\nmacro_rules! try_from_owned_value {\n    ($($target:ty), *) =\u003e {$(\n        impl TryFrom\u003cValue\u003e for $target {\n            type Error = ConvertError;\n\n            fn try_from(v: Value) -\u003e Result\u003cSelf\u003e {\n                Self::try_from(\u0026v)\n            }\n        }\n    )*}\n}\n\ntry_from_owned_value!(\n    bool, i8, i16, i32, i64, i128, f32, f64, u8, u16, u32, u64, u128, usize, Decimal\n);\n\nimpl From\u003c\u0026Value\u003e for String {\n    fn from(v: \u0026Value) -\u003e Self {\n        match v {\n            Value::Str(value) =\u003e value.to_owned(),\n            Value::Bytea(value) =\u003e hex::encode(value),\n            Value::Inet(value) =\u003e value.to_string(),\n            Value::Bool(value) =\u003e (if *value { \"TRUE\" } else { \"FALSE\" }).to_owned(),\n            Value::I8(value) =\u003e value.to_string(),\n            Value::I16(value) =\u003e value.to_string(),\n            Value::I32(value) =\u003e value.to_string(),\n            Value::I64(value) =\u003e value.to_string(),\n            Value::I128(value) =\u003e value.to_string(),\n            Value::U8(value) =\u003e value.to_string(),\n            Value::U16(value) =\u003e value.to_string(),\n            Value::U32(value) =\u003e value.to_string(),\n            Value::U64(value) =\u003e value.to_string(),\n            Value::U128(value) =\u003e value.to_string(),\n            Value::F32(value) =\u003e value.to_string(),\n            Value::F64(value) =\u003e value.to_string(),\n            Value::Date(value) =\u003e value.to_string(),\n            Value::Timestamp(value) =\u003e value.to_string(),\n            Value::Time(value) =\u003e value.to_string(),\n            Value::Interval(value) =\u003e value.to_sql_str(),\n            Value::Uuid(value) =\u003e Uuid::from_u128(*value).to_string(),\n            Value::Map(_) =\u003e TryInto::\u003cserde_json::Value\u003e::try_into(v.clone())\n                .unwrap_or_default()\n                .to_string(),\n            Value::List(_) =\u003e TryInto::\u003cserde_json::Value\u003e::try_into(v.clone())\n                .unwrap_or_default()\n                .to_string(),\n            Value::Decimal(value) =\u003e value.to_string(),\n            Value::Point(value) =\u003e value.to_string(),\n            Value::Null =\u003e \"NULL\".to_owned(),\n        }\n    }\n}\n\nimpl From\u003cValue\u003e for String {\n    fn from(v: Value) -\u003e String {\n        match v {\n            Value::Str(value) =\u003e value,\n            _ =\u003e String::from(\u0026v),\n        }\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for bool {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cSelf\u003e {\n        macro_rules! int_to_bool {\n            ($num: ident) =\u003e {\n                match $num {\n                    1 =\u003e true,\n                    0 =\u003e false,\n                    _ =\u003e {\n                        return Err(ConvertError {\n                            value: v.clone(),\n                            data_type: DataType::Boolean,\n                        })\n                    }\n                }\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e *value,\n            Value::I8(value) =\u003e int_to_bool!(value),\n            Value::I16(value) =\u003e int_to_bool!(value),\n            Value::I32(value) =\u003e int_to_bool!(value),\n            Value::I64(value) =\u003e int_to_bool!(value),\n            Value::I128(value) =\u003e int_to_bool!(value),\n            Value::U8(value) =\u003e int_to_bool!(value),\n            Value::U16(value) =\u003e int_to_bool!(value),\n            Value::U32(value) =\u003e int_to_bool!(value),\n            Value::U64(value) =\u003e int_to_bool!(value),\n            Value::U128(value) =\u003e int_to_bool!(value),\n            Value::F32(value) =\u003e {\n                if value.eq(\u00261.0_f32) {\n                    true\n                } else if value.eq(\u00260.0_f32) {\n                    false\n                } else {\n                    return Err(ConvertError {\n                        value: v.clone(),\n                        data_type: DataType::Boolean,\n                    });\n                }\n            }\n            Value::F64(value) =\u003e {\n                if value.eq(\u00261.0) {\n                    true\n                } else if value.eq(\u00260.0) {\n                    false\n                } else {\n                    return Err(ConvertError {\n                        value: v.clone(),\n                        data_type: DataType::Boolean,\n                    });\n                }\n            }\n            Value::Str(value) =\u003e match value.to_uppercase().as_str() {\n                \"TRUE\" =\u003e true,\n                \"FALSE\" =\u003e false,\n                _ =\u003e {\n                    return Err(ConvertError {\n                        value: v.clone(),\n                        data_type: DataType::Boolean,\n                    });\n                }\n            },\n            Value::Decimal(value) =\u003e {\n                if value == \u0026rust_decimal::Decimal::ONE {\n                    true\n                } else if value == \u0026rust_decimal::Decimal::ZERO {\n                    false\n                } else {\n                    return Err(ConvertError {\n                        value: v.clone(),\n                        data_type: DataType::Boolean,\n                    });\n                }\n            }\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Inet(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Boolean,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for i8 {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003ci8\u003e {\n        macro_rules! num_to_i8 {\n            ($num: ident) =\u003e {\n                $num.to_i8().ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Int8,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e i8::from(*value),\n            Value::I8(value) =\u003e *value,\n            Value::I16(value) =\u003e num_to_i8!(value),\n            Value::I32(value) =\u003e num_to_i8!(value),\n            Value::I64(value) =\u003e num_to_i8!(value),\n            Value::I128(value) =\u003e num_to_i8!(value),\n            Value::U8(value) =\u003e num_to_i8!(value),\n            Value::U16(value) =\u003e num_to_i8!(value),\n            Value::U32(value) =\u003e num_to_i8!(value),\n            Value::U64(value) =\u003e num_to_i8!(value),\n            Value::U128(value) =\u003e num_to_i8!(value),\n            Value::F32(value) =\u003e num_to_i8!(value),\n            Value::F64(value) =\u003e num_to_i8!(value),\n            Value::Str(value) =\u003e value.parse::\u003ci8\u003e().map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Int8,\n            })?,\n            Value::Decimal(value) =\u003e value.to_i8().ok_or_else(|| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Int8,\n            })?,\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Inet(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Int8,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for i16 {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003ci16\u003e {\n        macro_rules! num_to_i16 {\n            ($num: ident) =\u003e {\n                $num.to_i16().ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Int16,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e i16::from(*value),\n            Value::I8(value) =\u003e *value as i16,\n            Value::I16(value) =\u003e *value,\n            Value::I32(value) =\u003e num_to_i16!(value),\n            Value::I64(value) =\u003e num_to_i16!(value),\n            Value::I128(value) =\u003e num_to_i16!(value),\n            Value::U8(value) =\u003e num_to_i16!(value),\n            Value::U16(value) =\u003e num_to_i16!(value),\n            Value::U32(value) =\u003e num_to_i16!(value),\n            Value::U64(value) =\u003e num_to_i16!(value),\n            Value::U128(value) =\u003e num_to_i16!(value),\n            Value::F32(value) =\u003e num_to_i16!(value),\n            Value::F64(value) =\u003e num_to_i16!(value),\n            Value::Str(value) =\u003e value.parse::\u003ci16\u003e().map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Int16,\n            })?,\n            Value::Decimal(value) =\u003e value.to_i16().ok_or_else(|| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Int16,\n            })?,\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Inet(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Int16,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for i32 {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003ci32\u003e {\n        macro_rules! num_to_i32 {\n            ($num: ident) =\u003e {\n                $num.to_i32().ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Int32,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e i32::from(*value),\n            Value::I8(value) =\u003e *value as i32,\n            Value::I16(value) =\u003e *value as i32,\n            Value::I32(value) =\u003e *value,\n            Value::I64(value) =\u003e num_to_i32!(value),\n            Value::I128(value) =\u003e num_to_i32!(value),\n            Value::U8(value) =\u003e num_to_i32!(value),\n            Value::U16(value) =\u003e num_to_i32!(value),\n            Value::U32(value) =\u003e num_to_i32!(value),\n            Value::U64(value) =\u003e num_to_i32!(value),\n            Value::U128(value) =\u003e num_to_i32!(value),\n            Value::F32(value) =\u003e num_to_i32!(value),\n            Value::F64(value) =\u003e num_to_i32!(value),\n            Value::Str(value) =\u003e value.parse::\u003ci32\u003e().map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Int32,\n            })?,\n            Value::Decimal(value) =\u003e num_to_i32!(value),\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Inet(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Int32,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for i64 {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003ci64\u003e {\n        macro_rules! num_to_i64 {\n            ($num: ident) =\u003e {\n                $num.to_i64().ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Int,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e i64::from(*value),\n            Value::I8(value) =\u003e *value as i64,\n            Value::I16(value) =\u003e *value as i64,\n            Value::I32(value) =\u003e *value as i64,\n            Value::I64(value) =\u003e *value,\n            Value::I128(value) =\u003e num_to_i64!(value),\n            Value::U8(value) =\u003e num_to_i64!(value),\n            Value::U16(value) =\u003e num_to_i64!(value),\n            Value::U32(value) =\u003e num_to_i64!(value),\n            Value::U64(value) =\u003e num_to_i64!(value),\n            Value::U128(value) =\u003e num_to_i64!(value),\n            Value::F32(value) =\u003e num_to_i64!(value),\n            Value::F64(value) =\u003e num_to_i64!(value),\n            Value::Str(value) =\u003e value.parse::\u003ci64\u003e().map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Int,\n            })?,\n            Value::Decimal(value) =\u003e num_to_i64!(value),\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Inet(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Int,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for i128 {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003ci128\u003e {\n        macro_rules! num_to_i128 {\n            ($num: ident) =\u003e {\n                $num.to_i128().ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Int128,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e i128::from(*value),\n            Value::I8(value) =\u003e *value as i128,\n            Value::I16(value) =\u003e *value as i128,\n            Value::I32(value) =\u003e *value as i128,\n            Value::I64(value) =\u003e *value as i128,\n            Value::I128(value) =\u003e *value,\n            Value::U8(value) =\u003e *value as i128,\n            Value::U16(value) =\u003e *value as i128,\n            Value::U32(value) =\u003e num_to_i128!(value),\n            Value::U64(value) =\u003e num_to_i128!(value),\n            Value::U128(value) =\u003e num_to_i128!(value),\n            Value::F32(value) =\u003e num_to_i128!(value),\n            Value::F64(value) =\u003e num_to_i128!(value),\n            Value::Str(value) =\u003e value.parse::\u003ci128\u003e().map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Int128,\n            })?,\n            Value::Decimal(value) =\u003e num_to_i128!(value),\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Inet(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Int128,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for u8 {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cu8\u003e {\n        macro_rules! num_to_u8 {\n            ($num: ident) =\u003e {\n                $num.to_u8().ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Uint8,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e u8::from(*value),\n            Value::I8(value) =\u003e num_to_u8!(value),\n            Value::I16(value) =\u003e num_to_u8!(value),\n            Value::I32(value) =\u003e num_to_u8!(value),\n            Value::I64(value) =\u003e num_to_u8!(value),\n            Value::I128(value) =\u003e num_to_u8!(value),\n            Value::U8(value) =\u003e *value,\n            Value::U16(value) =\u003e num_to_u8!(value),\n            Value::U32(value) =\u003e num_to_u8!(value),\n            Value::U64(value) =\u003e num_to_u8!(value),\n            Value::U128(value) =\u003e num_to_u8!(value),\n            Value::F32(value) =\u003e num_to_u8!(value),\n            Value::F64(value) =\u003e num_to_u8!(value),\n            Value::Str(value) =\u003e value.parse::\u003cu8\u003e().map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Uint8,\n            })?,\n            Value::Decimal(value) =\u003e num_to_u8!(value),\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Inet(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Uint8,\n                });\n            }\n        })\n    }\n}\nimpl TryFrom\u003c\u0026Value\u003e for u16 {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cu16\u003e {\n        macro_rules! num_to_u16 {\n            ($num: ident) =\u003e {\n                $num.to_u16().ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Uint16,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e u16::from(*value),\n            Value::I8(value) =\u003e num_to_u16!(value),\n            Value::I16(value) =\u003e num_to_u16!(value),\n            Value::I32(value) =\u003e num_to_u16!(value),\n            Value::I64(value) =\u003e num_to_u16!(value),\n            Value::I128(value) =\u003e num_to_u16!(value),\n            Value::U8(value) =\u003e u16::from(*value),\n            Value::U16(value) =\u003e *value,\n            Value::U32(value) =\u003e num_to_u16!(value),\n            Value::U64(value) =\u003e num_to_u16!(value),\n            Value::U128(value) =\u003e num_to_u16!(value),\n            Value::F32(value) =\u003e num_to_u16!(value),\n            Value::F64(value) =\u003e num_to_u16!(value),\n            Value::Str(value) =\u003e value.parse::\u003cu16\u003e().map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Uint16,\n            })?,\n            Value::Decimal(value) =\u003e num_to_u16!(value),\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Inet(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Uint16,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for u32 {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cu32\u003e {\n        macro_rules! num_to_u32 {\n            ($num: ident) =\u003e {\n                $num.to_u32().ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Uint32,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e u32::from(*value),\n            Value::I8(value) =\u003e num_to_u32!(value),\n            Value::I16(value) =\u003e num_to_u32!(value),\n            Value::I32(value) =\u003e num_to_u32!(value),\n            Value::I64(value) =\u003e num_to_u32!(value),\n            Value::I128(value) =\u003e num_to_u32!(value),\n            Value::U8(value) =\u003e u32::from(*value),\n            Value::U16(value) =\u003e u32::from(*value),\n            Value::U32(value) =\u003e *value,\n            Value::U64(value) =\u003e num_to_u32!(value),\n            Value::U128(value) =\u003e num_to_u32!(value),\n            Value::F32(value) =\u003e num_to_u32!(value),\n            Value::F64(value) =\u003e num_to_u32!(value),\n            Value::Str(value) =\u003e value.parse::\u003cu32\u003e().map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Uint32,\n            })?,\n            Value::Decimal(value) =\u003e num_to_u32!(value),\n            Value::Inet(IpAddr::V4(value)) =\u003e u32::from(*value),\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Inet(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Uint32,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for u64 {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cu64\u003e {\n        macro_rules! num_to_u64 {\n            ($num: ident) =\u003e {\n                $num.to_u64().ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Uint64,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e u64::from(*value),\n            Value::I8(value) =\u003e num_to_u64!(value),\n            Value::I16(value) =\u003e num_to_u64!(value),\n            Value::I32(value) =\u003e num_to_u64!(value),\n            Value::I64(value) =\u003e num_to_u64!(value),\n            Value::I128(value) =\u003e num_to_u64!(value),\n            Value::U8(value) =\u003e u64::from(*value),\n            Value::U16(value) =\u003e u64::from(*value),\n            Value::U32(value) =\u003e u64::from(*value),\n            Value::U64(value) =\u003e *value,\n            Value::U128(value) =\u003e num_to_u64!(value),\n            Value::F32(value) =\u003e num_to_u64!(value),\n            Value::F64(value) =\u003e num_to_u64!(value),\n            Value::Str(value) =\u003e value.parse::\u003cu64\u003e().map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Uint64,\n            })?,\n            Value::Decimal(value) =\u003e num_to_u64!(value),\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Inet(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Uint64,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for u128 {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cu128\u003e {\n        macro_rules! num_to_u128 {\n            ($num: ident) =\u003e {\n                $num.to_u128().ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Uint128,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e u128::from(*value),\n            Value::I8(value) =\u003e num_to_u128!(value),\n            Value::I16(value) =\u003e num_to_u128!(value),\n            Value::I32(value) =\u003e num_to_u128!(value),\n            Value::I64(value) =\u003e num_to_u128!(value),\n            Value::I128(value) =\u003e num_to_u128!(value),\n            Value::U8(value) =\u003e u128::from(*value),\n            Value::U16(value) =\u003e u128::from(*value),\n            Value::U32(value) =\u003e u128::from(*value),\n            Value::U64(value) =\u003e u128::from(*value),\n            Value::U128(value) =\u003e *value,\n            Value::F32(value) =\u003e num_to_u128!(value),\n            Value::F64(value) =\u003e num_to_u128!(value),\n            Value::Str(value) =\u003e value.parse::\u003cu128\u003e().map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Uint128,\n            })?,\n            Value::Decimal(value) =\u003e num_to_u128!(value),\n            Value::Inet(IpAddr::V6(v)) =\u003e u128::from(*v),\n            Value::Uuid(value) =\u003e *value,\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Inet(IpAddr::V4(_))\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Uint128,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for f32 {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cf32\u003e {\n        macro_rules! num_to_f32 {\n            ($num: ident) =\u003e {\n                $num.to_f32().ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Float32,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e {\n                if *value {\n                    1.0\n                } else {\n                    0.0\n                }\n            }\n            Value::I8(value) =\u003e num_to_f32!(value),\n            Value::I16(value) =\u003e num_to_f32!(value),\n            Value::I32(value) =\u003e num_to_f32!(value),\n            Value::I64(value) =\u003e num_to_f32!(value),\n            Value::I128(value) =\u003e num_to_f32!(value),\n            Value::U8(value) =\u003e num_to_f32!(value),\n            Value::U16(value) =\u003e num_to_f32!(value),\n            Value::U32(value) =\u003e num_to_f32!(value),\n            Value::U64(value) =\u003e num_to_f32!(value),\n            Value::U128(value) =\u003e num_to_f32!(value),\n            Value::F32(value) =\u003e *value,\n            Value::F64(value) =\u003e num_to_f32!(value),\n            Value::Str(value) =\u003e value.parse::\u003cf32\u003e().map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Float32,\n            })?,\n            Value::Decimal(value) =\u003e num_to_f32!(value),\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Inet(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Float32,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for f64 {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cf64\u003e {\n        macro_rules! num_to_f64 {\n            ($num: ident) =\u003e {\n                $num.to_f64().ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Float,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e {\n                if *value {\n                    1.0\n                } else {\n                    0.0\n                }\n            }\n            Value::I8(value) =\u003e num_to_f64!(value),\n            Value::I16(value) =\u003e num_to_f64!(value),\n            Value::I32(value) =\u003e num_to_f64!(value),\n            Value::I64(value) =\u003e num_to_f64!(value),\n            Value::I128(value) =\u003e num_to_f64!(value),\n            Value::U8(value) =\u003e num_to_f64!(value),\n            Value::U16(value) =\u003e num_to_f64!(value),\n            Value::U32(value) =\u003e num_to_f64!(value),\n            Value::U64(value) =\u003e num_to_f64!(value),\n            Value::U128(value) =\u003e num_to_f64!(value),\n            Value::F32(value) =\u003e num_to_f64!(value),\n            Value::F64(value) =\u003e *value,\n            Value::Str(value) =\u003e value.parse::\u003cf64\u003e().map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Float,\n            })?,\n            Value::Decimal(value) =\u003e num_to_f64!(value),\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Inet(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Float,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for usize {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cusize\u003e {\n        let err = || ConvertError {\n            value: v.clone(),\n            #[cfg(target_pointer_width = \"64\")]\n            data_type: DataType::Uint64,\n            #[cfg(target_pointer_width = \"32\")]\n            data_type: DataType::Uint32,\n        };\n\n        macro_rules! num_to_usize {\n            ($num: ident) =\u003e {\n                $num.to_usize().ok_or_else(err)?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e usize::from(*value),\n            Value::I8(value) =\u003e num_to_usize!(value),\n            Value::I16(value) =\u003e num_to_usize!(value),\n            Value::I32(value) =\u003e num_to_usize!(value),\n            Value::I64(value) =\u003e num_to_usize!(value),\n            Value::I128(value) =\u003e num_to_usize!(value),\n            Value::U8(value) =\u003e num_to_usize!(value),\n            Value::U16(value) =\u003e num_to_usize!(value),\n            Value::U32(value) =\u003e num_to_usize!(value),\n            Value::U64(value) =\u003e num_to_usize!(value),\n            Value::U128(value) =\u003e num_to_usize!(value),\n            Value::F32(value) =\u003e num_to_usize!(value),\n            Value::F64(value) =\u003e num_to_usize!(value),\n            Value::Str(value) =\u003e value.parse::\u003cusize\u003e().map_err(|_| err())?,\n            Value::Decimal(value) =\u003e num_to_usize!(value),\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Inet(_)\n            | Value::Null =\u003e return Err(err()),\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for Decimal {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cDecimal\u003e {\n        macro_rules! num_to_decimal {\n            ($num: expr, $method: ident) =\u003e {\n                Decimal::$method($num).ok_or_else(|| ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Decimal,\n                })?\n            };\n        }\n\n        Ok(match v {\n            Value::Bool(value) =\u003e {\n                if *value {\n                    Decimal::ONE\n                } else {\n                    Decimal::ZERO\n                }\n            }\n            Value::I8(value) =\u003e num_to_decimal!(*value, from_i8),\n            Value::I16(value) =\u003e num_to_decimal!(*value, from_i16),\n            Value::I32(value) =\u003e num_to_decimal!(*value, from_i32),\n            Value::I64(value) =\u003e num_to_decimal!(*value, from_i64),\n            Value::I128(value) =\u003e num_to_decimal!(*value, from_i128),\n            Value::U8(value) =\u003e num_to_decimal!(*value, from_u8),\n            Value::U16(value) =\u003e num_to_decimal!(*value, from_u16),\n            Value::U32(value) =\u003e num_to_decimal!(*value, from_u32),\n            Value::U64(value) =\u003e num_to_decimal!(*value, from_u64),\n            Value::U128(value) =\u003e num_to_decimal!(*value, from_u128),\n            Value::F32(value) =\u003e num_to_decimal!(*value, from_f32),\n            Value::F64(value) =\u003e num_to_decimal!(*value, from_f64),\n            Value::Str(value) =\u003e Decimal::from_str(value).map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Decimal,\n            })?,\n            Value::Decimal(value) =\u003e *value,\n\n            Value::Date(_)\n            | Value::Timestamp(_)\n            | Value::Time(_)\n            | Value::Interval(_)\n            | Value::Uuid(_)\n            | Value::Map(_)\n            | Value::List(_)\n            | Value::Bytea(_)\n            | Value::Point(_)\n            | Value::Inet(_)\n            | Value::Null =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Decimal,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for NaiveDate {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cNaiveDate\u003e {\n        Ok(match v {\n            Value::Date(value) =\u003e *value,\n            Value::Timestamp(value) =\u003e value.date(),\n            Value::Str(value) =\u003e parse_date(value).ok_or_else(|| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Date,\n            })?,\n\n            _ =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Date,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for NaiveTime {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cNaiveTime\u003e {\n        Ok(match v {\n            Value::Time(value) =\u003e *value,\n            Value::Str(value) =\u003e parse_time(value).ok_or_else(|| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Time,\n            })?,\n\n            _ =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Time,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for NaiveDateTime {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cNaiveDateTime\u003e {\n        Ok(match v {\n            Value::Date(value) =\u003e value.and_hms_opt(0, 0, 0).ok_or_else(|| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Timestamp,\n            })?,\n            Value::Str(value) =\u003e parse_timestamp(value).ok_or_else(|| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Timestamp,\n            })?,\n            Value::Timestamp(value) =\u003e *value,\n\n            _ =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Timestamp,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for IpAddr {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cIpAddr\u003e {\n        Ok(match v {\n            Value::Inet(value) =\u003e *value,\n            Value::Str(value) =\u003e IpAddr::from_str(value).map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Inet,\n            })?,\n\n            _ =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Inet,\n                });\n            }\n        })\n    }\n}\n\nimpl TryFrom\u003c\u0026Value\u003e for Point {\n    type Error = ConvertError;\n\n    fn try_from(v: \u0026Value) -\u003e Result\u003cPoint\u003e {\n        Ok(match v {\n            Value::Point(value) =\u003e *value,\n            Value::Str(value) =\u003e Point::from_wkt(value).map_err(|_| ConvertError {\n                value: v.clone(),\n                data_type: DataType::Point,\n            })?,\n\n            _ =\u003e {\n                return Err(ConvertError {\n                    value: v.clone(),\n                    data_type: DataType::Point,\n                });\n            }\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::{ConvertError, Result, Value},\n        crate::{ast::DataType, data::Interval as I, data::Point, data::point},\n        chrono::{self, NaiveDate, NaiveDateTime, NaiveTime},\n        rust_decimal::Decimal,\n        std::{\n            collections::HashMap,\n            net::{IpAddr, Ipv4Addr, Ipv6Addr},\n            str::FromStr,\n        },\n    };\n\n    fn timestamp(y: i32, m: u32, d: u32, hh: u32, mm: u32, ss: u32, ms: u32) -\u003e NaiveDateTime {\n        NaiveDate::from_ymd_opt(y, m, d)\n            .unwrap()\n            .and_hms_milli_opt(hh, mm, ss, ms)\n            .unwrap()\n    }\n\n    fn time(hour: u32, min: u32, sec: u32, milli: u32) -\u003e NaiveTime {\n        NaiveTime::from_hms_milli_opt(hour, min, sec, milli).unwrap()\n    }\n\n    fn date(year: i32, month: u32, day: u32) -\u003e NaiveDate {\n        NaiveDate::from_ymd_opt(year, month, day).unwrap()\n    }\n\n    #[test]\n    fn from() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!(String::from($from), $to.to_owned())\n            };\n        }\n\n        test!(Value::Str(\"text\".to_owned()), \"text\");\n        test!(Value::Bytea(hex::decode(\"1234\").unwrap()), \"1234\");\n        test!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()), \"::1\");\n        test!(Value::Bool(true), \"TRUE\");\n        test!(Value::I8(122), \"122\");\n        test!(Value::I16(122), \"122\");\n        test!(Value::I32(122), \"122\");\n        test!(Value::I64(1234567890), \"1234567890\");\n        test!(Value::I128(1234567890), \"1234567890\");\n        test!(Value::U8(122), \"122\");\n        test!(Value::U16(122), \"122\");\n        test!(Value::U32(122), \"122\");\n        test!(Value::U64(122), \"122\");\n        test!(Value::U128(122), \"122\");\n        test!(Value::F32(123456.1_f32), \"123456.1\");\n        test!(Value::F64(1234567890.0987), \"1234567890.0987\");\n        test!(Value::Date(date(2021, 11, 20)), \"2021-11-20\");\n        test!(\n            Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)),\n            \"2021-11-20 10:00:00\"\n        );\n        test!(Value::Time(time(10, 0, 0, 0)), \"10:00:00\");\n        test!(Value::Interval(I::Month(1)), I::Month(1).to_sql_str());\n        test!(\n            Value::Uuid(195965723427462096757863453463987888808),\n            \"936da01f-9abd-4d9d-80c7-02af85c822a8\"\n        );\n        test!(Value::Map(HashMap::new()), \"{}\");\n        test!(Value::List(Vec::new()), \"[]\");\n\n        let mut map = HashMap::new();\n        map.insert(\"abc\".to_owned(), Value::I32(123));\n        test!(Value::Map(map), \"{\\\"abc\\\":123}\");\n        test!(Value::List(vec![Value::I32(1), Value::I32(2)]), \"[1,2]\");\n        test!(\n            Value::Point(point::Point::new(1.0313, 2.0314)),\n            \"POINT(1.0313 2.0314)\"\n        );\n        test!(Value::Decimal(Decimal::new(2000, 1)), \"200.0\");\n        test!(Value::Null, \"NULL\");\n    }\n\n    #[test]\n    fn try_into_bool() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cbool\u003e, $to);\n                assert_eq!(bool::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Boolean,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(true));\n        test!(Value::I8(1), Ok(true));\n        test!(Value::I8(0), Ok(false));\n        test!(Value::I16(1), Ok(true));\n        test!(Value::I16(0), Ok(false));\n        test!(Value::I32(1), Ok(true));\n        test!(Value::I32(0), Ok(false));\n        test!(Value::I64(1), Ok(true));\n        test!(Value::I64(0), Ok(false));\n        test!(Value::I128(1), Ok(true));\n        test!(Value::I128(0), Ok(false));\n        test!(Value::U8(1), Ok(true));\n        test!(Value::U8(0), Ok(false));\n\n        test!(Value::U16(1), Ok(true));\n        test!(Value::U16(0), Ok(false));\n        test!(Value::U32(1), Ok(true));\n        test!(Value::U32(0), Ok(false));\n        test!(Value::U64(1), Ok(true));\n        test!(Value::U64(0), Ok(false));\n        test!(Value::U128(1), Ok(true));\n        test!(Value::U128(0), Ok(false));\n\n        test!(Value::F32(1.0_f32), Ok(true));\n        test!(Value::F32(0.0_f32), Ok(false));\n        test!(Value::F64(1.0), Ok(true));\n        test!(Value::F64(0.0), Ok(false));\n        test!(Value::Str(\"true\".to_owned()), Ok(true));\n        test!(Value::Str(\"false\".to_owned()), Ok(false));\n        test!(Value::Decimal(Decimal::new(10, 1)), Ok(true));\n        test!(Value::Decimal(Decimal::new(0, 1)), Ok(false));\n\n        err!(Value::I8(3));\n        err!(Value::I16(3));\n        err!(Value::I32(3));\n        err!(Value::I64(3));\n        err!(Value::I128(3));\n        err!(Value::U8(3));\n        err!(Value::U16(3));\n        err!(Value::U32(3));\n        err!(Value::U64(3));\n        err!(Value::U128(3));\n        err!(Value::F32(2.0_f32));\n        err!(Value::F64(2.0));\n        err!(Value::Decimal(Decimal::new(2, 0)));\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Point(point::Point::new(1.0313, 2.0314)));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_i8() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003ci8\u003e, $to);\n                assert_eq!(i8::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Int8,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1));\n        test!(Value::Bool(false), Ok(0));\n        test!(Value::I8(122), Ok(122));\n        test!(Value::I16(122), Ok(122));\n        test!(Value::I32(122), Ok(122));\n        test!(Value::I64(122), Ok(122));\n        test!(Value::I128(122), Ok(122));\n        test!(Value::U8(122), Ok(122));\n        test!(Value::U16(122), Ok(122));\n        test!(Value::U32(122), Ok(122));\n        test!(Value::U64(122), Ok(122));\n        test!(Value::U128(122), Ok(122));\n        test!(Value::F32(122.0_f32), Ok(122));\n        test!(Value::F64(122.0), Ok(122));\n        test!(Value::Str(\"122\".to_owned()), Ok(122));\n        test!(Value::Decimal(Decimal::new(123, 0)), Ok(123));\n\n        err!(Value::I16(128));\n        err!(Value::I32(128));\n        err!(Value::I64(128));\n        err!(Value::I128(128));\n        err!(Value::U8(128));\n        err!(Value::U16(128));\n        err!(Value::U32(128));\n        err!(Value::U64(128));\n        err!(Value::U128(128));\n        err!(Value::F32(128.0_f32));\n        err!(Value::F64(128.0));\n        err!(Value::Decimal(Decimal::new(128, 0)));\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Point(point::Point::new(1.0313, 2.0314)));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_i16() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003ci16\u003e, $to);\n                assert_eq!(i16::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Int16,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1));\n        test!(Value::Bool(false), Ok(0));\n        test!(Value::I8(122), Ok(122));\n        test!(Value::I16(122), Ok(122));\n        test!(Value::I32(122), Ok(122));\n        test!(Value::I64(122), Ok(122));\n        test!(Value::I128(122), Ok(122));\n        test!(Value::U8(122), Ok(122));\n        test!(Value::U16(122), Ok(122));\n        test!(Value::U32(122), Ok(122));\n        test!(Value::U64(122), Ok(122));\n        test!(Value::U128(122), Ok(122));\n        test!(Value::F32(122.0_f32), Ok(122));\n        test!(Value::F32(122.1_f32), Ok(122));\n        test!(Value::F64(122.0), Ok(122));\n        test!(Value::F64(122.1), Ok(122));\n        test!(Value::Str(\"122\".to_owned()), Ok(122));\n        test!(Value::Decimal(Decimal::new(122, 0)), Ok(122));\n\n        err!(Value::I32(i32::MAX));\n        err!(Value::I64(i64::MAX));\n        err!(Value::I128(i128::MAX));\n\n        err!(Value::U16(u16::MAX));\n        err!(Value::U32(u32::MAX));\n        err!(Value::U64(u64::MAX));\n        err!(Value::U128(u128::MAX));\n\n        err!(Value::F32(f32::MAX));\n        err!(Value::F64(f64::MAX));\n        err!(Value::Decimal(Decimal::new(i64::MAX, 0)));\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Point(point::Point::new(1.0313, 2.0314)));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_i32() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003ci32\u003e, $to);\n                assert_eq!(i32::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Int32,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1));\n        test!(Value::Bool(false), Ok(0));\n        test!(Value::I8(122), Ok(122));\n        test!(Value::I16(122), Ok(122));\n        test!(Value::I32(122), Ok(122));\n        test!(Value::I64(122), Ok(122));\n        test!(Value::I128(122), Ok(122));\n        test!(Value::U8(122), Ok(122));\n        test!(Value::U16(122), Ok(122));\n        test!(Value::U32(122), Ok(122));\n        test!(Value::U64(122), Ok(122));\n        test!(Value::U128(122), Ok(122));\n        test!(Value::I64(1234567890), Ok(1234567890));\n        test!(Value::F32(1234567890.0_f32), Ok(1234567890.0_f32 as i32));\n        test!(Value::F32(1234567890.1_f32), Ok(1234567890.1_f32 as i32));\n        test!(Value::F64(1234567890.0), Ok(1234567890));\n        test!(Value::F64(1234567890.1), Ok(1234567890));\n        test!(Value::Str(\"1234567890\".to_owned()), Ok(1234567890));\n        test!(Value::Decimal(Decimal::new(1234567890, 0)), Ok(1234567890));\n\n        err!(Value::I64(i64::MAX));\n        err!(Value::I128(i128::MAX));\n\n        err!(Value::U32(u32::MAX));\n        err!(Value::U64(u64::MAX));\n        err!(Value::U128(u128::MAX));\n\n        err!(Value::F32(f32::MAX));\n        err!(Value::F64(f64::MAX));\n\n        err!(Value::Decimal(Decimal::new(i64::MAX, 0)));\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Point(point::Point::new(1.0313, 2.0314)));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_i64() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003ci64\u003e, $to);\n                assert_eq!(i64::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Int,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1));\n        test!(Value::Bool(false), Ok(0));\n        test!(Value::I8(122), Ok(122));\n        test!(Value::I16(122), Ok(122));\n        test!(Value::I32(122), Ok(122));\n        test!(Value::I64(122), Ok(122));\n        test!(Value::I128(122), Ok(122));\n        test!(Value::U8(122), Ok(122));\n        test!(Value::U16(122), Ok(122));\n        test!(Value::U32(122), Ok(122));\n        test!(Value::U64(122), Ok(122));\n        test!(Value::U128(122), Ok(122));\n        test!(Value::I64(1234567890), Ok(1234567890));\n        test!(Value::F32(1234567890.0_f32), Ok(1234567890.0_f32 as i64));\n        test!(Value::F32(1234567890.1_f32), Ok(1234567890.1_f32 as i64));\n        test!(Value::F64(1234567890.0), Ok(1234567890));\n        test!(Value::F64(1234567890.1), Ok(1234567890));\n        test!(Value::Str(\"1234567890\".to_owned()), Ok(1234567890));\n        test!(Value::Decimal(Decimal::new(1234567890, 0)), Ok(1234567890));\n\n        err!(Value::I128(i128::MAX));\n\n        err!(Value::U64(u64::MAX));\n        err!(Value::U128(u128::MAX));\n\n        err!(Value::F32(f32::MAX));\n        err!(Value::F64(f64::MAX));\n\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Point(point::Point::new(1.0313, 2.0314)));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_i128() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003ci128\u003e, $to);\n                assert_eq!(i128::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Int128,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1));\n        test!(Value::Bool(false), Ok(0));\n        test!(Value::I8(122), Ok(122));\n        test!(Value::I16(122), Ok(122));\n        test!(Value::I32(122), Ok(122));\n        test!(Value::I64(122), Ok(122));\n        test!(Value::I128(122), Ok(122));\n        test!(Value::U8(122), Ok(122));\n        test!(Value::U16(122), Ok(122));\n        test!(Value::U32(122), Ok(122));\n        test!(Value::U64(122), Ok(122));\n        test!(Value::U128(122), Ok(122));\n        test!(Value::I64(1234567890), Ok(1234567890));\n        test!(Value::F32(1234567890.0_f32), Ok(1234567890.0_f32 as i128));\n        test!(Value::F32(1234567890.9_f32), Ok(1234567890.9_f32 as i128));\n        test!(Value::F64(1234567890.0), Ok(1234567890));\n        test!(Value::F64(1234567890.9), Ok(1234567890));\n        test!(Value::Str(\"1234567890\".to_owned()), Ok(1234567890));\n        test!(Value::Decimal(Decimal::new(1234567890, 0)), Ok(1234567890));\n\n        err!(Value::U128(u128::MAX));\n\n        err!(Value::F32(f32::MAX));\n        err!(Value::F64(f64::MAX));\n\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Point(point::Point::new(1.0313, 2.0314)));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_u8() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cu8\u003e, $to);\n                assert_eq!(u8::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Uint8,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1));\n        test!(Value::Bool(false), Ok(0));\n        test!(Value::I8(122), Ok(122));\n        test!(Value::I16(122), Ok(122));\n        test!(Value::I32(122), Ok(122));\n        test!(Value::I64(122), Ok(122));\n        test!(Value::I128(122), Ok(122));\n        test!(Value::U8(122), Ok(122));\n        test!(Value::U16(122), Ok(122));\n        test!(Value::U32(122), Ok(122));\n        test!(Value::U64(122), Ok(122));\n        test!(Value::U128(122), Ok(122));\n        test!(Value::F32(122.0_f32), Ok(122));\n        test!(Value::F32(122.9_f32), Ok(122));\n        test!(Value::F64(122.0), Ok(122));\n        test!(Value::F64(122.9), Ok(122));\n        test!(Value::Str(\"122\".to_owned()), Ok(122));\n        test!(Value::Decimal(Decimal::new(123, 0)), Ok(123));\n\n        // impossible casts to u8\n        err!(Value::I16(256));\n        err!(Value::I32(256));\n        err!(Value::I64(256));\n        err!(Value::I128(256));\n\n        err!(Value::U16(256));\n        err!(Value::U32(256));\n        err!(Value::U64(256));\n        err!(Value::U128(256));\n\n        err!(Value::F32(256.0_f32));\n        err!(Value::F64(256.0));\n\n        err!(Value::Decimal(Decimal::new(256, 0)));\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Point(point::Point::new(1.0313, 2.0314)));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_u16() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cu16\u003e, $to);\n                assert_eq!(u16::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Uint16,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1));\n        test!(Value::Bool(false), Ok(0));\n        test!(Value::I8(122), Ok(122));\n        test!(Value::I16(122), Ok(122));\n        test!(Value::I32(122), Ok(122));\n        test!(Value::I64(122), Ok(122));\n        test!(Value::I128(122), Ok(122));\n        test!(Value::U8(122), Ok(122));\n        test!(Value::U16(122), Ok(122));\n        test!(Value::U32(122), Ok(122));\n        test!(Value::U64(122), Ok(122));\n        test!(Value::U128(122), Ok(122));\n        test!(Value::F32(122.0_f32), Ok(122));\n        test!(Value::F32(122.1_f32), Ok(122));\n        test!(Value::F64(122.0), Ok(122));\n        test!(Value::F64(122.1), Ok(122));\n        test!(Value::Str(\"122\".to_owned()), Ok(122));\n        test!(Value::Decimal(Decimal::new(122, 0)), Ok(122));\n\n        err!(Value::I32(65536));\n        err!(Value::I64(65536));\n        err!(Value::I128(65536));\n\n        err!(Value::U32(65536));\n        err!(Value::U64(65536));\n        err!(Value::U128(65536));\n\n        err!(Value::F32(65536.0_f32));\n        err!(Value::F64(65536.0));\n\n        err!(Value::Decimal(Decimal::new(65536, 0)));\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_u32() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cu32\u003e, $to);\n                assert_eq!(u32::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Uint32,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1));\n        test!(Value::Bool(false), Ok(0));\n        test!(Value::I8(122), Ok(122));\n        test!(Value::I16(122), Ok(122));\n        test!(Value::I32(122), Ok(122));\n        test!(Value::I64(122), Ok(122));\n        test!(Value::I128(122), Ok(122));\n        test!(Value::U8(122), Ok(122));\n        test!(Value::U16(122), Ok(122));\n        test!(Value::U32(122), Ok(122));\n        test!(Value::U64(122), Ok(122));\n        test!(Value::U128(122), Ok(122));\n        test!(Value::F32(122.0_f32), Ok(122));\n        test!(Value::F32(122.1_f32), Ok(122));\n        test!(Value::F64(122.0), Ok(122));\n        test!(Value::F64(122.1), Ok(122));\n        test!(Value::Str(\"122\".to_owned()), Ok(122));\n        test!(Value::Decimal(Decimal::new(122, 0)), Ok(122));\n\n        err!(Value::I64(i64::MAX));\n        err!(Value::I128(i128::MAX));\n\n        err!(Value::U64(u64::MAX));\n        err!(Value::U128(u128::MAX));\n\n        err!(Value::F32(f32::MAX));\n        err!(Value::F64(f64::MAX));\n\n        err!(Value::Decimal(Decimal::new(i64::MAX, 0)));\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::0\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Null);\n\n        assert_eq!(\n            u32::try_from(\u0026Value::Inet(IpAddr::from_str(\"0.0.0.0\").unwrap())),\n            Ok(u32::from(Ipv4Addr::from(0)))\n        );\n    }\n\n    #[test]\n    fn try_into_u64() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cu64\u003e, $to);\n                assert_eq!(u64::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Uint64,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1));\n        test!(Value::Bool(false), Ok(0));\n        test!(Value::I8(122), Ok(122));\n        test!(Value::I16(122), Ok(122));\n        test!(Value::I32(122), Ok(122));\n        test!(Value::I64(122), Ok(122));\n        test!(Value::I128(122), Ok(122));\n        test!(Value::U8(122), Ok(122));\n        test!(Value::U16(122), Ok(122));\n        test!(Value::U32(122), Ok(122));\n        test!(Value::U64(122), Ok(122));\n        test!(Value::U128(122), Ok(122));\n        test!(Value::F32(122.0_f32), Ok(122));\n        test!(Value::F32(122.1_f32), Ok(122));\n        test!(Value::F64(122.0), Ok(122));\n        test!(Value::F64(122.1), Ok(122));\n        test!(Value::Str(\"122\".to_owned()), Ok(122));\n        test!(Value::Decimal(Decimal::new(122, 0)), Ok(122));\n\n        err!(Value::I128(i128::MIN));\n\n        err!(Value::U128(u128::MAX));\n\n        err!(Value::F32(f32::MIN));\n        err!(Value::F64(f64::MIN));\n\n        err!(Value::Decimal(Decimal::new(i64::MIN, 0)));\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Point(point::Point::new(1.0313, 2.0314)));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_u128() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cu128\u003e, $to);\n                assert_eq!(u128::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Uint128,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1));\n        test!(Value::Bool(false), Ok(0));\n        test!(Value::I8(122), Ok(122));\n        test!(Value::I16(122), Ok(122));\n        test!(Value::I32(122), Ok(122));\n        test!(Value::I64(122), Ok(122));\n        test!(Value::I128(122), Ok(122));\n        test!(Value::U8(122), Ok(122));\n        test!(Value::U16(122), Ok(122));\n        test!(Value::U32(122), Ok(122));\n        test!(Value::U64(122), Ok(122));\n        test!(Value::U128(122), Ok(122));\n        test!(Value::F32(122.0_f32), Ok(122));\n        test!(Value::F32(122.1_f32), Ok(122));\n        test!(Value::F64(122.0), Ok(122));\n        test!(Value::F64(122.1), Ok(122));\n        test!(Value::Str(\"122\".to_owned()), Ok(122));\n        test!(Value::Decimal(Decimal::new(122, 0)), Ok(122));\n\n        err!(Value::F32(f32::MIN));\n        err!(Value::F64(f64::MIN));\n\n        err!(Value::Decimal(Decimal::new(i64::MIN, 0)));\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Null);\n\n        let uuid = 195965723427462096757863453463987888808;\n        assert_eq!((\u0026Value::Uuid(uuid)).try_into() as Result\u003cu128\u003e, Ok(uuid));\n        assert_eq!(u128::try_from(\u0026Value::Uuid(uuid)), Ok(uuid));\n\n        let ip = Ipv6Addr::from(9876543210);\n        assert_eq!(\n            u128::try_from(\u0026Value::Inet(IpAddr::V6(ip))),\n            Ok(u128::from(ip))\n        );\n    }\n\n    #[test]\n    fn try_into_f32() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cf32\u003e, $to);\n                assert_eq!(f32::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Float32,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1.0_f32));\n        test!(Value::Bool(false), Ok(0.0_f32));\n        test!(Value::I8(122), Ok(122.0_f32));\n        test!(Value::I16(122), Ok(122.0_f32));\n        test!(Value::I32(122), Ok(122.0_f32));\n        test!(Value::I64(122), Ok(122.0_f32));\n        test!(Value::I128(122), Ok(122.0_f32));\n        test!(Value::U8(122), Ok(122.0_f32));\n        test!(Value::U16(122), Ok(122.0_f32));\n        test!(Value::U32(122), Ok(122.0_f32));\n        test!(Value::U64(122), Ok(122.0_f32));\n        test!(Value::U128(122), Ok(122.0_f32));\n        test!(Value::I64(1234567890), Ok(1234567890.0_f32));\n        test!(Value::F64(1234567890.1), Ok(1234567890.1_f32));\n        test!(Value::F32(1234567890.1_f32), Ok(1234567890.1_f32));\n        test!(Value::Str(\"1234567890.1\".to_owned()), Ok(1234567890.1_f32));\n        test!(\n            Value::Decimal(Decimal::new(12345678901, 1)),\n            Ok(1234567890.1_f32)\n        );\n\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_f64() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cf64\u003e, $to);\n                assert_eq!(f64::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Float,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1.0));\n        test!(Value::Bool(false), Ok(0.0));\n        test!(Value::I8(122), Ok(122.0));\n        test!(Value::I16(122), Ok(122.0));\n        test!(Value::I32(122), Ok(122.0));\n        test!(Value::I64(122), Ok(122.0));\n        test!(Value::I128(122), Ok(122.0));\n        test!(Value::U8(122), Ok(122.0));\n        test!(Value::U16(122), Ok(122.0));\n        test!(Value::U32(122), Ok(122.0));\n        test!(Value::U64(122), Ok(122.0));\n        test!(Value::U128(122), Ok(122.0));\n        test!(Value::I64(1234567890), Ok(1234567890.0));\n        test!(Value::F32(1234567890.1_f32), Ok(1234567890.1_f32 as f64));\n        test!(Value::F64(1234567890.1), Ok(1234567890.1));\n        test!(Value::Str(\"1234567890.1\".to_owned()), Ok(1234567890.1));\n        test!(\n            Value::Decimal(Decimal::new(12345678901, 1)),\n            Ok(1234567890.1)\n        );\n\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Point(point::Point::new(1.0313, 2.0314)));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_usize() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cusize\u003e, $to);\n                assert_eq!(usize::try_from(\u0026$from), $to);\n            };\n        }\n\n        let err = |value: Value| ConvertError {\n            value,\n            #[cfg(target_pointer_width = \"64\")]\n            data_type: DataType::Uint64,\n            #[cfg(target_pointer_width = \"32\")]\n            data_type: DataType::Uint32,\n        };\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!($from, Err(err($from.clone())))\n            };\n        }\n\n        test!(Value::Bool(true), Ok(1usize));\n        test!(Value::Bool(false), Ok(0));\n        test!(Value::I8(122), Ok(122));\n        test!(Value::I16(122), Ok(122));\n        test!(Value::I32(122), Ok(122));\n        test!(Value::I64(122), Ok(122));\n        test!(Value::I128(122), Ok(122));\n        test!(Value::U8(122), Ok(122));\n        test!(Value::U16(122), Ok(122));\n        test!(Value::U32(122), Ok(122));\n        test!(Value::U64(122), Ok(122));\n        test!(Value::U128(122), Ok(122));\n        test!(Value::I64(1234567890), Ok(1234567890));\n        test!(Value::F32(1234567890.0_f32), Ok(1234567890.0_f32 as usize));\n        test!(Value::F32(1234567890.1_f32), Ok(1234567890.1_f32 as usize));\n        test!(Value::F64(1234567890.0), Ok(1234567890));\n        test!(Value::F64(1234567890.1), Ok(1234567890));\n        test!(Value::Str(\"1234567890\".to_owned()), Ok(1234567890));\n        test!(Value::Decimal(Decimal::new(1234567890, 0)), Ok(1234567890));\n\n        err!(Value::I128(i128::MIN));\n\n        err!(Value::U128(u128::MAX));\n\n        err!(Value::F32(f32::MIN));\n        err!(Value::F64(f64::MIN));\n\n        err!(Value::Decimal(Decimal::new(i64::MIN, 0)));\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Point(point::Point::new(1.0313, 2.0314)));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_decimal() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cDecimal\u003e, $to);\n                assert_eq!(Decimal::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Decimal,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Bool(true), Ok(Decimal::new(1, 0)));\n        test!(Value::Bool(false), Ok(Decimal::new(0, 0)));\n        test!(Value::I8(122), Ok(Decimal::new(122, 0)));\n        test!(Value::I16(122), Ok(Decimal::new(122, 0)));\n        test!(Value::I32(122), Ok(Decimal::new(122, 0)));\n        test!(Value::I64(122), Ok(Decimal::new(122, 0)));\n        test!(Value::I128(122), Ok(Decimal::new(122, 0)));\n        test!(Value::U8(122), Ok(Decimal::new(122, 0)));\n        test!(Value::U16(122), Ok(Decimal::new(122, 0)));\n        test!(Value::U32(122), Ok(Decimal::new(122, 0)));\n        test!(Value::U64(122), Ok(Decimal::new(122, 0)));\n        test!(Value::U128(122), Ok(Decimal::new(122, 0)));\n        test!(Value::F32(122.0_f32), Ok(Decimal::new(122, 0)));\n        test!(Value::F32(122.1_f32), Ok(Decimal::new(1221, 1)));\n        test!(Value::F64(122.0), Ok(Decimal::new(122, 0)));\n        test!(Value::F64(122.1), Ok(Decimal::new(1221, 1)));\n        test!(Value::Str(\"122\".to_owned()), Ok(Decimal::new(122, 0)));\n        test!(\n            Value::Decimal(Decimal::new(122, 0)),\n            Ok(Decimal::new(122, 0))\n        );\n\n        err!(Value::Str(\"text\".to_owned()));\n        err!(Value::Bytea(Vec::new()));\n        err!(Value::Inet(IpAddr::from_str(\"::1\").unwrap()));\n        err!(Value::Date(date(2021, 11, 20)));\n        err!(Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)));\n        err!(Value::Time(time(10, 0, 0, 0)));\n        err!(Value::Interval(I::Month(1)));\n        err!(Value::Uuid(195965723427462096757863453463987888808));\n        err!(Value::Map(HashMap::new()));\n        err!(Value::List(Vec::new()));\n        err!(Value::Null);\n    }\n\n    #[test]\n    fn try_into_naive_date() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cchrono::NaiveDate\u003e, $to);\n                assert_eq!(chrono::NaiveDate::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Date,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Date(date(2021, 11, 20)), Ok(date(2021, 11, 20)));\n        test!(\n            Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)),\n            Ok(date(2021, 11, 20))\n        );\n        test!(Value::Str(\"2021-11-20\".to_owned()), Ok(date(2021, 11, 20)));\n\n        err!(Value::F32(1.0_f32));\n        err!(Value::F64(1.0));\n    }\n\n    #[test]\n    fn try_into_naive_time() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cchrono::NaiveTime\u003e, $to);\n                assert_eq!(chrono::NaiveTime::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Time,\n                    })\n                )\n            };\n        }\n\n        test!(Value::Time(time(10, 0, 0, 0)), Ok(time(10, 0, 0, 0)));\n        test!(Value::Str(\"10:00:00\".to_owned()), Ok(time(10, 0, 0, 0)));\n\n        err!(Value::F32(1.0_f32));\n        err!(Value::F64(1.0));\n    }\n\n    #[test]\n    fn try_into_naive_date_time() {\n        macro_rules! test {\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!((\u0026$from).try_into() as Result\u003cchrono::NaiveDateTime\u003e, $to);\n                assert_eq!(chrono::NaiveDateTime::try_from(\u0026$from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Timestamp,\n                    })\n                )\n            };\n        }\n\n        let datetime = chrono::NaiveDateTime::new;\n        test!(\n            Value::Date(date(2021, 11, 20)),\n            Ok(datetime(date(2021, 11, 20), time(0, 0, 0, 0)))\n        );\n        test!(\n            Value::Timestamp(timestamp(2021, 11, 20, 10, 0, 0, 0)),\n            Ok(datetime(date(2021, 11, 20), time(10, 0, 0, 0)))\n        );\n        test!(\n            Value::Str(\"2021-11-20\".to_owned()),\n            Ok(datetime(date(2021, 11, 20), time(0, 0, 0, 0)))\n        );\n\n        err!(Value::F32(1.0_f32));\n        err!(Value::F64(1.0));\n    }\n\n    #[test]\n    fn try_into_ipaddr() {\n        macro_rules! test {\n            ($from: expr, $to: literal) =\u003e {\n                assert_eq!(IpAddr::try_from($from), Ok(IpAddr::from_str($to).unwrap()));\n            };\n\n            ($from: expr, $to: expr) =\u003e {\n                assert_eq!(IpAddr::try_from($from), $to);\n            };\n        }\n\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                test!(\n                    $from,\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Inet,\n                    })\n                )\n            };\n        }\n\n        test!(\u0026Value::Inet(IpAddr::from_str(\"::1\").unwrap()), \"::1\");\n        test!(\u0026Value::Str(\"127.0.0.1\".to_owned()), \"127.0.0.1\");\n        test!(\u0026Value::Str(\"0.0.0.0\".to_owned()), \"0.0.0.0\");\n        test!(IpAddr::from_str(\"::1\").unwrap(), \"::1\");\n        test!(IpAddr::from_str(\"::2:4cb0:16ea\").unwrap(), \"::2:4cb0:16ea\");\n\n        err!(\u0026Value::Date(date(2021, 11, 20)));\n    }\n\n    #[test]\n    fn try_into_point() {\n        macro_rules! err {\n            ($from: expr) =\u003e {\n                assert_eq!(\n                    Point::try_from($from),\n                    Err(ConvertError {\n                        value: $from.clone(),\n                        data_type: DataType::Point,\n                    })\n                );\n            };\n        }\n\n        assert_eq!(\n            Point::try_from(\u0026Value::Str(\"POINT(0.2 0.1)\".to_owned())),\n            Ok(Point::from_wkt(\"POINT(0.2 0.1)\").unwrap())\n        );\n        assert_eq!(\n            Point::try_from(\u0026Value::Point(Point::new(0.1, 0.2))),\n            Ok(Point::from_wkt(\"POINT(0.1 0.2)\").unwrap())\n        );\n\n        err!(\u0026Value::Date(date(2021, 11, 20)));\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":953,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}},{"line":1020,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1029,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1043,"address":[],"length":0,"stats":{"Line":0}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1048,"address":[],"length":0,"stats":{"Line":0}},{"line":1049,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":489},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","date.rs"],"content":"use chrono::{DateTime, NaiveDate, NaiveDateTime, NaiveTime, offset::Utc};\n\npub fn parse_date(v: \u0026str) -\u003e Option\u003cNaiveDate\u003e {\n    if let Ok(v) = v.parse::\u003cNaiveDate\u003e() {\n        return Some(v);\n    }\n\n    let forms = [\"%Y-%m-%d\", \"%m-%d-%Y\"];\n\n    let v = v.to_uppercase();\n\n    for form in forms.iter() {\n        if let Ok(v) = NaiveDate::parse_from_str(\u0026v, form) {\n            return Some(v);\n        }\n    }\n\n    None\n}\n\npub fn parse_time(v: \u0026str) -\u003e Option\u003cNaiveTime\u003e {\n    if let Ok(v) = v.parse::\u003cNaiveTime\u003e() {\n        return Some(v);\n    }\n\n    let forms = [\n        \"%P %I:%M\",\n        \"%P %l:%M\",\n        \"%P %I:%M:%S\",\n        \"%P %l:%M:%S\",\n        \"%P %I:%M:%S%.f\",\n        \"%P %l:%M:%S%.f\",\n        \"%I:%M %P\",\n        \"%l:%M %P\",\n        \"%I:%M:%S %P\",\n        \"%l:%M:%S %P\",\n        \"%I:%M:%S%.f %P\",\n        \"%l:%M:%S%.f %P\",\n    ];\n\n    let v = v.to_uppercase();\n\n    for form in forms.iter() {\n        if let Ok(v) = NaiveTime::parse_from_str(\u0026v, form) {\n            return Some(v);\n        }\n    }\n\n    None\n}\n\npub fn parse_timestamp(v: \u0026str) -\u003e Option\u003cNaiveDateTime\u003e {\n    if let Ok(v) = v.parse::\u003cDateTime\u003cUtc\u003e\u003e() {\n        return Some(v.naive_utc());\n    } else if let Ok(v) = v.parse::\u003cNaiveDateTime\u003e() {\n        return Some(v);\n    } else if let Ok(v) = v.parse::\u003cNaiveDate\u003e() {\n        return v.and_hms_opt(0, 0, 0);\n    }\n\n    let forms = [\"%Y-%m-%d %H:%M:%S\", \"%Y-%m-%d %H:%M:%S%.f\"];\n\n    for form in forms.iter() {\n        if let Ok(v) = NaiveDateTime::parse_from_str(v, form) {\n            return Some(v);\n        }\n    }\n\n    None\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":0}},{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":34},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","error.rs"],"content":"use {\n    crate::{\n        ast::{DataType, DateTimeField},\n        data::Value,\n    },\n    serde::Serialize,\n    std::fmt::Debug,\n    strum_macros::Display,\n    thiserror::Error,\n};\n\n#[derive(Error, Serialize, Debug, PartialEq)]\npub enum ValueError {\n    #[error(\"literal: {literal} is incompatible with data type: {data_type:?}\")]\n    IncompatibleLiteralForDataType {\n        data_type: DataType,\n        literal: String,\n    },\n\n    #[error(\"incompatible data type, data type: {data_type:#?}, value: {value:#?}\")]\n    IncompatibleDataType { data_type: DataType, value: Value },\n\n    #[error(\"null value on not null field\")]\n    NullValueOnNotNullField,\n\n    #[error(\"failed to parse number\")]\n    FailedToParseNumber,\n\n    #[error(\"failed to convert Float to Decimal: {0}\")]\n    FloatToDecimalConversionFailure(f64),\n\n    #[error(\"failed to parse date: {0}\")]\n    FailedToParseDate(String),\n\n    #[error(\"failed to parse timestamp: {0}\")]\n    FailedToParseTimestamp(String),\n\n    #[error(\"failed to parse time: {0}\")]\n    FailedToParseTime(String),\n\n    #[error(\"failed to UUID: {0}\")]\n    FailedToParseUUID(String),\n\n    #[error(\"failed to parse point: {0}\")]\n    FailedToParsePoint(String),\n\n    #[error(\"failed to parse Decimal: {0}\")]\n    FailedToParseDecimal(String),\n\n    #[error(\"failed to parse hex string: {0}\")]\n    FailedToParseHexString(String),\n\n    #[error(\"failed to parse inet string: {0}\")]\n    FailedToParseInetString(String),\n\n    #[error(\"non-numeric values {lhs:?} {operator} {rhs:?}\")]\n    NonNumericMathOperation {\n        lhs: Value,\n        rhs: Value,\n        operator: NumericBinaryOperator,\n    },\n\n    #[error(\"the divisor should not be zero\")]\n    DivisorShouldNotBeZero,\n\n    #[error(\"unary plus operation for non numeric value\")]\n    UnaryPlusOnNonNumeric,\n\n    #[error(\"unary minus operation for non numeric value\")]\n    UnaryMinusOnNonNumeric,\n\n    #[error(\"unary factorial operation for non numeric value\")]\n    FactorialOnNonNumeric,\n\n    #[error(\"unary factorial operation for non integer value\")]\n    FactorialOnNonInteger,\n\n    #[error(\"unary factorial operation for negative numeric value\")]\n    FactorialOnNegativeNumeric,\n\n    #[error(\"unary factorial operation overflow\")]\n    FactorialOverflow,\n\n    #[error(\"unary bit_not operation for non numeric value\")]\n    UnaryBitwiseNotOnNonNumeric,\n\n    #[error(\"unary bit_not operation for non integer value\")]\n    UnaryBitwiseNotOnNonInteger,\n\n    #[error(\"unreachable failure on parsing number\")]\n    UnreachableNumberParsing,\n\n    #[error(\"unimplemented cast: {value:?} as {data_type}\")]\n    UnimplementedCast { value: Value, data_type: DataType },\n\n    #[error(\"failed to cast from hex string to bytea: {0}\")]\n    CastFromHexToByteaFailed(String),\n\n    // Cast errors from literal to value\n    #[error(\"literal cast failed from text to integer: {0}\")]\n    LiteralCastFromTextToIntegerFailed(String),\n\n    #[error(\"literal cast failed from text to Unsigned Int(8): {0}\")]\n    LiteralCastFromTextToUnsignedInt8Failed(String),\n\n    #[error(\"literal cast failed from text to UINT16: {0}\")]\n    LiteralCastFromTextToUint16Failed(String),\n\n    #[error(\"literal cast failed from text to UINT32: {0}\")]\n    LiteralCastFromTextToUint32Failed(String),\n\n    #[error(\"literal cast failed from text to UINT64: {0}\")]\n    LiteralCastFromTextToUint64Failed(String),\n\n    #[error(\"literal cast failed from text to UINT128: {0}\")]\n    LiteralCastFromTextToUint128Failed(String),\n\n    #[error(\"literal cast failed from text to float: {0}\")]\n    LiteralCastFromTextToFloatFailed(String),\n\n    #[error(\"literal cast failed from text to decimal: {0}\")]\n    LiteralCastFromTextToDecimalFailed(String),\n\n    #[error(\"literal cast failed to boolean: {0}\")]\n    LiteralCastToBooleanFailed(String),\n\n    #[error(\"literal cast failed to date: {0}\")]\n    LiteralCastToDateFailed(String),\n\n    #[error(\"literal cast from {1} to {0} failed\")]\n    LiteralCastToDataTypeFailed(DataType, String),\n\n    #[error(\"literal cast failed to Int(8): {0}\")]\n    LiteralCastToInt8Failed(String),\n\n    #[error(\"literal cast failed to Unsigned Int(8): {0}\")]\n    LiteralCastToUnsignedInt8Failed(String),\n\n    #[error(\"literal cast failed to UINT16: {0}\")]\n    LiteralCastToUint16Failed(String),\n\n    #[error(\"literal cast failed to UNIT32: {0}\")]\n    LiteralCastToUint32Failed(String),\n\n    #[error(\"literal cast failed to UNIT64: {0}\")]\n    LiteralCastToUint64Failed(String),\n\n    #[error(\"literal cast failed to UNIT128: {0}\")]\n    LiteralCastToUint128Failed(String),\n\n    #[error(\"literal cast failed to time: {0}\")]\n    LiteralCastToTimeFailed(String),\n\n    #[error(\"literal cast failed to timestamp: {0}\")]\n    LiteralCastToTimestampFailed(String),\n\n    #[error(\"unreachable literal cast from number to integer: {0}\")]\n    UnreachableLiteralCastFromNumberToInteger(String),\n\n    #[error(\"unreachable literal cast from number to float: {0}\")]\n    UnreachableLiteralCastFromNumberToFloat(String),\n\n    #[error(\"unimplemented literal cast: {literal} as {data_type:?}\")]\n    UnimplementedLiteralCast {\n        data_type: DataType,\n        literal: String,\n    },\n\n    #[error(\"unreachable integer overflow: {0}\")]\n    UnreachableIntegerOverflow(String),\n\n    #[error(\"operator doesn't exist: {base:?} {case} {pattern:?}\", case = if *case_sensitive { \"LIKE\" } else { \"ILIKE\" })]\n    LikeOnNonString {\n        base: Value,\n        pattern: Value,\n        case_sensitive: bool,\n    },\n\n    #[error(\"extract format not matched: {value:?} FROM {field:?})\")]\n    ExtractFormatNotMatched { value: Value, field: DateTimeField },\n\n    #[error(\"big endian export not supported for {0} type\")]\n    BigEndianExportNotSupported(String),\n\n    #[error(\"invalid json string: {0}\")]\n    InvalidJsonString(String),\n\n    #[error(\"json object type is required\")]\n    JsonObjectTypeRequired,\n\n    #[error(\"json array type is required\")]\n    JsonArrayTypeRequired,\n\n    #[error(\"unreachable - failed to parse json number: {0}\")]\n    UnreachableJsonNumberParseFailure(String),\n\n    #[error(\"selector requires MAP or LIST types\")]\n    SelectorRequiresMapOrListTypes,\n\n    #[error(\"overflow occurred: {lhs:?} {operator} {rhs:?}\")]\n    BinaryOperationOverflow {\n        lhs: Value,\n        rhs: Value,\n        operator: NumericBinaryOperator,\n    },\n\n    #[error(\"non numeric value in sqrt {0:?}\")]\n    SqrtOnNonNumeric(Value),\n\n    #[error(\"non-string parameter in position: {} IN {}\", String::from(.from), String::from(.sub))]\n    NonStringParameterInPosition { from: Value, sub: Value },\n\n    #[error(\"non-string parameter in find idx: {}, {}\", String::from(.sub), String::from(.from))]\n    NonStringParameterInFindIdx { sub: Value, from: Value },\n\n    #[error(\"non positive offset in find idx: {0}\")]\n    NonPositiveIntegerOffsetInFindIdx(String),\n\n    #[error(\"failed to convert Value to Expr\")]\n    ValueToExprConversionFailure,\n}\n\n#[derive(Debug, PartialEq, Eq, Serialize, Display)]\npub enum NumericBinaryOperator {\n    #[strum(to_string = \"+\")]\n    Add,\n    #[strum(to_string = \"-\")]\n    Subtract,\n    #[strum(to_string = \"*\")]\n    Multiply,\n    #[strum(to_string = \"/\")]\n    Divide,\n    #[strum(to_string = \"%\")]\n    Modulo,\n    #[strum(to_string = \"\u0026\")]\n    BitwiseAnd,\n    #[strum(to_string = \"\u003c\u003c\")]\n    BitwiseShiftLeft,\n    #[strum(to_string = \"\u003e\u003e\")]\n    BitwiseShiftRight,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","expr.rs"],"content":"use {\n    super::ValueError::ValueToExprConversionFailure,\n    crate::{\n        ast::{AstLiteral, DateTimeField, Expr},\n        chrono::{TimeZone, Utc},\n        data::Interval,\n        prelude::{DataType, Value},\n        result::{Error, Result},\n    },\n    bigdecimal::{BigDecimal, FromPrimitive},\n    serde_json::{Map as JsonMap, Value as JsonValue},\n    uuid::Uuid,\n};\n\nimpl TryFrom\u003cValue\u003e for Expr {\n    type Error = Error;\n\n    fn try_from(value: Value) -\u003e Result\u003cSelf\u003e {\n        const SECOND: i64 = 1_000_000;\n\n        let expr = match value {\n            Value::Bool(v) =\u003e Expr::Literal(AstLiteral::Boolean(v)),\n            Value::I8(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_i8(v).ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::I16(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_i16(v).ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::I32(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_i32(v).ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::I64(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_i64(v).ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::I128(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_i128(v).ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::U8(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_u8(v).ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::U16(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_u16(v).ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::U32(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_u32(v).ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::U64(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_u64(v).ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::U128(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_u128(v).ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::F32(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_f32(v).ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::F64(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_f64(v).ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::Decimal(v) =\u003e Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_f64(v.try_into().map_err(|_| ValueToExprConversionFailure)?)\n                    .ok_or(ValueToExprConversionFailure)?,\n            )),\n            Value::Str(v) =\u003e Expr::Literal(AstLiteral::QuotedString(v)),\n            Value::Bytea(v) =\u003e Expr::Literal(AstLiteral::HexString(hex::encode(v))),\n            Value::Inet(v) =\u003e Expr::Literal(AstLiteral::QuotedString(v.to_string())),\n            Value::Date(v) =\u003e Expr::TypedString {\n                data_type: DataType::Date,\n                value: v.to_string(),\n            },\n            Value::Timestamp(v) =\u003e Expr::TypedString {\n                data_type: DataType::Timestamp,\n                value: Utc.from_utc_datetime(\u0026v).to_string(),\n            },\n            Value::Time(v) =\u003e Expr::TypedString {\n                data_type: DataType::Time,\n                value: v.to_string(),\n            },\n            Value::Interval(v) =\u003e match v {\n                Interval::Month(v) =\u003e Expr::Interval {\n                    expr: Box::new(Expr::Literal(AstLiteral::Number(\n                        BigDecimal::from_i32(v).ok_or(ValueToExprConversionFailure)?,\n                    ))),\n                    leading_field: Some(DateTimeField::Month),\n                    last_field: None,\n                },\n                Interval::Microsecond(v) =\u003e Expr::Interval {\n                    expr: Box::new(Expr::Literal(AstLiteral::Number(\n                        BigDecimal::from_i64(v / SECOND).ok_or(ValueToExprConversionFailure)?,\n                    ))),\n                    leading_field: Some(DateTimeField::Second),\n                    last_field: None,\n                },\n            },\n            Value::Uuid(v) =\u003e Expr::Literal(AstLiteral::QuotedString(\n                Uuid::from_u128(v).hyphenated().to_string(),\n            )),\n            Value::Map(v) =\u003e {\n                let json: JsonValue = v\n                    .into_iter()\n                    .map(|(key, value)| value.try_into().map(|value| (key, value)))\n                    .collect::\u003cResult\u003cVec\u003c(String, JsonValue)\u003e\u003e\u003e()\n                    .map(|v| JsonMap::from_iter(v).into())\n                    .map_err(|_| ValueToExprConversionFailure)?;\n\n                Expr::Literal(AstLiteral::QuotedString(json.to_string()))\n            }\n            Value::List(v) =\u003e {\n                let json: JsonValue = v\n                    .into_iter()\n                    .map(|value| value.try_into())\n                    .collect::\u003cResult\u003cVec\u003cJsonValue\u003e\u003e\u003e()\n                    .map(|v| v.into())\n                    .map_err(|_| ValueToExprConversionFailure)?;\n\n                Expr::Literal(AstLiteral::QuotedString(json.to_string()))\n            }\n            Value::Point(v) =\u003e Expr::Literal(AstLiteral::QuotedString(v.to_string())),\n            Value::Null =\u003e Expr::Literal(AstLiteral::Null),\n        };\n\n        Ok(expr)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            ast::{AstLiteral, DateTimeField, Expr},\n            data::{Interval, Point},\n            prelude::{DataType, Value},\n        },\n        bigdecimal::{BigDecimal, FromPrimitive},\n        chrono::{NaiveDate, NaiveTime},\n        rust_decimal::Decimal,\n        std::collections::HashMap,\n    };\n\n    #[test]\n    fn value_to_expr() {\n        assert_eq!(\n            Value::Bool(true).try_into(),\n            Ok(Expr::Literal(AstLiteral::Boolean(true)))\n        );\n\n        assert_eq!(\n            Value::I8(127).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_i8(127).unwrap()\n            )))\n        );\n        assert_eq!(\n            Value::I16(32767).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_i16(32767).unwrap()\n            )))\n        );\n        assert_eq!(\n            Value::I32(2147483647).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_i32(2147483647).unwrap()\n            )))\n        );\n        assert_eq!(\n            Value::I64(64).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_i64(64).unwrap()\n            )))\n        );\n        assert_eq!(\n            Value::I128(128).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_i128(128).unwrap()\n            )))\n        );\n        assert_eq!(\n            Value::U8(8).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_u8(8).unwrap()\n            )))\n        );\n        assert_eq!(\n            Value::U16(16).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_u16(16).unwrap()\n            )))\n        );\n        assert_eq!(\n            Value::U32(32).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_u32(32).unwrap()\n            )))\n        );\n        assert_eq!(\n            Value::U64(64).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_u64(64).unwrap()\n            )))\n        );\n        assert_eq!(\n            Value::U128(128).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_u128(128).unwrap()\n            )))\n        );\n\n        assert_eq!(\n            Value::F32(64.4_f32).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_f32(64.4).unwrap()\n            )))\n        );\n        assert_eq!(\n            Value::F64(64.4).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_f64(64.4).unwrap()\n            )))\n        );\n        assert_eq!(\n            Value::Decimal(Decimal::new(315, 2)).try_into(),\n            Ok(Expr::Literal(AstLiteral::Number(\n                BigDecimal::from_f64(3.15).unwrap()\n            )))\n        );\n        assert_eq!(\n            Value::Str(\"data\".to_owned()).try_into(),\n            Ok(Expr::Literal(AstLiteral::QuotedString(\"data\".to_owned())))\n        );\n        assert_eq!(\n            Value::Bytea(hex::decode(\"1234\").unwrap()).try_into(),\n            Ok(Expr::Literal(AstLiteral::HexString(\"1234\".to_owned())))\n        );\n        assert_eq!(\n            Value::Date(NaiveDate::from_ymd_opt(2022, 11, 3).unwrap()).try_into(),\n            Ok(Expr::TypedString {\n                data_type: DataType::Date,\n                value: \"2022-11-03\".to_owned(),\n            })\n        );\n        assert_eq!(\n            Value::Timestamp(\n                NaiveDate::from_ymd_opt(2022, 11, 3)\n                    .unwrap()\n                    .and_hms_milli_opt(8, 5, 30, 900)\n                    .unwrap()\n            )\n            .try_into(),\n            Ok(Expr::TypedString {\n                data_type: DataType::Timestamp,\n                value: \"2022-11-03 08:05:30.900 UTC\".to_owned(),\n            }),\n        );\n        assert_eq!(\n            Value::Time(NaiveTime::from_hms_opt(20, 11, 59).unwrap()).try_into(),\n            Ok(Expr::TypedString {\n                data_type: DataType::Time,\n                value: \"20:11:59\".to_owned()\n            }),\n        );\n        assert_eq!(\n            Value::Interval(Interval::Month(1)).try_into(),\n            Ok(Expr::Interval {\n                expr: Box::new(Expr::Literal(AstLiteral::Number(\n                    BigDecimal::from_i64(1).unwrap()\n                ))),\n                leading_field: Some(DateTimeField::Month),\n                last_field: None\n            })\n        );\n        assert_eq!(\n            Value::Uuid(195965723427462096757863453463987888808).try_into(),\n            Ok(Expr::Literal(AstLiteral::QuotedString(\n                \"936da01f-9abd-4d9d-80c7-02af85c822a8\".to_owned()\n            )))\n        );\n        assert_eq!(\n            Value::Map(HashMap::from([(\"a\".to_owned(), Value::Bool(true))])).try_into(),\n            Ok(Expr::Literal(AstLiteral::QuotedString(\n                \"{\\\"a\\\":true}\".to_owned()\n            )))\n        );\n        assert_eq!(\n            Value::List(vec![\n                Value::I64(1),\n                Value::Bool(true),\n                Value::Str(\"a\".to_owned())\n            ])\n            .try_into(),\n            Ok(Expr::Literal(AstLiteral::QuotedString(\n                \"[1,true,\\\"a\\\"]\".to_owned()\n            )))\n        );\n        assert_eq!(Value::Null.try_into(), Ok(Expr::Literal(AstLiteral::Null)));\n        assert_eq!(\n            Value::Point(Point::new(0.31413, 0.3415)).try_into(),\n            Ok(Expr::Literal(AstLiteral::QuotedString(\n                \"POINT(0.31413 0.3415)\".to_owned()\n            )))\n        );\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":55},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","json.rs"],"content":"use {\n    super::{Value, ValueError},\n    crate::result::{Error, Result},\n    chrono::{TimeZone, offset::Utc},\n    core::str::FromStr,\n    serde_json::{Map as JsonMap, Number as JsonNumber, Value as JsonValue},\n    std::collections::HashMap,\n    uuid::Uuid,\n};\n\npub trait HashMapJsonExt {\n    fn parse_json_object(value: \u0026str) -\u003e Result\u003cHashMap\u003cString, Value\u003e\u003e;\n\n    fn try_from_json_map(json_map: JsonMap\u003cString, JsonValue\u003e) -\u003e Result\u003cHashMap\u003cString, Value\u003e\u003e;\n}\n\nimpl HashMapJsonExt for HashMap\u003cString, Value\u003e {\n    fn parse_json_object(value: \u0026str) -\u003e Result\u003cHashMap\u003cString, Value\u003e\u003e {\n        let value = serde_json::from_str(value)\n            .map_err(|_| ValueError::InvalidJsonString(value.to_owned()))?;\n\n        match value {\n            JsonValue::Object(json_map) =\u003e HashMap::try_from_json_map(json_map),\n            _ =\u003e Err(ValueError::JsonObjectTypeRequired.into()),\n        }\n    }\n\n    fn try_from_json_map(json_map: JsonMap\u003cString, JsonValue\u003e) -\u003e Result\u003cHashMap\u003cString, Value\u003e\u003e {\n        json_map\n            .into_iter()\n            .map(|(key, value)| value.try_into().map(|value| (key, value)))\n            .collect::\u003cResult\u003cHashMap\u003cString, Value\u003e\u003e\u003e()\n    }\n}\n\nimpl Value {\n    pub fn parse_json_map(value: \u0026str) -\u003e Result\u003cValue\u003e {\n        HashMap::parse_json_object(value).map(Value::Map)\n    }\n\n    pub fn parse_json_list(value: \u0026str) -\u003e Result\u003cValue\u003e {\n        let value = serde_json::from_str(value)\n            .map_err(|_| ValueError::InvalidJsonString(value.to_owned()))?;\n\n        if !matches!(value, JsonValue::Array(_)) {\n            return Err(ValueError::JsonArrayTypeRequired.into());\n        }\n\n        value.try_into()\n    }\n}\n\nimpl TryFrom\u003cValue\u003e for JsonValue {\n    type Error = Error;\n\n    fn try_from(value: Value) -\u003e Result\u003cSelf\u003e {\n        match value {\n            Value::Bool(v) =\u003e Ok(JsonValue::Bool(v)),\n            Value::I8(v) =\u003e Ok(v.into()),\n            Value::I16(v) =\u003e Ok(v.into()),\n            Value::I32(v) =\u003e Ok(v.into()),\n            Value::I64(v) =\u003e Ok(v.into()),\n            Value::I128(v) =\u003e JsonNumber::from_str(\u0026v.to_string())\n                .map(JsonValue::Number)\n                .map_err(|_| ValueError::UnreachableJsonNumberParseFailure(v.to_string()).into()),\n            Value::U8(v) =\u003e Ok(v.into()),\n            Value::U16(v) =\u003e Ok(v.into()),\n            Value::U32(v) =\u003e Ok(v.into()),\n            Value::U64(v) =\u003e Ok(v.into()),\n            Value::U128(v) =\u003e JsonNumber::from_str(\u0026v.to_string())\n                .map(JsonValue::Number)\n                .map_err(|_| ValueError::UnreachableJsonNumberParseFailure(v.to_string()).into()),\n            Value::F32(v) =\u003e Ok(v.into()),\n            Value::F64(v) =\u003e Ok(v.into()),\n            Value::Decimal(v) =\u003e JsonNumber::from_str(\u0026v.to_string())\n                .map(JsonValue::Number)\n                .map_err(|_| ValueError::UnreachableJsonNumberParseFailure(v.to_string()).into()),\n            Value::Str(v) =\u003e Ok(v.into()),\n            Value::Bytea(v) =\u003e Ok(hex::encode(v).into()),\n            Value::Inet(v) =\u003e Ok(v.to_string().into()),\n            Value::Date(v) =\u003e Ok(v.to_string().into()),\n            Value::Timestamp(v) =\u003e Ok(Utc.from_utc_datetime(\u0026v).to_string().into()),\n            Value::Time(v) =\u003e Ok(v.to_string().into()),\n            Value::Interval(v) =\u003e Ok(v.to_sql_str().into()),\n            Value::Uuid(v) =\u003e Ok(Uuid::from_u128(v).hyphenated().to_string().into()),\n            Value::Map(v) =\u003e v\n                .into_iter()\n                .map(|(key, value)| value.try_into().map(|value| (key, value)))\n                .collect::\u003cResult\u003cVec\u003c(String, JsonValue)\u003e\u003e\u003e()\n                .map(|v| JsonMap::from_iter(v).into()),\n            Value::List(v) =\u003e v\n                .into_iter()\n                .map(|value| value.try_into())\n                .collect::\u003cResult\u003cVec\u003cJsonValue\u003e\u003e\u003e()\n                .map(|v| v.into()),\n            Value::Point(v) =\u003e Ok(v.to_string().into()),\n            Value::Null =\u003e Ok(JsonValue::Null),\n        }\n    }\n}\n\nimpl TryFrom\u003cJsonValue\u003e for Value {\n    type Error = Error;\n\n    fn try_from(json_value: JsonValue) -\u003e Result\u003cSelf\u003e {\n        match json_value {\n            JsonValue::Null =\u003e Ok(Value::Null),\n            JsonValue::Bool(v) =\u003e Ok(Value::Bool(v)),\n            JsonValue::Number(v) =\u003e {\n                if let Some(value) = v.as_i64().map(Value::I64) {\n                    return Ok(value);\n                }\n\n                v.as_f64().map(Value::F64).ok_or_else(|| {\n                    ValueError::UnreachableJsonNumberParseFailure(v.to_string()).into()\n                })\n            }\n            JsonValue::String(v) =\u003e Ok(Value::Str(v)),\n            JsonValue::Array(json_array) =\u003e json_array\n                .into_iter()\n                .map(Value::try_from)\n                .collect::\u003cResult\u003cVec\u003cValue\u003e\u003e\u003e()\n                .map(Value::List),\n            JsonValue::Object(json_map) =\u003e json_map\n                .into_iter()\n                .map(|(key, value)| value.try_into().map(|value| (key, value)))\n                .collect::\u003cResult\u003cHashMap\u003cString, Value\u003e\u003e\u003e()\n                .map(Value::Map),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::data::{Interval, Point, Value, ValueError, value::uuid::parse_uuid},\n        chrono::{NaiveDate, NaiveTime},\n        rust_decimal::Decimal,\n        serde_json::{Number as JsonNumber, Value as JsonValue, json},\n        std::{net::IpAddr, str::FromStr},\n    };\n\n    #[test]\n    fn parse_json() {\n        assert_eq!(\n            Value::parse_json_map(\"[1, 2, 3]\"),\n            Err(ValueError::JsonObjectTypeRequired.into())\n        );\n        assert_eq!(\n            Value::parse_json_list(r#\"{ \"a\": 30 }\"#),\n            Err(ValueError::JsonArrayTypeRequired.into())\n        );\n    }\n\n    #[test]\n    fn value_to_json() {\n        assert_eq!(Value::Bool(true).try_into(), Ok(JsonValue::Bool(true)));\n        assert_eq!(Value::I8(16).try_into(), Ok(JsonValue::Number(16.into())));\n        assert_eq!(\n            Value::I16(100).try_into(),\n            Ok(JsonValue::Number(100.into()))\n        );\n        assert_eq!(\n            Value::I32(100).try_into(),\n            Ok(JsonValue::Number(100.into()))\n        );\n        assert_eq!(\n            Value::I64(100).try_into(),\n            Ok(JsonValue::Number(100.into()))\n        );\n        assert_eq!(\n            Value::I128(100).try_into(),\n            Ok(JsonValue::Number(100.into()))\n        );\n        assert_eq!(Value::U8(100).try_into(), Ok(JsonValue::Number(100.into())));\n        assert_eq!(\n            Value::U16(100).try_into(),\n            Ok(JsonValue::Number(100.into()))\n        );\n        assert_eq!(\n            Value::U32(100).try_into(),\n            Ok(JsonValue::Number(100.into()))\n        );\n        assert_eq!(\n            Value::U64(100).try_into(),\n            Ok(JsonValue::Number(100.into()))\n        );\n        assert_eq!(\n            Value::U128(100).try_into(),\n            Ok(JsonValue::Number(100.into()))\n        );\n        assert!(JsonValue::try_from(Value::I128(i128::MAX)).is_ok());\n\n        assert_eq!(\n            Value::F32(1.23_f32).try_into(),\n            Ok(JsonValue::Number(\n                JsonNumber::from_f64(1.23_f32 as f64).unwrap()\n            ))\n        );\n        assert_eq!(\n            Value::F64(1.23).try_into(),\n            Ok(JsonValue::Number(JsonNumber::from_f64(1.23).unwrap()))\n        );\n        assert_eq!(\n            Value::Decimal(Decimal::ONE).try_into(),\n            Ok(JsonValue::Number(1.into()))\n        );\n        assert_eq!(\n            Value::Str(\"abc\".to_owned()).try_into(),\n            Ok(JsonValue::String(\"abc\".to_owned()))\n        );\n        assert_eq!(\n            Value::Bytea(hex::decode(\"a1b2\").unwrap()).try_into(),\n            Ok(JsonValue::String(\"a1b2\".to_owned()))\n        );\n        assert_eq!(\n            Value::Inet(IpAddr::from_str(\"::1\").unwrap()).try_into(),\n            Ok(JsonValue::String(\"::1\".to_owned()))\n        );\n        assert_eq!(\n            Value::Date(NaiveDate::from_ymd_opt(2020, 1, 3).unwrap()).try_into(),\n            Ok(JsonValue::String(\"2020-01-03\".to_owned()))\n        );\n        assert_eq!(\n            Value::Timestamp(\n                NaiveDate::from_ymd_opt(2022, 6, 11)\n                    .unwrap()\n                    .and_hms_opt(13, 30, 1)\n                    .unwrap()\n            )\n            .try_into(),\n            Ok(JsonValue::String(\"2022-06-11 13:30:01 UTC\".to_owned()))\n        );\n        assert_eq!(\n            Value::Time(NaiveTime::from_hms_opt(20, 11, 59).unwrap()).try_into(),\n            Ok(JsonValue::String(\"20:11:59\".to_owned()))\n        );\n        assert_eq!(\n            Value::Interval(Interval::Month(17)).try_into(),\n            Ok(JsonValue::String(\"'1-5' YEAR TO MONTH\".to_owned()))\n        );\n\n        let uuid = \"43185717-59af-4e2b-9cd3-3264bf3691a4\";\n        assert_eq!(\n            Value::Uuid(parse_uuid(uuid).unwrap()).try_into(),\n            Ok(JsonValue::String(uuid.to_owned()))\n        );\n\n        assert_eq!(\n            Value::parse_json_map(r#\"{ \"a\": 10, \"b\": { \"c\": true, \"d\": \"hello\" }}\"#)\n                .unwrap()\n                .try_into(),\n            Ok(json!({\n                \"a\": 10,\n                \"b\": {\n                    \"c\": true,\n                    \"d\": \"hello\",\n                }\n            }))\n        );\n        assert_eq!(\n            Value::parse_json_list(r#\"[1, 2, { \"a\": 3 }]\"#)\n                .unwrap()\n                .try_into(),\n            Ok(json!([1, 2, { \"a\": 3 }]))\n        );\n        assert_eq!(\n            Value::Point(Point::new(0.34, 0.56)).try_into(),\n            Ok(JsonValue::String(\"POINT(0.34 0.56)\".to_owned()))\n        );\n        assert_eq!(Value::Null.try_into(), Ok(JsonValue::Null));\n    }\n\n    #[test]\n    fn json_to_value() {\n        assert!(Value::try_from(JsonValue::Null).unwrap().is_null());\n        assert!(\n            Value::try_from(JsonValue::Bool(false))\n                .unwrap()\n                .evaluate_eq(\u0026Value::Bool(false))\n        );\n        assert!(\n            Value::try_from(JsonValue::Number(54321.into()))\n                .unwrap()\n                .evaluate_eq(\u0026Value::I32(54321))\n        );\n        assert!(\n            Value::try_from(JsonValue::Number(54321.into()))\n                .unwrap()\n                .evaluate_eq(\u0026Value::I64(54321))\n        );\n        assert!(\n            Value::try_from(JsonValue::Number(54321.into()))\n                .unwrap()\n                .evaluate_eq(\u0026Value::I128(54321))\n        );\n        assert!(\n            Value::try_from(JsonValue::Number(JsonNumber::from_f64(3.21).unwrap()))\n                .unwrap()\n                .evaluate_eq(\u0026Value::F64(3.21))\n        );\n        assert!(\n            Value::try_from(JsonValue::String(\"world\".to_owned()))\n                .unwrap()\n                .evaluate_eq(\u0026Value::Str(\"world\".to_owned()))\n        );\n        assert!(\n            Value::try_from(JsonValue::Array(vec![JsonValue::Bool(true)]))\n                .unwrap()\n                .evaluate_eq(\u0026Value::List(vec![Value::Bool(true)]))\n        );\n        assert!(\n            Value::try_from(json!({ \"a\": true }))\n                .unwrap()\n                .evaluate_eq(\u0026Value::Map(\n                    [(\"a\".to_owned(), Value::Bool(true))].into_iter().collect()\n                ))\n        );\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":69},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","literal.rs"],"content":"use {\n    super::{\n        Value,\n        date::{parse_date, parse_time, parse_timestamp},\n        error::ValueError,\n    },\n    crate::{\n        ast::DataType,\n        data::{BigDecimalExt, Interval, Literal, Point, value::uuid::parse_uuid},\n        result::{Error, Result},\n    },\n    bigdecimal::BigDecimal,\n    chrono::NaiveDate,\n    rust_decimal::Decimal,\n    std::{\n        cmp::Ordering,\n        net::{IpAddr, Ipv4Addr, Ipv6Addr},\n        str::FromStr,\n    },\n};\n\nimpl TryFrom\u003c\u0026Literal\u003c'_\u003e\u003e for Value {\n    type Error = Error;\n\n    fn try_from(literal: \u0026Literal\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        match literal {\n            Literal::Number(v) =\u003e v\n                .to_i64()\n                .map(Value::I64)\n                .or_else(|| v.to_f64().map(Value::F64))\n                .ok_or_else(|| ValueError::FailedToParseNumber.into()),\n            Literal::Boolean(v) =\u003e Ok(Value::Bool(*v)),\n            Literal::Text(v) =\u003e Ok(Value::Str(v.as_ref().to_owned())),\n            Literal::Bytea(v) =\u003e Ok(Value::Bytea(v.to_vec())),\n            Literal::Null =\u003e Ok(Value::Null),\n        }\n    }\n}\n\nimpl TryFrom\u003cLiteral\u003c'_\u003e\u003e for Value {\n    type Error = Error;\n\n    fn try_from(literal: Literal\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        match literal {\n            Literal::Text(v) =\u003e Ok(Value::Str(v.into_owned())),\n            _ =\u003e Value::try_from(\u0026literal),\n        }\n    }\n}\n\nimpl Value {\n    pub fn evaluate_eq_with_literal(\u0026self, other: \u0026Literal\u003c'_\u003e) -\u003e bool {\n        match (self, other) {\n            (Value::Bool(l), Literal::Boolean(r)) =\u003e l == r,\n            (Value::I8(l), Literal::Number(r)) =\u003e r.to_i8().map(|r| *l == r).unwrap_or(false),\n            (Value::I16(l), Literal::Number(r)) =\u003e r.to_i16().map(|r| *l == r).unwrap_or(false),\n            (Value::I32(l), Literal::Number(r)) =\u003e r.to_i32().map(|r| *l == r).unwrap_or(false),\n            (Value::I64(l), Literal::Number(r)) =\u003e r.to_i64().map(|r| *l == r).unwrap_or(false),\n            (Value::I128(l), Literal::Number(r)) =\u003e r.to_i128().map(|r| *l == r).unwrap_or(false),\n            (Value::U8(l), Literal::Number(r)) =\u003e r.to_u8().map(|r| *l == r).unwrap_or(false),\n            (Value::U16(l), Literal::Number(r)) =\u003e r.to_u16().map(|r| *l == r).unwrap_or(false),\n            (Value::U32(l), Literal::Number(r)) =\u003e r.to_u32().map(|r| *l == r).unwrap_or(false),\n            (Value::U64(l), Literal::Number(r)) =\u003e r.to_u64().map(|r| *l == r).unwrap_or(false),\n            (Value::U128(l), Literal::Number(r)) =\u003e r.to_u128().map(|r| *l == r).unwrap_or(false),\n            (Value::F32(l), Literal::Number(r)) =\u003e r.to_f32().map(|r| *l == r).unwrap_or(false),\n            (Value::F64(l), Literal::Number(r)) =\u003e r.to_f64().map(|r| *l == r).unwrap_or(false),\n            (Value::Str(l), Literal::Text(r)) =\u003e l == r.as_ref(),\n            (Value::Bytea(l), Literal::Bytea(r)) =\u003e l == r,\n            (Value::Date(l), Literal::Text(r)) =\u003e match r.parse::\u003cNaiveDate\u003e() {\n                Ok(r) =\u003e l == \u0026r,\n                Err(_) =\u003e false,\n            },\n            (Value::Timestamp(l), Literal::Text(r)) =\u003e match parse_timestamp(r) {\n                Some(r) =\u003e l == \u0026r,\n                None =\u003e false,\n            },\n            (Value::Time(l), Literal::Text(r)) =\u003e match parse_time(r) {\n                Some(r) =\u003e l == \u0026r,\n                None =\u003e false,\n            },\n            (Value::Uuid(l), Literal::Text(r)) =\u003e parse_uuid(r).map(|r| l == \u0026r).unwrap_or(false),\n            (Value::Inet(l), Literal::Text(r)) =\u003e match IpAddr::from_str(r) {\n                Ok(x) =\u003e l == \u0026x,\n                Err(_) =\u003e false,\n            },\n            (Value::Inet(l), Literal::Number(r)) =\u003e {\n                if let Some(x) = r.to_u32() {\n                    l == \u0026Ipv4Addr::from(x)\n                } else if let Some(x) = r.to_u128() {\n                    l == \u0026Ipv6Addr::from(x)\n                } else {\n                    false\n                }\n            }\n            (Value::Null, Literal::Null) =\u003e false,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn evaluate_cmp_with_literal(\u0026self, other: \u0026Literal\u003c'_\u003e) -\u003e Option\u003cOrdering\u003e {\n        match (self, other) {\n            (Value::I8(l), Literal::Number(r)) =\u003e l.partial_cmp(\u0026r.to_i8()?),\n            (Value::I16(l), Literal::Number(r)) =\u003e l.partial_cmp(\u0026r.to_i16()?),\n            (Value::I32(l), Literal::Number(r)) =\u003e l.partial_cmp(\u0026r.to_i32()?),\n            (Value::I64(l), Literal::Number(r)) =\u003e l.partial_cmp(\u0026r.to_i64()?),\n            (Value::I128(l), Literal::Number(r)) =\u003e l.partial_cmp(\u0026r.to_i128()?),\n            (Value::U8(l), Literal::Number(r)) =\u003e l.partial_cmp(\u0026r.to_u8()?),\n            (Value::U16(l), Literal::Number(r)) =\u003e l.partial_cmp(\u0026r.to_u16()?),\n            (Value::U32(l), Literal::Number(r)) =\u003e l.partial_cmp(\u0026r.to_u32()?),\n            (Value::U64(l), Literal::Number(r)) =\u003e l.partial_cmp(\u0026r.to_u64()?),\n            (Value::U128(l), Literal::Number(r)) =\u003e l.partial_cmp(\u0026r.to_u128()?),\n            (Value::F32(l), Literal::Number(r)) =\u003e l.partial_cmp(\u0026r.to_f32()?),\n            (Value::F64(l), Literal::Number(r)) =\u003e l.partial_cmp(\u0026r.to_f64()?),\n            (Value::Decimal(l), Literal::Number(r)) =\u003e {\n                BigDecimal::new(l.mantissa().into(), l.scale() as i64).partial_cmp(r)\n            }\n            (Value::Str(l), Literal::Text(r)) =\u003e Some(l.as_str().cmp(r)),\n            (Value::Date(l), Literal::Text(r)) =\u003e l.partial_cmp(\u0026r.parse::\u003cNaiveDate\u003e().ok()?),\n            (Value::Timestamp(l), Literal::Text(r)) =\u003e l.partial_cmp(\u0026parse_timestamp(r)?),\n            (Value::Time(l), Literal::Text(r)) =\u003e l.partial_cmp(\u0026parse_time(r)?),\n            (Value::Uuid(l), Literal::Text(r)) =\u003e l.partial_cmp(\u0026parse_uuid(r).ok()?),\n            (Value::Inet(l), Literal::Text(r)) =\u003e l.partial_cmp(\u0026IpAddr::from_str(r).ok()?),\n            (Value::Inet(l), Literal::Number(r)) =\u003e {\n                if let Some(x) = r.to_u32() {\n                    l.partial_cmp(\u0026Ipv4Addr::from(x))\n                } else if let Some(x) = r.to_u128() {\n                    l.partial_cmp(\u0026Ipv6Addr::from(x))\n                } else {\n                    None\n                }\n            }\n            _ =\u003e None,\n        }\n    }\n\n    pub fn try_from_literal(data_type: \u0026DataType, literal: \u0026Literal\u003c'_\u003e) -\u003e Result\u003cValue\u003e {\n        match (data_type, literal) {\n            (DataType::Boolean, Literal::Boolean(v)) =\u003e Ok(Value::Bool(*v)),\n            (DataType::Int8, Literal::Number(v)) =\u003e v\n                .to_i8()\n                .map(Value::I8)\n                .ok_or_else(|| ValueError::FailedToParseNumber.into()),\n            (DataType::Int16, Literal::Number(v)) =\u003e v\n                .to_i16()\n                .map(Value::I16)\n                .ok_or_else(|| ValueError::FailedToParseNumber.into()),\n            (DataType::Int32, Literal::Number(v)) =\u003e v\n                .to_i32()\n                .map(Value::I32)\n                .ok_or_else(|| ValueError::FailedToParseNumber.into()),\n            (DataType::Int, Literal::Number(v)) =\u003e v\n                .to_i64()\n                .map(Value::I64)\n                .ok_or_else(|| ValueError::FailedToParseNumber.into()),\n            (DataType::Int128, Literal::Number(v)) =\u003e v\n                .to_i128()\n                .map(Value::I128)\n                .ok_or_else(|| ValueError::FailedToParseNumber.into()),\n            (DataType::Uint8, Literal::Number(v)) =\u003e v\n                .to_u8()\n                .map(Value::U8)\n                .ok_or_else(|| ValueError::FailedToParseNumber.into()),\n            (DataType::Uint16, Literal::Number(v)) =\u003e v\n                .to_u16()\n                .map(Value::U16)\n                .ok_or_else(|| ValueError::FailedToParseNumber.into()),\n            (DataType::Uint32, Literal::Number(v)) =\u003e v\n                .to_u32()\n                .map(Value::U32)\n                .ok_or_else(|| ValueError::FailedToParseNumber.into()),\n            (DataType::Uint64, Literal::Number(v)) =\u003e v\n                .to_u64()\n                .map(Value::U64)\n                .ok_or_else(|| ValueError::FailedToParseNumber.into()),\n            (DataType::Uint128, Literal::Number(v)) =\u003e v\n                .to_u128()\n                .map(Value::U128)\n                .ok_or_else(|| ValueError::FailedToParseNumber.into()),\n            (DataType::Float32, Literal::Number(v)) =\u003e v\n                .to_f32()\n                .map(Value::F32)\n                .ok_or_else(|| ValueError::UnreachableNumberParsing.into()),\n            (DataType::Float, Literal::Number(v)) =\u003e v\n                .to_f64()\n                .map(Value::F64)\n                .ok_or_else(|| ValueError::UnreachableNumberParsing.into()),\n            (DataType::Text, Literal::Text(v)) =\u003e Ok(Value::Str(v.to_string())),\n            (DataType::Bytea, Literal::Bytea(v)) =\u003e Ok(Value::Bytea(v.to_vec())),\n            (DataType::Bytea, Literal::Text(v)) =\u003e hex::decode(v.as_ref())\n                .map(Value::Bytea)\n                .map_err(|_| ValueError::FailedToParseHexString(v.to_string()).into()),\n            (DataType::Inet, Literal::Text(v)) =\u003e IpAddr::from_str(v.as_ref())\n                .map(Value::Inet)\n                .map_err(|_| ValueError::FailedToParseInetString(v.to_string()).into()),\n            (DataType::Inet, Literal::Number(v)) =\u003e {\n                if let Some(x) = v.to_u32() {\n                    Ok(Value::Inet(IpAddr::V4(Ipv4Addr::from(x))))\n                } else {\n                    Ok(Value::Inet(IpAddr::V6(Ipv6Addr::from(\n                        v.to_u128().unwrap(),\n                    ))))\n                }\n            }\n            (DataType::Date, Literal::Text(v)) =\u003e v\n                .parse::\u003cNaiveDate\u003e()\n                .map(Value::Date)\n                .map_err(|_| ValueError::FailedToParseDate(v.to_string()).into()),\n            (DataType::Timestamp, Literal::Text(v)) =\u003e parse_timestamp(v)\n                .map(Value::Timestamp)\n                .ok_or_else(|| ValueError::FailedToParseTimestamp(v.to_string()).into()),\n            (DataType::Time, Literal::Text(v)) =\u003e parse_time(v)\n                .map(Value::Time)\n                .ok_or_else(|| ValueError::FailedToParseTime(v.to_string()).into()),\n            (DataType::Uuid, Literal::Text(v)) =\u003e parse_uuid(v).map(Value::Uuid),\n            (DataType::Uuid, Literal::Bytea(v)) =\u003e parse_uuid(\u0026hex::encode(v)).map(Value::Uuid),\n            (DataType::Map, Literal::Text(v)) =\u003e Value::parse_json_map(v),\n            (DataType::List, Literal::Text(v)) =\u003e Value::parse_json_list(v),\n            (DataType::Decimal, Literal::Number(v)) =\u003e v\n                .to_string()\n                .parse::\u003cDecimal\u003e()\n                .map(Value::Decimal)\n                .map_err(|_| ValueError::FailedToParseDecimal(v.to_string()).into()),\n            (_, Literal::Null) =\u003e Ok(Value::Null),\n            _ =\u003e Err(ValueError::IncompatibleLiteralForDataType {\n                data_type: data_type.clone(),\n                literal: format!(\"{:?}\", literal),\n            }\n            .into()),\n        }\n    }\n\n    pub fn try_cast_from_literal(data_type: \u0026DataType, literal: \u0026Literal\u003c'_\u003e) -\u003e Result\u003cValue\u003e {\n        match (data_type, literal) {\n            (DataType::Boolean, Literal::Boolean(v)) =\u003e Ok(Value::Bool(*v)),\n            (DataType::Boolean, Literal::Text(v)) =\u003e match v.to_uppercase().as_str() {\n                \"TRUE\" | \"1\" =\u003e Ok(Value::Bool(true)),\n                \"FALSE\" | \"0\" =\u003e Ok(Value::Bool(false)),\n                _ =\u003e Err(ValueError::LiteralCastToBooleanFailed(v.to_string()).into()),\n            },\n            (DataType::Boolean, Literal::Number(v)) =\u003e match v.to_i64() {\n                Some(0) =\u003e Ok(Value::Bool(false)),\n                Some(1) =\u003e Ok(Value::Bool(true)),\n                _ =\u003e Err(ValueError::LiteralCastToBooleanFailed(v.to_string()).into()),\n            },\n            (DataType::Int8, Literal::Text(v)) =\u003e v\n                .parse::\u003ci8\u003e()\n                .map(Value::I8)\n                .map_err(|_| ValueError::LiteralCastFromTextToIntegerFailed(v.to_string()).into()),\n            (DataType::Int8, Literal::Number(v)) =\u003e match v.to_i8() {\n                Some(x) =\u003e Ok(Value::I8(x)),\n                None =\u003e Err(ValueError::LiteralCastToInt8Failed(v.to_string()).into()),\n            },\n            (DataType::Int8, Literal::Boolean(v)) =\u003e {\n                let v = i8::from(*v);\n\n                Ok(Value::I8(v))\n            }\n            (DataType::Int16, Literal::Text(v)) =\u003e v\n                .parse::\u003ci16\u003e()\n                .map(Value::I16)\n                .map_err(|_| ValueError::LiteralCastFromTextToIntegerFailed(v.to_string()).into()),\n            (DataType::Int16, Literal::Number(v)) =\u003e match v.to_i16() {\n                Some(x) =\u003e Ok(Value::I16(x)),\n                None =\u003e Err(ValueError::LiteralCastToInt8Failed(v.to_string()).into()),\n            },\n            (DataType::Int16, Literal::Boolean(v)) =\u003e {\n                let v = i16::from(*v);\n\n                Ok(Value::I16(v))\n            }\n            (DataType::Int32, Literal::Text(v)) =\u003e v\n                .parse::\u003ci32\u003e()\n                .map(Value::I32)\n                .map_err(|_| ValueError::LiteralCastFromTextToIntegerFailed(v.to_string()).into()),\n            (DataType::Int32, Literal::Number(v)) =\u003e match v.to_i32() {\n                Some(x) =\u003e Ok(Value::I32(x)),\n                None =\u003e Err(ValueError::LiteralCastToDataTypeFailed(\n                    DataType::Int32,\n                    v.to_string(),\n                )\n                .into()),\n            },\n            (DataType::Int32, Literal::Boolean(v)) =\u003e {\n                let v = i32::from(*v);\n\n                Ok(Value::I32(v))\n            }\n            (DataType::Int, Literal::Text(v)) =\u003e v\n                .parse::\u003ci64\u003e()\n                .map(Value::I64)\n                .map_err(|_| ValueError::LiteralCastFromTextToIntegerFailed(v.to_string()).into()),\n            (DataType::Int, Literal::Number(v)) =\u003e match v.to_i64() {\n                Some(x) =\u003e Ok(Value::I64(x)),\n                None =\u003e Err(\n                    ValueError::LiteralCastToDataTypeFailed(DataType::Int, v.to_string()).into(),\n                ),\n            },\n            (DataType::Int, Literal::Boolean(v)) =\u003e {\n                let v = i64::from(*v);\n\n                Ok(Value::I64(v))\n            }\n            (DataType::Int128, Literal::Text(v)) =\u003e v\n                .parse::\u003ci128\u003e()\n                .map(Value::I128)\n                .map_err(|_| ValueError::LiteralCastFromTextToIntegerFailed(v.to_string()).into()),\n            (DataType::Int128, Literal::Number(v)) =\u003e match v.to_i128() {\n                Some(x) =\u003e Ok(Value::I128(x)),\n                None =\u003e Err(ValueError::LiteralCastToDataTypeFailed(\n                    DataType::Int128,\n                    v.to_string(),\n                )\n                .into()),\n            },\n            (DataType::Int128, Literal::Boolean(v)) =\u003e {\n                let v = i128::from(*v);\n\n                Ok(Value::I128(v))\n            }\n            (DataType::Uint8, Literal::Text(v)) =\u003e v.parse::\u003cu8\u003e().map(Value::U8).map_err(|_| {\n                ValueError::LiteralCastFromTextToUnsignedInt8Failed(v.to_string()).into()\n            }),\n            (DataType::Uint8, Literal::Number(v)) =\u003e match v.to_u8() {\n                Some(x) =\u003e Ok(Value::U8(x)),\n                None =\u003e Err(ValueError::LiteralCastToUnsignedInt8Failed(v.to_string()).into()),\n            },\n            (DataType::Uint8, Literal::Boolean(v)) =\u003e {\n                let v = u8::from(*v);\n\n                Ok(Value::U8(v))\n            }\n            (DataType::Uint16, Literal::Text(v)) =\u003e v\n                .parse::\u003cu16\u003e()\n                .map(Value::U16)\n                .map_err(|_| ValueError::LiteralCastFromTextToUint16Failed(v.to_string()).into()),\n            (DataType::Uint16, Literal::Number(v)) =\u003e match v.to_u16() {\n                Some(x) =\u003e Ok(Value::U16(x)),\n                None =\u003e Err(ValueError::LiteralCastToUint16Failed(v.to_string()).into()),\n            },\n            (DataType::Uint16, Literal::Boolean(v)) =\u003e {\n                let v = u16::from(*v);\n\n                Ok(Value::U16(v))\n            }\n            (DataType::Uint32, Literal::Text(v)) =\u003e v\n                .parse::\u003cu32\u003e()\n                .map(Value::U32)\n                .map_err(|_| ValueError::LiteralCastFromTextToUint32Failed(v.to_string()).into()),\n            (DataType::Uint32, Literal::Number(v)) =\u003e match v.to_u32() {\n                Some(x) =\u003e Ok(Value::U32(x)),\n                None =\u003e Err(ValueError::LiteralCastToUint32Failed(v.to_string()).into()),\n            },\n            (DataType::Uint32, Literal::Boolean(v)) =\u003e {\n                let v = u32::from(*v);\n\n                Ok(Value::U32(v))\n            }\n\n            (DataType::Uint64, Literal::Text(v)) =\u003e v\n                .parse::\u003cu64\u003e()\n                .map(Value::U64)\n                .map_err(|_| ValueError::LiteralCastFromTextToUint64Failed(v.to_string()).into()),\n            (DataType::Uint64, Literal::Number(v)) =\u003e match v.to_u64() {\n                Some(x) =\u003e Ok(Value::U64(x)),\n                None =\u003e Err(ValueError::LiteralCastToUint64Failed(v.to_string()).into()),\n            },\n            (DataType::Uint64, Literal::Boolean(v)) =\u003e {\n                let v = u64::from(*v);\n\n                Ok(Value::U64(v))\n            }\n\n            (DataType::Uint128, Literal::Text(v)) =\u003e v\n                .parse::\u003cu128\u003e()\n                .map(Value::U128)\n                .map_err(|_| ValueError::LiteralCastFromTextToUint128Failed(v.to_string()).into()),\n            (DataType::Uint128, Literal::Number(v)) =\u003e match v.to_u128() {\n                Some(x) =\u003e Ok(Value::U128(x)),\n                None =\u003e Err(ValueError::LiteralCastToUint128Failed(v.to_string()).into()),\n            },\n            (DataType::Uint128, Literal::Boolean(v)) =\u003e {\n                let v = u128::from(*v);\n\n                Ok(Value::U128(v))\n            }\n\n            (DataType::Float32, Literal::Text(v)) =\u003e v\n                .parse::\u003cf32\u003e()\n                .map(Value::F32)\n                .map_err(|_| ValueError::LiteralCastFromTextToFloatFailed(v.to_string()).into()),\n            (DataType::Float32, Literal::Number(v)) =\u003e {\n                v.to_f32().map(Value::F32).ok_or_else(|| {\n                    ValueError::UnreachableLiteralCastFromNumberToFloat(v.to_string()).into()\n                })\n            }\n            (DataType::Float32, Literal::Boolean(v)) =\u003e {\n                let v = if *v { 1.0 } else { 0.0 };\n\n                Ok(Value::F32(v))\n            }\n            (DataType::Float, Literal::Text(v)) =\u003e v\n                .parse::\u003cf64\u003e()\n                .map(Value::F64)\n                .map_err(|_| ValueError::LiteralCastFromTextToFloatFailed(v.to_string()).into()),\n            (DataType::Float, Literal::Number(v)) =\u003e v.to_f64().map(Value::F64).ok_or_else(|| {\n                ValueError::UnreachableLiteralCastFromNumberToFloat(v.to_string()).into()\n            }),\n            (DataType::Float, Literal::Boolean(v)) =\u003e {\n                let v = if *v { 1.0 } else { 0.0 };\n\n                Ok(Value::F64(v))\n            }\n            (DataType::Decimal, Literal::Text(v)) =\u003e v\n                .parse::\u003cDecimal\u003e()\n                .map(Value::Decimal)\n                .map_err(|_| ValueError::LiteralCastFromTextToDecimalFailed(v.to_string()).into()),\n            (DataType::Decimal, Literal::Number(v)) =\u003e v\n                .to_string()\n                .parse::\u003cDecimal\u003e()\n                .map(Value::Decimal)\n                .map_err(|_| ValueError::LiteralCastFromTextToDecimalFailed(v.to_string()).into()),\n            (DataType::Decimal, Literal::Boolean(v)) =\u003e {\n                let v = if *v { Decimal::ONE } else { Decimal::ZERO };\n\n                Ok(Value::Decimal(v))\n            }\n\n            (DataType::Text, Literal::Number(v)) =\u003e Ok(Value::Str(v.to_string())),\n            (DataType::Text, Literal::Text(v)) =\u003e Ok(Value::Str(v.to_string())),\n            (DataType::Text, Literal::Boolean(v)) =\u003e {\n                let v = if *v { \"TRUE\" } else { \"FALSE\" };\n\n                Ok(Value::Str(v.to_owned()))\n            }\n            (DataType::Interval, Literal::Text(v)) =\u003e {\n                Interval::parse(v.as_ref()).map(Value::Interval)\n            }\n            (DataType::Uuid, Literal::Text(v)) =\u003e parse_uuid(v).map(Value::Uuid),\n            (DataType::Boolean, Literal::Null)\n            | (DataType::Int8, Literal::Null)\n            | (DataType::Int16, Literal::Null)\n            | (DataType::Int32, Literal::Null)\n            | (DataType::Int, Literal::Null)\n            | (DataType::Int128, Literal::Null)\n            | (DataType::Uint8, Literal::Null)\n            | (DataType::Uint16, Literal::Null)\n            | (DataType::Uint32, Literal::Null)\n            | (DataType::Uint64, Literal::Null)\n            | (DataType::Uint128, Literal::Null)\n            | (DataType::Float32, Literal::Null)\n            | (DataType::Float, Literal::Null)\n            | (DataType::Decimal, Literal::Null)\n            | (DataType::Text, Literal::Null) =\u003e Ok(Value::Null),\n            (DataType::Date, Literal::Text(v)) =\u003e parse_date(v)\n                .map(Value::Date)\n                .ok_or_else(|| ValueError::LiteralCastToDateFailed(v.to_string()).into()),\n            (DataType::Time, Literal::Text(v)) =\u003e parse_time(v)\n                .map(Value::Time)\n                .ok_or_else(|| ValueError::LiteralCastToTimeFailed(v.to_string()).into()),\n            (DataType::Timestamp, Literal::Text(v)) =\u003e parse_timestamp(v)\n                .map(Value::Timestamp)\n                .ok_or_else(|| ValueError::LiteralCastToTimestampFailed(v.to_string()).into()),\n            (DataType::Inet, Literal::Number(v)) =\u003e {\n                if let Some(x) = v.to_u32() {\n                    Ok(Value::Inet(IpAddr::V4(Ipv4Addr::from(x))))\n                } else if let Some(x) = v.to_u128() {\n                    Ok(Value::Inet(IpAddr::V6(Ipv6Addr::from(x))))\n                } else {\n                    Err(ValueError::FailedToParseInetString(v.to_string()).into())\n                }\n            }\n            (DataType::Inet, Literal::Text(v)) =\u003e IpAddr::from_str(v)\n                .map(Value::Inet)\n                .map_err(|_| ValueError::FailedToParseInetString(v.to_string()).into()),\n            (DataType::Point, Literal::Text(v)) =\u003e Point::from_wkt(v)\n                .map(Value::Point)\n                .map_err(|_| ValueError::FailedToParsePoint(v.to_string()).into()),\n            (DataType::Map, Literal::Text(v)) =\u003e Value::parse_json_map(v),\n            (DataType::List, Literal::Text(v)) =\u003e Value::parse_json_list(v),\n            _ =\u003e Err(ValueError::UnimplementedLiteralCast {\n                data_type: data_type.clone(),\n                literal: format!(\"{:?}\", literal),\n            }\n            .into()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::parse_uuid,\n        crate::data::{Literal, Value},\n        bigdecimal::BigDecimal,\n        chrono::{NaiveDate, NaiveDateTime, NaiveTime},\n        rust_decimal::Decimal,\n        std::{\n            borrow::Cow,\n            cmp::Ordering,\n            net::{IpAddr, Ipv4Addr, Ipv6Addr},\n            str::FromStr,\n        },\n    };\n\n    fn date(year: i32, month: u32, day: u32) -\u003e NaiveDate {\n        chrono::NaiveDate::from_ymd_opt(year, month, day).unwrap()\n    }\n\n    fn date_time(y: i32, m: u32, d: u32, hh: u32, mm: u32, ss: u32, ms: u32) -\u003e NaiveDateTime {\n        chrono::NaiveDate::from_ymd_opt(y, m, d)\n            .unwrap()\n            .and_hms_milli_opt(hh, mm, ss, ms)\n            .unwrap()\n    }\n\n    fn time(hour: u32, min: u32, sec: u32, milli: u32) -\u003e NaiveTime {\n        chrono::NaiveTime::from_hms_milli_opt(hour, min, sec, milli).unwrap()\n    }\n\n    #[test]\n    fn evaluate_eq_with_literal() {\n        macro_rules! num {\n            ($num: expr) =\u003e {\n                \u0026Literal::Number(Cow::Owned(BigDecimal::from_str($num).unwrap()))\n            };\n        }\n\n        macro_rules! text {\n            ($text: expr) =\u003e {\n                \u0026Literal::Text(Cow::Owned($text.to_owned()))\n            };\n        }\n\n        let uuid_text = \"936DA01F9ABD4d9d80C702AF85C822A8\";\n        let uuid = parse_uuid(uuid_text).unwrap();\n\n        let bytea = || hex::decode(\"123456\").unwrap();\n        let inet = |v: \u0026str| Value::Inet(IpAddr::from_str(v).unwrap());\n\n        assert!(Value::Bool(true).evaluate_eq_with_literal(\u0026Literal::Boolean(true)));\n        assert!(Value::I8(8).evaluate_eq_with_literal(num!(\"8\")));\n        assert!(Value::I32(32).evaluate_eq_with_literal(num!(\"32\")));\n        assert!(Value::I16(16).evaluate_eq_with_literal(num!(\"16\")));\n        assert!(Value::I32(32).evaluate_eq_with_literal(num!(\"32\")));\n        assert!(Value::I64(64).evaluate_eq_with_literal(num!(\"64\")));\n        assert!(Value::I128(128).evaluate_eq_with_literal(num!(\"128\")));\n        assert!(Value::U8(7).evaluate_eq_with_literal(num!(\"7\")));\n        assert!(Value::U16(64).evaluate_eq_with_literal(num!(\"64\")));\n        assert!(Value::U32(64).evaluate_eq_with_literal(num!(\"64\")));\n        assert!(Value::U64(64).evaluate_eq_with_literal(num!(\"64\")));\n        assert!(Value::U128(64).evaluate_eq_with_literal(num!(\"64\")));\n        assert!(Value::F32(7.123).evaluate_eq_with_literal(num!(\"7.123\")));\n        assert!(Value::F64(7.123).evaluate_eq_with_literal(num!(\"7.123\")));\n        assert!(Value::Str(\"Hello\".to_owned()).evaluate_eq_with_literal(text!(\"Hello\")));\n        assert!(Value::Bytea(bytea()).evaluate_eq_with_literal(\u0026Literal::Bytea(bytea())));\n        assert!(inet(\"127.0.0.1\").evaluate_eq_with_literal(text!(\"127.0.0.1\")));\n        assert!(inet(\"::1\").evaluate_eq_with_literal(text!(\"::1\")));\n        assert!(inet(\"0.0.0.0\").evaluate_eq_with_literal(num!(\"0\")));\n        assert!(!inet(\"::1\").evaluate_eq_with_literal(num!(\"0\")));\n        assert!(inet(\"::2:4cb0:16ea\").evaluate_eq_with_literal(num!(\"9876543210\")));\n        assert!(!inet(\"::1\").evaluate_eq_with_literal(text!(\"-1\")));\n        assert!(!inet(\"::1\").evaluate_eq_with_literal(num!(\"-1\")));\n        assert!(Value::Date(date(2021, 11, 20)).evaluate_eq_with_literal(text!(\"2021-11-20\")));\n        assert!(!Value::Date(date(2021, 11, 20)).evaluate_eq_with_literal(text!(\"202=abcdef\")));\n        assert!(\n            Value::Timestamp(date_time(2021, 11, 20, 10, 0, 0, 0))\n                .evaluate_eq_with_literal(text!(\"2021-11-20T10:00:00Z\"))\n        );\n        assert!(\n            !Value::Timestamp(date_time(2021, 11, 20, 10, 0, 0, 0))\n                .evaluate_eq_with_literal(text!(\"2021-11-Hello\"))\n        );\n        assert!(Value::Time(time(10, 0, 0, 0)).evaluate_eq_with_literal(text!(\"10:00:00\")));\n        assert!(!Value::Time(time(10, 0, 0, 0)).evaluate_eq_with_literal(text!(\"FALSE\")));\n        assert!(Value::Uuid(uuid).evaluate_eq_with_literal(text!(uuid_text)));\n    }\n\n    #[test]\n    fn evaluate_cmp_with_literal() {\n        let num = |n| Literal::Number(Cow::Owned(BigDecimal::from(n)));\n        let text = |v: \u0026str| Literal::Text(Cow::Owned(v.to_owned()));\n\n        let test = |value: Value, literal, expected| {\n            assert_eq!(value.evaluate_cmp_with_literal(\u0026literal), expected);\n        };\n\n        test(Value::I8(1), num(1), Some(Ordering::Equal));\n        test(Value::I16(1), num(2), Some(Ordering::Less));\n        test(Value::I32(10), num(3), Some(Ordering::Greater));\n        test(Value::I64(10), num(10), Some(Ordering::Equal));\n        test(Value::I128(10), num(10), Some(Ordering::Equal));\n        test(Value::U8(1), num(1), Some(Ordering::Equal));\n        test(Value::U16(1), num(2), Some(Ordering::Less));\n        test(Value::U32(10), num(3), Some(Ordering::Greater));\n        test(Value::U64(10), num(10), Some(Ordering::Equal));\n        test(Value::U128(10), num(10), Some(Ordering::Equal));\n        test(Value::F32(10.0), num(10), Some(Ordering::Equal));\n        test(Value::F64(10.0), num(10), Some(Ordering::Equal));\n        test(\n            Value::Decimal(Decimal::new(215, 2)),\n            num(3),\n            Some(Ordering::Less),\n        );\n        test(\n            Value::Str(\"Hello\".to_owned()),\n            text(\"Hello\"),\n            Some(Ordering::Equal),\n        );\n        test(\n            Value::Date(date(2021, 11, 21)),\n            text(\"2021-11-21\"),\n            Some(Ordering::Equal),\n        );\n        test(\n            Value::Timestamp(date_time(2021, 11, 21, 10, 0, 0, 0)),\n            text(\"2021-11-21T10:00:00Z\"),\n            Some(Ordering::Equal),\n        );\n        test(\n            Value::Time(time(10, 0, 0, 0)),\n            text(\"10:00:00\"),\n            Some(Ordering::Equal),\n        );\n        test(\n            Value::Uuid(parse_uuid(\"936DA01F9ABD4d9d80C702AF85C822A8\").unwrap()),\n            text(\"936DA01F9ABD4d9d80C702AF85C822A8\"),\n            Some(Ordering::Equal),\n        );\n        test(\n            Value::Inet(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1))),\n            text(\"215.87.1.1\"),\n            Some(Ordering::Less),\n        );\n        test(\n            Value::Inet(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1))),\n            text(\"215.87.1.1\"),\n            Some(Ordering::Less),\n        );\n        test(\n            Value::Inet(IpAddr::V4(Ipv4Addr::new(255, 255, 255, 255))),\n            Literal::Number(Cow::Owned(BigDecimal::new(4294967295u32.into(), 0))),\n            Some(Ordering::Equal),\n        );\n        test(\n            Value::Inet(IpAddr::from_str(\"::2:4cb0:16ea\").unwrap()),\n            Literal::Number(Cow::Owned(BigDecimal::new(9876543210u128.into(), 0))),\n            Some(Ordering::Equal),\n        );\n        test(Value::Null, num(1), None);\n    }\n\n    #[test]\n    fn timestamp_literal() {\n        macro_rules! test (\n            ($timestamp: literal, $result: expr) =\u003e {\n                assert_eq!(super::parse_timestamp($timestamp), Some($result));\n            }\n        );\n\n        test!(\"2022-12-20T10:00:00Z\", date_time(2022, 12, 20, 10, 0, 0, 0));\n        test!(\n            \"2022-12-20T10:00:00.132Z\",\n            date_time(2022, 12, 20, 10, 0, 0, 132)\n        );\n        test!(\n            \"2022-12-20T10:00:00.132+09:00\",\n            date_time(2022, 12, 20, 1, 0, 0, 132)\n        );\n        test!(\"2022-11-21\", date_time(2022, 11, 21, 0, 0, 0, 0));\n        test!(\"2022-12-20T10:00:00\", date_time(2022, 12, 20, 10, 0, 0, 0));\n        test!(\"2022-12-20 10:00:00Z\", date_time(2022, 12, 20, 10, 0, 0, 0));\n        test!(\"2022-12-20 10:00:00\", date_time(2022, 12, 20, 10, 0, 0, 0));\n        test!(\n            \"2022-12-20 10:00:00.987\",\n            date_time(2022, 12, 20, 10, 0, 0, 987)\n        );\n    }\n\n    #[test]\n    fn time_literal() {\n        macro_rules! test (\n            ($time: literal, $result: expr) =\u003e {\n                assert_eq!(super::parse_time($time), Some($result));\n            }\n        );\n\n        test!(\"12:00:35\", time(12, 0, 35, 0));\n        test!(\"12:00:35.917\", time(12, 0, 35, 917));\n        test!(\"AM 08:00\", time(8, 0, 0, 0));\n        test!(\"PM 8:00\", time(20, 0, 0, 0));\n        test!(\"AM 09:30:37\", time(9, 30, 37, 0));\n        test!(\"PM 3:30:37\", time(15, 30, 37, 0));\n        test!(\"PM 03:30:37.123\", time(15, 30, 37, 123));\n        test!(\"AM 9:30:37.917\", time(9, 30, 37, 917));\n        test!(\"08:00 AM\", time(8, 0, 0, 0));\n        test!(\"8:00 PM\", time(20, 0, 0, 0));\n        test!(\"09:30:37 AM\", time(9, 30, 37, 0));\n        test!(\"3:30:37 PM\", time(15, 30, 37, 0));\n        test!(\"03:30:37.123 PM\", time(15, 30, 37, 123));\n        test!(\"9:30:37.917 AM\", time(9, 30, 37, 917));\n    }\n\n    #[test]\n    fn try_from_literal() {\n        use {\n            crate::{ast::DataType, data::ValueError},\n            chrono::NaiveDate,\n            rust_decimal::Decimal,\n            std::{borrow::Cow, str::FromStr},\n        };\n\n        macro_rules! num {\n            ($num: expr) =\u003e {\n                Literal::Number(Cow::Owned(BigDecimal::from_str($num).unwrap()))\n            };\n        }\n\n        macro_rules! text {\n            ($text: expr) =\u003e {\n                Literal::Text(Cow::Owned($text.to_owned()))\n            };\n        }\n\n        macro_rules! test {\n            ($to: expr, $from: expr, $expected: expr) =\u003e {\n                assert_eq!(Value::try_from_literal(\u0026$to, \u0026$from), Ok($expected));\n            };\n        }\n\n        let bytea = |v| hex::decode(v).unwrap();\n        let inet = |v| IpAddr::from_str(v).unwrap();\n\n        test!(DataType::Boolean, Literal::Boolean(true), Value::Bool(true));\n        test!(DataType::Int, num!(\"123456789\"), Value::I64(123456789));\n        test!(DataType::Int8, num!(\"64\"), Value::I8(64));\n        test!(DataType::Int16, num!(\"64\"), Value::I16(64));\n        test!(DataType::Int32, num!(\"64\"), Value::I32(64));\n        test!(DataType::Int, num!(\"64\"), Value::I64(64));\n        test!(DataType::Int128, num!(\"64\"), Value::I128(64));\n        test!(DataType::Uint8, num!(\"8\"), Value::U8(8));\n        test!(DataType::Uint16, num!(\"64\"), Value::U16(64));\n        test!(DataType::Uint32, num!(\"64\"), Value::U32(64));\n        test!(DataType::Uint64, num!(\"64\"), Value::U64(64));\n        test!(DataType::Uint128, num!(\"64\"), Value::U128(64));\n        test!(\n            DataType::Float32,\n            num!(\"123456789\"),\n            Value::F32(123456789.0_f32)\n        );\n        test!(DataType::Float, num!(\"123456789\"), Value::F64(123456789.0));\n        test!(\n            DataType::Text,\n            text!(\"Good!\"),\n            Value::Str(\"Good!\".to_owned())\n        );\n        test!(\n            DataType::Bytea,\n            Literal::Bytea(bytea(\"1234\")),\n            Value::Bytea(bytea(\"1234\"))\n        );\n        test!(DataType::Bytea, text!(\"1234\"), Value::Bytea(bytea(\"1234\")));\n        assert_eq!(\n            Value::try_from_literal(\u0026DataType::Bytea, \u0026text!(\"123\")),\n            Err(ValueError::FailedToParseHexString(\"123\".to_owned()).into())\n        );\n        test!(DataType::Inet, text!(\"::1\"), Value::Inet(inet(\"::1\")));\n        test!(\n            DataType::Inet,\n            num!(\"4294967295\"),\n            Value::Inet(inet(\"255.255.255.255\"))\n        );\n        test!(\n            DataType::Inet,\n            num!(\"9876543210\"),\n            Value::Inet(inet(\"::2:4cb0:16ea\"))\n        );\n        test!(\n            DataType::Inet,\n            num!(\"9876543210\"),\n            Value::Inet(inet(\"::2:4cb0:16ea\"))\n        );\n        assert_eq!(\n            Value::try_from_literal(\u0026DataType::Inet, \u0026text!(\"123\")),\n            Err(ValueError::FailedToParseInetString(\"123\".to_owned()).into())\n        );\n        test!(\n            DataType::Date,\n            text!(\"2015-09-05\"),\n            Value::Date(NaiveDate::from_ymd_opt(2015, 9, 5).unwrap())\n        );\n        test!(\n            DataType::Timestamp,\n            text!(\"2022-12-20 10:00:00.987\"),\n            Value::Timestamp(date_time(2022, 12, 20, 10, 0, 0, 987))\n        );\n        test!(\n            DataType::Time,\n            text!(\"12:00:35\"),\n            Value::Time(chrono::NaiveTime::from_hms_milli_opt(12, 0, 35, 0).unwrap())\n        );\n        test!(\n            DataType::Uuid,\n            text!(\"936DA01F9ABD4d9d80C702AF85C822A8\"),\n            Value::Uuid(195965723427462096757863453463987888808)\n        );\n        test!(\n            DataType::Uuid,\n            Literal::Bytea(bytea(\"936DA01F9ABD4d9d80C702AF85C822A8\")),\n            Value::Uuid(195965723427462096757863453463987888808)\n        );\n\n        assert_eq!(\n            Value::try_from_literal(\n                \u0026DataType::Map,\n                \u0026text!(\n                    r#\"{\n            \"name\": \"John Doe\",\n            \"age\": 43\n        }\"#\n                )\n            ),\n            Value::parse_json_map(\n                r#\"{\n            \"name\": \"John Doe\",\n            \"age\": 43\n        }\"#\n            )\n        );\n        assert_eq!(\n            Value::try_from_literal(\n                \u0026DataType::List,\n                \u0026text!(\n                    r#\"[\n            \"+44 1234567\",\n            \"+44 2345678\"\n        ]\"#\n                )\n            ),\n            Value::parse_json_list(\n                r#\"[\n            \"+44 1234567\",\n            \"+44 2345678\"\n        ]\"#\n            )\n        );\n        test!(\n            DataType::Decimal,\n            num!(\"200\"),\n            Value::Decimal(Decimal::new(200, 0))\n        );\n    }\n\n    #[test]\n    fn try_from() {\n        use std::{borrow::Cow, str::FromStr};\n\n        macro_rules! text {\n            ($text: expr) =\u003e {\n                Literal::Text(Cow::Owned($text.to_owned()))\n            };\n        }\n\n        macro_rules! num {\n            ($num: expr) =\u003e {\n                \u0026Literal::Number(Cow::Owned(BigDecimal::from_str($num).unwrap()))\n            };\n        }\n\n        let bytea = |v| hex::decode(v).unwrap();\n\n        macro_rules! test {\n            ($from: expr, $expected: expr) =\u003e {\n                assert!(Value::try_from($from).unwrap().evaluate_eq(\u0026$expected));\n            };\n        }\n\n        test!(text!(\"hello\"), Value::Str(\"hello\".to_owned()));\n        test!(\u0026text!(\"hallo\"), Value::Str(\"hallo\".to_owned()));\n        test!(Literal::Bytea(bytea(\"1234\")), Value::Bytea(bytea(\"1234\")));\n        test!(\u0026Literal::Bytea(bytea(\"1234\")), Value::Bytea(bytea(\"1234\")));\n        test!(num!(\"1234567890\"), Value::I64(1234567890));\n        test!(num!(\"1.0\"), Value::F32(1.0_f32));\n        test!(num!(\"1.0\"), Value::F64(1.0));\n        test!(\u0026Literal::Boolean(false), Value::Bool(false));\n        assert!(matches!(Value::try_from(\u0026Literal::Null), Ok(Value::Null)))\n    }\n\n    #[test]\n    fn try_cast_from_literal() {\n        use {\n            crate::{ast::DataType, data::Interval as I},\n            chrono::NaiveDate,\n            std::{borrow::Cow, str::FromStr},\n        };\n\n        macro_rules! text {\n            ($text: expr) =\u003e {\n                Literal::Text(Cow::Owned($text.to_owned()))\n            };\n        }\n\n        macro_rules! num {\n            ($num: expr) =\u003e {\n                \u0026Literal::Number(Cow::Owned(BigDecimal::from_str($num).unwrap()))\n            };\n        }\n\n        macro_rules! test {\n            ($to: expr, $from: expr, $expected: expr) =\u003e {\n                let actual = Value::try_cast_from_literal(\u0026$to, \u0026$from);\n\n                assert_eq!(actual, Ok($expected))\n            };\n        }\n\n        macro_rules! test_null {\n            ($to: expr, $from: expr) =\u003e {\n                assert!(matches!(\n                    Value::try_cast_from_literal(\u0026$to, \u0026$from),\n                    Ok(Value::Null)\n                ))\n            };\n        }\n\n        let timestamp = |y, m, d, hh, mm, ss, ms| {\n            chrono::NaiveDate::from_ymd_opt(y, m, d)\n                .unwrap()\n                .and_hms_milli_opt(hh, mm, ss, ms)\n                .unwrap()\n        };\n\n        test!(\n            DataType::Boolean,\n            Literal::Boolean(false),\n            Value::Bool(false)\n        );\n        test!(DataType::Boolean, text!(\"false\"), Value::Bool(false));\n        test!(DataType::Boolean, text!(\"true\"), Value::Bool(true));\n        test!(DataType::Boolean, num!(\"0\"), Value::Bool(false));\n        test!(DataType::Boolean, num!(\"1\"), Value::Bool(true));\n\n        test!(DataType::Int8, text!(\"127\"), Value::I8(127));\n        test!(DataType::Int8, num!(\"125\"), Value::I8(125));\n        test!(DataType::Int8, Literal::Boolean(true), Value::I8(1));\n        test!(DataType::Int8, Literal::Boolean(false), Value::I8(0));\n\n        test!(DataType::Int16, text!(\"127\"), Value::I16(127));\n        test!(DataType::Int16, num!(\"125\"), Value::I16(125));\n        test!(DataType::Int16, Literal::Boolean(true), Value::I16(1));\n        test!(DataType::Int16, Literal::Boolean(false), Value::I16(0));\n\n        test!(DataType::Int32, text!(\"127\"), Value::I32(127));\n        test!(DataType::Int32, num!(\"125\"), Value::I32(125));\n        test!(DataType::Int32, Literal::Boolean(true), Value::I32(1));\n        test!(DataType::Int32, Literal::Boolean(false), Value::I32(0));\n\n        test!(DataType::Int, text!(\"1234567890\"), Value::I64(1234567890));\n        test!(DataType::Int, num!(\"1234567890\"), Value::I64(1234567890));\n        test!(DataType::Int, Literal::Boolean(true), Value::I64(1));\n        test!(DataType::Int, Literal::Boolean(false), Value::I64(0));\n        test!(DataType::Int128, text!(\"127\"), Value::I128(127));\n        test!(DataType::Int128, num!(\"125\"), Value::I128(125));\n        test!(DataType::Int128, Literal::Boolean(true), Value::I128(1));\n        test!(DataType::Int128, Literal::Boolean(false), Value::I128(0));\n\n        test!(DataType::Uint8, text!(\"127\"), Value::U8(127));\n        test!(DataType::Uint8, num!(\"125\"), Value::U8(125));\n        test!(DataType::Uint8, Literal::Boolean(true), Value::U8(1));\n        test!(DataType::Uint8, Literal::Boolean(false), Value::U8(0));\n\n        test!(DataType::Uint16, text!(\"127\"), Value::U16(127));\n        test!(DataType::Uint16, num!(\"125\"), Value::U16(125));\n        test!(DataType::Uint16, Literal::Boolean(true), Value::U16(1));\n        test!(DataType::Uint16, Literal::Boolean(false), Value::U16(0));\n\n        test!(DataType::Uint32, text!(\"127\"), Value::U32(127));\n        test!(DataType::Uint32, num!(\"125\"), Value::U32(125));\n        test!(DataType::Uint32, Literal::Boolean(true), Value::U32(1));\n        test!(DataType::Uint32, Literal::Boolean(false), Value::U32(0));\n\n        test!(DataType::Uint64, text!(\"127\"), Value::U64(127));\n        test!(DataType::Uint64, num!(\"125\"), Value::U64(125));\n        test!(DataType::Uint64, Literal::Boolean(true), Value::U64(1));\n        test!(DataType::Uint64, Literal::Boolean(false), Value::U64(0));\n\n        test!(DataType::Uint128, text!(\"127\"), Value::U128(127));\n        test!(DataType::Uint128, num!(\"125\"), Value::U128(125));\n        test!(DataType::Uint128, Literal::Boolean(true), Value::U128(1));\n        test!(DataType::Uint128, Literal::Boolean(false), Value::U128(0));\n\n        test!(\n            DataType::Float32,\n            text!(\"12345.67\"),\n            Value::F32(12345.67_f32)\n        );\n        test!(\n            DataType::Float32,\n            num!(\"123456.78\"),\n            Value::F32(123456.78_f32)\n        );\n        test!(\n            DataType::Float32,\n            Literal::Boolean(true),\n            Value::F32(1.0_f32)\n        );\n        test!(\n            DataType::Float32,\n            Literal::Boolean(false),\n            Value::F32(0.0_f32)\n        );\n\n        test!(DataType::Float, text!(\"12345.6789\"), Value::F64(12345.6789));\n        test!(DataType::Float, num!(\"123456.789\"), Value::F64(123456.789));\n        test!(DataType::Float, Literal::Boolean(true), Value::F64(1.0));\n        test!(DataType::Float, Literal::Boolean(false), Value::F64(0.0));\n        test!(\n            DataType::Text,\n            num!(\"1234567890\"),\n            Value::Str(\"1234567890\".to_owned())\n        );\n        test!(DataType::Text, text!(\"Cow\"), Value::Str(\"Cow\".to_owned()));\n        test!(\n            DataType::Text,\n            Literal::Boolean(true),\n            Value::Str(\"TRUE\".to_owned())\n        );\n        test!(\n            DataType::Text,\n            Literal::Boolean(false),\n            Value::Str(\"FALSE\".to_owned())\n        );\n        test!(\n            DataType::Interval,\n            text!(\"'+22-10' YEAR TO MONTH\"),\n            Value::Interval(I::Month(274))\n        );\n        test!(\n            DataType::Uuid,\n            text!(\"936DA01F9ABD4d9d80C702AF85C822A8\"),\n            Value::Uuid(195965723427462096757863453463987888808)\n        );\n        test_null!(DataType::Boolean, Literal::Null);\n        test_null!(DataType::Int, Literal::Null);\n        test_null!(DataType::Int8, Literal::Null);\n        test_null!(DataType::Uint8, Literal::Null);\n        test_null!(DataType::Uint16, Literal::Null);\n        test_null!(DataType::Uint32, Literal::Null);\n        test_null!(DataType::Uint64, Literal::Null);\n        test_null!(DataType::Uint128, Literal::Null);\n        test_null!(DataType::Float32, Literal::Null);\n        test_null!(DataType::Float, Literal::Null);\n        test_null!(DataType::Text, Literal::Null);\n        test!(\n            DataType::Date,\n            text!(\"2015-09-05\"),\n            Value::Date(NaiveDate::from_ymd_opt(2015, 9, 5).unwrap())\n        );\n        test!(\n            DataType::Time,\n            text!(\"12:00:35\"),\n            Value::Time(chrono::NaiveTime::from_hms_milli_opt(12, 0, 35, 0).unwrap())\n        );\n        test!(\n            DataType::Timestamp,\n            text!(\"2022-12-20 10:00:00.987\"),\n            Value::Timestamp(timestamp(2022, 12, 20, 10, 0, 0, 987))\n        );\n        test!(\n            DataType::Inet,\n            num!(\"1234567890\"),\n            Value::Inet(IpAddr::from(Ipv4Addr::from(1234567890)))\n        );\n        test!(\n            DataType::Inet,\n            num!(\"91234567890\"),\n            Value::Inet(IpAddr::from(Ipv6Addr::from(91234567890)))\n        );\n        test!(\n            DataType::Inet,\n            text!(\"::1\"),\n            Value::Inet(IpAddr::from_str(\"::1\").unwrap())\n        );\n        test!(\n            DataType::Map,\n            text!(r#\"{ \"a\": 1 }\"#),\n            Value::parse_json_map(r#\"{ \"a\": 1 }\"#).unwrap()\n        );\n        test!(\n            DataType::List,\n            text!(r#\"[ 1, 2, 3 ]\"#),\n            Value::parse_json_list(r#\"[ 1, 2, 3 ]\"#).unwrap()\n        );\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":315},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","selector.rs"],"content":"use {\n    super::{Value, ValueError},\n    crate::result::Result,\n    std::{\n        collections::HashMap,\n        ops::ControlFlow::{Break, Continue},\n    },\n};\n\nenum Selectable\u003c'a\u003e {\n    Map(\u0026'a HashMap\u003cString, Value\u003e),\n    List(\u0026'a Vec\u003cValue\u003e),\n    Other(\u0026'a Value),\n}\n\nimpl Value {\n    pub fn selector(\u0026self, selector: \u0026str) -\u003e Result\u003cValue\u003e {\n        let selectable = match self {\n            Value::Map(v) =\u003e Selectable::Map(v),\n            Value::List(v) =\u003e Selectable::List(v),\n            _ =\u003e return Err(ValueError::SelectorRequiresMapOrListTypes.into()),\n        };\n\n        let result = selector.split('.').try_fold(selectable, |selectable, key| {\n            let value = match selectable {\n                Selectable::Map(map) =\u003e map.get(key),\n                Selectable::List(list) =\u003e key.parse::\u003cusize\u003e().ok().and_then(|i| list.get(i)),\n                Selectable::Other(_) =\u003e return Break(()),\n            };\n\n            match value {\n                Some(Value::Map(map)) =\u003e Continue(Selectable::Map(map)),\n                Some(Value::List(list)) =\u003e Continue(Selectable::List(list)),\n                Some(value) =\u003e Continue(Selectable::Other(value)),\n                None =\u003e Break(()),\n            }\n        });\n\n        let value = match result {\n            Continue(Selectable::Map(map)) =\u003e Value::Map(map.clone()),\n            Continue(Selectable::List(list)) =\u003e Value::List(list.clone()),\n            Continue(Selectable::Other(value)) =\u003e value.clone(),\n            Break(_) =\u003e Value::Null,\n        };\n\n        Ok(value)\n    }\n\n    pub fn selector_by_index(\u0026self, selector: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n        selector\n            .iter()\n            .map(String::from)\n            .try_fold(self, |selectable, key| {\n                selectable.get_value_from_compound_type(\u0026key)\n            })\n            .cloned()\n    }\n\n    fn get_value_from_compound_type(\u0026self, key: \u0026str) -\u003e Result\u003c\u0026Value\u003e {\n        let value = match self {\n            Value::Map(map) =\u003e map.get(key),\n            Value::List(list) =\u003e key.parse::\u003cusize\u003e().ok().and_then(|i| list.get(i)),\n            _ =\u003e return Err(ValueError::SelectorRequiresMapOrListTypes.into()),\n        };\n\n        Ok(value.unwrap_or(\u0026Value::Null))\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":30},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value","uuid.rs"],"content":"use {super::ValueError, crate::result::Result, uuid::Uuid};\n\npub fn parse_uuid(v: \u0026str) -\u003e Result\u003cu128\u003e {\n    match Uuid::parse_str(v) {\n        Ok(u) =\u003e Ok(u.as_u128()),\n        _ =\u003e Err(ValueError::FailedToParseUUID(v.to_owned()).into()),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::data::value::ValueError;\n\n    #[test]\n    fn parse_uuid() {\n        macro_rules! test (\n            ($str: literal, $result: expr) =\u003e {\n                assert_eq!(super::parse_uuid($str), $result)\n            }\n        );\n\n        test!(\n            \"936DA01F9ABD4d9d80C702AF85C822A8\",\n            Ok(195965723427462096757863453463987888808)\n        );\n        test!(\n            \"550e8400-e29b-41d4-a716-446655440000\",\n            Ok(113059749145936325402354257176981405696)\n        );\n        test!(\n            \"urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4\",\n            Ok(331094848530093083170738142201201533412)\n        );\n\n        test!(\n            \"1\",\n            Err(ValueError::FailedToParseUUID(\"1\".to_owned()).into())\n        );\n        test!(\n            \"NOT_UUID_STRING\",\n            Err(ValueError::FailedToParseUUID(\"NOT_UUID_STRING\".to_owned()).into())\n        );\n    }\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":0}},{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data","value.rs"],"content":"use {\n    super::{Interval, Key, StringExt},\n    crate::{\n        ast::{DataType, DateTimeField},\n        data::point::Point,\n        result::Result,\n    },\n    binary_op::TryBinaryOperator,\n    chrono::{Datelike, NaiveDate, NaiveDateTime, NaiveTime, Timelike},\n    core::ops::Sub,\n    rust_decimal::Decimal,\n    serde::{Deserialize, Serialize},\n    std::{cmp::Ordering, collections::HashMap, fmt::Debug, net::IpAddr},\n};\n\nmod binary_op;\nmod convert;\nmod date;\nmod error;\nmod expr;\nmod json;\nmod literal;\nmod selector;\nmod uuid;\n\npub use {\n    convert::ConvertError,\n    error::{NumericBinaryOperator, ValueError},\n    json::HashMapJsonExt,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub enum Value {\n    Bool(bool),\n    I8(i8),\n    I16(i16),\n    I32(i32),\n    I64(i64),\n    I128(i128),\n    U8(u8),\n    U16(u16),\n    U32(u32),\n    U64(u64),\n    U128(u128),\n    F32(f32),\n    F64(f64),\n    Decimal(Decimal),\n    Str(String),\n    Bytea(Vec\u003cu8\u003e),\n    Inet(IpAddr),\n    Date(NaiveDate),\n    Timestamp(NaiveDateTime),\n    Time(NaiveTime),\n    Interval(Interval),\n    Uuid(u128),\n    Map(HashMap\u003cString, Value\u003e),\n    List(Vec\u003cValue\u003e),\n    Point(Point),\n    Null,\n}\n\nimpl Value {\n    pub fn evaluate_eq(\u0026self, other: \u0026Value) -\u003e bool {\n        match (self, other) {\n            (Value::I8(l), _) =\u003e l == other,\n            (Value::I16(l), _) =\u003e l == other,\n            (Value::I32(l), _) =\u003e l == other,\n            (Value::I64(l), _) =\u003e l == other,\n            (Value::I128(l), _) =\u003e l == other,\n            (Value::U8(l), _) =\u003e l == other,\n            (Value::U16(l), _) =\u003e l == other,\n            (Value::U32(l), _) =\u003e l == other,\n            (Value::U64(l), _) =\u003e l == other,\n            (Value::U128(l), _) =\u003e l == other,\n            (Value::F32(l), _) =\u003e l == other,\n            (Value::F64(l), _) =\u003e l == other,\n            (Value::Date(l), Value::Timestamp(r)) =\u003e l\n                .and_hms_opt(0, 0, 0)\n                .map(|date_time| \u0026date_time == r)\n                .unwrap_or(false),\n            (Value::Timestamp(l), Value::Date(r)) =\u003e r\n                .and_hms_opt(0, 0, 0)\n                .map(|date_time| l == \u0026date_time)\n                .unwrap_or(false),\n            (Value::Null, Value::Null) =\u003e false,\n            _ =\u003e self == other,\n        }\n    }\n\n    pub fn evaluate_cmp(\u0026self, other: \u0026Value) -\u003e Option\u003cOrdering\u003e {\n        match (self, other) {\n            (Value::I8(l), _) =\u003e l.partial_cmp(other),\n            (Value::I16(l), _) =\u003e l.partial_cmp(other),\n            (Value::I32(l), _) =\u003e l.partial_cmp(other),\n            (Value::I64(l), _) =\u003e l.partial_cmp(other),\n            (Value::I128(l), _) =\u003e l.partial_cmp(other),\n            (Value::U8(l), _) =\u003e l.partial_cmp(other),\n            (Value::U16(l), _) =\u003e l.partial_cmp(other),\n            (Value::U32(l), _) =\u003e l.partial_cmp(other),\n            (Value::U64(l), _) =\u003e l.partial_cmp(other),\n            (Value::U128(l), _) =\u003e l.partial_cmp(other),\n            (Value::F32(l), _) =\u003e l.partial_cmp(other),\n            (Value::F64(l), _) =\u003e l.partial_cmp(other),\n            (Value::Decimal(l), Value::Decimal(r)) =\u003e Some(l.cmp(r)),\n            (Value::Bool(l), Value::Bool(r)) =\u003e Some(l.cmp(r)),\n            (Value::Str(l), Value::Str(r)) =\u003e Some(l.cmp(r)),\n            (Value::Bytea(l), Value::Bytea(r)) =\u003e Some(l.cmp(r)),\n            (Value::Inet(l), Value::Inet(r)) =\u003e Some(l.cmp(r)),\n            (Value::Date(l), Value::Date(r)) =\u003e Some(l.cmp(r)),\n            (Value::Date(l), Value::Timestamp(r)) =\u003e {\n                l.and_hms_opt(0, 0, 0).map(|date_time| date_time.cmp(r))\n            }\n            (Value::Timestamp(l), Value::Date(r)) =\u003e {\n                r.and_hms_opt(0, 0, 0).map(|date_time| l.cmp(\u0026date_time))\n            }\n            (Value::Timestamp(l), Value::Timestamp(r)) =\u003e Some(l.cmp(r)),\n            (Value::Time(l), Value::Time(r)) =\u003e Some(l.cmp(r)),\n            (Value::Interval(l), Value::Interval(r)) =\u003e l.partial_cmp(r),\n            (Value::Uuid(l), Value::Uuid(r)) =\u003e Some(l.cmp(r)),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        match self {\n            Value::I8(v) =\u003e *v == 0,\n            Value::I16(v) =\u003e *v == 0,\n            Value::I32(v) =\u003e *v == 0,\n            Value::I64(v) =\u003e *v == 0,\n            Value::I128(v) =\u003e *v == 0,\n            Value::U8(v) =\u003e *v == 0,\n            Value::U16(v) =\u003e *v == 0,\n            Value::U32(v) =\u003e *v == 0,\n            Value::U64(v) =\u003e *v == 0,\n            Value::U128(v) =\u003e *v == 0,\n            Value::F32(v) =\u003e *v == 0.0,\n            Value::F64(v) =\u003e *v == 0.0,\n            Value::Decimal(v) =\u003e *v == Decimal::ZERO,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn get_type(\u0026self) -\u003e Option\u003cDataType\u003e {\n        match self {\n            Value::I8(_) =\u003e Some(DataType::Int8),\n            Value::I16(_) =\u003e Some(DataType::Int16),\n            Value::I32(_) =\u003e Some(DataType::Int32),\n            Value::I64(_) =\u003e Some(DataType::Int),\n            Value::I128(_) =\u003e Some(DataType::Int128),\n            Value::U8(_) =\u003e Some(DataType::Uint8),\n            Value::U16(_) =\u003e Some(DataType::Uint16),\n            Value::U32(_) =\u003e Some(DataType::Uint32),\n            Value::U64(_) =\u003e Some(DataType::Uint64),\n            Value::U128(_) =\u003e Some(DataType::Uint128),\n            Value::F32(_) =\u003e Some(DataType::Float32),\n            Value::F64(_) =\u003e Some(DataType::Float),\n            Value::Decimal(_) =\u003e Some(DataType::Decimal),\n            Value::Bool(_) =\u003e Some(DataType::Boolean),\n            Value::Str(_) =\u003e Some(DataType::Text),\n            Value::Bytea(_) =\u003e Some(DataType::Bytea),\n            Value::Inet(_) =\u003e Some(DataType::Inet),\n            Value::Date(_) =\u003e Some(DataType::Date),\n            Value::Timestamp(_) =\u003e Some(DataType::Timestamp),\n            Value::Time(_) =\u003e Some(DataType::Time),\n            Value::Interval(_) =\u003e Some(DataType::Interval),\n            Value::Uuid(_) =\u003e Some(DataType::Uuid),\n            Value::Map(_) =\u003e Some(DataType::Map),\n            Value::List(_) =\u003e Some(DataType::List),\n            Value::Point(_) =\u003e Some(DataType::Point),\n            Value::Null =\u003e None,\n        }\n    }\n\n    pub fn validate_type(\u0026self, data_type: \u0026DataType) -\u003e Result\u003c()\u003e {\n        let valid = self.get_type().is_none_or(|t| t == *data_type);\n\n        if !valid {\n            return Err(ValueError::IncompatibleDataType {\n                data_type: data_type.clone(),\n                value: self.clone(),\n            }\n            .into());\n        }\n\n        Ok(())\n    }\n\n    pub fn validate_null(\u0026self, nullable: bool) -\u003e Result\u003c()\u003e {\n        if !nullable \u0026\u0026 matches!(self, Value::Null) {\n            return Err(ValueError::NullValueOnNotNullField.into());\n        }\n\n        Ok(())\n    }\n\n    pub fn cast(\u0026self, data_type: \u0026DataType) -\u003e Result\u003cSelf\u003e {\n        match (data_type, self) {\n            (DataType::Int8, Value::I8(_))\n            | (DataType::Int16, Value::I16(_))\n            | (DataType::Int32, Value::I32(_))\n            | (DataType::Int, Value::I64(_))\n            | (DataType::Int128, Value::I128(_))\n            | (DataType::Uint8, Value::U8(_))\n            | (DataType::Uint16, Value::U16(_))\n            | (DataType::Uint32, Value::U32(_))\n            | (DataType::Uint64, Value::U64(_))\n            | (DataType::Uint128, Value::U128(_))\n            | (DataType::Float32, Value::F32(_))\n            | (DataType::Float, Value::F64(_))\n            | (DataType::Decimal, Value::Decimal(_))\n            | (DataType::Boolean, Value::Bool(_))\n            | (DataType::Text, Value::Str(_))\n            | (DataType::Bytea, Value::Bytea(_))\n            | (DataType::Inet, Value::Inet(_))\n            | (DataType::Point, Value::Point(_))\n            | (DataType::Date, Value::Date(_))\n            | (DataType::Timestamp, Value::Timestamp(_))\n            | (DataType::Time, Value::Time(_))\n            | (DataType::Interval, Value::Interval(_))\n            | (DataType::Uuid, Value::Uuid(_)) =\u003e Ok(self.clone()),\n\n            (_, Value::Null) =\u003e Ok(Value::Null),\n\n            (DataType::Boolean, value) =\u003e Ok(value.try_into().map(Value::Bool)?),\n            (DataType::Int8, value) =\u003e Ok(value.try_into().map(Value::I8)?),\n            (DataType::Int16, value) =\u003e Ok(value.try_into().map(Value::I16)?),\n            (DataType::Int32, value) =\u003e Ok(value.try_into().map(Value::I32)?),\n            (DataType::Int, value) =\u003e Ok(value.try_into().map(Value::I64)?),\n            (DataType::Int128, value) =\u003e Ok(value.try_into().map(Value::I128)?),\n            (DataType::Uint8, value) =\u003e Ok(value.try_into().map(Value::U8)?),\n            (DataType::Uint16, value) =\u003e Ok(value.try_into().map(Value::U16)?),\n            (DataType::Uint32, value) =\u003e Ok(value.try_into().map(Value::U32)?),\n            (DataType::Uint64, value) =\u003e Ok(value.try_into().map(Value::U64)?),\n            (DataType::Uint128, value) =\u003e Ok(value.try_into().map(Value::U128)?),\n            (DataType::Float32, value) =\u003e Ok(value.try_into().map(Value::F32)?),\n            (DataType::Float, value) =\u003e Ok(value.try_into().map(Value::F64)?),\n            (DataType::Decimal, value) =\u003e Ok(value.try_into().map(Value::Decimal)?),\n\n            (DataType::Text, value) =\u003e Ok(Value::Str(value.into())),\n\n            (DataType::Date, value) =\u003e Ok(value.try_into().map(Value::Date)?),\n            (DataType::Time, value) =\u003e Ok(value.try_into().map(Value::Time)?),\n            (DataType::Timestamp, value) =\u003e Ok(value.try_into().map(Value::Timestamp)?),\n\n            (DataType::Interval, Value::Str(value)) =\u003e Interval::parse(value).map(Value::Interval),\n            (DataType::Uuid, Value::Str(value)) =\u003e uuid::parse_uuid(value).map(Value::Uuid),\n\n            (DataType::Uuid, value) =\u003e Ok(value.try_into().map(Value::Uuid)?),\n            (DataType::Inet, value) =\u003e Ok(value.try_into().map(Value::Inet)?),\n            (DataType::Point, value) =\u003e Ok(value.try_into().map(Value::Point)?),\n\n            (DataType::Bytea, Value::Str(value)) =\u003e hex::decode(value)\n                .map_err(|_| ValueError::CastFromHexToByteaFailed(value.clone()).into())\n                .map(Value::Bytea),\n            (DataType::List, Value::Str(value)) =\u003e Self::parse_json_list(value),\n            (DataType::Map, Value::Str(value)) =\u003e Self::parse_json_map(value),\n\n            _ =\u003e Err(ValueError::UnimplementedCast {\n                value: self.clone(),\n                data_type: data_type.clone(),\n            }\n            .into()),\n        }\n    }\n\n    pub fn concat(self, other: Value) -\u003e Value {\n        match (self, other) {\n            (Value::Null, _) | (_, Value::Null) =\u003e Value::Null,\n            (Value::List(l), Value::List(r)) =\u003e Value::List([l, r].concat()),\n            (l, r) =\u003e Value::Str(String::from(l) + \u0026String::from(r)),\n        }\n    }\n\n    pub fn add(\u0026self, other: \u0026Value) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        match (self, other) {\n            (I8(a), b) =\u003e a.try_add(b),\n            (I16(a), b) =\u003e a.try_add(b),\n            (I32(a), b) =\u003e a.try_add(b),\n            (I64(a), b) =\u003e a.try_add(b),\n            (I128(a), b) =\u003e a.try_add(b),\n            (U8(a), b) =\u003e a.try_add(b),\n            (U16(a), b) =\u003e a.try_add(b),\n            (U32(a), b) =\u003e a.try_add(b),\n            (U64(a), b) =\u003e a.try_add(b),\n            (U128(a), b) =\u003e a.try_add(b),\n            (F32(a), b) =\u003e a.try_add(b),\n            (F64(a), b) =\u003e a.try_add(b),\n            (Decimal(a), b) =\u003e a.try_add(b),\n            (Date(a), Time(b)) =\u003e Ok(Timestamp(NaiveDateTime::new(*a, *b))),\n            (Date(a), Interval(b)) =\u003e b.add_date(a).map(Timestamp),\n            (Timestamp(a), Interval(b)) =\u003e b.add_timestamp(a).map(Timestamp),\n            (Time(a), Interval(b)) =\u003e b.add_time(a).map(Time),\n            (Interval(a), Interval(b)) =\u003e a.add(b).map(Interval),\n            (Null, I8(_))\n            | (Null, I16(_))\n            | (Null, I32(_))\n            | (Null, I64(_))\n            | (Null, I128(_))\n            | (Null, U8(_))\n            | (Null, U16(_))\n            | (Null, U32(_))\n            | (Null, U64(_))\n            | (Null, U128(_))\n            | (Null, F32(_))\n            | (Null, F64(_))\n            | (Null, Decimal(_))\n            | (Null, Date(_))\n            | (Null, Timestamp(_))\n            | (Null, Interval(_))\n            | (Date(_), Null)\n            | (Timestamp(_), Null)\n            | (Time(_), Null)\n            | (Interval(_), Null)\n            | (Null, Null) =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: self.clone(),\n                operator: NumericBinaryOperator::Add,\n                rhs: other.clone(),\n            }\n            .into()),\n        }\n    }\n\n    pub fn subtract(\u0026self, other: \u0026Value) -\u003e Result\u003cValue\u003e {\n        use {super::Interval as I, Value::*};\n\n        match (self, other) {\n            (I8(a), _) =\u003e a.try_subtract(other),\n            (I16(a), _) =\u003e a.try_subtract(other),\n            (I32(a), _) =\u003e a.try_subtract(other),\n            (I64(a), _) =\u003e a.try_subtract(other),\n            (I128(a), _) =\u003e a.try_subtract(other),\n            (U8(a), _) =\u003e a.try_subtract(other),\n            (U16(a), _) =\u003e a.try_subtract(other),\n            (U32(a), _) =\u003e a.try_subtract(other),\n            (U64(a), _) =\u003e a.try_subtract(other),\n            (U128(a), _) =\u003e a.try_subtract(other),\n            (F32(a), _) =\u003e a.try_subtract(other),\n            (F64(a), _) =\u003e a.try_subtract(other),\n            (Decimal(a), _) =\u003e a.try_subtract(other),\n            (Date(a), Date(b)) =\u003e Ok(Interval(I::days((*a - *b).num_days() as i32))),\n            (Date(a), Interval(b)) =\u003e b.subtract_from_date(a).map(Timestamp),\n            (Timestamp(a), Interval(b)) =\u003e b.subtract_from_timestamp(a).map(Timestamp),\n            (Timestamp(a), Timestamp(b)) =\u003e a\n                .sub(*b)\n                .num_microseconds()\n                .ok_or_else(|| {\n                    ValueError::UnreachableIntegerOverflow(format!(\"{:?} - {:?}\", a, b)).into()\n                })\n                .map(|v| Interval(I::microseconds(v))),\n            (Time(a), Time(b)) =\u003e a\n                .sub(*b)\n                .num_microseconds()\n                .ok_or_else(|| {\n                    ValueError::UnreachableIntegerOverflow(format!(\"{:?} - {:?}\", a, b)).into()\n                })\n                .map(|v| Interval(I::microseconds(v))),\n            (Time(a), Interval(b)) =\u003e b.subtract_from_time(a).map(Time),\n            (Interval(a), Interval(b)) =\u003e a.subtract(b).map(Interval),\n            (Null, I8(_))\n            | (Null, I16(_))\n            | (Null, I32(_))\n            | (Null, I64(_))\n            | (Null, I128(_))\n            | (Null, U8(_))\n            | (Null, U16(_))\n            | (Null, U32(_))\n            | (Null, U64(_))\n            | (Null, U128(_))\n            | (Null, F32(_))\n            | (Null, F64(_))\n            | (Null, Decimal(_))\n            | (Null, Date(_))\n            | (Null, Timestamp(_))\n            | (Null, Time(_))\n            | (Null, Interval(_))\n            | (Date(_), Null)\n            | (Timestamp(_), Null)\n            | (Time(_), Null)\n            | (Interval(_), Null)\n            | (Null, Null) =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: self.clone(),\n                operator: NumericBinaryOperator::Subtract,\n                rhs: other.clone(),\n            }\n            .into()),\n        }\n    }\n\n    pub fn multiply(\u0026self, other: \u0026Value) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        match (self, other) {\n            (I8(a), _) =\u003e a.try_multiply(other),\n            (I16(a), _) =\u003e a.try_multiply(other),\n            (I32(a), _) =\u003e a.try_multiply(other),\n            (I64(a), _) =\u003e a.try_multiply(other),\n            (I128(a), _) =\u003e a.try_multiply(other),\n            (U8(a), _) =\u003e a.try_multiply(other),\n            (U16(a), _) =\u003e a.try_multiply(other),\n            (U32(a), _) =\u003e a.try_multiply(other),\n            (U64(a), _) =\u003e a.try_multiply(other),\n            (U128(a), _) =\u003e a.try_multiply(other),\n            (F32(a), _) =\u003e a.try_multiply(other),\n            (F64(a), _) =\u003e a.try_multiply(other),\n            (Decimal(a), _) =\u003e a.try_multiply(other),\n            (Interval(a), I8(b)) =\u003e Ok(Interval(*a * *b)),\n            (Interval(a), I16(b)) =\u003e Ok(Interval(*a * *b)),\n            (Interval(a), I32(b)) =\u003e Ok(Interval(*a * *b)),\n            (Interval(a), I64(b)) =\u003e Ok(Interval(*a * *b)),\n            (Interval(a), I128(b)) =\u003e Ok(Interval(*a * *b)),\n            (Interval(a), F32(b)) =\u003e Ok(Interval(*a * *b)),\n            (Interval(a), F64(b)) =\u003e Ok(Interval(*a * *b)),\n            (Null, I8(_))\n            | (Null, I16(_))\n            | (Null, I32(_))\n            | (Null, I64(_))\n            | (Null, I128(_))\n            | (Null, U8(_))\n            | (Null, U16(_))\n            | (Null, U32(_))\n            | (Null, U64(_))\n            | (Null, U128(_))\n            | (Null, F32(_))\n            | (Null, F64(_))\n            | (Null, Decimal(_))\n            | (Null, Interval(_))\n            | (Interval(_), Null)\n            | (Null, Null) =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: self.clone(),\n                operator: NumericBinaryOperator::Multiply,\n                rhs: other.clone(),\n            }\n            .into()),\n        }\n    }\n\n    pub fn divide(\u0026self, other: \u0026Value) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        if other.is_zero() {\n            return Err(ValueError::DivisorShouldNotBeZero.into());\n        }\n\n        match (self, other) {\n            (I8(a), _) =\u003e a.try_divide(other),\n            (I16(a), _) =\u003e a.try_divide(other),\n            (I32(a), _) =\u003e a.try_divide(other),\n            (I64(a), _) =\u003e a.try_divide(other),\n            (I128(a), _) =\u003e a.try_divide(other),\n            (U8(a), _) =\u003e a.try_divide(other),\n            (U16(a), _) =\u003e a.try_divide(other),\n            (U32(a), _) =\u003e a.try_divide(other),\n            (U64(a), _) =\u003e a.try_divide(other),\n            (U128(a), _) =\u003e a.try_divide(other),\n            (F32(a), _) =\u003e a.try_divide(other),\n            (F64(a), _) =\u003e a.try_divide(other),\n            (Decimal(a), _) =\u003e a.try_divide(other),\n            (Interval(a), I8(b)) =\u003e Ok(Interval(*a / *b)),\n            (Interval(a), I16(b)) =\u003e Ok(Interval(*a / *b)),\n            (Interval(a), I32(b)) =\u003e Ok(Interval(*a / *b)),\n            (Interval(a), I64(b)) =\u003e Ok(Interval(*a / *b)),\n            (Interval(a), I128(b)) =\u003e Ok(Interval(*a / *b)),\n            (Interval(a), U8(b)) =\u003e Ok(Interval(*a / *b)),\n            (Interval(a), U16(b)) =\u003e Ok(Interval(*a / *b)),\n            (Interval(a), U32(b)) =\u003e Ok(Interval(*a / *b)),\n            (Interval(a), U64(b)) =\u003e Ok(Interval(*a / *b)),\n            (Interval(a), U128(b)) =\u003e Ok(Interval(*a / *b)),\n            (Interval(a), F32(b)) =\u003e Ok(Interval(*a / *b)),\n            (Interval(a), F64(b)) =\u003e Ok(Interval(*a / *b)),\n            (Null, I8(_))\n            | (Null, I16(_))\n            | (Null, I32(_))\n            | (Null, I64(_))\n            | (Null, I128(_))\n            | (Null, U8(_))\n            | (Null, U16(_))\n            | (Null, U32(_))\n            | (Null, U64(_))\n            | (Null, U128(_))\n            | (Null, F32(_))\n            | (Null, F64(_))\n            | (Null, Decimal(_))\n            | (Interval(_), Null)\n            | (Null, Null) =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: self.clone(),\n                operator: NumericBinaryOperator::Divide,\n                rhs: other.clone(),\n            }\n            .into()),\n        }\n    }\n\n    pub fn bitwise_and(\u0026self, other: \u0026Value) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        match (self, other) {\n            (I8(a), I8(b)) =\u003e Ok(I8(a \u0026 b)),\n            (I16(a), I16(b)) =\u003e Ok(I16(a \u0026 b)),\n            (I32(a), I32(b)) =\u003e Ok(I32(a \u0026 b)),\n            (I64(a), I64(b)) =\u003e Ok(I64(a \u0026 b)),\n            (I128(a), I128(b)) =\u003e Ok(I128(a \u0026 b)),\n            (U8(a), U8(b)) =\u003e Ok(U8(a \u0026 b)),\n            (U16(a), U16(b)) =\u003e Ok(U16(a \u0026 b)),\n            (U32(a), U32(b)) =\u003e Ok(U32(a \u0026 b)),\n            (U64(a), U64(b)) =\u003e Ok(U64(a \u0026 b)),\n            (U128(a), U128(b)) =\u003e Ok(U128(a \u0026 b)),\n            (Null, I8(_))\n            | (Null, I16(_))\n            | (Null, I32(_))\n            | (Null, I64(_))\n            | (Null, I128(_))\n            | (Null, U8(_))\n            | (Null, U16(_))\n            | (Null, U32(_))\n            | (Null, U64(_))\n            | (Null, U128(_))\n            | (Null, Null)\n            | (I8(_), Null)\n            | (I16(_), Null)\n            | (I32(_), Null)\n            | (I64(_), Null)\n            | (I128(_), Null)\n            | (U8(_), Null)\n            | (U16(_), Null)\n            | (U32(_), Null)\n            | (U64(_), Null)\n            | (U128(_), Null) =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: self.clone(),\n                rhs: other.clone(),\n                operator: NumericBinaryOperator::BitwiseAnd,\n            }\n            .into()),\n        }\n    }\n\n    pub fn modulo(\u0026self, other: \u0026Value) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        if other.is_zero() {\n            return Err(ValueError::DivisorShouldNotBeZero.into());\n        }\n\n        match (self, other) {\n            (I8(a), _) =\u003e a.try_modulo(other),\n            (I16(a), _) =\u003e a.try_modulo(other),\n            (I32(a), _) =\u003e a.try_modulo(other),\n            (I64(a), _) =\u003e a.try_modulo(other),\n            (I128(a), _) =\u003e a.try_modulo(other),\n            (U8(a), _) =\u003e a.try_modulo(other),\n            (U16(a), _) =\u003e a.try_modulo(other),\n            (U32(a), _) =\u003e a.try_modulo(other),\n            (U64(a), _) =\u003e a.try_modulo(other),\n            (U128(a), _) =\u003e a.try_modulo(other),\n            (F32(a), _) =\u003e a.try_modulo(other),\n            (F64(a), _) =\u003e a.try_modulo(other),\n            (Decimal(a), _) =\u003e a.try_modulo(other),\n            (Null, I8(_))\n            | (Null, I16(_))\n            | (Null, I32(_))\n            | (Null, I64(_))\n            | (Null, I128(_))\n            | (Null, U8(_))\n            | (Null, U16(_))\n            | (Null, U32(_))\n            | (Null, U64(_))\n            | (Null, U128(_))\n            | (Null, F32(_))\n            | (Null, F64(_))\n            | (Null, Decimal(_))\n            | (Null, Null) =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonNumericMathOperation {\n                lhs: self.clone(),\n                operator: NumericBinaryOperator::Modulo,\n                rhs: other.clone(),\n            }\n            .into()),\n        }\n    }\n\n    pub fn bitwise_shift_left(\u0026self, rhs: \u0026Value) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        if *rhs == Null {\n            return Ok(Null);\n        }\n        let rhs = u32::try_from(rhs)?;\n        match self {\n            I8(lhs) =\u003e lhs.checked_shl(rhs).map(I8),\n            I16(lhs) =\u003e lhs.checked_shl(rhs).map(I16),\n            I32(lhs) =\u003e lhs.checked_shl(rhs).map(I32),\n            I64(lhs) =\u003e lhs.checked_shl(rhs).map(I64),\n            I128(lhs) =\u003e lhs.checked_shl(rhs).map(I128),\n            U8(lhs) =\u003e lhs.checked_shl(rhs).map(U8),\n            U16(lhs) =\u003e lhs.checked_shl(rhs).map(U16),\n            U32(lhs) =\u003e lhs.checked_shl(rhs).map(U32),\n            U64(lhs) =\u003e lhs.checked_shl(rhs).map(U64),\n            U128(lhs) =\u003e lhs.checked_shl(rhs).map(U128),\n            Null =\u003e Some(Null),\n            _ =\u003e {\n                return Err(ValueError::NonNumericMathOperation {\n                    lhs: self.clone(),\n                    rhs: U32(rhs),\n                    operator: NumericBinaryOperator::BitwiseShiftLeft,\n                }\n                .into());\n            }\n        }\n        .ok_or_else(|| {\n            ValueError::BinaryOperationOverflow {\n                lhs: self.clone(),\n                rhs: U32(rhs),\n                operator: NumericBinaryOperator::BitwiseShiftLeft,\n            }\n            .into()\n        })\n    }\n\n    pub fn bitwise_shift_right(\u0026self, rhs: \u0026Value) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        if *rhs == Null {\n            return Ok(Null);\n        }\n        let rhs = u32::try_from(rhs)?;\n        match self {\n            I8(lhs) =\u003e lhs.checked_shr(rhs).map(I8),\n            I16(lhs) =\u003e lhs.checked_shr(rhs).map(I16),\n            I32(lhs) =\u003e lhs.checked_shr(rhs).map(I32),\n            I64(lhs) =\u003e lhs.checked_shr(rhs).map(I64),\n            I128(lhs) =\u003e lhs.checked_shr(rhs).map(I128),\n            U8(lhs) =\u003e lhs.checked_shr(rhs).map(U8),\n            U16(lhs) =\u003e lhs.checked_shr(rhs).map(U16),\n            U32(lhs) =\u003e lhs.checked_shr(rhs).map(U32),\n            U64(lhs) =\u003e lhs.checked_shr(rhs).map(U64),\n            U128(lhs) =\u003e lhs.checked_shr(rhs).map(U128),\n            Null =\u003e Some(Null),\n            _ =\u003e {\n                return Err(ValueError::NonNumericMathOperation {\n                    lhs: self.clone(),\n                    rhs: U32(rhs),\n                    operator: NumericBinaryOperator::BitwiseShiftRight,\n                }\n                .into());\n            }\n        }\n        .ok_or_else(|| {\n            ValueError::BinaryOperationOverflow {\n                lhs: self.clone(),\n                rhs: U32(rhs),\n                operator: NumericBinaryOperator::BitwiseShiftRight,\n            }\n            .into()\n        })\n    }\n\n    pub fn is_null(\u0026self) -\u003e bool {\n        matches!(self, Value::Null)\n    }\n\n    pub fn unary_plus(\u0026self) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        match self {\n            I8(_) | I16(_) | I32(_) | I64(_) | I128(_) | U8(_) | U16(_) | U32(_) | U64(_)\n            | U128(_) | F32(_) | F64(_) | Interval(_) | Decimal(_) =\u003e Ok(self.clone()),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::UnaryPlusOnNonNumeric.into()),\n        }\n    }\n\n    pub fn unary_minus(\u0026self) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        match self {\n            I8(a) =\u003e Ok(I8(-a)),\n            I16(a) =\u003e Ok(I16(-a)),\n            I32(a) =\u003e Ok(I32(-a)),\n            I64(a) =\u003e Ok(I64(-a)),\n            I128(a) =\u003e Ok(I128(-a)),\n            F32(a) =\u003e Ok(F32(-a)),\n            F64(a) =\u003e Ok(F64(-a)),\n            Decimal(a) =\u003e Ok(Decimal(-a)),\n            Interval(a) =\u003e Ok(Interval(a.unary_minus())),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::UnaryMinusOnNonNumeric.into()),\n        }\n    }\n\n    pub fn unary_factorial(\u0026self) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        fn factorial_function(a: i128) -\u003e Result\u003ci128\u003e {\n            if a.is_negative() {\n                return Err(ValueError::FactorialOnNegativeNumeric.into());\n            }\n\n            (1_i128..(a + 1_i128))\n                .try_fold(1_i128, |mul, x| mul.checked_mul(x))\n                .ok_or_else(|| ValueError::FactorialOverflow.into())\n        }\n\n        match self {\n            I8(a) =\u003e factorial_function(*a as i128).map(I128),\n            I16(a) =\u003e factorial_function(*a as i128).map(I128),\n            I32(a) =\u003e factorial_function(*a as i128).map(I128),\n            I64(a) =\u003e factorial_function(*a as i128).map(I128),\n            I128(a) =\u003e factorial_function(*a).map(I128),\n            U8(a) =\u003e factorial_function(*a as i128).map(I128),\n            U16(a) =\u003e factorial_function(*a as i128).map(I128),\n            U32(a) =\u003e factorial_function(*a as i128).map(I128),\n            U64(a) =\u003e factorial_function(*a as i128).map(I128),\n            U128(a) =\u003e factorial_function(*a as i128).map(I128),\n            F32(_) =\u003e Err(ValueError::FactorialOnNonInteger.into()),\n            F64(_) =\u003e Err(ValueError::FactorialOnNonInteger.into()),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::FactorialOnNonNumeric.into()),\n        }\n    }\n\n    pub fn unary_bitwise_not(\u0026self) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        match self {\n            I8(v) =\u003e Ok(Value::I8(!v)),\n            I16(v) =\u003e Ok(Value::I16(!v)),\n            I32(v) =\u003e Ok(Value::I32(!v)),\n            I64(v) =\u003e Ok(Value::I64(!v)),\n            I128(v) =\u003e Ok(Value::I128(!v)),\n            U8(v) =\u003e Ok(Value::U8(!v)),\n            U16(v) =\u003e Ok(Value::U16(!v)),\n            U32(v) =\u003e Ok(Value::U32(!v)),\n            U64(v) =\u003e Ok(Value::U64(!v)),\n            U128(v) =\u003e Ok(Value::U128(!v)),\n            F32(_) =\u003e Err(ValueError::UnaryBitwiseNotOnNonInteger.into()),\n            F64(_) =\u003e Err(ValueError::UnaryBitwiseNotOnNonInteger.into()),\n            Null =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::UnaryBitwiseNotOnNonNumeric.into()),\n        }\n    }\n\n    pub fn like(\u0026self, other: \u0026Value, case_sensitive: bool) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        match (self, other) {\n            (Str(a), Str(b)) =\u003e a.like(b, case_sensitive).map(Bool),\n            _ =\u003e Err(ValueError::LikeOnNonString {\n                base: self.clone(),\n                pattern: other.clone(),\n                case_sensitive,\n            }\n            .into()),\n        }\n    }\n\n    pub fn extract(\u0026self, date_type: \u0026DateTimeField) -\u003e Result\u003cValue\u003e {\n        let value = match (self, date_type) {\n            (Value::Date(v), DateTimeField::Year) =\u003e v.year().into(),\n            (Value::Date(v), DateTimeField::Month) =\u003e v.month().into(),\n            (Value::Date(v), DateTimeField::Day) =\u003e v.day().into(),\n            (Value::Time(v), DateTimeField::Hour) =\u003e v.hour().into(),\n            (Value::Time(v), DateTimeField::Minute) =\u003e v.minute().into(),\n            (Value::Time(v), DateTimeField::Second) =\u003e v.second().into(),\n            (Value::Timestamp(v), DateTimeField::Year) =\u003e v.year().into(),\n            (Value::Timestamp(v), DateTimeField::Month) =\u003e v.month().into(),\n            (Value::Timestamp(v), DateTimeField::Day) =\u003e v.day().into(),\n            (Value::Timestamp(v), DateTimeField::Hour) =\u003e v.hour().into(),\n            (Value::Timestamp(v), DateTimeField::Minute) =\u003e v.minute().into(),\n            (Value::Timestamp(v), DateTimeField::Second) =\u003e v.second().into(),\n            (Value::Interval(v), _) =\u003e {\n                return v.extract(date_type);\n            }\n            _ =\u003e {\n                return Err(ValueError::ExtractFormatNotMatched {\n                    value: self.clone(),\n                    field: *date_type,\n                }\n                .into());\n            }\n        };\n\n        Ok(Value::I64(value))\n    }\n\n    pub fn sqrt(\u0026self) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n        match self {\n            I8(_) | I16(_) | I64(_) | I128(_) | U8(_) | U16(_) | U32(_) | U64(_) | U128(_)\n            | F32(_) | F64(_) =\u003e {\n                let a: f64 = self.try_into()?;\n                Ok(Value::F64(a.sqrt()))\n            }\n            Null =\u003e Ok(Value::Null),\n            _ =\u003e Err(ValueError::SqrtOnNonNumeric(self.clone()).into()),\n        }\n    }\n\n    /// Value to Big-Endian for comparison purpose\n    pub fn to_cmp_be_bytes(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n        self.try_into().and_then(|key: Key| key.to_cmp_be_bytes())\n    }\n\n    /// # Description\n    /// The operation method differs depending on the argument.\n    /// 1. If both arguments are String\n    ///     - Support only [`Value::Str`] variant\n    ///     - Returns the position where the first letter of the substring starts if the string contains a substring.\n    ///     - Returns [`Value::I64`] 0 if the string to be found is not found.\n    ///     - Returns minimum value [`Value::I64`] 1 when the string is found.\n    ///     - Returns [`Value::Null`] if NULL parameter found.\n    ///\n    /// 2. Other arguments\n    ///     - Not Supported Yet.\n    ///\n    /// # Examples\n    /// ```\n    /// use gluesql_core::prelude::Value;\n    ///\n    /// let str1 = Value::Str(\"ramen\".to_owned());\n    /// let str2 = Value::Str(\"men\".to_owned());\n    ///\n    /// assert_eq!(str1.position(\u0026str2), Ok(Value::I64(3)));\n    /// assert_eq!(str2.position(\u0026str1), Ok(Value::I64(0)));\n    /// assert!(Value::Null.position(\u0026str2).unwrap().is_null());\n    /// assert!(str1.position(\u0026Value::Null).unwrap().is_null());\n    /// ```\n    pub fn position(\u0026self, other: \u0026Value) -\u003e Result\u003cValue\u003e {\n        use Value::*;\n\n        match (self, other) {\n            (Str(from), Str(sub)) =\u003e Ok(I64(str_position(from, sub) as i64)),\n            (Null, _) | (_, Null) =\u003e Ok(Null),\n            _ =\u003e Err(ValueError::NonStringParameterInPosition {\n                from: self.clone(),\n                sub: other.clone(),\n            }\n            .into()),\n        }\n    }\n\n    pub fn find_idx(\u0026self, sub_val: \u0026Value, start: \u0026Value) -\u003e Result\u003cValue\u003e {\n        let start: i64 = start.try_into()?;\n        if start \u003c= 0 {\n            return Err(ValueError::NonPositiveIntegerOffsetInFindIdx(start.to_string()).into());\n        }\n        let from = \u0026String::from(self);\n        let sub = \u0026String::from(sub_val);\n        let position = str_position(\u0026from[(start - 1) as usize..], sub) as i64;\n        let position = match position {\n            0 =\u003e 0,\n            _ =\u003e position + start - 1,\n        };\n        Ok(Value::I64(position))\n    }\n}\n\nfn str_position(from_str: \u0026str, sub_str: \u0026str) -\u003e usize {\n    if from_str.is_empty() || sub_str.is_empty() {\n        return 0;\n    }\n    from_str\n        .find(sub_str)\n        .map(|position| position + 1)\n        .unwrap_or(0)\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::{Interval, Value::*},\n        crate::data::{NumericBinaryOperator, ValueError, point::Point, value::uuid::parse_uuid},\n        chrono::{NaiveDate, NaiveTime},\n        rust_decimal::Decimal,\n        std::{net::IpAddr, str::FromStr},\n    };\n\n    fn time(hour: u32, min: u32, sec: u32) -\u003e NaiveTime {\n        NaiveTime::from_hms_opt(hour, min, sec).unwrap()\n    }\n\n    fn date(year: i32, month: u32, day: u32) -\u003e NaiveDate {\n        NaiveDate::from_ymd_opt(year, month, day).unwrap()\n    }\n\n    #[allow(clippy::eq_op)]\n    #[test]\n    fn evaluate_eq() {\n        use {\n            super::Interval,\n            chrono::{NaiveDateTime, NaiveTime},\n        };\n        let decimal = |n: i32| Decimal(n.into());\n        let bytea = |v: \u0026str| Bytea(hex::decode(v).unwrap());\n        let inet = |v: \u0026str| Inet(IpAddr::from_str(v).unwrap());\n\n        assert_eq!(Null, Null);\n        assert!(!Null.evaluate_eq(\u0026Null));\n        assert!(Bool(true).evaluate_eq(\u0026Bool(true)));\n        assert!(I8(1).evaluate_eq(\u0026I8(1)));\n        assert!(I16(1).evaluate_eq(\u0026I16(1)));\n        assert!(I32(1).evaluate_eq(\u0026I32(1)));\n        assert!(I64(1).evaluate_eq(\u0026I64(1)));\n        assert!(I128(1).evaluate_eq(\u0026I128(1)));\n        assert!(U8(1).evaluate_eq(\u0026U8(1)));\n        assert!(U16(1).evaluate_eq(\u0026U16(1)));\n        assert!(U32(1).evaluate_eq(\u0026U32(1)));\n        assert!(U64(1).evaluate_eq(\u0026U64(1)));\n        assert!(U128(1).evaluate_eq(\u0026U128(1)));\n        assert!(I64(1).evaluate_eq(\u0026F64(1.0)));\n        assert!(F32(1.0_f32).evaluate_eq(\u0026I64(1)));\n        assert!(F32(6.11_f32).evaluate_eq(\u0026F64(6.11)));\n        assert!(F64(1.0).evaluate_eq(\u0026I64(1)));\n        assert!(F64(6.11).evaluate_eq(\u0026F64(6.11)));\n        assert!(Str(\"Glue\".to_owned()).evaluate_eq(\u0026Str(\"Glue\".to_owned())));\n        assert!(bytea(\"1004\").evaluate_eq(\u0026bytea(\"1004\")));\n        assert!(inet(\"::1\").evaluate_eq(\u0026inet(\"::1\")));\n        assert!(Interval(Interval::Month(1)).evaluate_eq(\u0026Interval(Interval::Month(1))));\n        assert!(\n            Time(NaiveTime::from_hms_opt(12, 30, 11).unwrap())\n                .evaluate_eq(\u0026Time(NaiveTime::from_hms_opt(12, 30, 11).unwrap()))\n        );\n        assert!(decimal(1).evaluate_eq(\u0026decimal(1)));\n        assert!(\n            Date(\"2020-05-01\".parse().unwrap()).evaluate_eq(\u0026Date(\"2020-05-01\".parse().unwrap()))\n        );\n        assert!(\n            Timestamp(\"2020-05-01T00:00:00\".parse::\u003cNaiveDateTime\u003e().unwrap()).evaluate_eq(\n                \u0026Timestamp(\"2020-05-01T00:00:00\".parse::\u003cNaiveDateTime\u003e().unwrap())\n            )\n        );\n        assert!(\n            Uuid(parse_uuid(\"936DA01F9ABD4d9d80C702AF85C822A8\").unwrap()).evaluate_eq(\u0026Uuid(\n                parse_uuid(\"936DA01F9ABD4d9d80C702AF85C822A8\").unwrap()\n            ))\n        );\n        assert!(Point(Point::new(1.0, 2.0)).evaluate_eq(\u0026Point(Point::new(1.0, 2.0))));\n\n        let date = Date(\"2020-05-01\".parse().unwrap());\n        let timestamp = Timestamp(\"2020-05-01T00:00:00\".parse::\u003cNaiveDateTime\u003e().unwrap());\n\n        assert!(date.evaluate_eq(\u0026timestamp));\n        assert!(timestamp.evaluate_eq(\u0026date));\n    }\n\n    #[test]\n    fn cmp() {\n        use {\n            chrono::{NaiveDate, NaiveTime},\n            std::cmp::Ordering,\n        };\n\n        assert_eq!(\n            Bool(true).evaluate_cmp(\u0026Bool(false)),\n            Some(Ordering::Greater)\n        );\n        assert_eq!(Bool(true).evaluate_cmp(\u0026Bool(true)), Some(Ordering::Equal));\n        assert_eq!(\n            Bool(false).evaluate_cmp(\u0026Bool(false)),\n            Some(Ordering::Equal)\n        );\n        assert_eq!(Bool(false).evaluate_cmp(\u0026Bool(true)), Some(Ordering::Less));\n\n        let date = Date(NaiveDate::from_ymd_opt(2020, 5, 1).unwrap());\n        let timestamp = Timestamp(\n            NaiveDate::from_ymd_opt(2020, 3, 1)\n                .unwrap()\n                .and_hms_opt(0, 0, 0)\n                .unwrap(),\n        );\n\n        assert_eq!(date.evaluate_cmp(\u0026timestamp), Some(Ordering::Greater));\n        assert_eq!(timestamp.evaluate_cmp(\u0026date), Some(Ordering::Less));\n\n        assert_eq!(\n            Time(NaiveTime::from_hms_opt(23, 0, 1).unwrap())\n                .evaluate_cmp(\u0026Time(NaiveTime::from_hms_opt(10, 59, 59).unwrap())),\n            Some(Ordering::Greater)\n        );\n        assert_eq!(\n            Interval(Interval::Month(1)).evaluate_cmp(\u0026Interval(Interval::Month(2))),\n            Some(Ordering::Less)\n        );\n\n        let one = Decimal(rust_decimal::Decimal::ONE);\n        let two = Decimal(rust_decimal::Decimal::TWO);\n        assert_eq!(one.evaluate_cmp(\u0026two), Some(Ordering::Less));\n        assert_eq!(two.evaluate_cmp(\u0026one), Some(Ordering::Greater));\n\n        assert_eq!(\n            F32(1.0_f32).evaluate_cmp(\u0026F32(1.0_f32)),\n            Some(Ordering::Equal)\n        );\n        assert_eq!(F64(1.0).evaluate_cmp(\u0026F64(1.0)), Some(Ordering::Equal));\n\n        assert_eq!(\n            Interval(Interval::Month(1)).evaluate_cmp(\u0026Interval(Interval::Month(1))),\n            Some(Ordering::Equal)\n        );\n\n        assert_eq!(\n            Uuid(parse_uuid(\"936DA01F9ABD4d9d80C702AF85C822A8\").unwrap()).evaluate_cmp(\u0026Uuid(\n                parse_uuid(\"936DA01F9ABD4d9d80C702AF85C822A8\").unwrap()\n            )),\n            Some(Ordering::Equal)\n        );\n\n        assert_eq!(Null.evaluate_cmp(\u0026Null), None);\n\n        let bytea = |v: \u0026str| Bytea(hex::decode(v).unwrap());\n        assert_eq!(bytea(\"12\").evaluate_cmp(\u0026bytea(\"20\")), Some(Ordering::Less));\n        assert_eq!(\n            bytea(\"9123\").evaluate_cmp(\u0026bytea(\"9122\")),\n            Some(Ordering::Greater)\n        );\n        assert_eq!(\n            bytea(\"10\").evaluate_cmp(\u0026bytea(\"10\")),\n            Some(Ordering::Equal)\n        );\n\n        let inet = |v: \u0026str| Inet(IpAddr::from_str(v).unwrap());\n        assert_eq!(\n            inet(\"0.0.0.0\").evaluate_cmp(\u0026inet(\"127.0.0.1\")),\n            Some(Ordering::Less)\n        );\n        assert_eq!(\n            inet(\"192.168.0.1\").evaluate_cmp(\u0026inet(\"127.0.0.1\")),\n            Some(Ordering::Greater)\n        );\n        assert_eq!(\n            inet(\"::1\").evaluate_cmp(\u0026inet(\"::1\")),\n            Some(Ordering::Equal)\n        );\n    }\n\n    #[test]\n    fn cmp_ints() {\n        use std::cmp::Ordering;\n\n        assert_eq!(I8(0).evaluate_cmp(\u0026I8(-1)), Some(Ordering::Greater));\n        assert_eq!(I8(0).evaluate_cmp(\u0026I8(0)), Some(Ordering::Equal));\n        assert_eq!(I8(0).evaluate_cmp(\u0026I8(1)), Some(Ordering::Less));\n\n        assert_eq!(I16(0).evaluate_cmp(\u0026I8(-1)), Some(Ordering::Greater));\n        assert_eq!(I16(0).evaluate_cmp(\u0026I8(0)), Some(Ordering::Equal));\n        assert_eq!(I16(0).evaluate_cmp(\u0026I8(1)), Some(Ordering::Less));\n\n        assert_eq!(I32(0).evaluate_cmp(\u0026I8(-1)), Some(Ordering::Greater));\n        assert_eq!(I32(0).evaluate_cmp(\u0026I8(0)), Some(Ordering::Equal));\n        assert_eq!(I32(0).evaluate_cmp(\u0026I8(1)), Some(Ordering::Less));\n\n        assert_eq!(I64(0).evaluate_cmp(\u0026I8(-1)), Some(Ordering::Greater));\n        assert_eq!(I64(0).evaluate_cmp(\u0026I8(0)), Some(Ordering::Equal));\n        assert_eq!(I64(0).evaluate_cmp(\u0026I8(1)), Some(Ordering::Less));\n\n        assert_eq!(I128(0).evaluate_cmp(\u0026I8(-1)), Some(Ordering::Greater));\n        assert_eq!(I128(0).evaluate_cmp(\u0026I8(0)), Some(Ordering::Equal));\n        assert_eq!(I128(0).evaluate_cmp(\u0026I8(1)), Some(Ordering::Less));\n\n        assert_eq!(U8(1).evaluate_cmp(\u0026U8(0)), Some(Ordering::Greater));\n        assert_eq!(U8(0).evaluate_cmp(\u0026U8(0)), Some(Ordering::Equal));\n        assert_eq!(U8(0).evaluate_cmp(\u0026U8(1)), Some(Ordering::Less));\n\n        assert_eq!(U16(1).evaluate_cmp(\u0026U16(0)), Some(Ordering::Greater));\n        assert_eq!(U16(0).evaluate_cmp(\u0026U16(0)), Some(Ordering::Equal));\n        assert_eq!(U16(0).evaluate_cmp(\u0026U16(1)), Some(Ordering::Less));\n\n        assert_eq!(U32(1).evaluate_cmp(\u0026U32(0)), Some(Ordering::Greater));\n        assert_eq!(U32(0).evaluate_cmp(\u0026U32(0)), Some(Ordering::Equal));\n        assert_eq!(U32(0).evaluate_cmp(\u0026U32(1)), Some(Ordering::Less));\n\n        assert_eq!(U64(1).evaluate_cmp(\u0026U64(0)), Some(Ordering::Greater));\n        assert_eq!(U64(0).evaluate_cmp(\u0026U64(0)), Some(Ordering::Equal));\n        assert_eq!(U64(0).evaluate_cmp(\u0026U64(1)), Some(Ordering::Less));\n\n        assert_eq!(U128(1).evaluate_cmp(\u0026U128(0)), Some(Ordering::Greater));\n        assert_eq!(U128(0).evaluate_cmp(\u0026U128(0)), Some(Ordering::Equal));\n        assert_eq!(U128(0).evaluate_cmp(\u0026U128(1)), Some(Ordering::Less));\n    }\n\n    #[test]\n    fn is_zero() {\n        for i in -1..2 {\n            assert_eq!(I8(i).is_zero(), i == 0);\n            assert_eq!(I16(i.into()).is_zero(), i == 0);\n            assert_eq!(I32(i.into()).is_zero(), i == 0);\n            assert_eq!(I64(i.into()).is_zero(), i == 0);\n            assert_eq!(I128(i.into()).is_zero(), i == 0);\n            assert_eq!(F32(i.into()).is_zero(), i == 0);\n            assert_eq!(F64(i.into()).is_zero(), i == 0);\n            assert_eq!(Decimal(i.into()).is_zero(), i == 0);\n        }\n        assert!(U8(0).is_zero());\n        assert!(!U8(1).is_zero());\n        assert!(U16(0).is_zero());\n        assert!(!U16(1).is_zero());\n        assert!(U32(0).is_zero());\n        assert!(!U32(1).is_zero());\n        assert!(U64(0).is_zero());\n        assert!(!U64(1).is_zero());\n        assert!(U128(0).is_zero());\n        assert!(!U128(1).is_zero());\n    }\n\n    #[test]\n    fn arithmetic() {\n        use chrono::{NaiveDate, NaiveTime};\n\n        macro_rules! test {\n            ($op: ident $a: expr, $b: expr =\u003e $c: expr) =\u003e {\n                assert!($a.$op(\u0026$b).unwrap().evaluate_eq(\u0026$c));\n            };\n        }\n\n        macro_rules! mon {\n            ($n: expr) =\u003e {\n                Interval(Interval::Month($n))\n            };\n        }\n\n        let decimal = |n: i32| Decimal(n.into());\n\n        test!(add I8(1),    I8(2)    =\u003e I8(3));\n        test!(add I8(1),    I16(2)    =\u003e I16(3));\n        test!(add I8(1),    I32(2)   =\u003e I32(3));\n        test!(add I8(1),    I64(2)   =\u003e I64(3));\n        test!(add I8(1),    I128(2)  =\u003e I128(3));\n        test!(add I8(1),    U8(2)    =\u003e I64(3));\n\n        test!(add I16(1),    I8(2)    =\u003e I16(3));\n        test!(add I16(1),    I16(2)    =\u003e I16(3));\n        test!(add I16(1),    I32(2)   =\u003e I32(3));\n        test!(add I16(1),    I64(2)   =\u003e I64(3));\n        test!(add I16(1),    I128(2)  =\u003e I128(3));\n        test!(add I16(1),    U8(2)    =\u003e I16(3));\n\n        test!(add I32(1),    I8(2)      =\u003e I32(3));\n        test!(add I32(1),    I16(2)      =\u003e I32(3));\n        test!(add I32(1),    I32(2)     =\u003e I32(3));\n        test!(add I32(1),    I64(2)     =\u003e I64(3));\n        test!(add I32(1),    I128(2)    =\u003e I128(3));\n        test!(add I32(1),    U8(2)      =\u003e I32(3));\n\n        test!(add I64(1),    I8(2)      =\u003e I64(3));\n        test!(add I64(1),    I16(2)      =\u003e I64(3));\n        test!(add I64(1),    I32(2)     =\u003e I64(3));\n        test!(add I64(1),    I64(2)     =\u003e I64(3));\n        test!(add I64(1),    I128(2)    =\u003e I128(3));\n        test!(add I64(1),    U8(2)      =\u003e I64(3));\n\n        test!(add I128(1),    I8(2)    =\u003e I128(3));\n        test!(add I128(1),    I16(2)    =\u003e I128(3));\n        test!(add I128(1),    I32(2)    =\u003e I128(3));\n        test!(add I128(1),    I64(2)   =\u003e I128(3));\n        test!(add I128(1),    I128(2)  =\u003e I128(3));\n        test!(add I128(1),    U8(2)    =\u003e I128(3));\n\n        test!(add I8(1),    F64(2.0) =\u003e F64(3.0));\n\n        test!(add I32(1),   I8(2)    =\u003e I32(3));\n        test!(add I32(1),   I16(2)    =\u003e I32(3));\n        test!(add I32(1),   I32(2)   =\u003e I32(3));\n        test!(add I32(1),   I64(2)   =\u003e I64(3));\n        test!(add I32(1),   F32(2.0_f32) =\u003e F32(3.0_f32));\n        test!(add I32(1),   F64(2.0) =\u003e F64(3.0));\n\n        test!(add I64(1),   I8(2)    =\u003e I64(3));\n        test!(add I64(1),   I16(2)    =\u003e I64(3));\n        test!(add I64(1),   I32(2)   =\u003e I64(3));\n        test!(add I64(1),   I64(2)   =\u003e I64(3));\n        test!(add I64(1),   F32(2.0_f32) =\u003e F32(3.0_f32));\n        test!(add I64(1),   F64(2.0) =\u003e F64(3.0));\n\n        test!(add I128(1),   I8(2)    =\u003e I128(3));\n        test!(add I128(1),   I16(2)    =\u003e I128(3));\n        test!(add I128(1),   I32(2)   =\u003e I128(3));\n        test!(add I128(1),   I64(2)   =\u003e I128(3));\n        test!(add I128(1),   F32(2.0_f32) =\u003e F32(3.0_f32));\n        test!(add I128(1),   F64(2.0) =\u003e F64(3.0));\n\n        test!(add U8(1),   I8(2)     =\u003e I64(3));\n        test!(add U8(1),   I16(2)    =\u003e I16(3));\n        test!(add U8(1),   I32(2)    =\u003e I32(3));\n        test!(add U8(1),   I64(2)    =\u003e I64(3));\n        test!(add U8(1),   I128(2)   =\u003e I128(3));\n        test!(add U8(1),   U8(2)     =\u003e U8(3));\n        test!(add U8(1),   F32(2.0_f32)  =\u003e F32(3.0_f32));\n        test!(add U8(1),   F64(2.0)  =\u003e F64(3.0));\n\n        test!(add U16(1),   I8(2)     =\u003e U16(3));\n        test!(add U16(1),   I16(2)    =\u003e U16(3));\n        test!(add U16(1),   I32(2)    =\u003e U16(3));\n        test!(add U16(1),   I64(2)    =\u003e U16(3));\n        test!(add U16(1),   I128(2)   =\u003e U16(3));\n        test!(add U16(1),   U8(2)     =\u003e U16(3));\n        test!(add U16(1),   F32(2.0_f32)  =\u003e F32(3.0_f32));\n        test!(add U16(1),   F64(2.0)  =\u003e F64(3.0));\n\n        test!(add U32(1),   I8(2)     =\u003e U32(3));\n        test!(add U32(1),   I16(2)    =\u003e U32(3));\n        test!(add U32(1),   I32(2)    =\u003e U32(3));\n        test!(add U32(1),   I64(2)    =\u003e U32(3));\n        test!(add U32(1),   I128(2)   =\u003e U32(3));\n        test!(add U32(1),   U8(2)     =\u003e U32(3));\n        test!(add U32(1),   U16(2)     =\u003e U32(3));\n        test!(add U32(1),   U32(2)     =\u003e U32(3));\n        test!(add U32(1),   F32(2.0_f32)  =\u003e F32(3.0_f32));\n        test!(add U32(1),   F64(2.0)  =\u003e F64(3.0));\n\n        test!(add U64(1),   I8(2)     =\u003e U64(3));\n        test!(add U64(1),   I16(2)    =\u003e U64(3));\n        test!(add U64(1),   I32(2)    =\u003e U64(3));\n        test!(add U64(1),   I64(2)    =\u003e U64(3));\n        test!(add U64(1),   I128(2)   =\u003e U64(3));\n        test!(add U64(1),   U8(2)     =\u003e U64(3));\n        test!(add U64(1),   U16(2)     =\u003e U64(3));\n        test!(add U64(1),   U32(2)     =\u003e U64(3));\n        test!(add U64(1),   F32(2.0_f32)  =\u003e F32(3.0_f32));\n        test!(add U64(1),   F64(2.0)  =\u003e F64(3.0));\n\n        test!(add U128(1),   I8(2)     =\u003e U128(3));\n        test!(add U128(1),   I16(2)    =\u003e U128(3));\n        test!(add U128(1),   I32(2)    =\u003e U128(3));\n        test!(add U128(1),   I64(2)    =\u003e U128(3));\n        test!(add U128(1),   I128(2)   =\u003e U128(3));\n        test!(add U128(1),   U8(2)     =\u003e U128(3));\n        test!(add U128(1),   U16(2)     =\u003e U128(3));\n        test!(add U128(1),   U32(2)     =\u003e U128(3));\n        test!(add U128(1),   F32(2.0_f32)  =\u003e F32(3.0_f32));\n        test!(add U128(1),   F64(2.0)  =\u003e F64(3.0));\n\n        test!(add F32(1.0_f32), F32(2.0_f32) =\u003e F32(3.0_f32));\n        test!(add F32(1.0_f32), F64(2.0) =\u003e F64(3.0));\n        test!(add F32(1.0_f32), I8(2)    =\u003e F32(3.0_f32));\n        test!(add F32(1.0_f32), I32(2)   =\u003e F32(3.0_f32));\n        test!(add F32(1.0_f32), I64(2)   =\u003e F32(3.0_f32));\n        test!(add F32(1.0_f32), U8(2)   =\u003e F32(3.0_f32));\n        test!(add F32(1.0_f32), U16(2)   =\u003e F32(3.0_f32));\n        test!(add F32(1.0_f32), U32(2)   =\u003e F32(3.0_f32));\n        test!(add F32(1.0_f32), U64(2)   =\u003e F32(3.0_f32));\n        test!(add F32(1.0_f32), U128(2)   =\u003e F32(3.0_f32));\n\n        test!(add F64(1.0), F64(2.0) =\u003e F64(3.0));\n        test!(add F64(1.0), F32(2.0_f32) =\u003e F32(3.0_f32));\n        test!(add F64(1.0), I8(2)    =\u003e F64(3.0));\n        test!(add F64(1.0), I32(2)   =\u003e F64(3.0));\n        test!(add F64(1.0), I64(2)   =\u003e F64(3.0));\n        test!(add F64(1.0), U8(2)    =\u003e F64(3.0));\n\n        test!(add decimal(1), decimal(2) =\u003e decimal(3));\n\n        test!(add\n            Date(date(2021, 11, 11)),\n            mon!(14)\n            =\u003e\n            Timestamp(date(2023, 1, 11).and_hms_opt(0, 0, 0).unwrap())\n        );\n        test!(add\n            Date(date(2021, 5, 7)),\n            Time(time(12, 0, 0))\n            =\u003e\n            Timestamp(date(2021, 5, 7).and_hms_opt(12, 0, 0).unwrap())\n        );\n        test!(add\n            Timestamp(date(2021, 11, 11).and_hms_opt(0, 0, 0).unwrap()),\n            mon!(14)\n            =\u003e\n            Timestamp(date(2023, 1, 11).and_hms_opt(0, 0, 0).unwrap())\n        );\n        test!(add\n            Time(time(1, 4, 6)),\n            Interval(Interval::hours(20))\n            =\u003e\n            Time(time(21, 4, 6))\n        );\n        test!(add\n            Time(time(23, 10, 0)),\n            Interval(Interval::hours(5))\n            =\u003e\n            Time(time(4, 10, 0))\n        );\n        test!(add mon!(1),    mon!(2)    =\u003e mon!(3));\n\n        test!(subtract I8(3),    I8(2)    =\u003e I8(1));\n        test!(subtract I8(3),    I16(2)    =\u003e I8(1));\n        test!(subtract I8(3),    I32(2)   =\u003e I32(1));\n        test!(subtract I8(3),    I64(2)   =\u003e I64(1));\n        test!(subtract I8(3),    I128(2)  =\u003e I128(1));\n        test!(subtract I8(3),    U8(2)  =\u003e I64(1));\n\n        test!(subtract I32(3),    I8(2)    =\u003e I32(1));\n        test!(subtract I32(3),    I16(2)    =\u003e I32(1));\n        test!(subtract I32(3),    I32(2)   =\u003e I32(1));\n        test!(subtract I32(3),    I64(2)   =\u003e I64(1));\n        test!(subtract I32(3),    I128(2)  =\u003e I128(1));\n        test!(subtract I32(3),    U8(2)  =\u003e I32(1));\n\n        test!(subtract I64(3),    I8(2)    =\u003e I64(1));\n        test!(subtract I64(3),    I16(2)    =\u003e I64(1));\n        test!(subtract I64(3),    I32(2)   =\u003e I64(1));\n        test!(subtract I64(3),    I64(2)   =\u003e I64(1));\n        test!(subtract I64(3),    I128(2)  =\u003e I128(1));\n        test!(subtract I64(3),    U8(2)    =\u003e I64(1));\n\n        test!(subtract I128(3),    I8(2)   =\u003e I128(1));\n        test!(subtract I128(3),    I16(2)   =\u003e I128(1));\n        test!(subtract I128(3),    I32(2)  =\u003e I128(1));\n        test!(subtract I128(3),    I64(2)  =\u003e I128(1));\n        test!(subtract I128(3),    I128(2) =\u003e I128(1));\n        test!(subtract I128(3),    U8(2)   =\u003e I128(1));\n\n        test!(subtract U8(3),   I8(2)     =\u003e I64(1));\n        test!(subtract U8(3),   I16(2)    =\u003e I16(1));\n        test!(subtract U8(3),   I32(2)    =\u003e I32(1));\n        test!(subtract U8(3),   I64(2)    =\u003e I64(1));\n        test!(subtract U8(3),   I128(2)   =\u003e I128(1));\n        test!(subtract U8(3),   U8(2)     =\u003e U8(1));\n        test!(subtract U8(3),   F32(2.0_f32)  =\u003e F32(1.0_f32));\n        test!(subtract U8(3),   F64(2.0)  =\u003e F64(1.0));\n\n        test!(subtract U16(3),   I8(2)     =\u003e U16(1));\n        test!(subtract U16(3),   I16(2)    =\u003e U16(1));\n        test!(subtract U16(3),   I32(2)    =\u003e U16(1));\n        test!(subtract U16(3),   I64(2)    =\u003e U16(1));\n        test!(subtract U16(3),   I128(2)   =\u003e U16(1));\n        test!(subtract U16(3),   U8(2)     =\u003e U16(1));\n        test!(subtract U16(3),   F32(2.0_f32)  =\u003e F32(1.0_f32));\n        test!(subtract U16(3),   F64(2.0)  =\u003e F64(1.0));\n\n        test!(subtract U32(3),   I8(2)     =\u003e U32(1));\n        test!(subtract U32(3),   I16(2)    =\u003e U32(1));\n        test!(subtract U32(3),   I32(2)    =\u003e U32(1));\n        test!(subtract U32(3),   I64(2)    =\u003e U32(1));\n        test!(subtract U32(3),   I128(2)   =\u003e U32(1));\n        test!(subtract U32(3),   U8(2)     =\u003e U32(1));\n        test!(subtract U32(3),   F32(2.0_f32)  =\u003e F32(1.0_f32));\n        test!(subtract U32(3),   F64(2.0)  =\u003e F64(1.0));\n\n        test!(subtract U64(3),   I8(2)     =\u003e U64(1));\n        test!(subtract U64(3),   I16(2)    =\u003e U64(1));\n        test!(subtract U64(3),   I32(2)    =\u003e U64(1));\n        test!(subtract U64(3),   I64(2)    =\u003e U64(1));\n        test!(subtract U64(3),   I128(2)   =\u003e U64(1));\n        test!(subtract U64(3),   U8(2)     =\u003e U64(1));\n        test!(subtract U64(3),   F32(2.0_f32)  =\u003e F32(1.0_f32));\n        test!(subtract U64(3),   F64(2.0)  =\u003e F64(1.0));\n\n        test!(subtract U128(3),   I8(2)     =\u003e U128(1));\n        test!(subtract U128(3),   I16(2)    =\u003e U128(1));\n        test!(subtract U128(3),   I32(2)    =\u003e U128(1));\n        test!(subtract U128(3),   I64(2)    =\u003e U128(1));\n        test!(subtract U128(3),   I128(2)   =\u003e U128(1));\n        test!(subtract U128(3),   U8(2)     =\u003e U128(1));\n        test!(subtract U128(3),   F32(2.0_f32)  =\u003e F32(1.0_f32));\n        test!(subtract U128(3),   F64(2.0)  =\u003e F64(1.0));\n\n        test!(subtract I8(3),    F32(2.0_f32) =\u003e F32(1.0_f32));\n        test!(subtract I32(3),   F32(2.0_f32) =\u003e F32(1.0_f32));\n        test!(subtract I64(3),   F32(2.0_f32) =\u003e F32(1.0_f32));\n        test!(subtract I128(3),  F32(2.0_f32) =\u003e F32(1.0_f32));\n        test!(subtract U8(3),    F32(2.0_f32) =\u003e F32(1.0_f32));\n        test!(subtract U32(3),   F32(2.0_f32) =\u003e F32(1.0_f32));\n        test!(subtract U64(3),   F32(2.0_f32) =\u003e F32(1.0_f32));\n        test!(subtract U128(3),  F32(2.0_f32) =\u003e F32(1.0_f32));\n\n        test!(subtract I8(3),    F64(2.0) =\u003e F64(1.0));\n        test!(subtract I32(3),   F64(2.0) =\u003e F64(1.0));\n        test!(subtract I64(3),   F64(2.0) =\u003e F64(1.0));\n        test!(subtract I128(3),  F64(2.0) =\u003e F64(1.0));\n\n        test!(subtract I32(3),   I8(2)    =\u003e I64(1));\n        test!(subtract I32(3),   I16(2)    =\u003e I64(1));\n        test!(subtract I32(3),   I32(2)   =\u003e I32(1));\n        test!(subtract I32(3),   I64(2)   =\u003e I64(1));\n        test!(subtract I32(3),   I128(2)  =\u003e I128(1));\n\n        test!(subtract I32(3),   F32(2.0_f32) =\u003e F32(1.0_f32));\n        test!(subtract I32(3),   F64(2.0) =\u003e F64(1.0));\n\n        test!(subtract I64(3),   I8(2)    =\u003e I64(1));\n        test!(subtract I64(3),   I16(2)    =\u003e I64(1));\n        test!(subtract I64(3),   I32(2)   =\u003e I64(1));\n        test!(subtract I64(3),   I64(2)   =\u003e I64(1));\n        test!(subtract I64(3),   I128(2)   =\u003e I64(1));\n        test!(subtract I64(3),   F32(2.0_f32) =\u003e F32(1.0_f32));\n        test!(subtract I64(3),   F64(2.0) =\u003e F64(1.0));\n\n        test!(subtract F32(3.0_f32), F32(2.0_f32) =\u003e F32(1.0_f32));\n        test!(subtract F32(3.0_f32), F64(2.0) =\u003e F64(1.0));\n        test!(subtract F32(3.0_f32), I8(2)    =\u003e F32(1.0_f32));\n        test!(subtract F32(3.0_f32), I64(2)   =\u003e F32(1.0_f32));\n\n        test!(subtract F64(3.0), F32(2.0_f32) =\u003e F32(1.0_f32));\n        test!(subtract F64(3.0), F64(2.0) =\u003e F64(1.0));\n        test!(subtract F64(3.0), I8(2)    =\u003e F64(1.0));\n        test!(subtract F64(3.0), I64(2)   =\u003e F64(1.0));\n        test!(subtract F64(3.0), U8(2)   =\u003e F64(1.0));\n\n        test!(subtract decimal(3), decimal(2) =\u003e decimal(1));\n\n        test!(subtract\n            Date(NaiveDate::from_ymd_opt(2021, 11, 11).unwrap()),\n            Date(NaiveDate::from_ymd_opt(2021, 6, 11).unwrap())\n            =\u003e\n            Interval(Interval::days(153))\n        );\n        test!(subtract\n            Date(NaiveDate::from_ymd_opt(2021, 1, 1).unwrap()),\n            Interval(Interval::days(365))\n            =\u003e\n            Timestamp(NaiveDate::from_ymd_opt(2020, 1, 2).unwrap().and_hms_opt(0, 0, 0).unwrap())\n        );\n        test!(subtract\n            Timestamp(NaiveDate::from_ymd_opt(2021, 1, 1).unwrap().and_hms_opt(15, 0, 0).unwrap()),\n            Timestamp(NaiveDate::from_ymd_opt(2021, 1, 1).unwrap().and_hms_opt(12, 0, 0).unwrap())\n            =\u003e\n            Interval(Interval::hours(3))\n        );\n        test!(subtract\n            Timestamp(NaiveDate::from_ymd_opt(2021, 1, 1).unwrap().and_hms_opt(0, 3, 0).unwrap()),\n            Interval(Interval::days(365))\n            =\u003e\n            Timestamp(NaiveDate::from_ymd_opt(2020, 1, 2).unwrap().and_hms_opt(0, 3, 0).unwrap())\n        );\n        test!(subtract\n            Time(time(1, 4, 6)),\n            Interval(Interval::hours(20))\n            =\u003e\n            Time(time(5, 4, 6))\n        );\n        test!(subtract\n            Time(time(23, 10, 0)),\n            Interval(Interval::hours(5))\n            =\u003e\n            Time(time(18, 10, 0))\n        );\n        test!(subtract mon!(1),  mon!(2)  =\u003e mon!(-1));\n\n        test!(multiply I8(3),    I8(2)    =\u003e I8(6));\n        test!(multiply I8(3),    I16(2)    =\u003e I8(6));\n        test!(multiply I8(3),    I32(2)    =\u003e I32(6));\n        test!(multiply I8(3),    I64(2)   =\u003e I64(6));\n        test!(multiply I8(3),    I128(2)  =\u003e I128(6));\n        test!(multiply I8(3),    U8(2)    =\u003e I64(6));\n\n        test!(multiply I64(3),    I8(2)    =\u003e I64(6));\n        test!(multiply I64(3),    I16(2)    =\u003e I64(6));\n        test!(multiply I64(3),    I32(2)   =\u003e I64(6));\n        test!(multiply I64(3),    I64(2)   =\u003e I64(6));\n        test!(multiply I64(3),    I128(2)  =\u003e I128(6));\n        test!(multiply I64(3),    U8(2)    =\u003e I64(6));\n\n        test!(multiply I128(3),    I8(2)    =\u003e I128(6));\n        test!(multiply I128(3),    I16(2)    =\u003e I128(6));\n        test!(multiply I128(3),    I32(2)    =\u003e I128(6));\n        test!(multiply I128(3),    I64(2)   =\u003e I128(6));\n        test!(multiply I128(3),    I128(2)  =\u003e I128(6));\n        test!(multiply I128(3),    U8(2)  =\u003e I128(6));\n\n        test!(multiply I8(3),    F32(2.0_f32) =\u003e F32(6.0_f32));\n        test!(multiply I16(3),    F32(2.0_f32) =\u003e F32(6.0_f32));\n        test!(multiply I32(3),    F32(2.0_f32) =\u003e F32(6.0_f32));\n        test!(multiply I64(3),   F32(2.0_f32) =\u003e F32(6.0_f32));\n        test!(multiply I128(3),    F32(2.0_f32) =\u003e F32(6.0_f32));\n        test!(multiply I128(3),    U8(2) =\u003e I128(6));\n\n        test!(multiply I8(3),    F64(2.0) =\u003e F64(6.0));\n        test!(multiply I16(3),    F64(2.0) =\u003e F64(6.0));\n        test!(multiply I32(3),    F64(2.0) =\u003e F64(6.0));\n        test!(multiply I64(3),   F64(2.0) =\u003e F64(6.0));\n        test!(multiply I128(3),    F64(2.0) =\u003e F64(6.0));\n        test!(multiply I128(3),    U8(2) =\u003e I128(6));\n\n        test!(multiply U8(3),   I8(2)     =\u003e I64(6));\n        test!(multiply U8(3),   I16(2)    =\u003e I16(6));\n        test!(multiply U8(3),   I32(2)    =\u003e I32(6));\n        test!(multiply U8(3),   I64(2)    =\u003e I64(6));\n        test!(multiply U8(3),   I128(2)   =\u003e I128(6));\n        test!(multiply U8(3),   U8(2)     =\u003e U8(6));\n        test!(multiply U8(3),   F32(2.0_f32)  =\u003e F32(6.0_f32));\n        test!(multiply U8(3),   F64(2.0)  =\u003e F64(6.0));\n\n        test!(multiply U16(3),   I8(2)     =\u003e U16(6));\n        test!(multiply U16(3),   I16(2)    =\u003e U16(6));\n        test!(multiply U16(3),   I32(2)    =\u003e U16(6));\n        test!(multiply U16(3),   I64(2)    =\u003e U16(6));\n        test!(multiply U16(3),   I128(2)   =\u003e U16(6));\n        test!(multiply U16(3),   U8(2)     =\u003e U16(6));\n        test!(multiply U16(3),   F32(2.0_f32)  =\u003e F64(6.0));\n        test!(multiply U16(3),   F64(2.0)  =\u003e F64(6.0));\n\n        test!(multiply U32(3),   I8(2)     =\u003e U32(6));\n        test!(multiply U32(3),   I16(2)    =\u003e U32(6));\n        test!(multiply U32(3),   I32(2)    =\u003e U32(6));\n        test!(multiply U32(3),   I64(2)    =\u003e U32(6));\n        test!(multiply U32(3),   I128(2)   =\u003e U32(6));\n        test!(multiply U32(3),   U8(2)     =\u003e U32(6));\n        test!(multiply U32(3),   F32(2.0_f32)  =\u003e F64(6.0));\n        test!(multiply U32(3),   F64(2.0)  =\u003e F64(6.0));\n\n        test!(multiply U64(3),   I8(2)     =\u003e U64(6));\n        test!(multiply U64(3),   I16(2)    =\u003e U64(6));\n        test!(multiply U64(3),   I32(2)    =\u003e U64(6));\n        test!(multiply U64(3),   I64(2)    =\u003e U64(6));\n        test!(multiply U64(3),   I128(2)   =\u003e U64(6));\n        test!(multiply U64(3),   U8(2)     =\u003e U64(6));\n        test!(multiply U64(3),   F32(2.0_f32)  =\u003e F64(6.0));\n        test!(multiply U64(3),   F64(2.0)  =\u003e F64(6.0));\n\n        test!(multiply U128(3),   I8(2)     =\u003e U128(6));\n        test!(multiply U128(3),   I16(2)    =\u003e U128(6));\n        test!(multiply U128(3),   I32(2)    =\u003e U128(6));\n        test!(multiply U128(3),   I64(2)    =\u003e U128(6));\n        test!(multiply U128(3),   I128(2)   =\u003e U128(6));\n        test!(multiply U128(3),   U8(2)     =\u003e U128(6));\n        test!(multiply U128(3),   F32(2.0_f32)  =\u003e F32(6.0_f32));\n        test!(multiply U128(3),   F64(2.0)  =\u003e F64(6.0));\n\n        test!(multiply F32(3.0_f32), F32(2.0_f32) =\u003e F32(6.0_f32));\n        test!(multiply F32(3.0_f32), F64(2.0) =\u003e F64(6.0));\n        test!(multiply F32(3.0_f32), I8(2)    =\u003e F32(6.0_f32));\n        test!(multiply F32(3.0_f32), I32(2)   =\u003e F32(6.0_f32));\n        test!(multiply F32(3.0_f32), I64(2)   =\u003e F32(6.0_f32));\n        test!(multiply F32(3.0_f32), I128(2)  =\u003e F32(6.0_f32));\n        test!(multiply F32(3.0_f32), U8(2)    =\u003e F32(6.0_f32));\n\n        test!(multiply F64(3.0), F64(2.0) =\u003e F64(6.0));\n        test!(multiply F64(3.0), F32(2.0_f32) =\u003e F32(6.0_f32));\n        test!(multiply F64(3.0), I8(2)    =\u003e F64(6.0));\n        test!(multiply F64(3.0), I32(2)   =\u003e F64(6.0));\n        test!(multiply F64(3.0), I64(2)   =\u003e F64(6.0));\n        test!(multiply F64(3.0), I128(2)  =\u003e F64(6.0));\n        test!(multiply F64(3.0), U8(2)    =\u003e F64(6.0));\n\n        test!(multiply decimal(3), decimal(2) =\u003e decimal(6));\n\n        test!(multiply I8(3),    mon!(3)  =\u003e mon!(9));\n        test!(multiply I16(3),   mon!(3)  =\u003e mon!(9));\n        test!(multiply I32(3),   mon!(3)  =\u003e mon!(9));\n        test!(multiply I64(3),   mon!(3)  =\u003e mon!(9));\n        test!(multiply I128(3),  mon!(3)  =\u003e mon!(9));\n        test!(multiply F32(3.0_f32), mon!(3)  =\u003e mon!(9));\n        test!(multiply F64(3.0), mon!(3)  =\u003e mon!(9));\n        test!(multiply mon!(3),  I8(2)    =\u003e mon!(6));\n        test!(multiply mon!(3),  I16(2)   =\u003e mon!(6));\n        test!(multiply mon!(3),  I32(2)   =\u003e mon!(6));\n        test!(multiply mon!(3),  I64(2)   =\u003e mon!(6));\n        test!(multiply mon!(3),  I128(2)  =\u003e mon!(6));\n        test!(multiply mon!(3),  F32(2.0_f32) =\u003e mon!(6));\n        test!(multiply mon!(3),  F32(2.0_f32) =\u003e mon!(6));\n        test!(multiply mon!(3),  F64(2.0) =\u003e mon!(6));\n\n        test!(divide I8(0),     I8(5)   =\u003e I8(0));\n        test!(divide I8(0),     I16(5)   =\u003e I8(0));\n        test!(divide I8(0),     I32(5)  =\u003e I32(0));\n        test!(divide I8(0),     I64(5)  =\u003e I64(0));\n        test!(divide I8(0),     I128(5) =\u003e I128(0));\n        test!(divide I8(0),     U8(5)   =\u003e I64(0));\n        assert_eq!(\n            I8(5).divide(\u0026I8(0)),\n            Err(ValueError::DivisorShouldNotBeZero.into())\n        );\n\n        test!(divide I8(6),    I8(2)    =\u003e I8(3));\n        test!(divide I8(6),    I16(2)    =\u003e I8(3));\n        test!(divide I8(6),    I32(2)    =\u003e I8(3));\n        test!(divide I8(6),    I64(2)   =\u003e I64(3));\n        test!(divide I8(6),    I128(2)  =\u003e I128(3));\n        test!(divide I8(6),    U8(2)    =\u003e I64(3));\n\n        test!(divide I64(6),    I8(2)    =\u003e I64(3));\n        test!(divide I64(6),    I16(2)    =\u003e I64(3));\n        test!(divide I64(6),    I32(2)    =\u003e I64(3));\n        test!(divide I64(6),    I64(2)   =\u003e I64(3));\n        test!(divide I64(6),    I128(2)  =\u003e I128(3));\n        test!(divide I64(6),    U8(2)  =\u003e I64(3));\n\n        test!(divide I128(6),    I8(2)    =\u003e I128(3));\n        test!(divide I128(6),    I16(2)    =\u003e I128(3));\n        test!(divide I128(6),    I32(2)    =\u003e I128(3));\n        test!(divide I128(6),    I64(2)   =\u003e I128(3));\n        test!(divide I128(6),    I128(2)  =\u003e I128(3));\n        test!(divide I128(6),    U8(2)  =\u003e I64(3));\n\n        test!(divide I128(6),    I8(2)    =\u003e I128(3));\n        test!(divide I128(6),    I16(2)    =\u003e I128(3));\n        test!(divide I128(6),    I32(2)    =\u003e I128(3));\n        test!(divide I128(6),    I64(2)   =\u003e I128(3));\n        test!(divide I128(6),    I128(2)  =\u003e I128(3));\n\n        test!(divide U8(6),   I8(2)     =\u003e I64(3));\n        test!(divide U8(6),   I16(2)    =\u003e I16(3));\n        test!(divide U8(6),   I32(2)    =\u003e I32(3));\n        test!(divide U8(6),   I64(2)    =\u003e I64(3));\n        test!(divide U8(6),   I128(2)   =\u003e I128(3));\n        test!(divide U8(6),   U8(2)     =\u003e U8(3));\n        test!(divide U8(6),   F32(2.0_f32)  =\u003e F64(3.0));\n        test!(divide U8(6),   F64(2.0)  =\u003e F64(3.0));\n\n        test!(divide U16(6),   I8(2)     =\u003e U16(3));\n        test!(divide U16(6),   I16(2)    =\u003e U16(3));\n        test!(divide U16(6),   I32(2)    =\u003e U16(3));\n        test!(divide U16(6),   I64(2)    =\u003e U16(3));\n        test!(divide U16(6),   I128(2)   =\u003e U16(3));\n        test!(divide U16(6),   U8(2)     =\u003e U16(3));\n        test!(divide U16(6),   F32(2.0_f32)  =\u003e F64(3.0));\n        test!(divide U16(6),   F64(2.0)  =\u003e F64(3.0));\n\n        test!(divide U32(6),   I8(2)     =\u003e U32(3));\n        test!(divide U32(6),   I16(2)    =\u003e U32(3));\n        test!(divide U32(6),   I32(2)    =\u003e U32(3));\n        test!(divide U32(6),   I64(2)    =\u003e U32(3));\n        test!(divide U32(6),   I128(2)   =\u003e U32(3));\n        test!(divide U32(6),   U8(2)     =\u003e U32(3));\n        test!(divide U32(6),   F32(2.0_f32)  =\u003e F64(3.0));\n        test!(divide U32(6),   F64(2.0)  =\u003e F64(3.0));\n\n        test!(divide U64(6),   I8(2)     =\u003e U64(3));\n        test!(divide U64(6),   I16(2)    =\u003e U64(3));\n        test!(divide U64(6),   I32(2)    =\u003e U64(3));\n        test!(divide U64(6),   I64(2)    =\u003e U64(3));\n        test!(divide U64(6),   I128(2)   =\u003e U64(3));\n        test!(divide U64(6),   U8(2)     =\u003e U64(3));\n        test!(divide U64(6),   F32(2.0_f32)  =\u003e F64(3.0));\n        test!(divide U64(6),   F64(2.0)  =\u003e F64(3.0));\n\n        test!(divide U128(6),   I8(2)     =\u003e U128(3));\n        test!(divide U128(6),   I16(2)    =\u003e U128(3));\n        test!(divide U128(6),   I32(2)    =\u003e U128(3));\n        test!(divide U128(6),   I64(2)    =\u003e U128(3));\n        test!(divide U128(6),   I128(2)   =\u003e U128(3));\n        test!(divide U128(6),   U8(2)     =\u003e U128(3));\n        test!(divide U128(6),   F64(2.0)  =\u003e F64(3.0));\n\n        test!(divide I8(6),    F64(2.0) =\u003e F64(3.0));\n        test!(divide I32(6),    F64(2.0) =\u003e F64(3.0));\n        test!(divide I64(6),   F64(2.0) =\u003e F64(3.0));\n        test!(divide I128(6),    F64(2.0) =\u003e F64(3.0));\n        test!(divide F32(6.0_f32),    F64(2.0) =\u003e F64(3.0));\n\n        test!(divide I8(6),    F32(2.0_f32) =\u003e F32(3.0_f32));\n        test!(divide I32(6),    F32(2.0_f32) =\u003e F32(3.0_f32));\n        test!(divide I64(6),   F32(2.0_f32) =\u003e F32(3.0_f32));\n        test!(divide I128(6),    F32(2.0_f32) =\u003e F32(3.0_f32));\n        test!(divide F64(6.0), F32(2.0_f32) =\u003e F32(3.0_f32));\n\n        test!(divide F32(6.0_f32), I8(2)    =\u003e F32(3.0_f32));\n        test!(divide F32(6.0_f32), I16(2)    =\u003e F32(3.0_f32));\n        test!(divide F32(6.0_f32), I32(2)    =\u003e F32(3.0_f32));\n        test!(divide F32(6.0_f32), I64(2)   =\u003e F32(3.0_f32));\n        test!(divide F32(6.0_f32), I128(2)    =\u003e F32(3.0_f32));\n        test!(divide F64(6.0), F32(2.0_f32) =\u003e F32(3.0_f32));\n\n        test!(divide F64(6.0), I8(2)    =\u003e F64(3.0));\n        test!(divide F64(6.0), I16(2)    =\u003e F64(3.0));\n        test!(divide F64(6.0), I32(2)    =\u003e F64(3.0));\n        test!(divide F64(6.0), I64(2)   =\u003e F64(3.0));\n        test!(divide F64(6.0), I128(2)    =\u003e F64(3.0));\n        test!(divide F64(6.0), U8(2)    =\u003e F64(3.0));\n        test!(divide F64(6.0), F32(2.0_f32) =\u003e F32(3.0_f32));\n\n        test!(divide mon!(6),  I8(2)    =\u003e mon!(3));\n        test!(divide mon!(6),  I16(2)    =\u003e mon!(3));\n        test!(divide mon!(6),  I32(2)    =\u003e mon!(3));\n        test!(divide mon!(6),  I64(2)   =\u003e mon!(3));\n        test!(divide mon!(6),  I128(2)    =\u003e mon!(3));\n        test!(divide mon!(6),  U8(2)    =\u003e mon!(3));\n        test!(divide mon!(6),  U16(2)    =\u003e mon!(3));\n        test!(divide mon!(6),  U32(2)    =\u003e mon!(3));\n        test!(divide mon!(6),  U64(2)    =\u003e mon!(3));\n        test!(divide mon!(6),  U128(2)    =\u003e mon!(3));\n        test!(divide mon!(6),  F32(2.0_f32) =\u003e mon!(3));\n        test!(divide mon!(6),  F64(2.0) =\u003e mon!(3));\n\n        test!(modulo I8(6),    I8(4)    =\u003e I8(2));\n        test!(modulo I8(6),    I16(4)    =\u003e I8(2));\n        test!(modulo I8(6),    I32(4)    =\u003e I8(2));\n        test!(modulo I8(6),    I64(4)   =\u003e I64(2));\n        test!(modulo I8(6),    I128(4)  =\u003e I128(2));\n\n        assert_eq!(\n            I8(5).modulo(\u0026I8(0)),\n            Err(ValueError::DivisorShouldNotBeZero.into())\n        );\n\n        test!(modulo I64(6),    I8(4)    =\u003e I64(2));\n        test!(modulo I64(6),    I16(4)    =\u003e I64(2));\n        test!(modulo I64(6),    I32(4)   =\u003e I64(2));\n        test!(modulo I64(6),    I64(4)   =\u003e I64(2));\n        test!(modulo I64(6),    I128(4)  =\u003e I128(2));\n\n        test!(modulo I128(6),    I8(4)    =\u003e I128(2));\n        test!(modulo I128(6),    I16(4)    =\u003e I128(2));\n        test!(modulo I128(6),    I32(4)    =\u003e I128(2));\n        test!(modulo I128(6),    I64(4)   =\u003e I128(2));\n        test!(modulo I128(6),    I128(4)  =\u003e I128(2));\n\n        test!(modulo I8(6),   I8(2)   =\u003e I8(0));\n        test!(modulo I8(6),   F32(2.0_f32) =\u003e F32(0.0_f32));\n        test!(modulo I8(6),   F64(2.0) =\u003e F64(0.0));\n        test!(modulo I32(6),   I32(2)   =\u003e I32(0));\n        test!(modulo I32(6),   F64(2.0) =\u003e F64(0.0));\n        test!(modulo I64(6),   I32(2)   =\u003e I32(0));\n        test!(modulo I64(6),   F64(2.0) =\u003e F64(0.0));\n        test!(modulo F32(6.0_f32), I64(2)   =\u003e F32(0.0_f32));\n        test!(modulo F32(6.0_f32), F32(2.0_f32) =\u003e F32(0.0_f32));\n        test!(modulo F64(6.0), I64(2)   =\u003e F64(0.0));\n        test!(modulo F64(6.0), F64(2.0) =\u003e F64(0.0));\n        test!(modulo I128(6),   I8(2)   =\u003e I128(0));\n        test!(modulo I128(6),   I16(2)   =\u003e I128(0));\n        test!(modulo I128(6),   I32(2)   =\u003e I128(0));\n        test!(modulo I128(6),   I64(2)   =\u003e I128(0));\n        test!(modulo I128(6),   I128(2)   =\u003e I128(0));\n        test!(modulo I128(6),   F64(2.0) =\u003e F64(0.0));\n        test!(modulo I128(6),   F32(2.0_f32) =\u003e F32(0.0_f32));\n\n        macro_rules! null_test {\n            ($op: ident $a: expr, $b: expr) =\u003e {\n                assert!($a.$op(\u0026$b).unwrap().is_null());\n            };\n        }\n\n        let date = || Date(NaiveDate::from_ymd_opt(1989, 3, 1).unwrap());\n        let time = || Time(NaiveTime::from_hms_opt(6, 1, 1).unwrap());\n        let ts = || {\n            Timestamp(\n                NaiveDate::from_ymd_opt(1989, 1, 1)\n                    .unwrap()\n                    .and_hms_opt(0, 0, 0)\n                    .unwrap(),\n            )\n        };\n\n        null_test!(add      I8(1),    Null);\n        null_test!(add      I16(1),    Null);\n        null_test!(add      I32(1),   Null);\n        null_test!(add      I64(1),   Null);\n        null_test!(add      I128(1),   Null);\n        null_test!(add      U8(1),   Null);\n        null_test!(add      U16(1),   Null);\n        null_test!(add      U32(1),   Null);\n        null_test!(add      U64(1),   Null);\n        null_test!(add      U128(1),   Null);\n        null_test!(add      F32(1.0_f32), Null);\n        null_test!(add      F64(1.0), Null);\n        null_test!(add      decimal(1), Null);\n        null_test!(add      date(),   Null);\n        null_test!(add      ts(),     Null);\n        null_test!(add      time(),   Null);\n        null_test!(add      mon!(1),  Null);\n        null_test!(subtract I8(1),    Null);\n        null_test!(subtract I16(1),    Null);\n        null_test!(subtract I32(1),    Null);\n        null_test!(subtract I64(1),   Null);\n        null_test!(subtract I128(1),   Null);\n        null_test!(subtract U8(1),   Null);\n        null_test!(subtract U16(1),   Null);\n        null_test!(subtract U32(1),   Null);\n        null_test!(subtract U64(1),   Null);\n        null_test!(subtract U128(1),   Null);\n        null_test!(subtract F32(1.0_f32), Null);\n        null_test!(subtract F64(1.0), Null);\n        null_test!(subtract decimal(1), Null);\n        null_test!(subtract date(),   Null);\n        null_test!(subtract ts(),     Null);\n        null_test!(subtract time(),   Null);\n        null_test!(subtract mon!(1),  Null);\n        null_test!(multiply I8(1),    Null);\n        null_test!(multiply I16(1),    Null);\n        null_test!(multiply I32(1),   Null);\n        null_test!(multiply I64(1),   Null);\n        null_test!(multiply I128(1),   Null);\n        null_test!(multiply U8(1),   Null);\n        null_test!(multiply U16(1),   Null);\n        null_test!(multiply U32(1),   Null);\n        null_test!(multiply U64(1),   Null);\n        null_test!(multiply U128(1),   Null);\n        null_test!(multiply F32(1.0_f32), Null);\n        null_test!(multiply F64(1.0), Null);\n        null_test!(multiply decimal(1), Null);\n        null_test!(multiply mon!(1),  Null);\n        null_test!(divide   I8(1),    Null);\n        null_test!(divide   I16(1),    Null);\n        null_test!(divide   I32(1),    Null);\n        null_test!(divide   I64(1),   Null);\n        null_test!(divide   I128(1),   Null);\n        null_test!(divide   U8(1),   Null);\n        null_test!(divide   U16(1),   Null);\n        null_test!(divide   U32(1),   Null);\n        null_test!(divide   U64(1),   Null);\n        null_test!(divide   U128(1),   Null);\n        null_test!(divide   F32(1.0_f32), Null);\n        null_test!(divide   F64(1.0), Null);\n        null_test!(divide   decimal(1), Null);\n        null_test!(divide   mon!(1),  Null);\n        null_test!(modulo   I8(1),    Null);\n        null_test!(modulo   I16(1),    Null);\n        null_test!(modulo   I32(1),    Null);\n        null_test!(modulo   I64(1),   Null);\n        null_test!(modulo   I128(1),   Null);\n        null_test!(modulo   U8(1),   Null);\n        null_test!(modulo   U16(1),   Null);\n        null_test!(modulo   U32(1),   Null);\n        null_test!(modulo   U64(1),   Null);\n        null_test!(modulo   U128(1),   Null);\n        null_test!(modulo   F32(1.0_f32), Null);\n        null_test!(modulo   F64(1.0), Null);\n        null_test!(modulo   decimal(1), Null);\n\n        null_test!(add      Null, I8(1));\n        null_test!(add      Null, I16(1));\n        null_test!(add      Null, I32(1));\n        null_test!(add      Null, I64(1));\n        null_test!(add      Null, I128(1));\n        null_test!(add      Null, U8(1));\n        null_test!(add      Null, U16(1));\n        null_test!(add      Null, U32(1));\n        null_test!(add      Null, U64(1));\n        null_test!(add      Null, U128(1));\n        null_test!(add      Null, F32(1.0_f32));\n        null_test!(add      Null, F64(1.0));\n        null_test!(add      Null, decimal(1));\n        null_test!(add      Null, mon!(1));\n        null_test!(add      Null, date());\n        null_test!(add      Null, ts());\n        null_test!(subtract Null, I8(1));\n        null_test!(subtract Null, I16(1));\n        null_test!(subtract Null, I32(1));\n        null_test!(subtract Null, I64(1));\n        null_test!(subtract Null, I128(1));\n        null_test!(subtract Null, U8(1));\n        null_test!(subtract Null, U16(1));\n        null_test!(subtract Null, U32(1));\n        null_test!(subtract Null, U64(1));\n        null_test!(subtract Null, U128(1));\n        null_test!(subtract Null, F32(1.0_f32));\n        null_test!(subtract Null, F64(1.0));\n        null_test!(subtract Null, decimal(1));\n        null_test!(subtract Null, date());\n        null_test!(subtract Null, ts());\n        null_test!(subtract Null, time());\n        null_test!(subtract Null, mon!(1));\n        null_test!(multiply Null, I8(1));\n        null_test!(multiply Null, I16(1));\n        null_test!(multiply Null, I32(1));\n        null_test!(multiply Null, I64(1));\n        null_test!(multiply Null, I128(1));\n        null_test!(multiply Null, U8(1));\n        null_test!(multiply Null, U16(1));\n        null_test!(multiply Null, U32(1));\n        null_test!(multiply Null, U64(1));\n        null_test!(multiply Null, U128(1));\n        null_test!(multiply Null, F32(1.0_f32));\n        null_test!(multiply Null, F64(1.0));\n        null_test!(multiply Null, decimal(1));\n        null_test!(divide   Null, I8(1));\n        null_test!(divide   Null, I16(1));\n        null_test!(divide   Null, I32(1));\n        null_test!(divide   Null, I64(1));\n        null_test!(divide   Null, I128(1));\n        null_test!(divide   Null, U8(1));\n        null_test!(divide   Null, U16(1));\n        null_test!(divide   Null, U32(1));\n        null_test!(divide   Null, U64(1));\n        null_test!(divide   Null, U128(1));\n        null_test!(divide   Null, F32(1.0_f32));\n        null_test!(divide   Null, F64(1.0));\n        null_test!(divide   Null, decimal(1));\n        null_test!(modulo   Null, I8(1));\n        null_test!(modulo   Null, I32(1));\n        null_test!(modulo   Null, I64(1));\n        null_test!(modulo   Null, I128(1));\n        null_test!(modulo   Null, U8(1));\n        null_test!(modulo   Null, U16(1));\n        null_test!(modulo   Null, U32(1));\n        null_test!(modulo   Null, U64(1));\n        null_test!(modulo   Null, U128(1));\n        null_test!(modulo   Null, F32(1.0_f32));\n        null_test!(modulo   Null, F64(1.0));\n        null_test!(modulo   Null, decimal(1));\n\n        null_test!(add      Null, Null);\n        null_test!(subtract Null, Null);\n        null_test!(multiply Null, Null);\n        null_test!(divide   Null, Null);\n        null_test!(modulo   Null, Null);\n    }\n\n    #[test]\n    fn bitwise_shift_left() {\n        use {super::convert::ConvertError, crate::ast::DataType};\n\n        macro_rules! test {\n            ($op: ident $a: expr, $b: expr =\u003e $c: expr) =\u003e {\n                assert!($a.$op(\u0026$b).unwrap().evaluate_eq(\u0026$c));\n            };\n        }\n\n        macro_rules! mon {\n            ($n: expr) =\u003e {\n                Interval(Interval::Month($n))\n            };\n        }\n\n        // operation result test\n        test!(bitwise_shift_left I8(1),     I64(2) =\u003e I8(4));\n        test!(bitwise_shift_left I16(1),    I64(2) =\u003e I16(4));\n        test!(bitwise_shift_left I32(1),    I64(2) =\u003e I32(4));\n        test!(bitwise_shift_left I64(1),    I64(2) =\u003e I64(4));\n        test!(bitwise_shift_left I128(1),   I64(2) =\u003e I128(4));\n        test!(bitwise_shift_left U8(1),     I64(2) =\u003e U8(4));\n        test!(bitwise_shift_left U16(1),    I64(2) =\u003e U16(4));\n        test!(bitwise_shift_left U32(1),    I64(2) =\u003e U32(4));\n        test!(bitwise_shift_left U64(1),    I64(2) =\u003e U64(4));\n        test!(bitwise_shift_left U128(1),   I64(2) =\u003e U128(4));\n        test!(bitwise_shift_left I8(1),     U32(2) =\u003e I8(4));\n        test!(bitwise_shift_left I16(1),    U32(2) =\u003e I16(4));\n        test!(bitwise_shift_left I32(1),    U32(2) =\u003e I32(4));\n        test!(bitwise_shift_left I64(1),    U32(2) =\u003e I64(4));\n        test!(bitwise_shift_left I128(1),   U32(2) =\u003e I128(4));\n        test!(bitwise_shift_left U8(1),     U32(2) =\u003e U8(4));\n        test!(bitwise_shift_left U16(1),    U32(2) =\u003e U16(4));\n        test!(bitwise_shift_left U32(1),    U32(2) =\u003e U32(4));\n        test!(bitwise_shift_left U64(1),    U32(2) =\u003e U64(4));\n        test!(bitwise_shift_left U128(1),   U32(2) =\u003e U128(4));\n\n        //overflow test\n        assert_eq!(\n            I8(1).bitwise_shift_left(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: I8(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftLeft\n            }\n            .into())\n        );\n        assert_eq!(\n            I16(1).bitwise_shift_left(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: I16(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftLeft\n            }\n            .into())\n        );\n        assert_eq!(\n            I32(1).bitwise_shift_left(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: I32(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftLeft\n            }\n            .into())\n        );\n        assert_eq!(\n            I64(1).bitwise_shift_left(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: I64(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftLeft\n            }\n            .into())\n        );\n        assert_eq!(\n            I128(1).bitwise_shift_left(\u0026I64(150)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: I128(1),\n                rhs: U32(150),\n                operator: NumericBinaryOperator::BitwiseShiftLeft\n            }\n            .into())\n        );\n        assert_eq!(\n            U8(1).bitwise_shift_left(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: U8(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftLeft\n            }\n            .into())\n        );\n        assert_eq!(\n            U16(1).bitwise_shift_left(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: U16(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftLeft\n            }\n            .into())\n        );\n        assert_eq!(\n            U32(1).bitwise_shift_left(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: U32(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftLeft\n            }\n            .into())\n        );\n        assert_eq!(\n            U64(1).bitwise_shift_left(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: U64(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftLeft\n            }\n            .into())\n        );\n        assert_eq!(\n            U128(1).bitwise_shift_left(\u0026I64(150)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: U128(1),\n                rhs: U32(150),\n                operator: NumericBinaryOperator::BitwiseShiftLeft\n            }\n            .into())\n        );\n\n        // cast error test\n        assert_eq!(\n            I64(1).bitwise_shift_left(\u0026I64(-2)),\n            Err(ConvertError {\n                value: I64(-2),\n                data_type: DataType::Uint32,\n            }\n            .into())\n        );\n\n        // non numeric test\n        assert_eq!(\n            mon!(3).bitwise_shift_left(\u0026I64(2)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: mon!(3),\n                rhs: U32(2),\n                operator: NumericBinaryOperator::BitwiseShiftLeft,\n            }\n            .into())\n        );\n\n        // null test\n        macro_rules! null_test {\n            ($op: ident $a: expr, $b: expr) =\u003e {\n                assert!($a.$op(\u0026$b).unwrap().is_null());\n            };\n        }\n\n        null_test!(bitwise_shift_left   I64(1), Null);\n        null_test!(bitwise_shift_left   Null, I64(1));\n    }\n\n    #[test]\n    fn bitwise_shift_right() {\n        use {super::convert::ConvertError, crate::ast::DataType};\n\n        macro_rules! test {\n            ($op: ident $a: expr, $b: expr =\u003e $c: expr) =\u003e {\n                assert!($a.$op(\u0026$b).unwrap().evaluate_eq(\u0026$c));\n            };\n        }\n\n        macro_rules! mon {\n            ($n: expr) =\u003e {\n                Interval(Interval::Month($n))\n            };\n        }\n\n        // operation result test\n        test!(bitwise_shift_right I8(1),     I64(2) =\u003e I8(0));\n        test!(bitwise_shift_right I16(1),    I64(2) =\u003e I16(0));\n        test!(bitwise_shift_right I32(1),    I64(2) =\u003e I32(0));\n        test!(bitwise_shift_right I64(1),    I64(2) =\u003e I64(0));\n        test!(bitwise_shift_right I128(1),   I64(2) =\u003e I128(0));\n        test!(bitwise_shift_right U8(1),     I64(2) =\u003e U8(0));\n        test!(bitwise_shift_right U16(1),    I64(2) =\u003e U16(0));\n        test!(bitwise_shift_right U32(1),    I64(2) =\u003e U32(0));\n        test!(bitwise_shift_right U64(1),    I64(2) =\u003e U64(0));\n        test!(bitwise_shift_right U128(1),   I64(2) =\u003e U128(0));\n        test!(bitwise_shift_right I8(1),     U32(2) =\u003e I8(0));\n        test!(bitwise_shift_right I16(1),    U32(2) =\u003e I16(0));\n        test!(bitwise_shift_right I32(1),    U32(2) =\u003e I32(0));\n        test!(bitwise_shift_right I64(1),    U32(2) =\u003e I64(0));\n        test!(bitwise_shift_right I128(1),   U32(2) =\u003e I128(0));\n        test!(bitwise_shift_right U8(1),     U32(2) =\u003e U8(0));\n        test!(bitwise_shift_right U16(1),    U32(2) =\u003e U16(0));\n        test!(bitwise_shift_right U32(1),    U32(2) =\u003e U32(0));\n        test!(bitwise_shift_right U64(1),    U32(2) =\u003e U64(0));\n        test!(bitwise_shift_right U128(1),   U32(2) =\u003e U128(0));\n\n        //overflow test\n        assert_eq!(\n            I8(1).bitwise_shift_right(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: I8(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftRight\n            }\n            .into())\n        );\n        assert_eq!(\n            I16(1).bitwise_shift_right(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: I16(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftRight\n            }\n            .into())\n        );\n        assert_eq!(\n            I32(1).bitwise_shift_right(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: I32(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftRight\n            }\n            .into())\n        );\n        assert_eq!(\n            I64(1).bitwise_shift_right(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: I64(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftRight\n            }\n            .into())\n        );\n        assert_eq!(\n            I128(1).bitwise_shift_right(\u0026I64(150)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: I128(1),\n                rhs: U32(150),\n                operator: NumericBinaryOperator::BitwiseShiftRight\n            }\n            .into())\n        );\n        assert_eq!(\n            U8(1).bitwise_shift_right(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: U8(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftRight\n            }\n            .into())\n        );\n        assert_eq!(\n            U16(1).bitwise_shift_right(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: U16(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftRight\n            }\n            .into())\n        );\n        assert_eq!(\n            U32(1).bitwise_shift_right(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: U32(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftRight\n            }\n            .into())\n        );\n        assert_eq!(\n            U64(1).bitwise_shift_right(\u0026I64(100)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: U64(1),\n                rhs: U32(100),\n                operator: NumericBinaryOperator::BitwiseShiftRight\n            }\n            .into())\n        );\n        assert_eq!(\n            U128(1).bitwise_shift_right(\u0026I64(150)),\n            Err(ValueError::BinaryOperationOverflow {\n                lhs: U128(1),\n                rhs: U32(150),\n                operator: NumericBinaryOperator::BitwiseShiftRight\n            }\n            .into())\n        );\n\n        // cast error test\n        assert_eq!(\n            I64(1).bitwise_shift_right(\u0026I64(-2)),\n            Err(ConvertError {\n                value: I64(-2),\n                data_type: DataType::Uint32,\n            }\n            .into())\n        );\n\n        // non numeric test\n        assert_eq!(\n            mon!(3).bitwise_shift_right(\u0026I64(2)),\n            Err(ValueError::NonNumericMathOperation {\n                lhs: mon!(3),\n                rhs: U32(2),\n                operator: NumericBinaryOperator::BitwiseShiftRight,\n            }\n            .into())\n        );\n\n        // null test\n        macro_rules! null_test {\n            ($op: ident $a: expr, $b: expr) =\u003e {\n                assert!($a.$op(\u0026$b).unwrap().is_null());\n            };\n        }\n\n        null_test!(bitwise_shift_right   I64(1), Null);\n        null_test!(bitwise_shift_right   Null, I64(1));\n    }\n\n    #[test]\n    fn cast() {\n        use {\n            crate::{ast::DataType::*, data::Point, prelude::Value},\n            chrono::{NaiveDate, NaiveTime},\n        };\n\n        macro_rules! cast {\n            ($input: expr =\u003e $data_type: expr, $expected: expr) =\u003e {\n                let found = $input.cast(\u0026$data_type).unwrap();\n\n                match ($expected, found) {\n                    (Null, Null) =\u003e {}\n                    (expected, found) =\u003e {\n                        assert_eq!(expected, found);\n                    }\n                }\n            };\n        }\n\n        let bytea = Value::Bytea(hex::decode(\"0abc\").unwrap());\n        let inet = |v| Value::Inet(IpAddr::from_str(v).unwrap());\n        let point = |x, y| Value::Point(Point::new(x, y));\n\n        // Same as\n        cast!(Bool(true)            =\u003e Boolean      , Bool(true));\n        cast!(Str(\"a\".to_owned())   =\u003e Text         , Str(\"a\".to_owned()));\n        cast!(bytea                 =\u003e Bytea        , bytea);\n        cast!(inet(\"::1\")           =\u003e Inet         , inet(\"::1\"));\n        cast!(I8(1)                 =\u003e Int8         , I8(1));\n        cast!(I16(1)                 =\u003e Int16         , I16(1));\n        cast!(I32(1)                =\u003e Int32        , I32(1));\n        cast!(I64(1)                =\u003e Int          , I64(1));\n        cast!(I128(1)               =\u003e Int128       , I128(1));\n        cast!(U8(1)                 =\u003e Uint8        , U8(1));\n        cast!(U16(1)                 =\u003e Uint16        , U16(1));\n        cast!(U32(1)                 =\u003e Uint32        , U32(1));\n        cast!(U64(1)                 =\u003e Uint64        , U64(1));\n        cast!(U128(1)                 =\u003e Uint128        , U128(1));\n        cast!(F32(1.0_f32)              =\u003e Float32        , F32(1.0_f32));\n        cast!(F64(1.0)              =\u003e Float        , F64(1.0));\n        cast!(Value::Uuid(123)      =\u003e Uuid         , Value::Uuid(123));\n\n        // Boolean\n        cast!(Str(\"TRUE\".to_owned())    =\u003e Boolean, Bool(true));\n        cast!(Str(\"FALSE\".to_owned())   =\u003e Boolean, Bool(false));\n        cast!(I8(1)                     =\u003e Boolean, Bool(true));\n        cast!(I8(0)                     =\u003e Boolean, Bool(false));\n        cast!(I16(0)                     =\u003e Boolean, Bool(false));\n        cast!(I32(1)                     =\u003e Boolean, Bool(true));\n        cast!(I32(0)                     =\u003e Boolean, Bool(false));\n        cast!(I64(1)                    =\u003e Boolean, Bool(true));\n        cast!(I64(0)                    =\u003e Boolean, Bool(false));\n        cast!(I128(1)                   =\u003e Boolean, Bool(true));\n        cast!(I128(0)                   =\u003e Boolean, Bool(false));\n        cast!(U8(1)                   =\u003e Boolean, Bool(true));\n        cast!(U8(0)                   =\u003e Boolean, Bool(false));\n        cast!(U16(1)                   =\u003e Boolean, Bool(true));\n        cast!(U16(0)                   =\u003e Boolean, Bool(false));\n        cast!(U32(1)                   =\u003e Boolean, Bool(true));\n        cast!(U32(1)                   =\u003e Boolean, Bool(true));\n        cast!(U64(1)                   =\u003e Boolean, Bool(true));\n        cast!(U64(0)                   =\u003e Boolean, Bool(false));\n        cast!(U128(0)                   =\u003e Boolean, Bool(false));\n        cast!(U128(0)                   =\u003e Boolean, Bool(false));\n        cast!(F32(1.0_f32)                  =\u003e Boolean, Bool(true));\n        cast!(F32(0.0_f32)                  =\u003e Boolean, Bool(false));\n        cast!(F64(1.0)                  =\u003e Boolean, Bool(true));\n        cast!(F64(0.0)                  =\u003e Boolean, Bool(false));\n        cast!(Null                      =\u003e Boolean, Null);\n\n        // Integer\n        cast!(Bool(true)            =\u003e Int8, I8(1));\n        cast!(Bool(false)           =\u003e Int8, I8(0));\n        cast!(F32(1.1_f32)              =\u003e Int8, I8(1));\n        cast!(F64(1.1)              =\u003e Int8, I8(1));\n        cast!(Str(\"11\".to_owned())  =\u003e Int8, I8(11));\n        cast!(Null                  =\u003e Int8, Null);\n\n        cast!(Bool(true)            =\u003e Int32, I32(1));\n        cast!(Bool(false)           =\u003e Int32, I32(0));\n        cast!(F32(1.1_f32)              =\u003e Int32, I32(1));\n        cast!(F64(1.1)              =\u003e Int32, I32(1));\n        cast!(Str(\"11\".to_owned())  =\u003e Int32, I32(11));\n        cast!(Null                  =\u003e Int32, Null);\n\n        cast!(Bool(true)            =\u003e Int, I64(1));\n        cast!(Bool(false)           =\u003e Int, I64(0));\n        cast!(F32(1.1_f32)              =\u003e Int, I64(1));\n        cast!(F64(1.1)              =\u003e Int, I64(1));\n        cast!(Str(\"11\".to_owned())  =\u003e Int, I64(11));\n        cast!(Null                  =\u003e Int, Null);\n\n        cast!(Bool(true)            =\u003e Int128, I128(1));\n        cast!(Bool(false)           =\u003e Int128, I128(0));\n        cast!(F32(1.1_f32)          =\u003e Int128, I128(1));\n        cast!(F64(1.1)              =\u003e Int128, I128(1));\n        cast!(Str(\"11\".to_owned())  =\u003e Int128, I128(11));\n        cast!(Null                  =\u003e Int128, Null);\n\n        cast!(Bool(true)            =\u003e Uint8, U8(1));\n        cast!(Bool(false)           =\u003e Uint8, U8(0));\n        cast!(F32(1.1_f32)              =\u003e Uint8, U8(1));\n        cast!(F64(1.1)              =\u003e Uint8, U8(1));\n        cast!(Str(\"11\".to_owned())  =\u003e Uint8, U8(11));\n        cast!(Null                  =\u003e Uint8, Null);\n\n        cast!(Bool(true)            =\u003e Uint16, U16(1));\n        cast!(Bool(false)           =\u003e Uint16, U16(0));\n        cast!(F32(1.1_f32)              =\u003e Uint16, U16(1));\n        cast!(F64(1.1)              =\u003e Uint16, U16(1));\n        cast!(Str(\"11\".to_owned())  =\u003e Uint16, U16(11));\n        cast!(Null                  =\u003e Uint16, Null);\n\n        cast!(Bool(true)            =\u003e Uint32, U32(1));\n        cast!(Bool(false)           =\u003e Uint32, U32(0));\n        cast!(F32(1.1_f32)              =\u003e Uint32, U32(1));\n        cast!(F64(1.1)              =\u003e Uint32, U32(1));\n        cast!(Str(\"11\".to_owned())  =\u003e Uint32, U32(11));\n        cast!(Null                  =\u003e Uint32, Null);\n\n        cast!(Bool(true)            =\u003e Uint64, U64(1));\n        cast!(Bool(false)           =\u003e Uint64, U64(0));\n        cast!(F32(1.1_f32)              =\u003e Uint64, U64(1));\n        cast!(F64(1.1)              =\u003e Uint64, U64(1));\n        cast!(Str(\"11\".to_owned())  =\u003e Uint64, U64(11));\n        cast!(Null                  =\u003e Uint64, Null);\n\n        cast!(Bool(true)            =\u003e Uint128, U128(1));\n        cast!(Bool(false)           =\u003e Uint128, U128(0));\n        cast!(F32(1.1_f32)              =\u003e Uint128, U128(1));\n        cast!(F64(1.1)              =\u003e Uint128, U128(1));\n        cast!(Str(\"11\".to_owned())  =\u003e Uint128, U128(11));\n        cast!(Null                  =\u003e Uint128, Null);\n\n        // Float32\n        cast!(Bool(true)            =\u003e Float32, F32(1.0_f32));\n        cast!(Bool(false)           =\u003e Float32, F32(0.0_f32));\n        cast!(I8(1)                 =\u003e Float32, F32(1.0_f32));\n        cast!(I16(1)                 =\u003e Float32, F32(1.0_f32));\n        cast!(I32(1)                =\u003e Float32, F32(1.0_f32));\n        cast!(I64(1)                =\u003e Float32, F32(1.0_f32));\n        cast!(I128(1)               =\u003e Float32, F32(1.0_f32));\n        cast!(F64(1.0)               =\u003e Float32, F32(1.0_f32));\n\n        // Float\n        cast!(Bool(true)            =\u003e Float, F64(1.0));\n        cast!(Bool(false)           =\u003e Float, F64(0.0));\n        cast!(I8(1)                 =\u003e Float, F64(1.0));\n        cast!(I16(1)                 =\u003e Float, F64(1.0));\n        cast!(I32(1)                =\u003e Float, F64(1.0));\n        cast!(I64(1)                =\u003e Float, F64(1.0));\n        cast!(I128(1)               =\u003e Float, F64(1.0));\n        cast!(F32(1_f32)               =\u003e Float, F64(1.0));\n\n        cast!(U8(1)                 =\u003e Float, F64(1.0));\n        cast!(U16(1)                 =\u003e Float, F64(1.0));\n        cast!(U32(1)                 =\u003e Float, F64(1.0));\n        cast!(U64(1)                 =\u003e Float, F64(1.0));\n        cast!(U128(1)                 =\u003e Float, F64(1.0));\n        cast!(Str(\"11\".to_owned())  =\u003e Float, F64(11.0));\n        cast!(Null                  =\u003e Float, Null);\n\n        // Text\n        cast!(Bool(true)    =\u003e Text, Str(\"TRUE\".to_owned()));\n        cast!(Bool(false)   =\u003e Text, Str(\"FALSE\".to_owned()));\n        cast!(I8(11)        =\u003e Text, Str(\"11\".to_owned()));\n        cast!(I16(11)        =\u003e Text, Str(\"11\".to_owned()));\n        cast!(I32(11)        =\u003e Text, Str(\"11\".to_owned()));\n        cast!(I64(11)       =\u003e Text, Str(\"11\".to_owned()));\n        cast!(I128(11)        =\u003e Text, Str(\"11\".to_owned()));\n        cast!(U8(11)        =\u003e Text, Str(\"11\".to_owned()));\n        cast!(U16(11)        =\u003e Text, Str(\"11\".to_owned()));\n        cast!(U32(11)        =\u003e Text, Str(\"11\".to_owned()));\n        cast!(U64(11)        =\u003e Text, Str(\"11\".to_owned()));\n        cast!(U128(11)        =\u003e Text, Str(\"11\".to_owned()));\n        cast!(F32(1.0_f32)      =\u003e Text, Str(\"1\".to_owned()));\n        cast!(F64(1.0)      =\u003e Text, Str(\"1\".to_owned()));\n        cast!(inet(\"::1\")    =\u003e Text, Str(\"::1\".to_owned()));\n\n        let date = Value::Date(NaiveDate::from_ymd_opt(2021, 5, 1).unwrap());\n        cast!(date          =\u003e Text, Str(\"2021-05-01\".to_owned()));\n\n        let timestamp = Value::Timestamp(\n            NaiveDate::from_ymd_opt(2021, 5, 1)\n                .unwrap()\n                .and_hms_opt(12, 34, 50)\n                .unwrap(),\n        );\n        cast!(timestamp     =\u003e Text, Str(\"2021-05-01 12:34:50\".to_owned()));\n        cast!(Null          =\u003e Text, Null);\n\n        // Date\n        let date = Value::Date(NaiveDate::from_ymd_opt(2021, 5, 1).unwrap());\n        let timestamp = Value::Timestamp(\n            NaiveDate::from_ymd_opt(2021, 5, 1)\n                .unwrap()\n                .and_hms_opt(12, 34, 50)\n                .unwrap(),\n        );\n\n        cast!(Str(\"2021-05-01\".to_owned()) =\u003e Date, date.to_owned());\n        cast!(timestamp                    =\u003e Date, date);\n        cast!(Null                         =\u003e Date, Null);\n\n        // Time\n        cast!(Str(\"08:05:30\".to_owned()) =\u003e Time, Value::Time(NaiveTime::from_hms_opt(8, 5, 30).unwrap()));\n        cast!(Null                       =\u003e Time, Null);\n\n        // Timestamp\n        cast!(Value::Date(NaiveDate::from_ymd_opt(2021, 5, 1).unwrap()) =\u003e Timestamp, Value::Timestamp(NaiveDate::from_ymd_opt(2021, 5, 1).unwrap().and_hms_opt(0, 0, 0).unwrap()));\n        cast!(Str(\"2021-05-01 08:05:30\".to_owned())                     =\u003e Timestamp, Value::Timestamp(NaiveDate::from_ymd_opt(2021, 5, 1).unwrap().and_hms_opt(8, 5, 30).unwrap()));\n        cast!(Null                                                      =\u003e Timestamp, Null);\n\n        // Bytea\n        cast!(Value::Str(\"0abc\".to_owned()) =\u003e Bytea, Value::Bytea(hex::decode(\"0abc\").unwrap()));\n        assert_eq!(\n            Value::Str(\"!@#$5\".to_owned()).cast(\u0026Bytea),\n            Err(ValueError::CastFromHexToByteaFailed(\"!@#$5\".to_owned()).into()),\n        );\n\n        // Inet\n        cast!(inet(\"::1\") =\u003e Inet, inet(\"::1\"));\n        cast!(Str(\"::1\".to_owned()) =\u003e Inet, inet(\"::1\"));\n        cast!(Str(\"0.0.0.0\".to_owned()) =\u003e Inet, inet(\"0.0.0.0\"));\n\n        // Point\n        cast!(point(0.32, 0.52) =\u003e Point, point(0.32, 0.52));\n        cast!(Str(\"POINT(0.32 0.52)\".to_owned()) =\u003e Point, point(0.32, 0.52));\n\n        // Map\n        cast!(\n            Str(r#\"{\"a\": 1}\"#.to_owned()) =\u003e Map,\n            Value::parse_json_map(r#\"{\"a\": 1}\"#).unwrap()\n        );\n\n        // List\n        cast!(\n            Str(r#\"[1, 2, 3]\"#.to_owned()) =\u003e List,\n            Value::parse_json_list(r#\"[1, 2, 3]\"#).unwrap()\n        );\n\n        // Casting error\n        assert_eq!(\n            Value::Uuid(123).cast(\u0026List),\n            Err(ValueError::UnimplementedCast {\n                value: Value::Uuid(123),\n                data_type: List,\n            }\n            .into())\n        );\n    }\n\n    #[test]\n    fn concat() {\n        assert_eq!(\n            Str(\"A\".to_owned()).concat(Str(\"B\".to_owned())),\n            Str(\"AB\".to_owned())\n        );\n        assert_eq!(\n            Str(\"A\".to_owned()).concat(Bool(true)),\n            Str(\"ATRUE\".to_owned())\n        );\n        assert_eq!(Str(\"A\".to_owned()).concat(I8(1)), Str(\"A1\".to_owned()));\n        assert_eq!(Str(\"A\".to_owned()).concat(I16(1)), Str(\"A1\".to_owned()));\n        assert_eq!(Str(\"A\".to_owned()).concat(I32(1)), Str(\"A1\".to_owned()));\n        assert_eq!(Str(\"A\".to_owned()).concat(I64(1)), Str(\"A1\".to_owned()));\n        assert_eq!(Str(\"A\".to_owned()).concat(I128(1)), Str(\"A1\".to_owned()));\n        assert_eq!(Str(\"A\".to_owned()).concat(U8(1)), Str(\"A1\".to_owned()));\n        assert_eq!(Str(\"A\".to_owned()).concat(U16(1)), Str(\"A1\".to_owned()));\n        assert_eq!(Str(\"A\".to_owned()).concat(U32(1)), Str(\"A1\".to_owned()));\n        assert_eq!(Str(\"A\".to_owned()).concat(U64(1)), Str(\"A1\".to_owned()));\n        assert_eq!(Str(\"A\".to_owned()).concat(U128(1)), Str(\"A1\".to_owned()));\n        assert_eq!(\n            Str(\"A\".to_owned()).concat(F32(1.0_f32)),\n            Str(\"A1\".to_owned())\n        );\n        assert_eq!(Str(\"A\".to_owned()).concat(F64(1.0)), Str(\"A1\".to_owned()));\n        assert_eq!(\n            List(vec![I64(1)]).concat(List(vec![I64(2)])),\n            List(vec![I64(1), I64(2)])\n        );\n        assert_eq!(I64(2).concat(I64(1)), Str(\"21\".to_owned()));\n        assert!(Str(\"A\".to_owned()).concat(Null).is_null());\n    }\n\n    #[test]\n    fn validate_type() {\n        use {\n            super::{Value, ValueError},\n            crate::{ast::DataType as D, data::Interval as I, data::Point},\n            chrono::{NaiveDate, NaiveTime},\n        };\n\n        let date = Date(NaiveDate::from_ymd_opt(2021, 5, 1).unwrap());\n        let timestamp = Timestamp(\n            NaiveDate::from_ymd_opt(2021, 5, 1)\n                .unwrap()\n                .and_hms_opt(12, 34, 50)\n                .unwrap(),\n        );\n        let time = Time(NaiveTime::from_hms_opt(12, 30, 11).unwrap());\n        let interval = Interval(I::hours(5));\n        let uuid = Uuid(parse_uuid(\"936DA01F9ABD4d9d80C702AF85C822A8\").unwrap());\n        let point = Point(Point::new(1.0, 2.0));\n        let map = Value::parse_json_map(r#\"{ \"a\": 10 }\"#).unwrap();\n        let list = Value::parse_json_list(r#\"[ true ]\"#).unwrap();\n        let bytea = Bytea(hex::decode(\"9001\").unwrap());\n        let inet = Inet(IpAddr::from_str(\"::1\").unwrap());\n\n        assert!(Bool(true).validate_type(\u0026D::Boolean).is_ok());\n        assert!(Bool(true).validate_type(\u0026D::Int).is_err());\n        assert!(I8(1).validate_type(\u0026D::Int8).is_ok());\n        assert!(I8(1).validate_type(\u0026D::Text).is_err());\n        assert!(I16(1).validate_type(\u0026D::Text).is_err());\n        assert!(I32(1).validate_type(\u0026D::Int32).is_ok());\n        assert!(I32(1).validate_type(\u0026D::Text).is_err());\n        assert!(I64(1).validate_type(\u0026D::Int).is_ok());\n        assert!(I64(1).validate_type(\u0026D::Text).is_err());\n        assert!(I128(1).validate_type(\u0026D::Int128).is_ok());\n        assert!(I128(1).validate_type(\u0026D::Text).is_err());\n        assert!(U8(1).validate_type(\u0026D::Uint8).is_ok());\n        assert!(U8(1).validate_type(\u0026D::Text).is_err());\n        assert!(U16(1).validate_type(\u0026D::Uint16).is_ok());\n        assert!(U16(1).validate_type(\u0026D::Text).is_err());\n        assert!(U32(1).validate_type(\u0026D::Uint32).is_ok());\n        assert!(U32(1).validate_type(\u0026D::Text).is_err());\n        assert!(U64(1).validate_type(\u0026D::Uint64).is_ok());\n        assert!(U64(1).validate_type(\u0026D::Text).is_err());\n        assert!(U128(1).validate_type(\u0026D::Uint128).is_ok());\n        assert!(U128(1).validate_type(\u0026D::Text).is_err());\n        assert!(F32(1.0_f32).validate_type(\u0026D::Float32).is_ok());\n        assert!(F32(1.0_f32).validate_type(\u0026D::Int).is_err());\n        assert!(F64(1.0).validate_type(\u0026D::Float).is_ok());\n        assert!(F64(1.0).validate_type(\u0026D::Int).is_err());\n        assert!(\n            Decimal(rust_decimal::Decimal::ONE)\n                .validate_type(\u0026D::Decimal)\n                .is_ok()\n        );\n        assert!(\n            Decimal(rust_decimal::Decimal::ONE)\n                .validate_type(\u0026D::Int)\n                .is_err()\n        );\n        assert!(Str(\"a\".to_owned()).validate_type(\u0026D::Text).is_ok());\n        assert!(Str(\"a\".to_owned()).validate_type(\u0026D::Int).is_err());\n        assert!(bytea.validate_type(\u0026D::Bytea).is_ok());\n        assert!(bytea.validate_type(\u0026D::Uuid).is_err());\n        assert!(inet.validate_type(\u0026D::Inet).is_ok());\n        assert!(inet.validate_type(\u0026D::Uuid).is_err());\n        assert!(inet.validate_type(\u0026D::Inet).is_ok());\n        assert!(inet.validate_type(\u0026D::Uuid).is_err());\n        assert!(date.validate_type(\u0026D::Date).is_ok());\n        assert!(date.validate_type(\u0026D::Text).is_err());\n        assert!(timestamp.validate_type(\u0026D::Timestamp).is_ok());\n        assert!(timestamp.validate_type(\u0026D::Boolean).is_err());\n        assert!(time.validate_type(\u0026D::Time).is_ok());\n        assert!(time.validate_type(\u0026D::Date).is_err());\n        assert!(interval.validate_type(\u0026D::Interval).is_ok());\n        assert!(interval.validate_type(\u0026D::Date).is_err());\n        assert!(uuid.validate_type(\u0026D::Uuid).is_ok());\n        assert!(uuid.validate_type(\u0026D::Boolean).is_err());\n        assert!(point.validate_type(\u0026D::Point).is_ok());\n        assert!(point.validate_type(\u0026D::Boolean).is_err());\n        assert!(map.validate_type(\u0026D::Map).is_ok());\n        assert!(map.validate_type(\u0026D::Int).is_err());\n        assert!(list.validate_type(\u0026D::List).is_ok());\n        assert!(list.validate_type(\u0026D::Int).is_err());\n        assert!(Null.validate_type(\u0026D::Time).is_ok());\n        assert!(Null.validate_type(\u0026D::Boolean).is_ok());\n\n        assert_eq!(\n            Bool(true).validate_type(\u0026D::Text),\n            Err(ValueError::IncompatibleDataType {\n                data_type: D::Text,\n                value: Bool(true),\n            }\n            .into()),\n        );\n    }\n\n    #[test]\n    fn unary_minus() {\n        use crate::data::Interval as I;\n        assert_eq!(I8(1).unary_minus(), Ok(I8(-1)));\n        assert_eq!(I16(1).unary_minus(), Ok(I16(-1)));\n        assert_eq!(I32(1).unary_minus(), Ok(I32(-1)));\n        assert_eq!(I64(1).unary_minus(), Ok(I64(-1)));\n        assert_eq!(I128(1).unary_minus(), Ok(I128(-1)));\n\n        assert_eq!(F32(1.0_f32).unary_minus(), Ok(F32(-1.0)));\n        assert_eq!(F64(1.0).unary_minus(), Ok(F64(-1.0)));\n        assert_eq!(\n            Interval(I::hours(5)).unary_minus(),\n            Ok(Interval(I::hours(-5)))\n        );\n        assert_eq!(Null.unary_minus(), Ok(Null));\n        assert_eq!(\n            Decimal(Decimal::ONE).unary_minus(),\n            Ok(Decimal(-Decimal::ONE))\n        );\n\n        assert_eq!(\n            Str(\"abc\".to_owned()).unary_minus(),\n            Err(ValueError::UnaryMinusOnNonNumeric.into())\n        );\n    }\n\n    #[test]\n    fn unary_plus() {\n        assert_eq!(U8(1).unary_plus(), Ok(U8(1)));\n        assert!(Null.unary_plus().unwrap().is_null());\n    }\n\n    #[test]\n    fn factorial() {\n        assert_eq!(I8(5).unary_factorial(), Ok(I128(120)));\n        assert_eq!(I16(5).unary_factorial(), Ok(I128(120)));\n        assert_eq!(I32(5).unary_factorial(), Ok(I128(120)));\n        assert_eq!(I64(5).unary_factorial(), Ok(I128(120)));\n        assert_eq!(I128(5).unary_factorial(), Ok(I128(120)));\n        assert_eq!(U8(5).unary_factorial(), Ok(I128(120)));\n        assert_eq!(U16(5).unary_factorial(), Ok(I128(120)));\n        assert_eq!(U32(5).unary_factorial(), Ok(I128(120)));\n        assert_eq!(U64(5).unary_factorial(), Ok(I128(120)));\n        assert_eq!(U128(5).unary_factorial(), Ok(I128(120)));\n        assert_eq!(\n            F32(5.0_f32).unary_factorial(),\n            Err(ValueError::FactorialOnNonInteger.into())\n        );\n        assert_eq!(\n            F64(5.0).unary_factorial(),\n            Err(ValueError::FactorialOnNonInteger.into())\n        );\n        assert!(Null.unary_factorial().unwrap().is_null());\n        assert_eq!(\n            Str(\"5\".to_owned()).unary_factorial(),\n            Err(ValueError::FactorialOnNonNumeric.into())\n        );\n    }\n\n    #[test]\n    fn sqrt() {\n        assert_eq!(I8(9).sqrt(), Ok(F64(3.0)));\n        assert_eq!(I16(9).sqrt(), Ok(F64(3.0)));\n        assert_eq!(I64(9).sqrt(), Ok(F64(3.0)));\n        assert_eq!(I128(9).sqrt(), Ok(F64(3.0)));\n        assert_eq!(U8(9).sqrt(), Ok(F64(3.0)));\n        assert_eq!(U16(9).sqrt(), Ok(F64(3.0)));\n        assert_eq!(U32(9).sqrt(), Ok(F64(3.0)));\n        assert_eq!(U64(9).sqrt(), Ok(F64(3.0)));\n        assert_eq!(U128(9).sqrt(), Ok(F64(3.0)));\n        assert_eq!(F32(9.0_f32).sqrt(), Ok(F64(3.0)));\n        assert_eq!(F64(9.0).sqrt(), Ok(F64(3.0)));\n        assert!(Null.sqrt().unwrap().is_null());\n        assert_eq!(\n            Str(\"9\".to_owned()).sqrt(),\n            Err(ValueError::SqrtOnNonNumeric(Str(\"9\".to_owned())).into())\n        );\n    }\n\n    #[test]\n    fn bitwise_and() {\n        macro_rules! test {\n            ($op: ident $a: expr, $b: expr =\u003e $c: expr) =\u003e {\n                assert!($a.$op(\u0026$b).unwrap().evaluate_eq(\u0026$c));\n            };\n        }\n\n        macro_rules! test_bitwise_and {\n            ($($vt: ident $pt: ident);*;) =\u003e {\n                $(\n                    test!(bitwise_and $vt($pt::MIN), $vt($pt::MIN) =\u003e $vt($pt::MIN \u0026 $pt::MIN));\n                    test!(bitwise_and $vt($pt::MIN), $vt($pt::MAX) =\u003e $vt($pt::MIN \u0026 $pt::MAX));\n                    test!(bitwise_and $vt($pt::MAX), $vt($pt::MAX) =\u003e $vt($pt::MAX \u0026 $pt::MAX));\n                    test!(bitwise_and $vt(0), $vt(0) =\u003e $vt(0 \u0026 0));\n                    test!(bitwise_and $vt(0), $vt(1) =\u003e $vt(0 \u0026 1));\n                    test!(bitwise_and $vt(1), $vt(0) =\u003e $vt(1 \u0026 0));\n                    test!(bitwise_and $vt(1), $vt(1) =\u003e $vt(1 \u0026 1));\n                )*\n            };\n        }\n\n        test_bitwise_and!(\n            I8      i8;\n            I16     i16;\n            I32     i32;\n            I64     i64;\n            I128    i128;\n            U8      u8;\n            U16     u16;\n            U32     u32;\n            U64     u64;\n            U128    u128;\n        );\n\n        macro_rules! null_test {\n            ($op: ident $a: expr, $b: expr) =\u003e {\n                assert!($a.$op(\u0026$b).unwrap().is_null());\n            };\n        }\n\n        macro_rules! null_test_bitwise_and {\n            ($($vt: ident)*) =\u003e {\n                $(\n                    null_test!(bitwise_and $vt(1), Null);\n                    null_test!(bitwise_and Null, $vt(1));\n                    null_test!(bitwise_and Null, Null);\n                )*\n            };\n        }\n\n        null_test_bitwise_and!(\n            I8 I16 I32 I64 I128 U8 U16 U32 U64 U128\n        );\n\n        let lhs = I8(3);\n        let rhs = I16(12);\n        assert_eq!(\n            lhs.bitwise_and(\u0026rhs),\n            Err(ValueError::NonNumericMathOperation {\n                lhs,\n                rhs,\n                operator: NumericBinaryOperator::BitwiseAnd\n            }\n            .into())\n        )\n    }\n\n    #[test]\n    fn position() {\n        let str1 = Str(\"ramen\".to_owned());\n        let str2 = Str(\"men\".to_owned());\n        let empty_str = Str(\"\".to_owned());\n\n        assert_eq!(str1.position(\u0026str2), Ok(I64(3)));\n        assert_eq!(str2.position(\u0026str1), Ok(I64(0)));\n        assert!(Null.position(\u0026str2).unwrap().is_null());\n        assert!(str1.position(\u0026Null).unwrap().is_null());\n        assert_eq!(empty_str.position(\u0026str2), Ok(I64(0)));\n        assert_eq!(str1.position(\u0026empty_str), Ok(I64(0)));\n        assert_eq!(\n            str1.position(\u0026I64(1)),\n            Err(ValueError::NonStringParameterInPosition {\n                from: str1,\n                sub: I64(1)\n            }\n            .into())\n        );\n    }\n\n    #[test]\n    fn get_type() {\n        use {\n            super::Value,\n            crate::{ast::DataType as D, data::Interval as I, data::Point},\n            chrono::{NaiveDate, NaiveTime},\n        };\n\n        let decimal = Decimal(rust_decimal::Decimal::ONE);\n        let date = Date(NaiveDate::from_ymd_opt(2021, 5, 1).unwrap());\n        let timestamp = Timestamp(\n            NaiveDate::from_ymd_opt(2021, 5, 1)\n                .unwrap()\n                .and_hms_opt(12, 34, 50)\n                .unwrap(),\n        );\n        let time = Time(NaiveTime::from_hms_opt(12, 30, 11).unwrap());\n        let interval = Interval(I::hours(5));\n        let uuid = Uuid(parse_uuid(\"936DA01F9ABD4d9d80C702AF85C822A8\").unwrap());\n        let point = Point(Point::new(1.0, 2.0));\n        let map = Value::parse_json_map(r#\"{ \"a\": 10 }\"#).unwrap();\n        let list = Value::parse_json_list(r#\"[ true ]\"#).unwrap();\n        let bytea = Bytea(hex::decode(\"9001\").unwrap());\n        let inet = Inet(IpAddr::from_str(\"::1\").unwrap());\n\n        assert_eq!(I8(1).get_type(), Some(D::Int8));\n        assert_eq!(I16(1).get_type(), Some(D::Int16));\n        assert_eq!(I32(1).get_type(), Some(D::Int32));\n        assert_eq!(I64(1).get_type(), Some(D::Int));\n        assert_eq!(I128(1).get_type(), Some(D::Int128));\n        assert_eq!(U8(1).get_type(), Some(D::Uint8));\n        assert_eq!(U16(1).get_type(), Some(D::Uint16));\n        assert_eq!(U32(1).get_type(), Some(D::Uint32));\n        assert_eq!(U64(1).get_type(), Some(D::Uint64));\n        assert_eq!(U128(1).get_type(), Some(D::Uint128));\n        assert_eq!(F32(1.1_f32).get_type(), Some(D::Float32));\n        assert_eq!(F64(1.1).get_type(), Some(D::Float));\n        assert_eq!(decimal.get_type(), Some(D::Decimal));\n        assert_eq!(Bool(true).get_type(), Some(D::Boolean));\n        assert_eq!(Str('1'.into()).get_type(), Some(D::Text));\n        assert_eq!(bytea.get_type(), Some(D::Bytea));\n        assert_eq!(inet.get_type(), Some(D::Inet));\n        assert_eq!(date.get_type(), Some(D::Date));\n        assert_eq!(timestamp.get_type(), Some(D::Timestamp));\n        assert_eq!(time.get_type(), Some(D::Time));\n        assert_eq!(interval.get_type(), Some(D::Interval));\n        assert_eq!(uuid.get_type(), Some(D::Uuid));\n        assert_eq!(point.get_type(), Some(D::Point));\n        assert_eq!(map.get_type(), Some(D::Map));\n        assert_eq!(list.get_type(), Some(D::List));\n        assert_eq!(Null.get_type(), None);\n    }\n}\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":479},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","data.rs"],"content":"mod bigdecimal_ext;\nmod function;\nmod interval;\nmod key;\nmod literal;\nmod point;\nmod row;\nmod string_ext;\nmod table;\n\npub mod schema;\npub mod value;\n\npub use {\n    bigdecimal_ext::BigDecimalExt,\n    function::CustomFunction,\n    interval::{Interval, IntervalError},\n    key::{Key, KeyError},\n    literal::{Literal, LiteralError},\n    point::Point,\n    row::{Row, RowError},\n    schema::{Schema, SchemaIndex, SchemaIndexOrd, SchemaParseError},\n    string_ext::{StringExt, StringExtError},\n    table::{TableError, get_alias, get_index},\n    value::{ConvertError, HashMapJsonExt, NumericBinaryOperator, Value, ValueError},\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","aggregate","state.rs"],"content":"use {\n    crate::{\n        ast::{Aggregate, CountArgExpr, DataType},\n        data::{Key, Value},\n        executor::{context::RowContext, evaluate::evaluate},\n        result::Result,\n        store::GStore,\n    },\n    futures::stream::{self, StreamExt, TryStreamExt},\n    im_rc::{HashMap, HashSet},\n    itertools::Itertools,\n    std::{cmp::Ordering, rc::Rc},\n    utils::{IndexMap, Vector},\n};\n\ntype Group = Rc\u003cVec\u003cKey\u003e\u003e;\ntype ValuesMap\u003c'a\u003e = HashMap\u003c\u0026'a Aggregate, Value\u003e;\ntype Context\u003c'a\u003e = Rc\u003cRowContext\u003c'a\u003e\u003e;\n\nenum AggrValue {\n    Count {\n        wildcard: bool,\n        count: i64,\n    },\n    Sum(Value),\n    Min(Value),\n    Max(Value),\n    Avg {\n        sum: Value,\n        count: i64,\n    },\n    Variance {\n        sum_square: Value,\n        sum: Value,\n        count: i64,\n    },\n    Stdev {\n        sum_square: Value,\n        sum: Value,\n        count: i64,\n    },\n}\n\nimpl AggrValue {\n    fn new(aggr: \u0026Aggregate, value: \u0026Value) -\u003e Result\u003cSelf\u003e {\n        let value = value.clone();\n\n        Ok(match aggr {\n            Aggregate::Count(CountArgExpr::Wildcard) =\u003e AggrValue::Count {\n                wildcard: true,\n                count: 1,\n            },\n            Aggregate::Count(CountArgExpr::Expr(_)) =\u003e AggrValue::Count {\n                wildcard: false,\n                count: i64::from(!value.is_null()),\n            },\n            Aggregate::Sum(_) =\u003e AggrValue::Sum(value),\n            Aggregate::Min(_) =\u003e AggrValue::Min(value),\n            Aggregate::Max(_) =\u003e AggrValue::Max(value),\n            Aggregate::Avg(_) =\u003e AggrValue::Avg {\n                sum: value,\n                count: 1,\n            },\n            Aggregate::Variance(_) =\u003e AggrValue::Variance {\n                sum_square: value.multiply(\u0026value)?,\n                sum: value,\n                count: 1,\n            },\n            Aggregate::Stdev(_) =\u003e AggrValue::Stdev {\n                sum_square: value.multiply(\u0026value)?,\n                sum: value,\n                count: 1,\n            },\n        })\n    }\n\n    fn accumulate(\u0026self, new_value: \u0026Value) -\u003e Result\u003cOption\u003cSelf\u003e\u003e {\n        match self {\n            Self::Count { wildcard, count } =\u003e {\n                let wildcard = *wildcard;\n\n                if wildcard || !new_value.is_null() {\n                    Ok(Some(AggrValue::Count {\n                        wildcard,\n                        count: count + 1,\n                    }))\n                } else {\n                    Ok(None)\n                }\n            }\n            Self::Sum(value) =\u003e Ok(Some(Self::Sum(value.add(new_value)?))),\n            Self::Min(value) =\u003e match \u0026value.evaluate_cmp(new_value) {\n                Some(Ordering::Greater) =\u003e Ok(Some(Self::Min(new_value.clone()))),\n                _ =\u003e Ok(None),\n            },\n            Self::Max(value) =\u003e match \u0026value.evaluate_cmp(new_value) {\n                Some(Ordering::Less) =\u003e Ok(Some(Self::Max(new_value.clone()))),\n                _ =\u003e Ok(None),\n            },\n            Self::Avg { sum, count } =\u003e Ok(Some(Self::Avg {\n                sum: sum.add(new_value)?,\n                count: count + 1,\n            })),\n            Self::Variance {\n                sum_square,\n                sum,\n                count,\n            } =\u003e Ok(Some(Self::Variance {\n                sum_square: sum_square.add(\u0026new_value.multiply(new_value)?)?,\n                sum: sum.add(new_value)?,\n                count: count + 1,\n            })),\n            Self::Stdev {\n                sum_square,\n                sum,\n                count,\n            } =\u003e Ok(Some(Self::Stdev {\n                sum_square: sum_square.add(\u0026new_value.multiply(new_value)?)?,\n                sum: sum.add(new_value)?,\n                count: count + 1,\n            })),\n        }\n    }\n\n    async fn export(self) -\u003e Result\u003cValue\u003e {\n        let variance = |sum_square: Value, sum: Value, count: i64| async move {\n            let count = Value::I64(count);\n            let sum_expr1 = sum_square.multiply(\u0026count)?;\n            let sum_expr2 = sum.multiply(\u0026sum)?;\n            let expr_sub = sum_expr1.cast(\u0026DataType::Float)?.subtract(\u0026sum_expr2)?;\n            let cnt_square = count.multiply(\u0026count)?;\n            expr_sub.divide(\u0026cnt_square)\n        };\n\n        match self {\n            Self::Count { count, .. } =\u003e Ok(Value::I64(count)),\n            Self::Sum(value) | Self::Min(value) | Self::Max(value) =\u003e Ok(value),\n            Self::Avg { sum, count } =\u003e {\n                let sum = sum.cast(\u0026DataType::Float)?;\n\n                sum.divide(\u0026Value::I64(count))\n            }\n            Self::Variance {\n                sum_square,\n                sum,\n                count,\n            } =\u003e variance(sum_square, sum, count).await,\n            Self::Stdev {\n                sum_square,\n                sum,\n                count,\n            } =\u003e variance(sum_square, sum, count).await?.sqrt(),\n        }\n    }\n}\n\npub struct State\u003c'a, T: GStore\u003e {\n    storage: \u0026'a T,\n    index: usize,\n    group: Group,\n    values: IndexMap\u003c(Group, \u0026'a Aggregate), (usize, AggrValue)\u003e,\n    groups: HashSet\u003cGroup\u003e,\n    contexts: Vector\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n}\n\nimpl\u003c'a, T: GStore\u003e State\u003c'a, T\u003e {\n    pub fn new(storage: \u0026'a T) -\u003e Self {\n        State {\n            storage,\n            index: 0,\n            group: Rc::new(vec![Key::None]),\n            values: IndexMap::new(),\n            groups: HashSet::new(),\n            contexts: Vector::new(),\n        }\n    }\n\n    pub fn apply(self, index: usize, group: Vec\u003cKey\u003e, context: Rc\u003cRowContext\u003c'a\u003e\u003e) -\u003e Self {\n        let group = Rc::new(group);\n        let (groups, contexts) = if self.groups.contains(\u0026group) {\n            (self.groups, self.contexts)\n        } else {\n            (\n                self.groups.update(Rc::clone(\u0026group)),\n                self.contexts.push(context),\n            )\n        };\n\n        Self {\n            index,\n            group,\n            groups,\n            contexts,\n            ..self\n        }\n    }\n\n    fn update(self, aggr: \u0026'a Aggregate, value: AggrValue) -\u003e Self {\n        let key = (Rc::clone(\u0026self.group), aggr);\n        let (values, _) = self.values.insert(key, (self.index, value));\n        Self { values, ..self }\n    }\n\n    fn get(\u0026self, aggr: \u0026'a Aggregate) -\u003e Option\u003c\u0026(usize, AggrValue)\u003e {\n        let group = Rc::clone(\u0026self.group);\n\n        self.values.get(\u0026(group, aggr))\n    }\n\n    pub async fn export(self) -\u003e Result\u003cVec\u003c(Option\u003cValuesMap\u003c'a\u003e\u003e, Option\u003cContext\u003c'a\u003e\u003e)\u003e\u003e {\n        let size = match self.values.keys().next() {\n            Some((target, _)) =\u003e match self.values.keys().position(|(group, _)| group != target) {\n                Some(size) =\u003e size,\n                None =\u003e self.values.len(),\n            },\n            None =\u003e {\n                return Ok(self.contexts.into_iter().map(|c| (None, Some(c))).collect());\n            }\n        };\n\n        let Self {\n            values, contexts, ..\n        } = self;\n\n        stream::iter(values.into_iter().chunks(size).into_iter().enumerate())\n            .then(|(i, entries)| {\n                let next = contexts.get(i).map(Rc::clone);\n\n                async move {\n                    let aggregated = stream::iter(entries)\n                        .then(|((_, aggr), (_, aggr_value))| async move {\n                            aggr_value.export().await.map(|value| (aggr, value))\n                        })\n                        .try_collect::\u003cHashMap\u003c\u0026'a Aggregate, Value\u003e\u003e()\n                        .await?;\n\n                    Ok((Some(aggregated), next))\n                }\n            })\n            .try_collect::\u003cVec\u003c(Option\u003cValuesMap\u003c'a\u003e\u003e, Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e)\u003e\u003e()\n            .await\n    }\n\n    pub async fn accumulate(\n        self,\n        filter_context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n        aggr: \u0026'a Aggregate,\n    ) -\u003e Result\u003cState\u003c'a, T\u003e\u003e {\n        let value = match aggr {\n            Aggregate::Count(CountArgExpr::Wildcard) =\u003e Value::Null,\n            Aggregate::Count(CountArgExpr::Expr(expr))\n            | Aggregate::Sum(expr)\n            | Aggregate::Min(expr)\n            | Aggregate::Max(expr)\n            | Aggregate::Avg(expr)\n            | Aggregate::Variance(expr)\n            | Aggregate::Stdev(expr) =\u003e evaluate(self.storage, filter_context, None, expr)\n                .await?\n                .try_into()?,\n        };\n        let aggr_value = match self.get(aggr) {\n            Some((index, _)) if self.index \u003c= *index =\u003e None,\n            Some((_, aggr_value)) =\u003e aggr_value.accumulate(\u0026value)?,\n            None =\u003e Some(AggrValue::new(aggr, \u0026value)?),\n        };\n\n        match aggr_value {\n            Some(aggr_value) =\u003e Ok(self.update(aggr, aggr_value)),\n            None =\u003e Ok(self),\n        }\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":130},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","aggregate.rs"],"content":"mod state;\n\nuse {\n    self::state::State,\n    super::{\n        context::{AggregateContext, RowContext},\n        evaluate::{Evaluated, evaluate},\n        filter::check_expr,\n    },\n    crate::{\n        ast::{Expr, SelectItem},\n        data::Key,\n        result::Result,\n        store::GStore,\n    },\n    async_recursion::async_recursion,\n    futures::stream::{self, Stream, StreamExt, TryStreamExt},\n    std::rc::Rc,\n};\n\n#[derive(futures_enum::Stream)]\nenum S\u003cT1, T2\u003e {\n    NonAggregate(T1),\n    Aggregate(T2),\n}\n\nfn check_aggregate\u003c'a\u003e(fields: \u0026'a [SelectItem], group_by: \u0026'a [Expr]) -\u003e bool {\n    if !group_by.is_empty() {\n        return true;\n    }\n\n    fields.iter().any(|field| match field {\n        SelectItem::Expr { expr, .. } =\u003e check(expr),\n        _ =\u003e false,\n    })\n}\n\npub async fn apply\u003c'a, T: GStore, U: Stream\u003cItem = Result\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e\u003e + 'a\u003e(\n    storage: \u0026'a T,\n    fields: \u0026'a [SelectItem],\n    group_by: \u0026'a [Expr],\n    having: Option\u003c\u0026'a Expr\u003e,\n    filter_context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n    rows: U,\n) -\u003e Result\u003cimpl Stream\u003cItem = Result\u003cAggregateContext\u003c'a\u003e\u003e\u003e + use\u003c'a, T, U\u003e\u003e {\n    if !check_aggregate(fields, group_by) {\n        let rows = rows.map_ok(|project_context| AggregateContext {\n            aggregated: None,\n            next: project_context,\n        });\n        return Ok(S::NonAggregate(rows));\n    }\n\n    let state = rows\n        .into_stream()\n        .enumerate()\n        .map(|(i, row)| row.map(|row| (i, row)))\n        .try_fold(State::new(storage), |state, (index, project_context)| {\n            let filter_context = filter_context.clone();\n\n            async move {\n                let filter_context = match filter_context {\n                    Some(filter_context) =\u003e Rc::new(RowContext::concat(\n                        Rc::clone(\u0026project_context),\n                        filter_context,\n                    )),\n                    None =\u003e Rc::clone(\u0026project_context),\n                };\n                let filter_context = Some(filter_context);\n\n                let evaluated: Vec\u003cEvaluated\u003c'_\u003e\u003e = stream::iter(group_by.iter())\n                    .then(|expr| {\n                        let filter_clone = filter_context.as_ref().map(Rc::clone);\n                        async move { evaluate(storage, filter_clone, None, expr).await }\n                    })\n                    .try_collect::\u003cVec\u003c_\u003e\u003e()\n                    .await?;\n\n                let group = evaluated\n                    .iter()\n                    .map(Key::try_from)\n                    .collect::\u003cResult\u003cVec\u003cKey\u003e\u003e\u003e()?;\n\n                let state = state.apply(index, group, Rc::clone(\u0026project_context));\n                let state = stream::iter(fields)\n                    .map(Ok)\n                    .try_fold(state, |state, field| {\n                        let filter_clone = filter_context.as_ref().map(Rc::clone);\n\n                        async move {\n                            match field {\n                                SelectItem::Expr { expr, .. } =\u003e {\n                                    aggregate(state, filter_clone, expr).await\n                                }\n                                _ =\u003e Ok(state),\n                            }\n                        }\n                    })\n                    .await?;\n\n                Ok(state)\n            }\n        })\n        .await?;\n\n    group_by_having(storage, filter_context, having, state)\n        .await\n        .map(S::Aggregate)\n}\n\nasync fn group_by_having\u003c'a, T: GStore\u003e(\n    storage: \u0026'a T,\n    filter_context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n    having: Option\u003c\u0026'a Expr\u003e,\n    state: State\u003c'a, T\u003e,\n) -\u003e Result\u003cimpl Stream\u003cItem = Result\u003cAggregateContext\u003c'a\u003e\u003e\u003e\u003e {\n    let rows = state\n        .export()\n        .await?\n        .into_iter()\n        .filter_map(|(aggregated, next)| next.map(|next| (aggregated, next)));\n    let rows = stream::iter(rows)\n        .filter_map(move |(aggregated, next)| {\n            let filter_context = filter_context.as_ref().map(Rc::clone);\n\n            async move {\n                match having {\n                    None =\u003e Some(Ok((aggregated, next))),\n                    Some(having) =\u003e {\n                        let filter_context = match filter_context {\n                            Some(filter_context) =\u003e {\n                                Rc::new(RowContext::concat(Rc::clone(\u0026next), filter_context))\n                            }\n                            None =\u003e Rc::clone(\u0026next),\n                        };\n                        let filter_context = Some(filter_context);\n                        let aggr_rc = aggregated.clone().map(Rc::new);\n\n                        check_expr(storage, filter_context, aggr_rc, having)\n                            .await\n                            .map(|pass| pass.then_some((aggregated, next)))\n                            .transpose()\n                    }\n                }\n            }\n        })\n        .map(|res| res.map(|(aggregated, next)| AggregateContext { aggregated, next }));\n\n    Ok(rows)\n}\n\n#[async_recursion(?Send)]\nasync fn aggregate\u003c'a, T\u003e(\n    state: State\u003c'a, T\u003e,\n    filter_context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n    expr: \u0026'a Expr,\n) -\u003e Result\u003cState\u003c'a, T\u003e\u003e\nwhere\n    T: GStore,\n{\n    let aggr = |state, expr| aggregate(state, filter_context.as_ref().map(Rc::clone), expr);\n\n    match expr {\n        Expr::Between {\n            expr, low, high, ..\n        } =\u003e {\n            stream::iter([expr, low, high])\n                .map(Ok)\n                .try_fold(state, |state, expr| async move { aggr(state, expr).await })\n                .await\n        }\n        Expr::BinaryOp { left, right, .. } =\u003e {\n            stream::iter([left, right])\n                .map(Ok)\n                .try_fold(state, |state, expr| async move { aggr(state, expr).await })\n                .await\n        }\n        Expr::UnaryOp { expr, .. } =\u003e aggr(state, expr).await,\n        Expr::Nested(expr) =\u003e aggr(state, expr).await,\n        Expr::Case {\n            operand,\n            when_then,\n            else_result,\n        } =\u003e {\n            let operand = std::iter::once(operand.as_ref())\n                .filter_map(|operand| operand.map(|operand| \u0026**operand));\n            let when_then = when_then\n                .iter()\n                .flat_map(|(when, then)| std::iter::once(when).chain(std::iter::once(then)));\n            let else_result = std::iter::once(else_result.as_ref())\n                .filter_map(|else_result| else_result.map(|else_result| \u0026**else_result));\n\n            stream::iter(operand.chain(when_then).chain(else_result).map(Ok))\n                .try_fold(state, aggr)\n                .await\n        }\n        Expr::Aggregate(aggr) =\u003e state.accumulate(filter_context, aggr.as_ref()).await,\n        _ =\u003e Ok(state),\n    }\n}\n\nfn check(expr: \u0026Expr) -\u003e bool {\n    match expr {\n        Expr::Between {\n            expr, low, high, ..\n        } =\u003e check(expr) || check(low) || check(high),\n        Expr::BinaryOp { left, right, .. } =\u003e check(left) || check(right),\n        Expr::UnaryOp { expr, .. } =\u003e check(expr),\n        Expr::Nested(expr) =\u003e check(expr),\n        Expr::Case {\n            operand,\n            when_then,\n            else_result,\n        } =\u003e {\n            operand.as_ref().map(|expr| check(expr)).unwrap_or(false)\n                || when_then\n                    .iter()\n                    .any(|(when, then)| check(when) || check(then))\n                || else_result\n                    .as_ref()\n                    .map(|expr| check(expr))\n                    .unwrap_or(false)\n        }\n        Expr::Aggregate(_) =\u003e true,\n        _ =\u003e false,\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":124},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","alter","alter_table.rs"],"content":"use {\n    super::{AlterError, Referencing, validate},\n    crate::{\n        ast::{AlterTableOperation, Expr, Function},\n        data::{Schema, SchemaIndex},\n        result::Result,\n        store::{GStore, GStoreMut},\n    },\n};\n\npub async fn alter_table\u003cT: GStore + GStoreMut\u003e(\n    storage: \u0026mut T,\n    table_name: \u0026str,\n    operation: \u0026AlterTableOperation,\n) -\u003e Result\u003c()\u003e {\n    if let AlterTableOperation::RenameColumn {\n        old_column_name: column_name,\n        ..\n    }\n    | AlterTableOperation::DropColumn { column_name, .. } = operation\n    {\n        if let Some(schema) = storage.fetch_schema(table_name).await? {\n            let referencing_foreign_key = schema\n                .foreign_keys\n                .into_iter()\n                .find(|foreign_key| column_name == \u0026foreign_key.referencing_column_name);\n\n            if let Some(foreign_key) = referencing_foreign_key {\n                return Err(AlterError::CannotAlterReferencingColumn {\n                    referencing: Referencing {\n                        table_name: table_name.to_owned(),\n                        foreign_key,\n                    },\n                }\n                .into());\n            }\n        }\n\n        let referencings = storage.fetch_referencings(table_name).await?;\n        let referencing = referencings\n            .into_iter()\n            .find(|Referencing { foreign_key, .. }| {\n                column_name == \u0026foreign_key.referenced_column_name\n            });\n\n        if let Some(referencing) = referencing {\n            return Err(AlterError::CannotAlterReferencedColumn { referencing }.into());\n        }\n    }\n\n    match operation {\n        AlterTableOperation::RenameTable {\n            table_name: new_table_name,\n        } =\u003e storage.rename_schema(table_name, new_table_name).await,\n        AlterTableOperation::RenameColumn {\n            old_column_name,\n            new_column_name,\n        } =\u003e {\n            storage\n                .rename_column(table_name, old_column_name, new_column_name)\n                .await\n        }\n        AlterTableOperation::AddColumn { column_def } =\u003e {\n            validate(column_def).await?;\n\n            storage.add_column(table_name, column_def).await\n        }\n        AlterTableOperation::DropColumn {\n            column_name,\n            if_exists,\n        } =\u003e {\n            let indexes = match storage.fetch_schema(table_name).await? {\n                Some(Schema { indexes, .. }) =\u003e indexes,\n                None =\u003e {\n                    return Err(AlterError::TableNotFound(table_name.to_owned()).into());\n                }\n            };\n\n            let indexes = indexes\n                .iter()\n                .filter(|SchemaIndex { expr, .. }| find_column(expr, column_name))\n                .map(|SchemaIndex { name, .. }| name);\n\n            for index_name in indexes {\n                storage.drop_index(table_name, index_name).await?;\n            }\n\n            storage\n                .drop_column(table_name, column_name, *if_exists)\n                .await\n        }\n    }\n}\n\nfn find_column(expr: \u0026Expr, column_name: \u0026str) -\u003e bool {\n    let find = |expr| find_column(expr, column_name);\n\n    match expr {\n        Expr::Identifier(ident) =\u003e ident == column_name,\n        Expr::Nested(expr) =\u003e find(expr),\n        Expr::BinaryOp { left, right, .. } =\u003e find(left) || find(right),\n        Expr::UnaryOp { expr, .. } =\u003e find(expr),\n        Expr::Function(func) =\u003e match func.as_ref() {\n            Function::Cast { expr, .. } =\u003e find(expr),\n            _ =\u003e false,\n        },\n        _ =\u003e false,\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":62},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","alter","error.rs"],"content":"use {\n    super::table::Referencing,\n    crate::ast::{DataType, Expr},\n    serde::Serialize,\n    std::fmt::Debug,\n    thiserror::Error,\n};\n\n#[derive(Error, Serialize, Debug, PartialEq, Eq)]\npub enum AlterError {\n    // CREATE TABLE\n    #[error(\"table already exists: {0}\")]\n    TableAlreadyExists(String),\n\n    #[error(\"function already exists: {0}\")]\n    FunctionAlreadyExists(String),\n\n    #[error(\"function does not exist: {0}\")]\n    FunctionNotFound(String),\n\n    // CREATE INDEX, DROP TABLE\n    #[error(\"table does not exist: {0}\")]\n    TableNotFound(String),\n\n    #[error(\"CTAS source table does not exist: {0}\")]\n    CtasSourceTableNotFound(String),\n\n    // validate column def\n    #[error(\"column '{0}' of data type '{1:?}' is unsupported for unique constraint\")]\n    UnsupportedDataTypeForUniqueColumn(String, DataType),\n\n    // validate index expr\n    #[error(\"unsupported index expr: {0:#?}\")]\n    UnsupportedIndexExpr(Expr),\n\n    // validate index expr\n    #[error(\"unsupported unnamed argument\")]\n    UnsupportedUnnamedArg,\n\n    #[error(\"identifier not found: {0:#?}\")]\n    IdentifierNotFound(Expr),\n\n    #[error(\"duplicate column name: {0}\")]\n    DuplicateColumnName(String),\n\n    #[error(\"duplicate arg name: {0}\")]\n    DuplicateArgName(String),\n\n    #[error(\"non-default argument should not follow the default argument\")]\n    NonDefaultArgumentFollowsDefaultArgument,\n\n    #[error(\"foreign table not found: {0}\")]\n    ReferencedTableNotFound(String),\n\n    #[error(\"referenced column not found: {0}\")]\n    ReferencedColumnNotFound(String),\n\n    #[error(\"referencing column not found: {0}\")]\n    ReferencingColumnNotFound(String),\n\n    #[error(\n        \"referencing column '{referencing_column}' of data type '{referencing_column_type}' does not match referenced column '{referenced_column}' of data type '{referenced_column_type}'\"\n    )]\n    ForeignKeyDataTypeMismatch {\n        referencing_column: String,\n        referencing_column_type: DataType,\n        referenced_column: String,\n        referenced_column_type: DataType,\n    },\n\n    #[error(\n        \"referenced column '{referenced_table}.{referenced_column}' is not unique, cannot be used as foreign key\"\n    )]\n    ReferencingNonPKColumn {\n        referenced_table: String,\n        referenced_column: String,\n    },\n\n    #[error(\"cannot drop table '{referenced_table_name}' due to referencing tables: '{}'\", referencings.iter().map(ToString::to_string).collect::\u003cVec\u003c_\u003e\u003e().join(\", \"))]\n    CannotDropTableWithReferencing {\n        referenced_table_name: String,\n        referencings: Vec\u003cReferencing\u003e,\n    },\n\n    #[error(\"cannot drop column '{}.{}' referenced by '{}'\", referencing.foreign_key.referenced_table_name, referencing.foreign_key.referenced_column_name, referencing)]\n    CannotAlterReferencedColumn { referencing: Referencing },\n\n    #[error(\"cannot drop column '{}.{}' referencing with '{}'\", referencing.table_name, referencing.foreign_key.referencing_column_name, referencing)]\n    CannotAlterReferencingColumn { referencing: Referencing },\n\n    #[error(\"unreachable\")]\n    Unreachable,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","alter","function.rs"],"content":"use {\n    super::{AlterError, validate_arg_names, validate_default_args},\n    crate::{\n        ast::{Expr, OperateFunctionArg},\n        data::CustomFunction,\n        result::Result,\n        store::{GStore, GStoreMut},\n    },\n};\n\npub async fn insert_function\u003cT: GStore + GStoreMut\u003e(\n    storage: \u0026mut T,\n    func_name: \u0026str,\n    args: \u0026Vec\u003cOperateFunctionArg\u003e,\n    or_replace: bool,\n    body: \u0026Expr,\n) -\u003e Result\u003c()\u003e {\n    validate_arg_names(args)?;\n    validate_default_args(args).await?;\n\n    if storage.fetch_function(func_name).await?.is_none() || or_replace {\n        storage.delete_function(func_name).await?;\n        storage\n            .insert_function(CustomFunction {\n                func_name: func_name.to_owned(),\n                args: args.to_owned(),\n                body: body.to_owned(),\n            })\n            .await?;\n        Ok(())\n    } else {\n        Err(AlterError::FunctionAlreadyExists(func_name.to_owned()).into())\n    }\n}\n\npub async fn delete_function\u003cT: GStore + GStoreMut\u003e(\n    storage: \u0026mut T,\n    func_names: \u0026[String],\n    if_exists: bool,\n) -\u003e Result\u003c()\u003e {\n    for func_name in func_names {\n        let function = storage.fetch_function(func_name).await?;\n\n        if !if_exists {\n            function.ok_or_else(|| AlterError::FunctionNotFound(func_name.to_owned()))?;\n        }\n\n        storage.delete_function(func_name).await?;\n    }\n    Ok(())\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","alter","index.rs"],"content":"use {\n    super::AlterError,\n    crate::{\n        ast::{ColumnDef, Expr, Function, OrderByExpr},\n        data::Schema,\n        result::Result,\n        store::{GStore, GStoreMut},\n    },\n};\n\npub async fn create_index\u003cT: GStore + GStoreMut\u003e(\n    storage: \u0026mut T,\n    table_name: \u0026str,\n    index_name: \u0026str,\n    column: \u0026OrderByExpr,\n) -\u003e Result\u003c()\u003e {\n    let expr = \u0026column.expr;\n    let Schema { column_defs, .. } = storage\n        .fetch_schema(table_name)\n        .await?\n        .ok_or_else(|| AlterError::TableNotFound(table_name.to_owned()))?;\n    let columns = column_defs\n        .unwrap_or_default()\n        .into_iter()\n        .map(|ColumnDef { name, .. }| name)\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let (valid, has_ident) = validate_index_expr(\u0026columns, expr);\n    if !valid {\n        return Err(AlterError::UnsupportedIndexExpr(expr.clone()).into());\n    } else if !has_ident {\n        return Err(AlterError::IdentifierNotFound(expr.clone()).into());\n    }\n\n    storage.create_index(table_name, index_name, column).await\n}\n\nfn validate_index_expr(columns: \u0026[String], expr: \u0026Expr) -\u003e (bool, bool) {\n    let validate = |expr| validate_index_expr(columns, expr);\n\n    match expr {\n        Expr::Identifier(ident) =\u003e (columns.iter().any(|column| column == ident), true),\n        Expr::Literal(_) | Expr::TypedString { .. } =\u003e (true, false),\n        Expr::Nested(expr) =\u003e validate(expr),\n        Expr::BinaryOp { left, right, .. } =\u003e {\n            let (valid_l, has_ident_l) = validate(left);\n            let (valid_r, has_ident_r) = validate(right);\n\n            (valid_l \u0026\u0026 valid_r, has_ident_l || has_ident_r)\n        }\n        Expr::UnaryOp { expr, .. } =\u003e validate(expr),\n        Expr::Function(func) =\u003e match func.as_ref() {\n            Function::Cast { expr, .. } =\u003e validate(expr),\n            _ =\u003e (false, false),\n        },\n        _ =\u003e (false, false),\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","alter","table.rs"],"content":"use {\n    super::{AlterError, validate, validate_column_names},\n    crate::{\n        ast::{\n            ColumnDef, ColumnUniqueOption, ForeignKey, Query, SetExpr, TableFactor, ToSql, Values,\n        },\n        data::Schema,\n        executor::{evaluate_stateless, select::select},\n        prelude::{DataType, Value},\n        result::Result,\n        store::{GStore, GStoreMut},\n    },\n    futures::stream::TryStreamExt,\n    serde::Serialize,\n    std::fmt,\n};\n\npub struct CreateTableOptions\u003c'a\u003e {\n    pub target_table_name: \u0026'a str,\n    pub column_defs: Option\u003c\u0026'a [ColumnDef]\u003e,\n    pub if_not_exists: bool,\n    pub source: \u0026'a Option\u003cBox\u003cQuery\u003e\u003e,\n    pub engine: \u0026'a Option\u003cString\u003e,\n    pub foreign_keys: \u0026'a Vec\u003cForeignKey\u003e,\n    pub comment: \u0026'a Option\u003cString\u003e,\n}\n\npub async fn create_table\u003cT: GStore + GStoreMut\u003e(\n    storage: \u0026mut T,\n    CreateTableOptions {\n        target_table_name,\n        column_defs,\n        if_not_exists,\n        source,\n        engine,\n        foreign_keys,\n        comment,\n    }: CreateTableOptions\u003c'_\u003e,\n) -\u003e Result\u003c()\u003e {\n    let target_columns_defs = match source.as_deref() {\n        Some(Query { body, .. }) =\u003e match body {\n            SetExpr::Select(select_query) =\u003e match \u0026select_query.from.relation {\n                TableFactor::Table { name, .. } =\u003e {\n                    let schema = storage.fetch_schema(name).await?;\n                    let Schema {\n                        column_defs: source_column_defs,\n                        ..\n                    } = schema\n                        .ok_or_else(|| AlterError::CtasSourceTableNotFound(name.to_owned()))?;\n\n                    source_column_defs\n                }\n                TableFactor::Series { .. } =\u003e {\n                    let column_def = ColumnDef {\n                        name: \"N\".into(),\n                        data_type: DataType::Int,\n                        nullable: false,\n                        default: None,\n                        unique: None,\n                        comment: None,\n                    };\n\n                    Some(vec![column_def])\n                }\n                _ =\u003e {\n                    return Err(AlterError::Unreachable.into());\n                }\n            },\n            SetExpr::Values(Values(values_list)) =\u003e {\n                let first_len = values_list[0].len();\n                let mut column_types = vec![None; first_len];\n\n                for exprs in values_list {\n                    for (i, expr) in exprs.iter().enumerate() {\n                        if column_types[i].is_some() {\n                            continue;\n                        }\n\n                        column_types[i] = evaluate_stateless(None, expr)\n                            .await\n                            .and_then(Value::try_from)\n                            .map(|value| value.get_type())?;\n                    }\n\n                    if column_types.iter().all(Option::is_some) {\n                        break;\n                    }\n                }\n\n                let column_defs = column_types\n                    .iter()\n                    .map(|column_type| match column_type {\n                        Some(column_type) =\u003e column_type.to_owned(),\n                        None =\u003e DataType::Text,\n                    })\n                    .enumerate()\n                    .map(|(i, data_type)| ColumnDef {\n                        name: format!(\"column{}\", i + 1),\n                        data_type,\n                        nullable: true,\n                        default: None,\n                        unique: None,\n                        comment: None,\n                    })\n                    .collect::\u003cVec\u003c_\u003e\u003e();\n\n                Some(column_defs)\n            }\n        },\n        None if column_defs.is_some() =\u003e column_defs.map(\u003c[ColumnDef]\u003e::to_vec),\n        None =\u003e None,\n    };\n\n    if let Some(column_defs) = target_columns_defs.as_deref() {\n        validate_column_names(column_defs)?;\n\n        for column_def in column_defs {\n            validate(column_def).await?;\n        }\n    }\n\n    for foreign_key in foreign_keys {\n        let ForeignKey {\n            referencing_column_name,\n            referenced_table_name,\n            referenced_column_name,\n            ..\n        } = foreign_key;\n\n        let column_defs = if referenced_table_name == target_table_name {\n            target_columns_defs.clone()\n        } else {\n            let referenced_schema = storage\n                .fetch_schema(referenced_table_name)\n                .await?\n                .ok_or_else(|| {\n                    AlterError::ReferencedTableNotFound(referenced_table_name.to_owned())\n                })?;\n\n            referenced_schema.column_defs\n        };\n\n        let referenced_column_def = column_defs\n            .and_then(|column_defs| {\n                column_defs\n                    .into_iter()\n                    .find(|column_def| column_def.name == *referenced_column_name)\n            })\n            .ok_or_else(|| AlterError::ReferencedColumnNotFound(referenced_column_name.to_owned()))?\n            .to_owned();\n\n        let referencing_column_def = target_columns_defs\n            .as_deref()\n            .and_then(|column_defs| {\n                column_defs\n                    .iter()\n                    .find(|column_def| column_def.name == *referencing_column_name)\n            })\n            .ok_or_else(|| {\n                AlterError::ReferencingColumnNotFound(referencing_column_name.to_owned())\n            })?;\n\n        if referencing_column_def.data_type != referenced_column_def.data_type {\n            return Err(AlterError::ForeignKeyDataTypeMismatch {\n                referencing_column: referencing_column_name.to_owned(),\n                referencing_column_type: referencing_column_def.data_type.to_owned(),\n                referenced_column: referenced_column_name.to_owned(),\n                referenced_column_type: referenced_column_def.data_type.to_owned(),\n            }\n            .into());\n        }\n\n        if referenced_column_def.unique != Some(ColumnUniqueOption { is_primary: true }) {\n            return Err(AlterError::ReferencingNonPKColumn {\n                referenced_table: referenced_table_name.to_owned(),\n                referenced_column: referenced_column_name.to_owned(),\n            }\n            .into());\n        }\n    }\n\n    if storage.fetch_schema(target_table_name).await?.is_none() {\n        let schema = Schema {\n            table_name: target_table_name.to_owned(),\n            column_defs: target_columns_defs,\n            indexes: vec![],\n            engine: engine.clone(),\n            foreign_keys: foreign_keys.clone(),\n            comment: comment.clone(),\n        };\n\n        storage.insert_schema(\u0026schema).await?;\n    } else if !if_not_exists {\n        return Err(AlterError::TableAlreadyExists(target_table_name.to_owned()).into());\n    }\n\n    match source {\n        Some(query) =\u003e {\n            let rows = select(storage, query, None)\n                .await?\n                .map_ok(Into::into)\n                .try_collect()\n                .await?;\n\n            storage\n                .append_data(target_table_name, rows)\n                .await\n                .map(|_| ())\n        }\n        None =\u003e Ok(()),\n    }\n}\n\npub async fn drop_table\u003cT: GStore + GStoreMut\u003e(\n    storage: \u0026mut T,\n    table_names: \u0026[String],\n    if_exists: bool,\n    cascade: bool,\n) -\u003e Result\u003cusize\u003e {\n    let mut n = 0;\n\n    for table_name in table_names {\n        let schema = storage.fetch_schema(table_name).await?;\n\n        match (schema, if_exists) {\n            (None, true) =\u003e {\n                continue;\n            }\n            (None, false) =\u003e {\n                return Err(AlterError::TableNotFound(table_name.to_owned()).into());\n            }\n            _ =\u003e {}\n        }\n\n        let referencings = storage.fetch_referencings(table_name).await?;\n\n        if !referencings.is_empty() \u0026\u0026 !cascade {\n            return Err(AlterError::CannotDropTableWithReferencing {\n                referenced_table_name: table_name.into(),\n                referencings,\n            }\n            .into());\n        }\n\n        for Referencing {\n            table_name,\n            foreign_key: ForeignKey { name, .. },\n        } in referencings\n        {\n            let mut schema = storage\n                .fetch_schema(\u0026table_name)\n                .await?\n                .ok_or_else(|| AlterError::TableNotFound(table_name.to_owned()))?;\n            schema\n                .foreign_keys\n                .retain(|foreign_key| foreign_key.name != name);\n            storage.insert_schema(\u0026schema).await?;\n        }\n        storage.delete_schema(table_name).await?;\n\n        n += 1;\n    }\n\n    Ok(n)\n}\n\n#[derive(Debug, PartialEq, Eq, Serialize)]\npub struct Referencing {\n    pub table_name: String,\n    pub foreign_key: ForeignKey,\n}\n\nimpl fmt::Display for Referencing {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(\n            f,\n            r#\"{} on table \"{}\"\"#,\n            self.foreign_key.to_sql(),\n            self.table_name\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {super::*, crate::ast::ReferentialAction};\n\n    #[test]\n    fn test_referencing_display() {\n        let referencing = Referencing {\n            table_name: \"Referencing\".to_owned(),\n            foreign_key: ForeignKey {\n                name: \"FK_referenced_id-Referenced_id\".to_owned(),\n                referencing_column_name: \"referenced_id\".to_owned(),\n                referenced_table_name: \"Referenced\".to_owned(),\n                referenced_column_name: \"id\".to_owned(),\n                on_delete: ReferentialAction::NoAction,\n                on_update: ReferentialAction::NoAction,\n            },\n        };\n\n        assert_eq!(\n            format!(\"{}\", referencing),\n            r#\"CONSTRAINT \"FK_referenced_id-Referenced_id\" FOREIGN KEY (\"referenced_id\") REFERENCES \"Referenced\" (\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION on table \"Referencing\"\"#\n        );\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":144},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","alter","validate.rs"],"content":"use {\n    super::AlterError,\n    crate::{\n        ast::{ColumnDef, ColumnUniqueOption, DataType, OperateFunctionArg},\n        executor::evaluate_stateless,\n        result::Result,\n    },\n};\n\npub async fn validate(column_def: \u0026ColumnDef) -\u003e Result\u003c()\u003e {\n    let ColumnDef {\n        data_type,\n        default,\n        unique,\n        name,\n        ..\n    } = column_def;\n\n    // unique + data type\n    if matches!(data_type, DataType::Float | DataType::Map)\n        \u0026\u0026 matches!(unique, Some(ColumnUniqueOption { .. }))\n    {\n        return Err(AlterError::UnsupportedDataTypeForUniqueColumn(\n            name.to_owned(),\n            data_type.clone(),\n        )\n        .into());\n    }\n\n    if let Some(expr) = default {\n        evaluate_stateless(None, expr).await?;\n    }\n\n    Ok(())\n}\n\npub fn validate_column_names(column_defs: \u0026[ColumnDef]) -\u003e Result\u003c()\u003e {\n    let duplicate_column_name = column_defs\n        .iter()\n        .enumerate()\n        .find(|(i, base_column)| {\n            column_defs\n                .iter()\n                .skip(i + 1)\n                .any(|target_column| base_column.name == target_column.name)\n        })\n        .map(|(_, column)| \u0026column.name);\n\n    match duplicate_column_name {\n        Some(v) =\u003e Err(AlterError::DuplicateColumnName(v.to_owned()).into()),\n        None =\u003e Ok(()),\n    }\n}\n\npub fn validate_arg_names(args: \u0026[OperateFunctionArg]) -\u003e Result\u003c()\u003e {\n    let duplicate_arg_name = args\n        .iter()\n        .enumerate()\n        .find(|(i, base_arg)| {\n            args.iter()\n                .skip(i + 1)\n                .any(|target_arg| base_arg.name == target_arg.name)\n        })\n        .map(|(_, arg)| arg.name.to_owned());\n\n    match duplicate_arg_name {\n        Some(v) =\u003e Err(AlterError::DuplicateArgName(v).into()),\n        None =\u003e Ok(()),\n    }\n}\n\npub async fn validate_default_args(args: \u0026[OperateFunctionArg]) -\u003e Result\u003c()\u003e {\n    for expr in args.iter().filter_map(|arg| arg.default.as_ref()) {\n        evaluate_stateless(None, expr).await?;\n    }\n\n    if args\n        .iter()\n        .map(|arg| arg.default.as_ref())\n        .skip_while(Option::is_none)\n        .all(|default| default.is_some())\n    {\n        Ok(())\n    } else {\n        Err(AlterError::NonDefaultArgumentFollowsDefaultArgument.into())\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","alter.rs"],"content":"mod alter_table;\nmod error;\nmod function;\nmod index;\nmod table;\nmod validate;\n\nuse validate::{validate, validate_arg_names, validate_column_names, validate_default_args};\n\npub use {\n    alter_table::alter_table,\n    error::AlterError,\n    function::{delete_function, insert_function},\n    index::create_index,\n    table::{CreateTableOptions, Referencing, create_table, drop_table},\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","context","aggregate_context.rs"],"content":"use {\n    super::RowContext,\n    crate::{ast::Aggregate, data::Value},\n    im_rc::HashMap,\n    std::{fmt::Debug, rc::Rc},\n};\n\n#[derive(Debug)]\npub struct AggregateContext\u003c'a\u003e {\n    pub aggregated: Option\u003cHashMap\u003c\u0026'a Aggregate, Value\u003e\u003e,\n    pub next: Rc\u003cRowContext\u003c'a\u003e\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","context","row_context.rs"],"content":"use {\n    crate::data::{Row, Value},\n    std::{borrow::Cow, collections::HashMap, fmt::Debug, rc::Rc},\n};\n\n#[derive(Debug)]\npub enum RowContext\u003c'a\u003e {\n    Data {\n        table_alias: \u0026'a str,\n        row: Cow\u003c'a, Row\u003e,\n        next: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n    },\n    RefVecData {\n        columns: \u0026'a [String],\n        values: \u0026'a [Value],\n    },\n    RefMapData(\u0026'a HashMap\u003cString, Value\u003e),\n    Bridge {\n        left: Rc\u003cRowContext\u003c'a\u003e\u003e,\n        right: Rc\u003cRowContext\u003c'a\u003e\u003e,\n    },\n}\n\nimpl\u003c'a\u003e RowContext\u003c'a\u003e {\n    pub fn new(table_alias: \u0026'a str, row: Cow\u003c'a, Row\u003e, next: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e) -\u003e Self {\n        Self::Data {\n            table_alias,\n            row,\n            next,\n        }\n    }\n\n    pub fn concat(left: Rc\u003cRowContext\u003c'a\u003e\u003e, right: Rc\u003cRowContext\u003c'a\u003e\u003e) -\u003e Self {\n        Self::Bridge { left, right }\n    }\n\n    pub fn get_value(\u0026'a self, target: \u0026str) -\u003e Option\u003c\u0026'a Value\u003e {\n        match self {\n            Self::Data {\n                row, next: None, ..\n            } =\u003e row.get_value(target),\n            Self::Data {\n                row,\n                next: Some(next),\n                ..\n            } =\u003e row.get_value(target).or_else(|| next.get_value(target)),\n            Self::Bridge { left, right } =\u003e {\n                left.get_value(target).or_else(|| right.get_value(target))\n            }\n            Self::RefVecData { columns, values } =\u003e columns\n                .iter()\n                .position(|column| column == target)\n                .and_then(|index| values.get(index)),\n            Self::RefMapData(values) =\u003e values.get(target),\n        }\n    }\n\n    pub fn get_alias_value(\u0026'a self, target_table_alias: \u0026str, target: \u0026str) -\u003e Option\u003c\u0026'a Value\u003e {\n        match self {\n            Self::Data {\n                table_alias,\n                row,\n                next,\n            } if *table_alias == target_table_alias =\u003e {\n                let value = row.get_value(target);\n\n                if value.is_some() {\n                    value\n                } else {\n                    next.as_ref()\n                        .and_then(|context| context.get_alias_value(target_table_alias, target))\n                }\n            }\n            Self::Data { next: None, .. } =\u003e None,\n            Self::Data {\n                next: Some(next), ..\n            } =\u003e next.get_alias_value(target_table_alias, target),\n            Self::Bridge { left, right } =\u003e left\n                .get_alias_value(target_table_alias, target)\n                .or_else(|| right.get_alias_value(target_table_alias, target)),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn get_alias_entries(\u0026self, alias: \u0026str) -\u003e Option\u003cVec\u003c(\u0026String, Value)\u003e\u003e {\n        match self {\n            Self::Data {\n                table_alias, row, ..\n            } if *table_alias == alias =\u003e Some(row.iter().map(|(k, v)| (k, v.clone())).collect()),\n            Self::Data { next: None, .. } =\u003e None,\n            Self::Data {\n                next: Some(next), ..\n            } =\u003e next.get_alias_entries(alias),\n            Self::Bridge { left, right } =\u003e left\n                .get_alias_entries(alias)\n                .or_else(|| right.get_alias_entries(alias)),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn get_all_entries(\u0026self) -\u003e Vec\u003c(\u0026String, Value)\u003e {\n        match self {\n            Self::Data {\n                row, next: None, ..\n            } =\u003e row.iter().map(|(k, v)| (k, v.clone())).collect(),\n            Self::Data {\n                row,\n                next: Some(next),\n                ..\n            } =\u003e next\n                .get_all_entries()\n                .into_iter()\n                .chain(row.iter().map(|(k, v)| (k, v.clone())))\n                .collect(),\n            Self::Bridge { left, right } =\u003e {\n                [left.get_all_entries(), right.get_all_entries()].concat()\n            }\n            _ =\u003e vec![],\n        }\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":65},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","context.rs"],"content":"mod aggregate_context;\nmod row_context;\n\npub use {aggregate_context::AggregateContext, row_context::RowContext};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","delete.rs"],"content":"use {\n    super::{\n        Payload, Referencing,\n        fetch::{fetch, fetch_columns},\n    },\n    crate::{\n        ast::{BinaryOperator, Expr, ForeignKey, ReferentialAction},\n        result::{Error, Result},\n        store::{GStore, GStoreMut},\n    },\n    futures::stream::{StreamExt, TryStreamExt},\n    serde::Serialize,\n    std::rc::Rc,\n    thiserror::Error as ThisError,\n};\n\n#[derive(ThisError, Serialize, Debug, PartialEq, Eq)]\npub enum DeleteError {\n    #[error(\"referencing column exists: {0}\")]\n    ReferencingColumnExists(String),\n\n    #[error(\"Value not found on column: {0}\")]\n    ValueNotFound(String),\n}\n\npub async fn delete\u003cT: GStore + GStoreMut\u003e(\n    storage: \u0026mut T,\n    table_name: \u0026str,\n    selection: \u0026Option\u003cExpr\u003e,\n) -\u003e Result\u003cPayload\u003e {\n    let columns = fetch_columns(storage, table_name).await?.map(Rc::from);\n    let referencings = storage.fetch_referencings(table_name).await?;\n    let keys = fetch(storage, table_name, columns, selection.as_ref())\n        .await?\n        .into_stream()\n        .then(|item| async {\n            let (key, row) = item?;\n\n            for Referencing {\n                table_name: referencing_table_name,\n                foreign_key:\n                    ForeignKey {\n                        referencing_column_name,\n                        referenced_column_name,\n                        on_delete,\n                        ..\n                    },\n            } in \u0026referencings\n            {\n                let value = row\n                    .get_value(referenced_column_name)\n                    .ok_or(DeleteError::ValueNotFound(referenced_column_name.clone()))?\n                    .clone();\n\n                let expr = \u0026Expr::BinaryOp {\n                    left: Box::new(Expr::Identifier(referencing_column_name.clone())),\n                    op: BinaryOperator::Eq,\n                    right: Box::new(Expr::try_from(value)?),\n                };\n\n                let columns = Some(Rc::from(Vec::new()));\n                let referencing_rows =\n                    fetch(storage, referencing_table_name, columns, Some(expr)).await?;\n\n                let referencing_row_exists = Box::pin(referencing_rows).next().await.is_some();\n                if referencing_row_exists \u0026\u0026 on_delete == \u0026ReferentialAction::NoAction {\n                    return Err(DeleteError::ReferencingColumnExists(format!(\n                        \"{referencing_table_name}.{referencing_column_name}\"\n                    ))\n                    .into());\n                }\n            }\n\n            Ok::\u003c_, Error\u003e(key)\n        })\n        .try_collect::\u003cVec\u003c_\u003e\u003e()\n        .await?;\n    let num_keys = keys.len();\n\n    storage\n        .delete_data(table_name, keys)\n        .await\n        .map(|_| Payload::Delete(num_keys))\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":39},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","evaluate","error.rs"],"content":"use {\n    crate::ast::{Aggregate, BinaryOperator, Expr, ToSql},\n    serde::{Serialize, Serializer},\n    std::fmt::Debug,\n    thiserror::Error,\n};\n\n#[derive(Error, Serialize, Debug, PartialEq, Eq)]\npub enum EvaluateError {\n    #[error(transparent)]\n    #[serde(serialize_with = \"error_serialize\")]\n    FormatParseError(#[from] chrono::format::ParseError),\n\n    #[error(\"literal add on non-numeric\")]\n    LiteralAddOnNonNumeric,\n\n    #[error(\"function requires string value: {0}\")]\n    FunctionRequiresStringValue(String),\n\n    #[error(\"function requires integer or string value: {0}\")]\n    FunctionRequiresIntegerOrStringValue(String),\n\n    #[error(\"function requires integer value: {0}\")]\n    FunctionRequiresIntegerValue(String),\n\n    #[error(\"function requires float or integer value: {0}\")]\n    FunctionRequiresFloatOrIntegerValue(String),\n\n    #[error(\"function requires usize value: {0}\")]\n    FunctionRequiresUSizeValue(String),\n\n    #[error(\"function requires float value: {0}\")]\n    FunctionRequiresFloatValue(String),\n\n    #[error(\"extract format does not support value: {0}\")]\n    ExtractFormatNotMatched(String),\n\n    #[error(\"function requires map value: {0}\")]\n    FunctionRequiresMapValue(String),\n\n    #[error(\"function requires point value: {0}\")]\n    FunctionRequiresPointValue(String),\n\n    #[error(\"function requires date or datetime value: {0}\")]\n    FunctionRequiresDateOrDateTimeValue(String),\n\n    #[error(\"function requires one of string, list, map types: {0}\")]\n    FunctionRequiresStrOrListOrMapValue(String),\n\n    #[error(\"identifier not found: {0}\")]\n    IdentifierNotFound(String),\n\n    #[error(\"identifier not found: {table_alias}.{column_name}\")]\n    CompoundIdentifierNotFound {\n        table_alias: String,\n        column_name: String,\n    },\n\n    #[error(\"only boolean value is accepted: {0}\")]\n    BooleanTypeRequired(String),\n\n    #[error(\"expr requires map or list value\")]\n    MapOrListTypeRequired,\n\n    #[error(\"expr requires map value\")]\n    MapTypeRequired,\n\n    #[error(\"expr requires list value\")]\n    ListTypeRequired,\n\n    #[error(\"all elements in the list must be comparable to each other\")]\n    InvalidSortType,\n\n    #[error(\"sort order must be either ASC or DESC\")]\n    InvalidSortOrder,\n\n    #[error(\"map or string value required for json map conversion: {0}\")]\n    MapOrStringValueRequired(String),\n\n    #[error(\"text literal required for json map conversion: {0}\")]\n    TextLiteralRequired(String),\n\n    #[error(\"unsupported stateless expression: {}\", .0.to_sql())]\n    UnsupportedStatelessExpr(Expr),\n\n    #[error(\"context is required for identifier evaluation: {}\", .0.to_sql())]\n    ContextRequiredForIdentEvaluation(Expr),\n\n    #[error(\"unreachable empty aggregate value: {0:?}\")]\n    UnreachableEmptyAggregateValue(Aggregate),\n\n    #[error(\"incompatible bit operation between {0} and {1}\")]\n    IncompatibleBitOperation(String, String),\n\n    #[error(\"the divisor should not be zero\")]\n    DivisorShouldNotBeZero,\n\n    #[error(\"negative substring length not allowed\")]\n    NegativeSubstrLenNotAllowed,\n\n    #[error(\"subquery returns more than one row\")]\n    MoreThanOneRowReturned,\n\n    #[error(\"subquery returns more than one column\")]\n    MoreThanOneColumnReturned,\n\n    #[error(\"schemaless projection is not allowed for IN (subquery)\")]\n    SchemalessProjectionForInSubQuery,\n\n    #[error(\"schemaless projection is not allowed for subquery\")]\n    SchemalessProjectionForSubQuery,\n\n    #[error(\"format function does not support following data_type: {0}\")]\n    UnsupportedExprForFormatFunction(String),\n\n    #[error(\"support single character only\")]\n    AsciiFunctionRequiresSingleCharacterValue,\n\n    #[error(\"non-ascii character not allowed\")]\n    NonAsciiCharacterNotAllowed,\n\n    #[error(\"function requires integer value in range\")]\n    ChrFunctionRequiresIntegerValueInRange0To255,\n\n    #[error(\"unsupported evaluate binary operation {} {} {}\", .left, .op.to_sql(), .right)]\n    UnsupportedBinaryOperation {\n        left: String,\n        op: BinaryOperator,\n        right: String,\n    },\n\n    #[error(\"unsupported evaluate string unary plus: {0}\")]\n    UnsupportedUnaryPlus(String),\n\n    #[error(\"unsupported evaluate string unary minus: {0}\")]\n    UnsupportedUnaryMinus(String),\n\n    #[error(\"unsupported evaluate string unary factorial: {0}\")]\n    UnsupportedUnaryFactorial(String),\n\n    #[error(\"incompatible bit operation ~{0}\")]\n    IncompatibleUnaryBitwiseNotOperation(String),\n\n    #[error(\"unsupported custom function in subqueries\")]\n    UnsupportedCustomFunction,\n\n    #[error(r#\"The function \"{function_name}\" requires at least {required_minimum} argument(s), but {found} were provided.\"#)]\n    FunctionRequiresMoreArguments {\n        function_name: String,\n        required_minimum: usize,\n        found: usize,\n    },\n\n    #[error(\n        \"function args.length not matching: {name}, expected: {expected_minimum} ~ {expected_maximum}, found: {found}\"\n    )]\n    FunctionArgsLengthNotWithinRange {\n        name: String,\n        expected_minimum: usize,\n        expected_maximum: usize,\n        found: usize,\n    },\n\n    #[error(\"unsupported function: {0}\")]\n    UnsupportedFunction(String),\n\n    #[error(\"The provided arguments are non-comparable: {0}\")]\n    NonComparableArgumentError(String),\n\n    #[error(\"function requires at least one argument: {0}\")]\n    FunctionRequiresAtLeastOneArgument(String),\n\n    #[error(\"function CONCAT requires at least 1 argument\")]\n    EmptyArgNotAllowedInConcat,\n\n    #[error(\"LCM calculation resulted in a value out of the i64 range\")]\n    LcmResultOutOfRange,\n\n    #[error(\"GCD or LCM calculation overflowed on trying to get the absolute value of {0}\")]\n    GcdLcmOverflow(i64),\n\n    #[error(\"failed to convert Value to u32: {0}\")]\n    I64ToU32ConversionFailure(String),\n}\n\nfn error_serialize\u003cS\u003e(error: \u0026chrono::format::ParseError, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\nwhere\n    S: Serializer,\n{\n    let display = format!(\"{}\", error);\n    serializer.serialize_str(\u0026display)\n}\n","traces":[{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","evaluate","evaluated.rs"],"content":"use {\n    super::error::EvaluateError,\n    crate::{\n        ast::{BinaryOperator, DataType, TrimWhereField},\n        data::{Key, Literal, Value, value::HashMapJsonExt},\n        result::{Error, Result},\n    },\n    std::{borrow::Cow, cmp::Ordering, collections::HashMap, ops::Range},\n};\n\n#[derive(Clone, Debug, PartialEq)]\npub enum Evaluated\u003c'a\u003e {\n    Literal(Literal\u003c'a\u003e),\n    StrSlice {\n        source: Cow\u003c'a, str\u003e,\n        range: Range\u003cusize\u003e,\n    },\n    Value(Value),\n}\n\nimpl TryFrom\u003cEvaluated\u003c'_\u003e\u003e for Value {\n    type Error = Error;\n\n    fn try_from(e: Evaluated\u003c'_\u003e) -\u003e Result\u003cValue\u003e {\n        match e {\n            Evaluated::Literal(v) =\u003e Value::try_from(v),\n            Evaluated::StrSlice {\n                source: s,\n                range: r,\n            } =\u003e Ok(Value::Str(s[r].to_owned())),\n            Evaluated::Value(v) =\u003e Ok(v),\n        }\n    }\n}\n\nimpl TryFrom\u003cEvaluated\u003c'_\u003e\u003e for Key {\n    type Error = Error;\n\n    fn try_from(evaluated: Evaluated\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        Self::try_from(\u0026evaluated)\n    }\n}\n\nimpl TryFrom\u003c\u0026Evaluated\u003c'_\u003e\u003e for Key {\n    type Error = Error;\n\n    fn try_from(evaluated: \u0026Evaluated\u003c'_\u003e) -\u003e Result\u003cSelf\u003e {\n        match evaluated {\n            Evaluated::Literal(l) =\u003e Value::try_from(l)?.try_into(),\n            Evaluated::StrSlice { source, range } =\u003e Ok(Key::Str(source[range.clone()].to_owned())),\n            Evaluated::Value(v) =\u003e v.try_into(),\n        }\n    }\n}\n\nimpl TryFrom\u003cEvaluated\u003c'_\u003e\u003e for bool {\n    type Error = Error;\n\n    fn try_from(e: Evaluated\u003c'_\u003e) -\u003e Result\u003cbool\u003e {\n        match e {\n            Evaluated::Literal(Literal::Boolean(v)) =\u003e Ok(v),\n            Evaluated::Literal(v) =\u003e {\n                Err(EvaluateError::BooleanTypeRequired(format!(\"{:?}\", v)).into())\n            }\n            Evaluated::StrSlice { source, range } =\u003e {\n                Err(EvaluateError::BooleanTypeRequired(source[range].to_owned()).into())\n            }\n            Evaluated::Value(Value::Bool(v)) =\u003e Ok(v),\n            Evaluated::Value(v) =\u003e {\n                Err(EvaluateError::BooleanTypeRequired(format!(\"{:?}\", v)).into())\n            }\n        }\n    }\n}\n\nimpl TryFrom\u003cEvaluated\u003c'_\u003e\u003e for HashMap\u003cString, Value\u003e {\n    type Error = Error;\n\n    fn try_from(evaluated: Evaluated\u003c'_\u003e) -\u003e Result\u003cHashMap\u003cString, Value\u003e\u003e {\n        match evaluated {\n            Evaluated::Literal(Literal::Text(v)) =\u003e HashMap::parse_json_object(v.as_ref()),\n            Evaluated::Literal(v) =\u003e {\n                Err(EvaluateError::TextLiteralRequired(format!(\"{v:?}\")).into())\n            }\n            Evaluated::Value(Value::Str(v)) =\u003e HashMap::parse_json_object(v.as_str()),\n            Evaluated::Value(Value::Map(v)) =\u003e Ok(v),\n            Evaluated::Value(v) =\u003e Err(EvaluateError::MapOrStringValueRequired(v.into()).into()),\n            Evaluated::StrSlice { source, range } =\u003e HashMap::parse_json_object(\u0026source[range]),\n        }\n    }\n}\n\nfn binary_op\u003c'a, 'b, T, U\u003e(\n    l: \u0026Evaluated\u003c'a\u003e,\n    r: \u0026Evaluated\u003c'b\u003e,\n    op: BinaryOperator,\n    value_op: T,\n    literal_op: U,\n) -\u003e Result\u003cEvaluated\u003c'b\u003e\u003e\nwhere\n    T: FnOnce(\u0026Value, \u0026Value) -\u003e Result\u003cValue\u003e,\n    U: FnOnce(\u0026Literal\u003c'a\u003e, \u0026Literal\u003c'b\u003e) -\u003e Result\u003cLiteral\u003c'b\u003e\u003e,\n{\n    match (l, r) {\n        (Evaluated::Literal(l), Evaluated::Literal(r)) =\u003e literal_op(l, r).map(Evaluated::Literal),\n        (Evaluated::Literal(l), Evaluated::Value(r)) =\u003e {\n            value_op(\u0026Value::try_from(l)?, r).map(Evaluated::Value)\n        }\n        (Evaluated::Value(l), Evaluated::Literal(r)) =\u003e {\n            value_op(l, \u0026Value::try_from(r)?).map(Evaluated::Value)\n        }\n        (Evaluated::Value(l), Evaluated::Value(r)) =\u003e value_op(l, r).map(Evaluated::Value),\n        (l, r) =\u003e Err(EvaluateError::UnsupportedBinaryOperation {\n            left: format!(\"{:?}\", l),\n            op,\n            right: format!(\"{:?}\", r),\n        }\n        .into()),\n    }\n}\n\npub fn exceptional_int_val_to_eval\u003c'a\u003e(name: String, v: Value) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n    match v {\n        Value::Null =\u003e Ok(Evaluated::Value(Value::Null)),\n        _ =\u003e Err(EvaluateError::FunctionRequiresIntegerValue(name).into()),\n    }\n}\n\nimpl\u003c'a\u003e Evaluated\u003c'a\u003e {\n    pub fn evaluate_eq(\u0026self, other: \u0026Evaluated\u003c'a\u003e) -\u003e bool {\n        match (self, other) {\n            (Evaluated::Literal(a), Evaluated::Literal(b)) =\u003e a.evaluate_eq(b),\n            (Evaluated::Literal(b), Evaluated::Value(a))\n            | (Evaluated::Value(a), Evaluated::Literal(b)) =\u003e a.evaluate_eq_with_literal(b),\n            (Evaluated::Value(a), Evaluated::Value(b)) =\u003e a.evaluate_eq(b),\n            (Evaluated::Literal(a), Evaluated::StrSlice { source, range })\n            | (Evaluated::StrSlice { source, range }, Evaluated::Literal(a)) =\u003e {\n                let b = \u0026source[range.clone()];\n\n                a.evaluate_eq(\u0026Literal::Text(Cow::Borrowed(b)))\n            }\n            (Evaluated::Value(a), Evaluated::StrSlice { source, range })\n            | (Evaluated::StrSlice { source, range }, Evaluated::Value(a)) =\u003e {\n                let b = \u0026source[range.clone()];\n\n                a.evaluate_eq_with_literal(\u0026Literal::Text(Cow::Borrowed(b)))\n            }\n            (\n                Evaluated::StrSlice { source, range },\n                Evaluated::StrSlice {\n                    source: source2,\n                    range: range2,\n                },\n            ) =\u003e source[range.clone()] == source2[range2.clone()],\n        }\n    }\n\n    pub fn evaluate_cmp(\u0026self, other: \u0026Evaluated\u003c'a\u003e) -\u003e Option\u003cOrdering\u003e {\n        match (self, other) {\n            (Evaluated::Literal(l), Evaluated::Literal(r)) =\u003e l.evaluate_cmp(r),\n            (Evaluated::Literal(l), Evaluated::Value(r)) =\u003e {\n                r.evaluate_cmp_with_literal(l).map(|o| o.reverse())\n            }\n            (Evaluated::Value(l), Evaluated::Literal(r)) =\u003e l.evaluate_cmp_with_literal(r),\n            (Evaluated::Value(l), Evaluated::Value(r)) =\u003e l.evaluate_cmp(r),\n            (Evaluated::Literal(l), Evaluated::StrSlice { source, range }) =\u003e {\n                let r = Literal::Text(Cow::Borrowed(\u0026source[range.clone()]));\n\n                l.evaluate_cmp(\u0026r)\n            }\n            (Evaluated::Value(l), Evaluated::StrSlice { source, range }) =\u003e {\n                let r = Literal::Text(Cow::Borrowed(\u0026source[range.clone()]));\n\n                l.evaluate_cmp_with_literal(\u0026r)\n            }\n            (Evaluated::StrSlice { source, range }, Evaluated::Literal(l)) =\u003e {\n                let r = Literal::Text(Cow::Borrowed(\u0026source[range.clone()]));\n\n                l.evaluate_cmp(\u0026r).map(|o| o.reverse())\n            }\n            (Evaluated::StrSlice { source, range }, Evaluated::Value(r)) =\u003e {\n                let l = Literal::Text(Cow::Borrowed(\u0026source[range.clone()]));\n\n                r.evaluate_cmp_with_literal(\u0026l).map(|o| o.reverse())\n            }\n            (\n                Evaluated::StrSlice {\n                    source: a,\n                    range: ar,\n                },\n                Evaluated::StrSlice {\n                    source: b,\n                    range: br,\n                },\n            ) =\u003e a[ar.clone()].partial_cmp(\u0026b[br.clone()]),\n        }\n    }\n\n    pub fn add\u003c'b\u003e(\u0026'a self, other: \u0026Evaluated\u003c'b\u003e) -\u003e Result\u003cEvaluated\u003c'b\u003e\u003e {\n        binary_op(\n            self,\n            other,\n            BinaryOperator::Plus,\n            |l, r| l.add(r),\n            |l, r| l.add(r),\n        )\n    }\n\n    pub fn subtract\u003c'b\u003e(\u0026'a self, other: \u0026Evaluated\u003c'b\u003e) -\u003e Result\u003cEvaluated\u003c'b\u003e\u003e {\n        binary_op(\n            self,\n            other,\n            BinaryOperator::Minus,\n            |l, r| l.subtract(r),\n            |l, r| l.subtract(r),\n        )\n    }\n\n    pub fn multiply\u003c'b\u003e(\u0026'a self, other: \u0026Evaluated\u003c'b\u003e) -\u003e Result\u003cEvaluated\u003c'b\u003e\u003e {\n        binary_op(\n            self,\n            other,\n            BinaryOperator::Multiply,\n            |l, r| l.multiply(r),\n            |l, r| l.multiply(r),\n        )\n    }\n\n    pub fn divide\u003c'b\u003e(\u0026'a self, other: \u0026Evaluated\u003c'b\u003e) -\u003e Result\u003cEvaluated\u003c'b\u003e\u003e {\n        binary_op(\n            self,\n            other,\n            BinaryOperator::Divide,\n            |l, r| l.divide(r),\n            |l, r| l.divide(r),\n        )\n    }\n\n    pub fn bitwise_and\u003c'b\u003e(\u0026'a self, other: \u0026Evaluated\u003c'b\u003e) -\u003e Result\u003cEvaluated\u003c'b\u003e\u003e {\n        binary_op(\n            self,\n            other,\n            BinaryOperator::BitwiseAnd,\n            |l, r| l.bitwise_and(r),\n            |l, r| l.bitwise_and(r),\n        )\n    }\n\n    pub fn modulo\u003c'b\u003e(\u0026'a self, other: \u0026Evaluated\u003c'b\u003e) -\u003e Result\u003cEvaluated\u003c'b\u003e\u003e {\n        binary_op(\n            self,\n            other,\n            BinaryOperator::Modulo,\n            |l, r| l.modulo(r),\n            |l, r| l.modulo(r),\n        )\n    }\n\n    pub fn bitwise_shift_left\u003c'b\u003e(\u0026'a self, other: \u0026Evaluated\u003c'b\u003e) -\u003e Result\u003cEvaluated\u003c'b\u003e\u003e {\n        binary_op(\n            self,\n            other,\n            BinaryOperator::BitwiseShiftLeft,\n            |l, r| l.bitwise_shift_left(r),\n            |l, r| l.bitwise_shift_left(r),\n        )\n    }\n\n    pub fn bitwise_shift_right\u003c'b\u003e(\u0026'a self, other: \u0026Evaluated\u003c'b\u003e) -\u003e Result\u003cEvaluated\u003c'b\u003e\u003e {\n        binary_op(\n            self,\n            other,\n            BinaryOperator::BitwiseShiftRight,\n            |l, r| l.bitwise_shift_right(r),\n            |l, r| l.bitwise_shift_right(r),\n        )\n    }\n\n    pub fn unary_plus(\u0026self) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n        match self {\n            Evaluated::Literal(v) =\u003e v.unary_plus().map(Evaluated::Literal),\n            Evaluated::Value(v) =\u003e v.unary_plus().map(Evaluated::Value),\n            Evaluated::StrSlice { source, range } =\u003e {\n                Err(EvaluateError::UnsupportedUnaryPlus(source[range.clone()].to_owned()).into())\n            }\n        }\n    }\n\n    pub fn unary_minus(\u0026self) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n        match self {\n            Evaluated::Literal(v) =\u003e v.unary_minus().map(Evaluated::Literal),\n            Evaluated::Value(v) =\u003e v.unary_minus().map(Evaluated::Value),\n            Evaluated::StrSlice { source, range } =\u003e {\n                Err(EvaluateError::UnsupportedUnaryMinus(source[range.clone()].to_owned()).into())\n            }\n        }\n    }\n\n    pub fn unary_factorial(\u0026self) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n        match self {\n            Evaluated::Literal(v) =\u003e Value::try_from(v).and_then(|v| v.unary_factorial()),\n            Evaluated::Value(v) =\u003e v.unary_factorial(),\n            Evaluated::StrSlice { source, range } =\u003e Err(EvaluateError::UnsupportedUnaryFactorial(\n                source[range.clone()].to_owned(),\n            )\n            .into()),\n        }\n        .map(Evaluated::Value)\n    }\n\n    pub fn unary_bitwise_not(\u0026self) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n        match self {\n            Evaluated::Literal(v) =\u003e Value::try_from(v).and_then(|v| v.unary_bitwise_not()),\n            Evaluated::Value(v) =\u003e v.unary_bitwise_not(),\n            Evaluated::StrSlice { source, range } =\u003e {\n                Err(EvaluateError::IncompatibleUnaryBitwiseNotOperation(\n                    source[range.clone()].to_owned(),\n                )\n                .into())\n            }\n        }\n        .map(Evaluated::Value)\n    }\n\n    pub fn cast(self, data_type: \u0026DataType) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n        match self {\n            Evaluated::Literal(literal) =\u003e Value::try_cast_from_literal(data_type, \u0026literal),\n            Evaluated::Value(value) =\u003e value.cast(data_type),\n            Evaluated::StrSlice { source, range } =\u003e {\n                Value::Str(source[range].to_owned()).cast(data_type)\n            }\n        }\n        .map(Evaluated::Value)\n    }\n\n    pub fn concat(self, other: Evaluated) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n        let evaluated = match (self, other) {\n            (Evaluated::Literal(l), Evaluated::Literal(r)) =\u003e Evaluated::Literal(l.concat(r)),\n            (Evaluated::Literal(l), Evaluated::Value(r)) =\u003e {\n                Evaluated::Value((Value::try_from(l)?).concat(r))\n            }\n            (Evaluated::Value(l), Evaluated::Literal(r)) =\u003e {\n                Evaluated::Value(l.concat(Value::try_from(r)?))\n            }\n            (Evaluated::Value(l), Evaluated::Value(r)) =\u003e Evaluated::Value(l.concat(r)),\n            (Evaluated::Literal(l), Evaluated::StrSlice { source, range }) =\u003e {\n                Evaluated::Value((Value::try_from(l)?).concat(Value::Str(source[range].to_owned())))\n            }\n            (Evaluated::Value(l), Evaluated::StrSlice { source, range }) =\u003e {\n                Evaluated::Value(l.concat(Value::Str(source[range].to_owned())))\n            }\n            (Evaluated::StrSlice { source, range }, Evaluated::Literal(r)) =\u003e {\n                Evaluated::Value(Value::Str(source[range].to_owned()).concat(Value::try_from(r)?))\n            }\n            (Evaluated::StrSlice { source, range }, Evaluated::Value(r)) =\u003e {\n                Evaluated::Value(Value::Str(source[range].to_owned()).concat(r))\n            }\n            (\n                Evaluated::StrSlice {\n                    source: a,\n                    range: ar,\n                },\n                Evaluated::StrSlice {\n                    source: b,\n                    range: br,\n                },\n            ) =\u003e {\n                Evaluated::Value(Value::Str(a[ar].to_owned()).concat(Value::Str(b[br].to_owned())))\n            }\n        };\n\n        Ok(evaluated)\n    }\n\n    pub fn like(\u0026self, other: Evaluated\u003c'a\u003e, case_sensitive: bool) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n        let evaluated = match (self, other) {\n            (Evaluated::Literal(l), Evaluated::Literal(r)) =\u003e {\n                Evaluated::Literal(l.like(\u0026r, case_sensitive)?)\n            }\n            (Evaluated::Literal(l), Evaluated::Value(r)) =\u003e {\n                Evaluated::Value((Value::try_from(l)?).like(\u0026r, case_sensitive)?)\n            }\n            (Evaluated::Value(l), Evaluated::Literal(r)) =\u003e {\n                Evaluated::Value(l.like(\u0026Value::try_from(r)?, case_sensitive)?)\n            }\n            (Evaluated::Value(l), Evaluated::Value(r)) =\u003e {\n                Evaluated::Value(l.like(\u0026r, case_sensitive)?)\n            }\n            (Evaluated::Literal(l), Evaluated::StrSlice { source, range }) =\u003e Evaluated::Value(\n                Value::try_from(l)?.like(\u0026Value::Str(source[range].to_owned()), case_sensitive)?,\n            ),\n            (Evaluated::StrSlice { source, range }, Evaluated::Literal(r)) =\u003e Evaluated::Value(\n                Value::Str(source[range.clone()].to_owned())\n                    .like(\u0026Value::try_from(r)?, case_sensitive)?,\n            ),\n            (\n                Evaluated::StrSlice {\n                    source: a,\n                    range: ar,\n                },\n                Evaluated::StrSlice {\n                    source: b,\n                    range: br,\n                },\n            ) =\u003e Evaluated::Value(\n                Value::Str(a[ar.clone()].to_owned())\n                    .like(\u0026Value::Str(b[br].to_owned()), case_sensitive)?,\n            ),\n            (Evaluated::StrSlice { source, range }, Evaluated::Value(r)) =\u003e Evaluated::Value(\n                Value::Str(source[range.clone()].to_owned()).like(\u0026r, case_sensitive)?,\n            ),\n            (Evaluated::Value(l), Evaluated::StrSlice { source, range }) =\u003e {\n                Evaluated::Value(l.like(\u0026Value::Str(source[range].to_owned()), case_sensitive)?)\n            }\n        };\n\n        Ok(evaluated)\n    }\n\n    pub fn ltrim(self, name: String, chars: Option\u003cEvaluated\u003c'_\u003e\u003e) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n        let (source, range) = match self {\n            Evaluated::Literal(Literal::Text(l)) =\u003e {\n                let end = l.len();\n                (l, 0..end)\n            }\n            Evaluated::Literal(Literal::Null) | Evaluated::Value(Value::Null) =\u003e {\n                return Ok(Evaluated::Value(Value::Null));\n            }\n            Evaluated::StrSlice { source, range } =\u003e (source, range),\n            Evaluated::Value(Value::Str(v)) =\u003e {\n                let end = v.len();\n                (Cow::Owned(v), 0..end)\n            }\n            _ =\u003e return Err(EvaluateError::FunctionRequiresStringValue(name).into()),\n        };\n\n        let filter_chars = match chars {\n            Some(expr) =\u003e match expr.try_into()? {\n                Value::Str(value) =\u003e value,\n                Value::Null =\u003e {\n                    return Ok(Evaluated::Value(Value::Null));\n                }\n                _ =\u003e {\n                    return Err(EvaluateError::FunctionRequiresStringValue(name).into());\n                }\n            }\n            .chars()\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n            None =\u003e vec![' '],\n        };\n        let sliced_expr = \u0026source[range.clone()];\n        let matched_vec: Vec\u003c_\u003e = sliced_expr.match_indices(\u0026filter_chars[..]).collect();\n\n        //\"x\".trim_start_matches(['x','y','z']) =\u003e \"\"\n        if matched_vec.len() == sliced_expr.len() {\n            return Ok(Evaluated::StrSlice {\n                source,\n                range: 0..0,\n            });\n        }\n        //\"tuv\".trim_start_matches(['x','y','z']) =\u003e \"tuv\"\n        if matched_vec.is_empty() {\n            return Ok(Evaluated::StrSlice { source, range });\n        }\n        //\"txu\".trim_start_matches(['x','y','z']) =\u003e \"txu\"\n        if matched_vec[0].0 != 0 \u0026\u0026 matched_vec[matched_vec.len() - 1].0 != sliced_expr.len() - 1 {\n            return Ok(Evaluated::StrSlice { source, range });\n        }\n        let pivot = matched_vec\n            .iter()\n            .enumerate()\n            .skip_while(|(vec_idx, (slice_idx, _))| vec_idx == slice_idx)\n            .map(|(vec_idx, (_, _))| vec_idx)\n            .next();\n\n        let start = match pivot {\n            Some(idx) =\u003e match idx {\n                0 =\u003e 0,\n                _ =\u003e matched_vec[idx - 1].0 + 1,\n            },\n            _ =\u003e matched_vec[matched_vec.len() - 1].0 + 1,\n        };\n\n        Ok(Evaluated::StrSlice {\n            source,\n            range: range.start + start..range.end,\n        })\n    }\n\n    pub fn is_null(\u0026self) -\u003e bool {\n        match self {\n            Evaluated::Value(v) =\u003e v.is_null(),\n            Evaluated::StrSlice { .. } =\u003e false,\n            Evaluated::Literal(v) =\u003e matches!(v, \u0026Literal::Null),\n        }\n    }\n\n    pub fn rtrim(self, name: String, chars: Option\u003cEvaluated\u003c'_\u003e\u003e) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n        let (source, range) = match self {\n            Evaluated::Literal(Literal::Text(l)) =\u003e {\n                let end = l.len();\n                (l, 0..end)\n            }\n            Evaluated::Literal(Literal::Null) | Evaluated::Value(Value::Null) =\u003e {\n                return Ok(Evaluated::Value(Value::Null));\n            }\n            Evaluated::StrSlice { source, range } =\u003e (source, range),\n            Evaluated::Value(Value::Str(v)) =\u003e {\n                let end = v.len();\n                (Cow::Owned(v), 0..end)\n            }\n            _ =\u003e return Err(EvaluateError::FunctionRequiresStringValue(name).into()),\n        };\n\n        let filter_chars = match chars {\n            Some(expr) =\u003e match expr.try_into()? {\n                Value::Str(value) =\u003e value,\n                Value::Null =\u003e {\n                    return Ok(Evaluated::Value(Value::Null));\n                }\n                _ =\u003e {\n                    return Err(EvaluateError::FunctionRequiresStringValue(name).into());\n                }\n            }\n            .chars()\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n            None =\u003e vec![' '],\n        };\n        let sliced_expr = \u0026source[range.clone()];\n        let matched_vec: Vec\u003c_\u003e = sliced_expr.match_indices(\u0026filter_chars[..]).collect();\n\n        //\"x\".trim_end_matches(['x','y','z']) =\u003e \"\"\n        if matched_vec.len() == sliced_expr.len() {\n            return Ok(Evaluated::StrSlice {\n                source,\n                range: 0..0,\n            });\n        }\n        //\"tuv\".trim_end_matches(['x','y','z']) =\u003e \"tuv\"\n        if matched_vec.is_empty() {\n            return Ok(Evaluated::StrSlice { source, range });\n        }\n        //\"txu\".trim_end_matches(['x','y','z']) =\u003e \"txu\"\n        if matched_vec[0].0 != 0 \u0026\u0026 matched_vec[matched_vec.len() - 1].0 != sliced_expr.len() - 1 {\n            return Ok(Evaluated::StrSlice { source, range });\n        }\n\n        let pivot = matched_vec\n            .iter()\n            .rev()\n            .enumerate()\n            .skip_while(|(vec_idx, (slice_idx, _))| *vec_idx == sliced_expr.len() - slice_idx - 1)\n            .map(|(vec_idx, (_, _))| vec_idx)\n            .next();\n\n        let end = match pivot {\n            Some(idx) =\u003e match idx {\n                0 =\u003e range.end,\n                _ =\u003e matched_vec[matched_vec.len() - idx].0,\n            },\n            _ =\u003e matched_vec[0].0,\n        };\n\n        Ok(Evaluated::StrSlice {\n            source,\n            range: range.start..end,\n        })\n    }\n\n    pub fn substr(\n        self,\n        name: String,\n        start: Evaluated\u003c'a\u003e,\n        count: Option\u003cEvaluated\u003c'a\u003e\u003e,\n    ) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n        let (source, range) = match self {\n            Evaluated::Literal(Literal::Text(l)) =\u003e {\n                let end = l.len();\n                (l, 0..end)\n            }\n            Evaluated::Literal(Literal::Null) | Evaluated::Value(Value::Null) =\u003e {\n                return Ok(Evaluated::Value(Value::Null));\n            }\n            Evaluated::StrSlice { source, range } =\u003e (source, range),\n            Evaluated::Value(Value::Str(v)) =\u003e {\n                let end = v.len();\n                (Cow::Owned(v), 0..end)\n            }\n            _ =\u003e return Err(EvaluateError::FunctionRequiresStringValue(name).into()),\n        };\n\n        let start = {\n            let value = start.try_into()?;\n            match value {\n                Value::I64(num) =\u003e num,\n                _ =\u003e return exceptional_int_val_to_eval(name, value),\n            }\n        } - 1;\n\n        let count = match count {\n            Some(eval) =\u003e {\n                let value = eval.try_into()?;\n                match value {\n                    Value::I64(num) =\u003e num,\n                    _ =\u003e return exceptional_int_val_to_eval(name, value),\n                }\n            }\n            None =\u003e source.len() as i64,\n        };\n\n        let end = if count \u003c 0 {\n            return Err(EvaluateError::NegativeSubstrLenNotAllowed.into());\n        } else {\n            (range.start as i64 + start + count).clamp(0, source.len() as i64) as usize\n        };\n\n        let start = (start + range.start as i64).clamp(0, source.len() as i64) as usize;\n\n        Ok(Evaluated::StrSlice {\n            source,\n            range: start..end,\n        })\n    }\n\n    pub fn trim(\n        self,\n        name: String,\n        filter_chars: Option\u003cEvaluated\u003c'_\u003e\u003e,\n        trim_where_field: \u0026Option\u003cTrimWhereField\u003e,\n    ) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n        let (source, range) = match self {\n            Evaluated::Literal(Literal::Text(l)) =\u003e {\n                let end = l.len();\n                (l, 0..end)\n            }\n            Evaluated::Literal(Literal::Null) | Evaluated::Value(Value::Null) =\u003e {\n                return Ok(Evaluated::Value(Value::Null));\n            }\n            Evaluated::StrSlice { source, range } =\u003e (source, range),\n            Evaluated::Value(Value::Str(v)) =\u003e {\n                let end = v.len();\n                (Cow::Owned(v), 0..end)\n            }\n            _ =\u003e return Err(EvaluateError::FunctionRequiresStringValue(name).into()),\n        };\n\n        let filter_chars = match filter_chars {\n            Some(expr) =\u003e match expr.try_into()? {\n                Value::Str(value) =\u003e value,\n                Value::Null =\u003e {\n                    return Ok(Evaluated::Value(Value::Null));\n                }\n                _ =\u003e {\n                    return Err(EvaluateError::FunctionRequiresStringValue(name).into());\n                }\n            }\n            .chars()\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n            None =\u003e vec![' '],\n        };\n        let sliced_expr = \u0026source[range.clone()];\n        let matched_vec: Vec\u003c_\u003e = sliced_expr.match_indices(\u0026filter_chars[..]).collect();\n        //filter_chars =\u003e ['x','y','z']\n        //\"x\".trim_matches(filter_chars[..]) =\u003e \"\"\n        if matched_vec.len() == sliced_expr.len() {\n            return Ok(Evaluated::StrSlice {\n                source,\n                range: 0..0,\n            });\n        }\n        //filter_chars =\u003e ['x','y','z']\n        //\"tuv\".trim_matches(filter_chars[..]) =\u003e \"tuv\"\n        if matched_vec.is_empty() {\n            return Ok(Evaluated::StrSlice { source, range });\n        }\n        //filter_chars =\u003e ['x','y','z']\n        //\"txu\".trim_matches(filter_chars[..]) =\u003e \"txu\"\n        if matched_vec[0].0 != 0 \u0026\u0026 matched_vec[matched_vec.len() - 1].0 != sliced_expr.len() - 1 {\n            return Ok(Evaluated::StrSlice { source, range });\n        }\n        match trim_where_field {\n            Some(TrimWhereField::Both) =\u003e {\n                //filter_chars =\u003e ['x','y','z']\n                //\"xyzbyxlxyz  \".trim_matches(filter_chars[..]) =\u003e \"byxlxyz  \"\n                if matched_vec[0].0 == 0\n                    \u0026\u0026 matched_vec[matched_vec.len() - 1].0 != sliced_expr.len() - 1\n                {\n                    let pivot = matched_vec\n                        .iter()\n                        .enumerate()\n                        .skip_while(|(vec_idx, (slice_idx, _))| vec_idx == slice_idx)\n                        .map(|(vec_idx, (_, _))| vec_idx)\n                        .next();\n\n                    let start = match pivot {\n                        Some(idx) =\u003e matched_vec[idx - 1].0 + 1,\n                        _ =\u003e matched_vec[matched_vec.len() - 1].0 + 1,\n                    };\n\n                    return Ok(Evaluated::StrSlice {\n                        source,\n                        range: range.start + start..range.end,\n                    });\n                }\n                //filter_chars =\u003e ['x','y','z']\n                //\"  xyzblankxyzxx\".trim_matches(filter_chars[..]) =\u003e \"  xyzblank\"\n                if matched_vec[0].0 != 0\n                    \u0026\u0026 matched_vec[matched_vec.len() - 1].0 == sliced_expr.len() - 1\n                {\n                    let pivot = matched_vec\n                        .iter()\n                        .rev()\n                        .enumerate()\n                        .skip_while(|(vec_idx, (slice_idx, _))| {\n                            *vec_idx == sliced_expr.len() - slice_idx - 1\n                        })\n                        .map(|(vec_idx, (_, _))| vec_idx)\n                        .next();\n\n                    let end = match pivot {\n                        Some(idx) =\u003e matched_vec[matched_vec.len() - idx].0,\n                        _ =\u003e matched_vec[0].0,\n                    };\n\n                    return Ok(Evaluated::StrSlice {\n                        source,\n                        range: range.start..end,\n                    });\n                }\n                //filter_chars =\u003e ['x','y','z']\n                //\"xxbyz\".trim_matches(filter_chars[..]) =\u003e \"b\"\n                let pivot = matched_vec\n                    .iter()\n                    .enumerate()\n                    .skip_while(|(vec_idx, (slice_idx, _))| vec_idx == slice_idx)\n                    .map(|(vec_idx, (_, _))| vec_idx)\n                    .next()\n                    .unwrap_or(0);\n\n                let trim_range = matched_vec[pivot - 1].0..(matched_vec[pivot].0 + range.start);\n\n                Ok(Evaluated::StrSlice {\n                    source,\n                    range: range.start + trim_range.start + 1..trim_range.end,\n                })\n            }\n            Some(TrimWhereField::Leading) =\u003e {\n                let pivot = matched_vec\n                    .iter()\n                    .enumerate()\n                    .skip_while(|(vec_idx, (slice_idx, _))| vec_idx == slice_idx)\n                    .map(|(vec_idx, (_, _))| vec_idx)\n                    .next();\n\n                let start = match pivot {\n                    Some(idx) =\u003e match idx {\n                        0 =\u003e 0,\n                        _ =\u003e matched_vec[idx - 1].0 + 1,\n                    },\n                    _ =\u003e matched_vec[matched_vec.len() - 1].0 + 1,\n                };\n\n                Ok(Evaluated::StrSlice {\n                    source,\n                    range: range.start + start..range.end,\n                })\n            }\n            Some(TrimWhereField::Trailing) =\u003e {\n                let pivot = matched_vec\n                    .iter()\n                    .rev()\n                    .enumerate()\n                    .skip_while(|(vec_idx, (slice_idx, _))| {\n                        *vec_idx == sliced_expr.len() - slice_idx - 1\n                    })\n                    .map(|(vec_idx, (_, _))| vec_idx)\n                    .next();\n\n                let end = match pivot {\n                    Some(idx) =\u003e match idx {\n                        0 =\u003e range.end,\n                        _ =\u003e matched_vec[matched_vec.len() - idx].0,\n                    },\n                    _ =\u003e matched_vec[0].0,\n                };\n\n                Ok(Evaluated::StrSlice {\n                    source,\n                    range: range.start..end,\n                })\n            }\n            None =\u003e {\n                let start = source\n                    .chars()\n                    .skip(range.start)\n                    .enumerate()\n                    .find(|(_, c)| !c.is_whitespace())\n                    .map(|(idx, _)| idx + range.start)\n                    .unwrap_or(0);\n\n                let end = source.len()\n                    - source\n                        .chars()\n                        .rev()\n                        .skip(source.len() - range.end)\n                        .enumerate()\n                        .find(|(_, c)| !c.is_whitespace())\n                        .map(|(idx, _)| source.len() - (range.end - idx))\n                        .unwrap_or(0);\n\n                Ok(Evaluated::StrSlice {\n                    source,\n                    range: start..end,\n                })\n            }\n        }\n    }\n\n    pub fn try_into_value(self, data_type: \u0026DataType, nullable: bool) -\u003e Result\u003cValue\u003e {\n        let value = match self {\n            Evaluated::Literal(v) =\u003e Value::try_from_literal(data_type, \u0026v)?,\n            Evaluated::Value(v) =\u003e v,\n            Evaluated::StrSlice {\n                source: s,\n                range: r,\n            } =\u003e Value::Str(s[r].to_owned()),\n        };\n\n        value.validate_null(nullable)?;\n\n        Ok(value)\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":462},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","evaluate","expr.rs"],"content":"use {\n    super::{EvaluateError, Evaluated},\n    crate::{\n        ast::{AstLiteral, BinaryOperator, DataType, UnaryOperator},\n        data::{Literal, Value},\n        result::Result,\n    },\n    std::{borrow::Cow, cmp::Ordering},\n};\n\npub fn literal(ast_literal: \u0026AstLiteral) -\u003e Result\u003cEvaluated\u003c'_\u003e\u003e {\n    Literal::try_from(ast_literal).map(Evaluated::Literal)\n}\n\npub fn typed_string\u003c'a\u003e(data_type: \u0026'a DataType, value: Cow\u003c'a, str\u003e) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n    let literal = Literal::Text(value);\n\n    Value::try_from_literal(data_type, \u0026literal).map(Evaluated::Value)\n}\n\npub fn binary_op\u003c'a\u003e(\n    op: \u0026BinaryOperator,\n    l: Evaluated\u003c'a\u003e,\n    r: Evaluated\u003c'a\u003e,\n) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n    macro_rules! cmp {\n        ($expr: expr) =\u003e {\n            Ok(Evaluated::Value(Value::Bool($expr)))\n        };\n    }\n\n    macro_rules! cond {\n        (l $op: tt r) =\u003e {{\n            let l: bool = l.try_into()?;\n            let r: bool = r.try_into()?;\n            let v = l $op r;\n\n            Ok(Evaluated::Value(Value::Bool(v)))\n        }};\n    }\n\n    match op {\n        BinaryOperator::Plus =\u003e l.add(\u0026r),\n        BinaryOperator::Minus =\u003e l.subtract(\u0026r),\n        BinaryOperator::Multiply =\u003e l.multiply(\u0026r),\n        BinaryOperator::Divide =\u003e l.divide(\u0026r),\n        BinaryOperator::Modulo =\u003e l.modulo(\u0026r),\n        BinaryOperator::StringConcat =\u003e l.concat(r),\n        BinaryOperator::Eq =\u003e cmp!(l.evaluate_eq(\u0026r)),\n        BinaryOperator::NotEq =\u003e cmp!(!l.evaluate_eq(\u0026r)),\n        BinaryOperator::Lt =\u003e cmp!(l.evaluate_cmp(\u0026r) == Some(Ordering::Less)),\n        BinaryOperator::LtEq =\u003e cmp!(matches!(\n            l.evaluate_cmp(\u0026r),\n            Some(Ordering::Less) | Some(Ordering::Equal)\n        )),\n        BinaryOperator::Gt =\u003e cmp!(l.evaluate_cmp(\u0026r) == Some(Ordering::Greater)),\n        BinaryOperator::GtEq =\u003e cmp!(matches!(\n            l.evaluate_cmp(\u0026r),\n            Some(Ordering::Greater) | Some(Ordering::Equal)\n        )),\n        BinaryOperator::And =\u003e cond!(l \u0026\u0026 r),\n        BinaryOperator::Or =\u003e cond!(l || r),\n        BinaryOperator::Xor =\u003e cond!(l ^ r),\n        BinaryOperator::BitwiseAnd =\u003e l.bitwise_and(\u0026r),\n        BinaryOperator::BitwiseShiftLeft =\u003e l.bitwise_shift_left(\u0026r),\n        BinaryOperator::BitwiseShiftRight =\u003e l.bitwise_shift_right(\u0026r),\n    }\n}\n\npub fn unary_op\u003c'a\u003e(op: \u0026UnaryOperator, v: Evaluated\u003c'a\u003e) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n    match op {\n        UnaryOperator::Plus =\u003e v.unary_plus(),\n        UnaryOperator::Minus =\u003e v.unary_minus(),\n        UnaryOperator::Not =\u003e v\n            .try_into()\n            .map(|v: bool| Evaluated::Value(Value::Bool(!v))),\n        UnaryOperator::Factorial =\u003e v.unary_factorial(),\n        UnaryOperator::BitwiseNot =\u003e v.unary_bitwise_not(),\n    }\n}\n\npub fn between\u003c'a\u003e(\n    target: Evaluated\u003c'a\u003e,\n    negated: bool,\n    low: Evaluated\u003c'a\u003e,\n    high: Evaluated\u003c'a\u003e,\n) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n    let v = low.evaluate_cmp(\u0026target) != Some(Ordering::Greater)\n        \u0026\u0026 target.evaluate_cmp(\u0026high) != Some(Ordering::Greater);\n    let v = negated ^ v;\n\n    Ok(Evaluated::Value(Value::Bool(v)))\n}\n\npub fn array_index\u003c'a\u003e(obj: Evaluated\u003c'a\u003e, indexes: Vec\u003cEvaluated\u003c'a\u003e\u003e) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n    let value = match obj {\n        Evaluated::Value(value) =\u003e value,\n        _ =\u003e return Err(EvaluateError::MapOrListTypeRequired.into()),\n    };\n    let indexes = indexes\n        .into_iter()\n        .map(Value::try_from)\n        .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n    value.selector_by_index(\u0026indexes).map(Evaluated::Value)\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":58},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","evaluate","function.rs"],"content":"use {\n    super::{EvaluateError, Evaluated},\n    crate::{\n        ast::DateTimeField,\n        data::{Key, Point, Value},\n        result::{Error, Result},\n    },\n    chrono::{Datelike, Duration, Months},\n    md5::{Digest, Md5},\n    rand::{Rng, SeedableRng, rngs::StdRng},\n    std::ops::ControlFlow::{self as StdControlFlow, Break, Continue},\n    uuid::Uuid,\n};\n\ntype ControlFlow\u003cT\u003e = std::ops::ControlFlow\u003cBreakCase, T\u003e;\n\npub enum BreakCase {\n    Null,\n    Err(Error),\n}\n\ntrait ContinueOrBreak\u003cT\u003e {\n    fn continue_or_break(self, err: Error) -\u003e ControlFlow\u003cT\u003e;\n}\n\nimpl\u003cT\u003e ContinueOrBreak\u003cT\u003e for Option\u003cT\u003e {\n    fn continue_or_break(self, err: Error) -\u003e ControlFlow\u003cT\u003e {\n        match self {\n            Some(v) =\u003e Continue(v),\n            None =\u003e Break(BreakCase::Err(err)),\n        }\n    }\n}\n\ntrait BreakIfNull\u003cT\u003e {\n    fn break_if_null(self) -\u003e ControlFlow\u003cT\u003e;\n}\n\nimpl\u003c'a\u003e BreakIfNull\u003cEvaluated\u003c'a\u003e\u003e for Result\u003cEvaluated\u003c'a\u003e\u003e {\n    fn break_if_null(self) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n        match self {\n            Err(err) =\u003e Break(BreakCase::Err(err)),\n            Ok(value) if value.is_null() =\u003e Break(BreakCase::Null),\n            Ok(value) =\u003e Continue(value),\n        }\n    }\n}\n\nimpl BreakIfNull\u003cValue\u003e for Result\u003cValue\u003e {\n    fn break_if_null(self) -\u003e ControlFlow\u003cValue\u003e {\n        match self {\n            Err(err) =\u003e Break(BreakCase::Err(err)),\n            Ok(value) if value.is_null() =\u003e Break(BreakCase::Null),\n            Ok(value) =\u003e Continue(value),\n        }\n    }\n}\n\ntrait ControlFlowMap\u003cT, U, F\u003e {\n    fn map(self, f: F) -\u003e ControlFlow\u003cU\u003e\n    where\n        F: FnOnce(T) -\u003e U;\n}\n\nimpl\u003cT, U, F\u003e ControlFlowMap\u003cT, U, F\u003e for ControlFlow\u003cT\u003e {\n    fn map(self, f: F) -\u003e ControlFlow\u003cU\u003e\n    where\n        F: FnOnce(T) -\u003e U,\n    {\n        match self {\n            Continue(v) =\u003e Continue(f(v)),\n            Break(v) =\u003e Break(v),\n        }\n    }\n}\n\ntrait ControlFlowMapErr\u003cT, F\u003e {\n    fn map_err(self, f: F) -\u003e ControlFlow\u003cT\u003e\n    where\n        F: FnOnce(Error) -\u003e Error;\n}\n\nimpl\u003cT, F\u003e ControlFlowMapErr\u003cT, F\u003e for ControlFlow\u003cT\u003e {\n    fn map_err(self, f: F) -\u003e ControlFlow\u003cT\u003e\n    where\n        F: FnOnce(Error) -\u003e Error,\n    {\n        match self {\n            Continue(v) =\u003e Continue(v),\n            Break(BreakCase::Null) =\u003e Break(BreakCase::Null),\n            Break(BreakCase::Err(err)) =\u003e Break(BreakCase::Err(f(err))),\n        }\n    }\n}\n\npub trait IntoControlFlow\u003cT\u003e {\n    fn into_control_flow(self) -\u003e ControlFlow\u003cT\u003e;\n}\n\nimpl\u003cT\u003e IntoControlFlow\u003cT\u003e for Result\u003cT\u003e {\n    fn into_control_flow(self) -\u003e ControlFlow\u003cT\u003e {\n        match self {\n            Err(err) =\u003e Break(BreakCase::Err(err)),\n            Ok(value) =\u003e Continue(value),\n        }\n    }\n}\n\nfn eval_to_str(name: \u0026str, evaluated: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cString\u003e {\n    match evaluated.try_into().break_if_null()? {\n        Value::Str(value) =\u003e Continue(value),\n        _ =\u003e Break(BreakCase::Err(\n            EvaluateError::FunctionRequiresStringValue(name.to_owned()).into(),\n        )),\n    }\n}\n\nfn eval_to_int(name: \u0026str, evaluated: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003ci64\u003e {\n    match evaluated.try_into().break_if_null()? {\n        Value::I64(num) =\u003e Continue(num),\n        _ =\u003e Break(BreakCase::Err(\n            EvaluateError::FunctionRequiresIntegerValue(name.to_owned()).into(),\n        )),\n    }\n}\n\nfn eval_to_float(name: \u0026str, evaluated: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cf64\u003e {\n    match evaluated.try_into().break_if_null()? {\n        Value::I64(v) =\u003e Continue(v as f64),\n        Value::F32(v) =\u003e Continue(v.into()),\n        Value::F64(v) =\u003e Continue(v),\n        _ =\u003e Break(BreakCase::Err(\n            EvaluateError::FunctionRequiresFloatValue(name.to_owned()).into(),\n        )),\n    }\n}\n\nfn eval_to_point(name: \u0026str, evaluated: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cPoint\u003e {\n    match evaluated.try_into().break_if_null()? {\n        Value::Point(v) =\u003e Continue(v),\n        _ =\u003e Break(BreakCase::Err(\n            EvaluateError::FunctionRequiresPointValue(name.to_owned()).into(),\n        )),\n    }\n}\n\n// --- text ---\npub fn concat(exprs: Vec\u003cEvaluated\u003c'_\u003e\u003e) -\u003e ControlFlow\u003cEvaluated\u003e {\n    let value = exprs\n        .into_iter()\n        .try_fold(None, |left: Option\u003cEvaluated\u003e, right| match left {\n            None =\u003e Continue(Some(right)),\n            Some(left) =\u003e left.concat(right).break_if_null().map(Some),\n        })?;\n\n    value.continue_or_break(EvaluateError::EmptyArgNotAllowedInConcat.into())\n}\n\npub fn concat_ws\u003c'a\u003e(\n    name: String,\n    separator: Evaluated\u003c'a\u003e,\n    exprs: Vec\u003cEvaluated\u003c'a\u003e\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let separator = eval_to_str(\u0026name, separator)?;\n\n    let result = exprs\n        .into_iter()\n        .map(Value::try_from)\n        .filter(|value| !matches!(value, Ok(Value::Null)))\n        .map(|value| Ok(String::from(value?)))\n        .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n        .into_control_flow()?\n        .join(\u0026separator);\n\n    Continue(Evaluated::Value(Value::Str(result)))\n}\n\npub fn lower(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'_\u003e\u003e {\n    eval_to_str(\u0026name, expr)\n        .map(|value| value.to_lowercase())\n        .map(Value::Str)\n        .map(Evaluated::Value)\n}\n\npub fn initcap(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'_\u003e\u003e {\n    let string = eval_to_str(\u0026name, expr)?\n        .chars()\n        .scan(true, |state, c| {\n            let c = if *state {\n                c.to_ascii_uppercase()\n            } else {\n                c.to_ascii_lowercase()\n            };\n            *state = !c.is_alphanumeric();\n            Some(c)\n        })\n        .collect();\n\n    Continue(Evaluated::Value(Value::Str(string)))\n}\n\npub fn upper(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'_\u003e\u003e {\n    eval_to_str(\u0026name, expr)\n        .map(|value| value.to_uppercase())\n        .map(Value::Str)\n        .map(Evaluated::Value)\n}\n\npub fn left_or_right\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    size: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let string = eval_to_str(\u0026name, expr)?;\n    let size = eval_to_int(\u0026name, size)\n        .map(usize::try_from)?\n        .map_err(|_| EvaluateError::FunctionRequiresUSizeValue(name.clone()).into())\n        .into_control_flow()?;\n\n    let converted = if name == \"LEFT\" {\n        string.get(..size).map(|v| v.to_owned()).unwrap_or(string)\n    } else {\n        let start_pos = if size \u003e string.len() {\n            0\n        } else {\n            string.len() - size\n        };\n\n        string\n            .get(start_pos..)\n            .map(|value| value.to_owned())\n            .unwrap_or(string)\n    };\n\n    Continue(Evaluated::Value(Value::Str(converted)))\n}\n\npub fn lpad_or_rpad\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    size: Evaluated\u003c'_\u003e,\n    fill: Option\u003cEvaluated\u003c'_\u003e\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let string = eval_to_str(\u0026name, expr)?;\n    let size = eval_to_int(\u0026name, size)\n        .map(usize::try_from)?\n        .map_err(|_| EvaluateError::FunctionRequiresUSizeValue(name.clone()).into())\n        .into_control_flow()?;\n\n    let fill = match fill {\n        Some(expr) =\u003e eval_to_str(\u0026name, expr)?,\n        None =\u003e \" \".to_owned(),\n    };\n\n    let result = if size \u003e string.len() {\n        let padding_size = size - string.len();\n        let repeat_count = padding_size / fill.len();\n        let plus_count = padding_size % fill.len();\n        let fill = fill.repeat(repeat_count) + \u0026fill[0..plus_count];\n\n        if name == \"LPAD\" {\n            fill + \u0026string\n        } else {\n            string + \u0026fill\n        }\n    } else {\n        string[0..size].to_owned()\n    };\n\n    Continue(Evaluated::Value(Value::Str(result)))\n}\n\npub fn reverse(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'_\u003e\u003e {\n    let value = eval_to_str(\u0026name, expr)?.chars().rev().collect::\u003cString\u003e();\n\n    Continue(Evaluated::Value(Value::Str(value)))\n}\n\npub fn repeat\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    num: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let expr = eval_to_str(\u0026name, expr)?;\n    let num = eval_to_int(\u0026name, num)? as usize;\n    let value = expr.repeat(num);\n\n    Continue(Evaluated::Value(Value::Str(value)))\n}\n\npub fn replace\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    old: Evaluated\u003c'_\u003e,\n    new: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let expr = eval_to_str(\u0026name, expr)?;\n    let old = eval_to_str(\u0026name, old)?;\n    let new = eval_to_str(\u0026name, new)?;\n    let value = expr.replace(\u0026old, \u0026new);\n\n    Continue(Evaluated::Value(Value::Str(value)))\n}\n\npub fn ascii\u003c'a\u003e(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let string = eval_to_str(\u0026name, expr)?;\n    let mut iter = string.chars();\n\n    match (iter.next(), iter.next()) {\n        (Some(c), None) =\u003e {\n            if c.is_ascii() {\n                Continue(Evaluated::Value(Value::U8(c as u8)))\n            } else {\n                Err(EvaluateError::NonAsciiCharacterNotAllowed.into()).into_control_flow()\n            }\n        }\n        _ =\u003e {\n            Err(EvaluateError::AsciiFunctionRequiresSingleCharacterValue.into()).into_control_flow()\n        }\n    }\n}\n\npub fn chr\u003c'a\u003e(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let expr = eval_to_int(\u0026name, expr)?;\n\n    match expr {\n        0..=255 =\u003e {\n            let expr = expr as u8;\n\n            Continue(Evaluated::Value(Value::Str((expr as char).to_string())))\n        }\n        _ =\u003e Err(EvaluateError::ChrFunctionRequiresIntegerValueInRange0To255.into())\n            .into_control_flow(),\n    }\n}\n\npub fn md5\u003c'a\u003e(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let string = eval_to_str(\u0026name, expr)?;\n    let mut hasher = Md5::new();\n    hasher.update(string.as_bytes());\n    let result = hasher.finalize();\n    let result = format!(\"{:x}\", result);\n\n    Continue(Evaluated::Value(Value::Str(result)))\n}\n\npub fn hex\u003c'a\u003e(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    match expr.try_into().break_if_null()? {\n        Value::I64(number) =\u003e {\n            let result = format!(\"{number:X}\");\n            Continue(Evaluated::Value(Value::Str(result)))\n        }\n        Value::Str(string) =\u003e {\n            let result = string\n                .as_bytes()\n                .iter()\n                .map(|b| format!(\"{b:02X}\"))\n                .collect::\u003cString\u003e();\n\n            Continue(Evaluated::Value(Value::Str(result)))\n        }\n        _ =\u003e Break(BreakCase::Err(\n            EvaluateError::FunctionRequiresIntegerOrStringValue(name).into(),\n        )),\n    }\n}\n\n// --- float ---\n\npub fn abs\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let value = match n.try_into().break_if_null()? {\n        Value::I8(v) =\u003e Value::I8(v.abs()),\n        Value::I32(v) =\u003e Value::I32(v.abs()),\n        Value::I64(v) =\u003e Value::I64(v.abs()),\n        Value::I128(v) =\u003e Value::I128(v.abs()),\n        Value::Decimal(v) =\u003e Value::Decimal(v.abs()),\n        Value::F32(v) =\u003e Value::F32(v.abs()),\n        Value::F64(v) =\u003e Value::F64(v.abs()),\n        _ =\u003e {\n            return Err(EvaluateError::FunctionRequiresFloatValue(name).into()).into_control_flow();\n        }\n    };\n\n    Continue(Evaluated::Value(value))\n}\n\npub fn ifnull\u003c'a\u003e(expr: Evaluated\u003c'a\u003e, then: Evaluated\u003c'a\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    Continue(match expr.is_null() {\n        true =\u003e then,\n        false =\u003e expr,\n    })\n}\n\npub fn nullif\u003c'a\u003e(expr1: Evaluated\u003c'a\u003e, expr2: Evaluated\u003c'a\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    Continue(match expr1 == expr2 {\n        true =\u003e Evaluated::Value(Value::Null),\n        false =\u003e expr1,\n    })\n}\n\npub fn sign(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'_\u003e\u003e {\n    let x = eval_to_float(\u0026name, n)?;\n    if x == 0.0 {\n        return Continue(Evaluated::Value(Value::I8(0)));\n    }\n\n    Continue(Evaluated::Value(Value::I8(x.signum() as i8)))\n}\n\npub fn sqrt\u003c'a\u003e(n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    Value::try_from(n)\n        .and_then(|v| v.sqrt())\n        .into_control_flow()\n        .map(Evaluated::Value)\n}\n\npub fn power\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    power: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let expr = eval_to_float(\u0026name, expr)?;\n    let power = eval_to_float(\u0026name, power)?;\n\n    Continue(Evaluated::Value(Value::F64(expr.powf(power))))\n}\n\npub fn ceil\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.ceil())))\n}\n\npub fn rand\u003c'a\u003e(name: String, seed: Option\u003cEvaluated\u003c'_\u003e\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let seed = if let Some(v) = seed {\n        StdRng::seed_from_u64(eval_to_float(\u0026name, v)? as u64).r#gen()\n    } else {\n        rand::random()\n    };\n    Continue(Evaluated::Value(Value::F64(seed)))\n}\n\npub fn round\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.round())))\n}\n\npub fn floor\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.floor())))\n}\n\npub fn radians\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.to_radians())))\n}\n\npub fn degrees\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.to_degrees())))\n}\n\npub fn exp\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.exp())))\n}\n\npub fn log\u003c'a\u003e(\n    name: String,\n    antilog: Evaluated\u003c'_\u003e,\n    base: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let antilog = eval_to_float(\u0026name, antilog)?;\n    let base = eval_to_float(\u0026name, base)?;\n\n    Continue(Evaluated::Value(Value::F64(antilog.log(base))))\n}\n\npub fn ln\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.ln())))\n}\n\npub fn log2\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.log2())))\n}\n\npub fn log10\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.log10())))\n}\n\npub fn sin\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.sin())))\n}\n\npub fn cos\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.cos())))\n}\n\npub fn tan\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.tan())))\n}\n\npub fn asin\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.asin())))\n}\n\npub fn acos\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.acos())))\n}\n\npub fn atan\u003c'a\u003e(name: String, n: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    eval_to_float(\u0026name, n).map(|n| Evaluated::Value(Value::F64(n.atan())))\n}\n\n// --- integer ---\n\npub fn div\u003c'a\u003e(\n    name: String,\n    dividend: Evaluated\u003c'_\u003e,\n    divisor: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let dividend = eval_to_float(\u0026name, dividend)\n        .map_err(|_| EvaluateError::FunctionRequiresFloatOrIntegerValue(name.clone()).into())?;\n    let divisor = eval_to_float(\u0026name, divisor)\n        .map_err(|_| EvaluateError::FunctionRequiresFloatOrIntegerValue(name.clone()).into())?;\n\n    if divisor == 0.0 {\n        return Err(EvaluateError::DivisorShouldNotBeZero.into()).into_control_flow();\n    }\n\n    Continue(Evaluated::Value(Value::I64((dividend / divisor) as i64)))\n}\n\npub fn gcd\u003c'a\u003e(\n    name: String,\n    left: Evaluated\u003c'_\u003e,\n    right: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let left = eval_to_int(\u0026name, left)?;\n    let right = eval_to_int(\u0026name, right)?;\n\n    gcd_i64(left, right).map(|gcd| Evaluated::Value(Value::I64(gcd)))\n}\n\npub fn lcm\u003c'a\u003e(\n    name: String,\n    left: Evaluated\u003c'_\u003e,\n    right: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let left = eval_to_int(\u0026name, left)?;\n    let right = eval_to_int(\u0026name, right)?;\n\n    fn lcm(a: i64, b: i64) -\u003e ControlFlow\u003ci64\u003e {\n        let gcd_val: i128 = gcd_i64(a, b)?.into();\n\n        let a: i128 = a.into();\n        let b: i128 = b.into();\n\n        // lcm(a, b) = abs(a * b) / gcd(a, b)   if gcd(a, b) != 0\n        // lcm(a, b) = 0                        if gcd(a, b) == 0\n        let result = (a * b).abs().checked_div(gcd_val).unwrap_or(0);\n\n        i64::try_from(result)\n            .map_err(|_| EvaluateError::LcmResultOutOfRange.into())\n            .into_control_flow()\n    }\n\n    lcm(left, right).map(|lcm| Evaluated::Value(Value::I64(lcm)))\n}\n\nfn gcd_i64(a: i64, b: i64) -\u003e ControlFlow\u003ci64\u003e {\n    let mut a = a\n        .checked_abs()\n        .continue_or_break(EvaluateError::GcdLcmOverflow(a).into())?;\n    let mut b = b\n        .checked_abs()\n        .continue_or_break(EvaluateError::GcdLcmOverflow(b).into())?;\n\n    while b \u003e 0 {\n        (a, b) = (b, a % b);\n    }\n\n    Continue(a)\n}\n\n// --- list ---\npub fn append\u003c'a\u003e(expr: Evaluated\u003c'_\u003e, value: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let expr = expr.try_into().break_if_null()?;\n    let value = value.try_into().break_if_null()?;\n\n    match (expr, value) {\n        (Value::List(mut l), v) =\u003e {\n            l.push(v);\n            Continue(Evaluated::Value(Value::List(l)))\n        }\n        _ =\u003e Err(EvaluateError::ListTypeRequired.into()).into_control_flow(),\n    }\n}\n\npub fn prepend\u003c'a\u003e(expr: Evaluated\u003c'_\u003e, value: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let expr = expr.try_into().break_if_null()?;\n    let value = value.try_into().break_if_null()?;\n\n    match (expr, value) {\n        (Value::List(mut l), v) =\u003e {\n            l.insert(0, v);\n            Continue(Evaluated::Value(Value::List(l)))\n        }\n        _ =\u003e Err(EvaluateError::ListTypeRequired.into()).into_control_flow(),\n    }\n}\n\npub fn skip\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    size: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let expr = expr.try_into().break_if_null()?;\n    let size: usize = match size.try_into().break_if_null()? {\n        Value::I64(number) =\u003e usize::try_from(number)\n            .map_err(|_| EvaluateError::FunctionRequiresUSizeValue(name).into()),\n        _ =\u003e Err(EvaluateError::FunctionRequiresIntegerValue(name).into()),\n    }\n    .into_control_flow()?;\n\n    match expr {\n        Value::List(l) =\u003e {\n            let l = l.into_iter().skip(size).collect();\n            Continue(Evaluated::Value(Value::List(l)))\n        }\n        _ =\u003e Err(EvaluateError::ListTypeRequired.into()).into_control_flow(),\n    }\n}\n\npub fn sort\u003c'a\u003e(expr: Evaluated\u003c'_\u003e, order: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let expr = expr.try_into().break_if_null()?;\n    let order = order.try_into().break_if_null()?;\n\n    match expr {\n        Value::List(l) =\u003e {\n            let mut l: Vec\u003c(Key, Value)\u003e = l\n                .into_iter()\n                .map(|v| match Key::try_from(\u0026v) {\n                    Ok(key) =\u003e Ok((key, v)),\n                    Err(_) =\u003e Err(EvaluateError::InvalidSortType.into()),\n                })\n                .collect::\u003cResult\u003cVec\u003c(Key, Value)\u003e\u003e\u003e()\n                .into_control_flow()?;\n\n            let asc = match order {\n                Value::Str(s) =\u003e match s.to_uppercase().as_str() {\n                    \"ASC\" =\u003e true,\n                    \"DESC\" =\u003e false,\n                    _ =\u003e return Err(EvaluateError::InvalidSortOrder.into()).into_control_flow(),\n                },\n                _ =\u003e return Err(EvaluateError::InvalidSortOrder.into()).into_control_flow(),\n            };\n\n            l.sort_by(|a, b| if asc { a.0.cmp(\u0026b.0) } else { b.0.cmp(\u0026a.0) });\n\n            Continue(Evaluated::Value(Value::List(\n                l.into_iter().map(|(_, v)| v).collect(),\n            )))\n        }\n        _ =\u003e Err(EvaluateError::ListTypeRequired.into()).into_control_flow(),\n    }\n}\n\npub fn slice\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    start: Evaluated\u003c'_\u003e,\n    length: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let expr = expr.try_into().break_if_null()?;\n    let mut start = eval_to_int(\u0026name, start)?;\n    let length = eval_to_int(\u0026name, length)\n        .map(usize::try_from)?\n        .map_err(|_| EvaluateError::FunctionRequiresUSizeValue(name.clone()).into())\n        .into_control_flow()?;\n\n    match expr {\n        Value::List(l) =\u003e {\n            if start \u003c 0 {\n                start += l.len() as i64;\n            }\n            if start \u003c 0 {\n                start = 0;\n            }\n\n            let start_usize = start as usize;\n\n            let l = l.into_iter().skip(start_usize).take(length).collect();\n            Continue(Evaluated::Value(Value::List(l)))\n        }\n        _ =\u003e Err(EvaluateError::ListTypeRequired.into()).into_control_flow(),\n    }\n}\n\npub fn take\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    size: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let expr = expr.try_into().break_if_null()?;\n    let size = eval_to_int(\u0026name, size)\n        .map(usize::try_from)?\n        .map_err(|_| EvaluateError::FunctionRequiresUSizeValue(name.clone()).into())\n        .into_control_flow()?;\n\n    match expr {\n        Value::List(l) =\u003e {\n            let l = l.into_iter().take(size).collect();\n            Continue(Evaluated::Value(Value::List(l)))\n        }\n        _ =\u003e Err(EvaluateError::ListTypeRequired.into()).into_control_flow(),\n    }\n}\n\npub fn is_empty\u003c'a\u003e(expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let expr = expr.try_into().break_if_null()?;\n    let length = match expr {\n        Value::List(l) =\u003e l.len(),\n        Value::Map(m) =\u003e m.len(),\n        _ =\u003e {\n            return Err(EvaluateError::MapOrListTypeRequired.into()).into_control_flow();\n        }\n    };\n\n    Continue(Evaluated::Value(Value::Bool(length == 0)))\n}\n\n// --- etc ---\n\npub fn unwrap\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'a\u003e,\n    selector: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let value = match expr {\n        _ if expr.is_null() =\u003e return Continue(expr),\n        Evaluated::Value(value) =\u003e value,\n        _ =\u003e {\n            return Err(EvaluateError::FunctionRequiresMapValue(name).into()).into_control_flow();\n        }\n    };\n    let selector = eval_to_str(\u0026name, selector)?;\n\n    value\n        .selector(\u0026selector)\n        .into_control_flow()\n        .map(Evaluated::Value)\n}\n\npub fn generate_uuid\u003c'a\u003e() -\u003e Evaluated\u003c'a\u003e {\n    Evaluated::Value(Value::Uuid(Uuid::new_v4().as_u128()))\n}\n\npub fn greatest(name: String, exprs: Vec\u003cEvaluated\u003c'_\u003e\u003e) -\u003e Result\u003cEvaluated\u003c'_\u003e\u003e {\n    exprs\n        .into_iter()\n        .try_fold(None, |greatest, expr| -\u003e Result\u003c_\u003e {\n            let greatest = match greatest {\n                Some(greatest) =\u003e greatest,\n                None =\u003e return Ok(Some(expr)),\n            };\n\n            match greatest.evaluate_cmp(\u0026expr) {\n                Some(std::cmp::Ordering::Less) =\u003e Ok(Some(expr)),\n                Some(_) =\u003e Ok(Some(greatest)),\n                None =\u003e Err(EvaluateError::NonComparableArgumentError(name.to_owned()).into()),\n            }\n        })?\n        .ok_or(EvaluateError::FunctionRequiresAtLeastOneArgument(name.to_owned()).into())\n}\n\npub fn format\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    format: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    match expr.try_into().break_if_null()? {\n        Value::Date(expr) =\u003e eval_to_str(\u0026name, format)\n            .map(|format| chrono::NaiveDate::format(\u0026expr, \u0026format).to_string()),\n        Value::Timestamp(expr) =\u003e eval_to_str(\u0026name, format)\n            .map(|format| chrono::NaiveDateTime::format(\u0026expr, \u0026format).to_string()),\n        Value::Time(expr) =\u003e eval_to_str(\u0026name, format)\n            .map(|format| chrono::NaiveTime::format(\u0026expr, \u0026format).to_string()),\n        value =\u003e Err(EvaluateError::UnsupportedExprForFormatFunction(value.into()).into())\n            .into_control_flow(),\n    }\n    .map(Value::Str)\n    .map(Evaluated::Value)\n}\n\npub fn last_day\u003c'a\u003e(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let date = match expr.try_into().break_if_null()? {\n        Value::Date(date) =\u003e date,\n        Value::Timestamp(timestamp) =\u003e timestamp.date(),\n        _ =\u003e {\n            return Err(EvaluateError::FunctionRequiresDateOrDateTimeValue(name).into())\n                .into_control_flow();\n        }\n    };\n\n    Continue(Evaluated::Value(Value::Date(\n        date + Months::new(1) - Duration::days(date.day() as i64),\n    )))\n}\n\npub fn to_date\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    format: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    match expr.try_into().break_if_null()? {\n        Value::Str(expr) =\u003e {\n            let format = eval_to_str(\u0026name, format)?;\n\n            chrono::NaiveDate::parse_from_str(\u0026expr, \u0026format)\n                .map(Value::Date)\n                .map(Evaluated::Value)\n                .map_err(|err| {\n                    let err: EvaluateError = err.into();\n                    err.into()\n                })\n        }\n        _ =\u003e Err(EvaluateError::FunctionRequiresStringValue(name).into()),\n    }\n    .into_control_flow()\n}\n\npub fn to_timestamp\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    format: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    match expr.try_into().break_if_null()? {\n        Value::Str(expr) =\u003e {\n            let format = eval_to_str(\u0026name, format)?;\n\n            chrono::NaiveDateTime::parse_from_str(\u0026expr, \u0026format)\n                .map(Value::Timestamp)\n                .map(Evaluated::Value)\n                .map_err(|err| {\n                    let err: EvaluateError = err.into();\n                    err.into()\n                })\n        }\n        _ =\u003e Err(EvaluateError::FunctionRequiresStringValue(name).into()),\n    }\n    .into_control_flow()\n}\n\npub fn add_month\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    size: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let size = eval_to_int(\u0026name, size)?;\n    let expr = eval_to_str(\u0026name, expr)?;\n    let expr = chrono::NaiveDate::parse_from_str(\u0026expr, \"%Y-%m-%d\")\n        .map_err(EvaluateError::from)\n        .map_err(Error::from)\n        .into_control_flow()?;\n    let date = {\n        let size_as_u32 = size\n            .abs()\n            .try_into()\n            .map_err(|_| EvaluateError::I64ToU32ConversionFailure(name).into())\n            .into_control_flow()?;\n        let new_months = chrono::Months::new(size_as_u32);\n\n        if size \u003c= 0 {\n            expr.checked_sub_months(new_months)\n        } else {\n            expr.checked_add_months(new_months)\n        }\n        .continue_or_break(EvaluateError::ChrFunctionRequiresIntegerValueInRange0To255.into())?\n    };\n    Continue(Evaluated::Value(Value::Date(date)))\n}\n\npub fn to_time\u003c'a\u003e(\n    name: String,\n    expr: Evaluated\u003c'_\u003e,\n    format: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    match expr.try_into().break_if_null()? {\n        Value::Str(expr) =\u003e {\n            let format = eval_to_str(\u0026name, format)?;\n\n            chrono::NaiveTime::parse_from_str(\u0026expr, \u0026format)\n                .map(Value::Time)\n                .map(Evaluated::Value)\n                .map_err(|err| {\n                    let err: EvaluateError = err.into();\n                    err.into()\n                })\n        }\n        _ =\u003e Err(EvaluateError::FunctionRequiresStringValue(name).into()),\n    }\n    .into_control_flow()\n}\n\npub fn position\u003c'a\u003e(\n    from_expr: Evaluated\u003c'_\u003e,\n    sub_expr: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let from: Value = from_expr.try_into().break_if_null()?;\n    let sub = sub_expr.try_into().break_if_null()?;\n\n    from.position(\u0026sub)\n        .map(Evaluated::Value)\n        .into_control_flow()\n}\n\npub fn find_idx\u003c'a\u003e(\n    name: String,\n    from: Evaluated\u003c'a\u003e,\n    sub: Evaluated\u003c'a\u003e,\n    start: Option\u003cEvaluated\u003c'a\u003e\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let from_expr = eval_to_str(\u0026name, from)?;\n    let sub_expr = eval_to_str(\u0026name, sub)?;\n\n    match start {\n        Some(start) =\u003e {\n            let start = eval_to_int(\u0026name, start)?;\n            Value::find_idx(\n                \u0026Value::Str(from_expr),\n                \u0026Value::Str(sub_expr),\n                \u0026Value::I64(start),\n            )\n        }\n        None =\u003e Value::position(\u0026Value::Str(from_expr), \u0026Value::Str(sub_expr)),\n    }\n    .map(Evaluated::Value)\n    .into_control_flow()\n}\n\npub fn extract\u003c'a\u003e(field: \u0026DateTimeField, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    Value::try_from(expr)\n        .and_then(|v| v.extract(field))\n        .map(Evaluated::Value)\n        .into_control_flow()\n}\n\npub fn point\u003c'a\u003e(name: String, x: Evaluated\u003c'_\u003e, y: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let x = eval_to_float(\u0026name, x)?;\n    let y = eval_to_float(\u0026name, y)?;\n\n    Continue(Evaluated::Value(Value::Point(Point::new(x, y))))\n}\n\npub fn get_x\u003c'a\u003e(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    match expr.try_into().break_if_null()? {\n        Value::Point(v) =\u003e Ok(Evaluated::Value(Value::F64(v.x))),\n        _ =\u003e Err(EvaluateError::FunctionRequiresPointValue(name).into()),\n    }\n    .into_control_flow()\n}\n\npub fn get_y\u003c'a\u003e(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    match expr.try_into().break_if_null()? {\n        Value::Point(v) =\u003e Ok(Evaluated::Value(Value::F64(v.y))),\n        _ =\u003e Err(EvaluateError::FunctionRequiresPointValue(name).into()),\n    }\n    .into_control_flow()\n}\n\npub fn calc_distance\u003c'a\u003e(\n    name: String,\n    x: Evaluated\u003c'_\u003e,\n    y: Evaluated\u003c'_\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let x = eval_to_point(\u0026name, x)?;\n    let y = eval_to_point(\u0026name, y)?;\n\n    Continue(Evaluated::Value(Value::F64(Point::calc_distance(\u0026x, \u0026y))))\n}\n\npub fn length\u003c'a\u003e(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    match expr.try_into().break_if_null()? {\n        Value::Str(expr) =\u003e Ok(Evaluated::Value(Value::U64(expr.chars().count() as u64))),\n        Value::List(expr) =\u003e Ok(Evaluated::Value(Value::U64(expr.len() as u64))),\n        Value::Map(expr) =\u003e Ok(Evaluated::Value(Value::U64(expr.len() as u64))),\n        _ =\u003e Err(EvaluateError::FunctionRequiresStrOrListOrMapValue(name).into()),\n    }\n    .into_control_flow()\n}\n\npub fn coalesce\u003c'a\u003e(exprs: Vec\u003cEvaluated\u003c'_\u003e\u003e) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n    if exprs.is_empty() {\n        return Err((EvaluateError::FunctionRequiresMoreArguments {\n            function_name: \"COALESCE\".to_owned(),\n            required_minimum: 1,\n            found: exprs.len(),\n        })\n        .into());\n    }\n\n    let control_flow = exprs.into_iter().map(|expr| expr.try_into()).try_for_each(\n        |item: Result\u003cValue\u003e| match item {\n            Ok(value) if value.is_null() =\u003e StdControlFlow::Continue(()),\n            Ok(value) =\u003e StdControlFlow::Break(Ok(value)),\n            Err(err) =\u003e StdControlFlow::Break(Err(err)),\n        },\n    );\n\n    match control_flow {\n        StdControlFlow::Break(Ok(value)) =\u003e Ok(Evaluated::Value(value)),\n        StdControlFlow::Break(Err(err)) =\u003e Err(err),\n        StdControlFlow::Continue(()) =\u003e Ok(Evaluated::Value(Value::Null)),\n    }\n}\n\npub fn entries\u003c'a\u003e(name: String, expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    match expr.try_into().break_if_null()? {\n        Value::Map(expr) =\u003e {\n            let entries = expr\n                .into_iter()\n                .map(|(k, v)| Value::List(vec![Value::Str(k), v]))\n                .collect::\u003cVec\u003c_\u003e\u003e();\n            Ok(Evaluated::Value(Value::List(entries)))\n        }\n        _ =\u003e Err(EvaluateError::FunctionRequiresMapValue(name).into()),\n    }\n    .into_control_flow()\n}\n\npub fn keys\u003c'a\u003e(expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    match expr.try_into().break_if_null()? {\n        Value::Map(m) =\u003e Ok(Evaluated::Value(Value::List(\n            m.into_keys().map(Value::Str).collect(),\n        ))),\n        _ =\u003e Err(EvaluateError::MapTypeRequired.into()),\n    }\n    .into_control_flow()\n}\n\npub fn values\u003c'a\u003e(expr: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    match expr.try_into().break_if_null()? {\n        Value::Map(m) =\u003e Ok(Evaluated::Value(Value::List(m.into_values().collect()))),\n        _ =\u003e Err(EvaluateError::MapTypeRequired.into()),\n    }\n    .into_control_flow()\n}\n\npub fn splice\u003c'a\u003e(\n    name: String,\n    list_data: Evaluated\u003c'_\u003e,\n    begin_index: Evaluated\u003c'_\u003e,\n    end_index: Evaluated\u003c'_\u003e,\n    values: Option\u003cEvaluated\u003c'_\u003e\u003e,\n) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    let list_data = match list_data.try_into().break_if_null()? {\n        Value::List(list) =\u003e list,\n        _ =\u003e {\n            return Err(EvaluateError::ListTypeRequired.into()).into_control_flow();\n        }\n    };\n\n    let begin_index = eval_to_int(\u0026name, begin_index)?.max(0);\n    let begin_index = usize::try_from(begin_index)\n        .map_err(|_| EvaluateError::FunctionRequiresUSizeValue(name.clone()).into())\n        .into_control_flow()?;\n    let end_index = eval_to_int(\u0026name, end_index)?.max(0);\n    let end_index = usize::try_from(end_index)\n        .map_err(|_| EvaluateError::FunctionRequiresUSizeValue(name.clone()).into())\n        .into_control_flow()?;\n\n    let (left, right) = {\n        let mut list_iter = list_data.into_iter();\n        let left: Vec\u003c_\u003e = list_iter.by_ref().take(begin_index).collect();\n        let right: Vec\u003c_\u003e = list_iter.skip(end_index - begin_index).collect();\n        (left, right)\n    };\n\n    let center = match values {\n        Some(values) =\u003e match values.try_into().break_if_null()? {\n            Value::List(list) =\u003e list,\n            _ =\u003e return Err(EvaluateError::ListTypeRequired.into()).into_control_flow(),\n        },\n        None =\u003e vec![],\n    };\n\n    let result = {\n        let mut result = vec![];\n        result.extend(left);\n        result.extend(center);\n        result.extend(right);\n        result\n    };\n\n    Continue(Evaluated::Value(Value::List(result)))\n}\n\npub fn dedup\u003c'a\u003e(list: Evaluated\u003c'_\u003e) -\u003e ControlFlow\u003cEvaluated\u003c'a\u003e\u003e {\n    match list.try_into().break_if_null()? {\n        Value::List(mut list) =\u003e {\n            list.dedup();\n            Continue(Evaluated::Value(Value::List(list)))\n        }\n        _ =\u003e Err(EvaluateError::ListTypeRequired.into()).into_control_flow(),\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1011,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1020,"address":[],"length":0,"stats":{"Line":0}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1043,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[],"length":0,"stats":{"Line":0}},{"line":1051,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1053,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1061,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1067,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1074,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1081,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1086,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[],"length":0,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":0}},{"line":1094,"address":[],"length":0,"stats":{"Line":0}},{"line":1095,"address":[],"length":0,"stats":{"Line":0}},{"line":1096,"address":[],"length":0,"stats":{"Line":0}},{"line":1098,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":541},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","evaluate.rs"],"content":"mod error;\nmod evaluated;\nmod expr;\nmod function;\n\nuse {\n    self::function::BreakCase,\n    super::{context::RowContext, select::select},\n    crate::{\n        ast::{Aggregate, Expr, Function},\n        data::{CustomFunction, Interval, Literal, Row, Value},\n        mock::MockStorage,\n        result::{Error, Result},\n        store::GStore,\n    },\n    async_recursion::async_recursion,\n    chrono::prelude::Utc,\n    futures::{\n        future::{ready, try_join_all},\n        stream::{self, StreamExt, TryStreamExt},\n    },\n    im_rc::HashMap,\n    std::{borrow::Cow, ops::ControlFlow, rc::Rc},\n};\n\npub use {error::EvaluateError, evaluated::Evaluated};\n\npub async fn evaluate\u003c'a, 'b, 'c, T\u003e(\n    storage: \u0026'a T,\n    context: Option\u003cRc\u003cRowContext\u003c'b\u003e\u003e\u003e,\n    aggregated: Option\u003cRc\u003cHashMap\u003c\u0026'c Aggregate, Value\u003e\u003e\u003e,\n    expr: \u0026'a Expr,\n) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e\nwhere\n    'b: 'a,\n    'c: 'a,\n    T: GStore,\n{\n    evaluate_inner(Some(storage), context, aggregated, expr).await\n}\n\npub async fn evaluate_stateless\u003c'a, 'b: 'a\u003e(\n    context: Option\u003cRowContext\u003c'b\u003e\u003e,\n    expr: \u0026'a Expr,\n) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n    let context = context.map(Rc::new);\n    let storage: Option\u003c\u0026MockStorage\u003e = None;\n\n    evaluate_inner(storage, context, None, expr).await\n}\n\n#[async_recursion(?Send)]\nasync fn evaluate_inner\u003c'a, 'b, 'c, T\u003e(\n    storage: Option\u003c\u0026'a T\u003e,\n    context: Option\u003cRc\u003cRowContext\u003c'b\u003e\u003e\u003e,\n    aggregated: Option\u003cRc\u003cHashMap\u003c\u0026'c Aggregate, Value\u003e\u003e\u003e,\n    expr: \u0026'a Expr,\n) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e\nwhere\n    'b: 'a,\n    'c: 'a,\n    T: GStore,\n{\n    let eval = |expr| {\n        let context = context.as_ref().map(Rc::clone);\n        let aggregated = aggregated.as_ref().map(Rc::clone);\n\n        evaluate_inner(storage, context, aggregated, expr)\n    };\n\n    match expr {\n        Expr::Literal(ast_literal) =\u003e expr::literal(ast_literal),\n        Expr::TypedString { data_type, value } =\u003e {\n            expr::typed_string(data_type, Cow::Borrowed(value))\n        }\n        Expr::Identifier(ident) =\u003e {\n            let context = context\n                .ok_or_else(|| EvaluateError::ContextRequiredForIdentEvaluation(expr.clone()))?;\n\n            match context.get_value(ident) {\n                Some(value) =\u003e Ok(value.clone()),\n                None =\u003e Err(EvaluateError::IdentifierNotFound(ident.to_owned()).into()),\n            }\n            .map(Evaluated::Value)\n        }\n        Expr::Nested(expr) =\u003e eval(expr).await,\n        Expr::CompoundIdentifier { alias, ident } =\u003e {\n            let context = context\n                .ok_or_else(|| EvaluateError::ContextRequiredForIdentEvaluation(expr.clone()))?;\n\n            match context.get_alias_value(alias, ident) {\n                Some(value) =\u003e Ok(value.clone()),\n                None =\u003e Err(EvaluateError::CompoundIdentifierNotFound {\n                    table_alias: alias.to_owned(),\n                    column_name: ident.to_owned(),\n                }\n                .into()),\n            }\n            .map(Evaluated::Value)\n        }\n        Expr::Subquery(query) =\u003e {\n            let storage =\n                storage.ok_or_else(|| EvaluateError::UnsupportedStatelessExpr(expr.clone()))?;\n\n            let evaluations = select(storage, query, context.as_ref().map(Rc::clone))\n                .await?\n                .map(|row| {\n                    let value = match row? {\n                        Row::Vec { columns, values } =\u003e {\n                            if columns.len() \u003e 1 {\n                                return Err(EvaluateError::MoreThanOneColumnReturned.into());\n                            }\n                            values\n                        }\n                        Row::Map(_) =\u003e {\n                            return Err(EvaluateError::SchemalessProjectionForSubQuery.into());\n                        }\n                    }\n                    .into_iter()\n                    .next();\n\n                    Ok::\u003c_, Error\u003e(value)\n                })\n                .take(2)\n                .try_collect::\u003cVec\u003c_\u003e\u003e()\n                .await?;\n\n            if evaluations.len() \u003e 1 {\n                return Err(EvaluateError::MoreThanOneRowReturned.into());\n            }\n\n            let value = evaluations\n                .into_iter()\n                .next()\n                .flatten()\n                .unwrap_or(Value::Null);\n\n            Ok(Evaluated::Value(value))\n        }\n        Expr::BinaryOp { op, left, right } =\u003e {\n            let left = eval(left).await?;\n            let right = eval(right).await?;\n\n            expr::binary_op(op, left, right)\n        }\n        Expr::UnaryOp { op, expr } =\u003e {\n            let v = eval(expr).await?;\n\n            expr::unary_op(op, v)\n        }\n        Expr::Aggregate(aggr) =\u003e match aggregated\n            .as_ref()\n            .and_then(|aggregated| aggregated.get(aggr.as_ref()))\n        {\n            Some(value) =\u003e Ok(Evaluated::Value(value.clone())),\n            None =\u003e Err(EvaluateError::UnreachableEmptyAggregateValue(*aggr.clone()).into()),\n        },\n        Expr::Function(func) =\u003e {\n            let context = context.as_ref().map(Rc::clone);\n            let aggregated = aggregated.as_ref().map(Rc::clone);\n\n            evaluate_function(storage, context, aggregated, func).await\n        }\n        Expr::InList {\n            expr,\n            list,\n            negated,\n        } =\u003e {\n            let negated = *negated;\n            let target = eval(expr).await?;\n\n            stream::iter(list)\n                .then(eval)\n                .try_filter(|evaluated| ready(evaluated.evaluate_eq(\u0026target)))\n                .try_next()\n                .await\n                .map(|v| v.is_some() ^ negated)\n                .map(Value::Bool)\n                .map(Evaluated::Value)\n        }\n        Expr::InSubquery {\n            expr: target_expr,\n            subquery,\n            negated,\n        } =\u003e {\n            let storage =\n                storage.ok_or_else(|| EvaluateError::UnsupportedStatelessExpr(expr.clone()))?;\n            let target = eval(target_expr).await?;\n\n            select(storage, subquery, context)\n                .await?\n                .map(|row| {\n                    let value = match row? {\n                        Row::Vec { values, .. } =\u003e values,\n                        Row::Map(_) =\u003e {\n                            return Err(EvaluateError::SchemalessProjectionForInSubQuery.into());\n                        }\n                    }\n                    .into_iter()\n                    .next()\n                    .unwrap_or(Value::Null);\n\n                    Ok(Evaluated::Value(value))\n                })\n                .try_filter(|evaluated| ready(evaluated.evaluate_eq(\u0026target)))\n                .try_next()\n                .await\n                .map(|v| v.is_some() ^ negated)\n                .map(Value::Bool)\n                .map(Evaluated::Value)\n        }\n        Expr::Between {\n            expr,\n            negated,\n            low,\n            high,\n        } =\u003e {\n            let target = eval(expr).await?;\n            let low = eval(low).await?;\n            let high = eval(high).await?;\n\n            expr::between(target, *negated, low, high)\n        }\n        Expr::Like {\n            expr,\n            negated,\n            pattern,\n        } =\u003e {\n            let target = eval(expr).await?;\n            let pattern = eval(pattern).await?;\n            let evaluated = target.like(pattern, true)?;\n\n            Ok(match negated {\n                true =\u003e Evaluated::Value(Value::Bool(\n                    evaluated.evaluate_eq(\u0026Evaluated::Literal(Literal::Boolean(false))),\n                )),\n                false =\u003e evaluated,\n            })\n        }\n        Expr::ILike {\n            expr,\n            negated,\n            pattern,\n        } =\u003e {\n            let target = eval(expr).await?;\n            let pattern = eval(pattern).await?;\n            let evaluated = target.like(pattern, false)?;\n\n            Ok(match negated {\n                true =\u003e Evaluated::Value(Value::Bool(\n                    evaluated.evaluate_eq(\u0026Evaluated::Literal(Literal::Boolean(false))),\n                )),\n                false =\u003e evaluated,\n            })\n        }\n        Expr::Exists { subquery, negated } =\u003e {\n            let storage =\n                storage.ok_or_else(|| EvaluateError::UnsupportedStatelessExpr(expr.clone()))?;\n\n            select(storage, subquery, context)\n                .await?\n                .try_next()\n                .await\n                .map(|v| v.is_some() ^ negated)\n                .map(Value::Bool)\n                .map(Evaluated::Value)\n        }\n        Expr::IsNull(expr) =\u003e {\n            let v = eval(expr).await?.is_null();\n\n            Ok(Evaluated::Value(Value::Bool(v)))\n        }\n        Expr::IsNotNull(expr) =\u003e {\n            let v = eval(expr).await?.is_null();\n\n            Ok(Evaluated::Value(Value::Bool(!v)))\n        }\n        Expr::Case {\n            operand,\n            when_then,\n            else_result,\n        } =\u003e {\n            let operand = match operand {\n                Some(op) =\u003e eval(op).await?,\n                None =\u003e Evaluated::Value(Value::Bool(true)),\n            };\n\n            for (when, then) in when_then.iter() {\n                let when = eval(when).await?;\n\n                if when.evaluate_eq(\u0026operand) {\n                    return eval(then).await;\n                }\n            }\n\n            match else_result {\n                Some(er) =\u003e eval(er).await,\n                None =\u003e Ok(Evaluated::Value(Value::Null)),\n            }\n        }\n        Expr::ArrayIndex { obj, indexes } =\u003e {\n            let obj = eval(obj).await?;\n            let indexes = try_join_all(indexes.iter().map(eval)).await?;\n            expr::array_index(obj, indexes)\n        }\n        Expr::Array { elem } =\u003e try_join_all(elem.iter().map(eval))\n            .await?\n            .into_iter()\n            .map(Value::try_from)\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n            .map(Value::List)\n            .map(Evaluated::Value),\n        Expr::Interval {\n            expr,\n            leading_field,\n            last_field,\n        } =\u003e {\n            let value = eval(expr)\n                .await\n                .and_then(Value::try_from)\n                .map(String::from)?;\n\n            Interval::try_from_str(\u0026value, *leading_field, *last_field)\n                .map(Value::Interval)\n                .map(Evaluated::Value)\n        }\n    }\n}\n\nasync fn evaluate_function\u003c'a, 'b: 'a, 'c: 'a, T: GStore\u003e(\n    storage: Option\u003c\u0026'a T\u003e,\n    context: Option\u003cRc\u003cRowContext\u003c'b\u003e\u003e\u003e,\n    aggregated: Option\u003cRc\u003cHashMap\u003c\u0026'c Aggregate, Value\u003e\u003e\u003e,\n    func: \u0026'b Function,\n) -\u003e Result\u003cEvaluated\u003c'a\u003e\u003e {\n    use function as f;\n\n    let eval = |expr| {\n        let context = context.as_ref().map(Rc::clone);\n        let aggregated = aggregated.as_ref().map(Rc::clone);\n\n        evaluate_inner(storage, context, aggregated, expr)\n    };\n\n    let name = func.to_string();\n\n    let result = match func {\n        // --- text ---\n        Function::Concat(exprs) =\u003e {\n            let exprs = stream::iter(exprs).then(eval).try_collect().await?;\n            f::concat(exprs)\n        }\n        Function::Custom { name, exprs } =\u003e {\n            let CustomFunction {\n                func_name,\n                args,\n                body,\n            } = storage\n                .ok_or(EvaluateError::UnsupportedCustomFunction)?\n                .fetch_function(name)\n                .await?\n                .ok_or_else(|| EvaluateError::UnsupportedFunction(name.to_string()))?;\n\n            let min = args.iter().filter(|arg| arg.default.is_none()).count();\n            let max = args.len();\n\n            if !(min..=max).contains(\u0026exprs.len()) {\n                return Err((EvaluateError::FunctionArgsLengthNotWithinRange {\n                    name: func_name.to_owned(),\n                    expected_minimum: min,\n                    expected_maximum: max,\n                    found: exprs.len(),\n                })\n                .into());\n            }\n\n            let exprs = exprs.iter().chain(\n                args.iter()\n                    .skip(exprs.len())\n                    .filter_map(|arg| arg.default.as_ref()),\n            );\n\n            let context = stream::iter(args.iter().zip(exprs))\n                .then(|(arg, expr)| async {\n                    eval(expr)\n                        .await?\n                        .try_into_value(\u0026arg.data_type, true)\n                        .map(|value| (arg.name.to_owned(), value))\n                })\n                .try_collect()\n                .await\n                .map(|values| {\n                    let row = Cow::Owned(Row::Map(values));\n                    let context = RowContext::new(name, row, None);\n                    Some(Rc::new(context))\n                })?;\n\n            return evaluate_inner(storage, context, None, body).await;\n        }\n        Function::Iif {\n            cond,\n            then,\n            else_result,\n        } =\u003e {\n            let cond = eval(cond).await?;\n            let cond: bool = cond.try_into()?;\n            if cond {\n                return eval(then).await;\n            } else {\n                return eval(else_result).await;\n            }\n        }\n        Function::ConcatWs { separator, exprs } =\u003e {\n            let separator = eval(separator).await?;\n            let exprs = stream::iter(exprs).then(eval).try_collect().await?;\n            f::concat_ws(name, separator, exprs)\n        }\n        Function::IfNull { expr, then } =\u003e f::ifnull(eval(expr).await?, eval(then).await?),\n        Function::NullIf { expr1, expr2 } =\u003e f::nullif(eval(expr1).await?, eval(expr2).await?),\n        Function::Lower(expr) =\u003e f::lower(name, eval(expr).await?),\n        Function::Initcap(expr) =\u003e f::initcap(name, eval(expr).await?),\n        Function::Upper(expr) =\u003e f::upper(name, eval(expr).await?),\n        Function::Left { expr, size } | Function::Right { expr, size } =\u003e {\n            let expr = eval(expr).await?;\n            let size = eval(size).await?;\n\n            f::left_or_right(name, expr, size)\n        }\n        Function::Replace { expr, old, new } =\u003e {\n            let expr = eval(expr).await?;\n            let old = eval(old).await?;\n            let new = eval(new).await?;\n\n            f::replace(name, expr, old, new)\n        }\n        Function::Lpad { expr, size, fill } | Function::Rpad { expr, size, fill } =\u003e {\n            let expr = eval(expr).await?;\n            let size = eval(size).await?;\n            let fill = match fill {\n                Some(v) =\u003e Some(eval(v).await?),\n                None =\u003e None,\n            };\n\n            f::lpad_or_rpad(name, expr, size, fill)\n        }\n        Function::LastDay(expr) =\u003e {\n            let expr = eval(expr).await?;\n            f::last_day(name, expr)\n        }\n        Function::Trim {\n            expr,\n            filter_chars,\n            trim_where_field,\n        } =\u003e {\n            let expr = eval(expr).await?;\n            let filter_chars = match filter_chars {\n                Some(v) =\u003e Some(eval(v).await?),\n                None =\u003e None,\n            };\n\n            return expr.trim(name, filter_chars, trim_where_field);\n        }\n        Function::Ltrim { expr, chars } =\u003e {\n            let expr = eval(expr).await?;\n            let chars = match chars {\n                Some(v) =\u003e Some(eval(v).await?),\n                None =\u003e None,\n            };\n\n            return expr.ltrim(name, chars);\n        }\n        Function::Rtrim { expr, chars } =\u003e {\n            let expr = eval(expr).await?;\n            let chars = match chars {\n                Some(v) =\u003e Some(eval(v).await?),\n                None =\u003e None,\n            };\n\n            return expr.rtrim(name, chars);\n        }\n        Function::Reverse(expr) =\u003e {\n            let expr = eval(expr).await?;\n\n            f::reverse(name, expr)\n        }\n        Function::Repeat { expr, num } =\u003e {\n            let expr = eval(expr).await?;\n            let num = eval(num).await?;\n\n            f::repeat(name, expr, num)\n        }\n        Function::Substr { expr, start, count } =\u003e {\n            let expr = eval(expr).await?;\n            let start = eval(start).await?;\n            let count = match count {\n                Some(v) =\u003e Some(eval(v).await?),\n                None =\u003e None,\n            };\n\n            return expr.substr(name, start, count);\n        }\n        Function::Ascii(expr) =\u003e f::ascii(name, eval(expr).await?),\n        Function::Chr(expr) =\u003e f::chr(name, eval(expr).await?),\n        Function::Md5(expr) =\u003e f::md5(name, eval(expr).await?),\n        Function::Hex(expr) =\u003e f::hex(name, eval(expr).await?),\n\n        // --- float ---\n        Function::Abs(expr) =\u003e f::abs(name, eval(expr).await?),\n        Function::Sign(expr) =\u003e f::sign(name, eval(expr).await?),\n        Function::Sqrt(expr) =\u003e f::sqrt(eval(expr).await?),\n        Function::Power { expr, power } =\u003e {\n            let expr = eval(expr).await?;\n            let power = eval(power).await?;\n\n            f::power(name, expr, power)\n        }\n        Function::Ceil(expr) =\u003e f::ceil(name, eval(expr).await?),\n        Function::Rand(expr) =\u003e {\n            let expr = match expr {\n                Some(v) =\u003e Some(eval(v).await?),\n                None =\u003e None,\n            };\n\n            f::rand(name, expr)\n        }\n        Function::Round(expr) =\u003e f::round(name, eval(expr).await?),\n        Function::Floor(expr) =\u003e f::floor(name, eval(expr).await?),\n        Function::Radians(expr) =\u003e f::radians(name, eval(expr).await?),\n        Function::Degrees(expr) =\u003e f::degrees(name, eval(expr).await?),\n        Function::Pi() =\u003e return Ok(Evaluated::Value(Value::F64(std::f64::consts::PI))),\n        Function::Exp(expr) =\u003e f::exp(name, eval(expr).await?),\n        Function::Log { antilog, base } =\u003e {\n            let antilog = eval(antilog).await?;\n            let base = eval(base).await?;\n\n            f::log(name, antilog, base)\n        }\n        Function::Ln(expr) =\u003e f::ln(name, eval(expr).await?),\n        Function::Log2(expr) =\u003e f::log2(name, eval(expr).await?),\n        Function::Log10(expr) =\u003e f::log10(name, eval(expr).await?),\n        Function::Sin(expr) =\u003e f::sin(name, eval(expr).await?),\n        Function::Cos(expr) =\u003e f::cos(name, eval(expr).await?),\n        Function::Tan(expr) =\u003e f::tan(name, eval(expr).await?),\n        Function::Asin(expr) =\u003e f::asin(name, eval(expr).await?),\n        Function::Acos(expr) =\u003e f::acos(name, eval(expr).await?),\n        Function::Atan(expr) =\u003e f::atan(name, eval(expr).await?),\n\n        // --- integer ---\n        Function::Div { dividend, divisor } =\u003e {\n            let dividend = eval(dividend).await?;\n            let divisor = eval(divisor).await?;\n\n            f::div(name, dividend, divisor)\n        }\n        Function::Mod { dividend, divisor } =\u003e {\n            let dividend = eval(dividend).await?;\n            let divisor = eval(divisor).await?;\n\n            return dividend.modulo(\u0026divisor);\n        }\n        Function::Gcd { left, right } =\u003e {\n            let left = eval(left).await?;\n            let right = eval(right).await?;\n\n            f::gcd(name, left, right)\n        }\n        Function::Lcm { left, right } =\u003e {\n            let left = eval(left).await?;\n            let right = eval(right).await?;\n\n            f::lcm(name, left, right)\n        }\n\n        // --- spatial ---\n        Function::Point { x, y } =\u003e {\n            let x = eval(x).await?;\n            let y = eval(y).await?;\n\n            f::point(name, x, y)\n        }\n        Function::GetX(expr) =\u003e f::get_x(name, eval(expr).await?),\n        Function::GetY(expr) =\u003e f::get_y(name, eval(expr).await?),\n        Function::CalcDistance {\n            geometry1,\n            geometry2,\n        } =\u003e {\n            let geometry1 = eval(geometry1).await?;\n            let geometry2 = eval(geometry2).await?;\n\n            f::calc_distance(name, geometry1, geometry2)\n        }\n\n        // --- etc ---\n        Function::Unwrap { expr, selector } =\u003e {\n            let expr = eval(expr).await?;\n            let selector = eval(selector).await?;\n\n            f::unwrap(name, expr, selector)\n        }\n        Function::GenerateUuid() =\u003e return Ok(f::generate_uuid()),\n        Function::Greatest(exprs) =\u003e {\n            let exprs = stream::iter(exprs).then(eval).try_collect().await?;\n            return f::greatest(name, exprs);\n        }\n        Function::Now() | Function::CurrentTimestamp() =\u003e {\n            return Ok(Evaluated::Value(Value::Timestamp(Utc::now().naive_utc())));\n        }\n        Function::CurrentDate() =\u003e {\n            return Ok(Evaluated::Value(Value::Date(Utc::now().date_naive())));\n        }\n        Function::CurrentTime() =\u003e return Ok(Evaluated::Value(Value::Time(Utc::now().time()))),\n        Function::Format { expr, format } =\u003e {\n            let expr = eval(expr).await?;\n            let format = eval(format).await?;\n\n            f::format(name, expr, format)\n        }\n        Function::ToDate { expr, format } =\u003e {\n            let expr = eval(expr).await?;\n            let format = eval(format).await?;\n            f::to_date(name, expr, format)\n        }\n        Function::ToTimestamp { expr, format } =\u003e {\n            let expr = eval(expr).await?;\n            let format = eval(format).await?;\n            f::to_timestamp(name, expr, format)\n        }\n        Function::ToTime { expr, format } =\u003e {\n            let expr = eval(expr).await?;\n            let format = eval(format).await?;\n            f::to_time(name, expr, format)\n        }\n        Function::Position {\n            from_expr,\n            sub_expr,\n        } =\u003e {\n            let from_expr = eval(from_expr).await?;\n            let sub_expr = eval(sub_expr).await?;\n            f::position(from_expr, sub_expr)\n        }\n        Function::FindIdx {\n            from_expr,\n            sub_expr,\n            start,\n        } =\u003e {\n            let from_expr = eval(from_expr).await?;\n            let sub_expr = eval(sub_expr).await?;\n            let start = match start {\n                Some(idx) =\u003e Some(eval(idx).await?),\n                None =\u003e None,\n            };\n            f::find_idx(name, from_expr, sub_expr, start)\n        }\n        Function::Cast { expr, data_type } =\u003e return eval(expr).await?.cast(data_type),\n        Function::Extract { field, expr } =\u003e {\n            let expr = eval(expr).await?;\n            f::extract(field, expr)\n        }\n        Function::Coalesce(exprs) =\u003e {\n            let exprs = stream::iter(exprs).then(eval).try_collect().await?;\n            return f::coalesce(exprs);\n        }\n\n        // --- list ---\n        Function::Append { expr, value } =\u003e {\n            let expr = eval(expr).await?;\n            let value = eval(value).await?;\n            f::append(expr, value)\n        }\n        Function::Prepend { expr, value } =\u003e {\n            let expr = eval(expr).await?;\n            let value = eval(value).await?;\n            f::prepend(expr, value)\n        }\n        Function::Skip { expr, size } =\u003e {\n            let expr = eval(expr).await?;\n            let size = eval(size).await?;\n            f::skip(name, expr, size)\n        }\n        Function::Sort { expr, order } =\u003e {\n            let expr = eval(expr).await?;\n            let order = match order {\n                Some(o) =\u003e eval(o).await?,\n                None =\u003e Evaluated::Value(Value::Str(\"ASC\".to_owned())),\n            };\n            f::sort(expr, order)\n        }\n        Function::Take { expr, size } =\u003e {\n            let expr = eval(expr).await?;\n            let size = eval(size).await?;\n            f::take(name, expr, size)\n        }\n        Function::Slice {\n            expr,\n            start,\n            length,\n        } =\u003e {\n            let expr = eval(expr).await?;\n            let start = eval(start).await?;\n            let length = eval(length).await?;\n            f::slice(name, expr, start, length)\n        }\n        Function::IsEmpty(expr) =\u003e {\n            let expr = eval(expr).await?;\n            f::is_empty(expr)\n        }\n        Function::AddMonth { expr, size } =\u003e {\n            let expr = eval(expr).await?;\n            let size = eval(size).await?;\n            f::add_month(name, expr, size)\n        }\n        Function::Length(expr) =\u003e f::length(name, eval(expr).await?),\n        Function::Entries(expr) =\u003e f::entries(name, eval(expr).await?),\n        Function::Keys(expr) =\u003e f::keys(eval(expr).await?),\n        Function::Values(expr) =\u003e {\n            let expr = eval(expr).await?;\n            f::values(expr)\n        }\n        Function::Splice {\n            list_data,\n            begin_index,\n            end_index,\n            values,\n        } =\u003e {\n            let list_data = eval(list_data).await?;\n            let begin_index = eval(begin_index).await?;\n            let end_index = eval(end_index).await?;\n            let values = match values {\n                Some(v) =\u003e Some(eval(v).await?),\n                None =\u003e None,\n            };\n            f::splice(name, list_data, begin_index, end_index, values)\n        }\n        Function::Dedup(list) =\u003e f::dedup(eval(list).await?),\n    };\n\n    match result {\n        ControlFlow::Continue(v) =\u003e Ok(v),\n        ControlFlow::Break(BreakCase::Null) =\u003e Ok(Evaluated::Value(Value::Null)),\n        ControlFlow::Break(BreakCase::Err(err)) =\u003e Err(err),\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":493},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","execute.rs"],"content":"use {\n    super::{\n        alter::{\n            CreateTableOptions, alter_table, create_index, create_table, delete_function,\n            drop_table, insert_function,\n        },\n        delete::delete,\n        fetch::fetch,\n        insert::insert,\n        select::{select, select_with_labels},\n        update::Update,\n        validate::{ColumnValidation, validate_unique},\n    },\n    crate::{\n        ast::{\n            AstLiteral, BinaryOperator, DataType, Dictionary, Expr, Query, SelectItem, SetExpr,\n            Statement, TableAlias, TableFactor, TableWithJoins, Variable,\n        },\n        data::{Key, Row, Schema, Value},\n        result::Result,\n        store::{GStore, GStoreMut},\n    },\n    futures::stream::{StreamExt, TryStreamExt},\n    serde::{Deserialize, Serialize},\n    std::{collections::HashMap, env::var, fmt::Debug, rc::Rc},\n    thiserror::Error as ThisError,\n};\n\n#[derive(ThisError, Serialize, Debug, PartialEq, Eq)]\npub enum ExecuteError {\n    #[error(\"table not found: {0}\")]\n    TableNotFound(String),\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]\npub enum Payload {\n    ShowColumns(Vec\u003c(String, DataType)\u003e),\n    Create,\n    Insert(usize),\n    Select {\n        labels: Vec\u003cString\u003e,\n        rows: Vec\u003cVec\u003cValue\u003e\u003e,\n    },\n    SelectMap(Vec\u003cHashMap\u003cString, Value\u003e\u003e),\n    Delete(usize),\n    Update(usize),\n    DropTable(usize),\n    DropFunction,\n    AlterTable,\n    CreateIndex,\n    DropIndex,\n    StartTransaction,\n    Commit,\n    Rollback,\n    ShowVariable(PayloadVariable),\n}\n\nimpl Payload {\n    /// Exports `select` payloads as an [`std::iter::Iterator`].\n    ///\n    /// The items of the Iterator are `HashMap\u003cColumn, Value\u003e`, and they are borrowed by default.\n    /// If ownership is required, you need to acquire them directly.\n    ///\n    /// - Some: [`Payload::Select`], [`Payload::SelectMap`]\n    /// - None: otherwise\n    pub fn select(\u0026self) -\u003e Option\u003cimpl Iterator\u003cItem = HashMap\u003c\u0026str, \u0026Value\u003e\u003e\u003e {\n        #[derive(iter_enum::Iterator)]\n        enum Iter\u003cI1, I2\u003e {\n            Schema(I1),\n            Schemaless(I2),\n        }\n\n        Some(match self {\n            Payload::Select { labels, rows } =\u003e Iter::Schema(rows.iter().map(move |row| {\n                labels\n                    .iter()\n                    .zip(row.iter())\n                    .map(|(label, value)| (label.as_str(), value))\n                    .collect::\u003cHashMap\u003c_, _\u003e\u003e()\n            })),\n            Payload::SelectMap(rows) =\u003e Iter::Schemaless(rows.iter().map(|row| {\n                row.iter()\n                    .map(|(k, v)| (k.as_str(), v))\n                    .collect::\u003cHashMap\u003c_, _\u003e\u003e()\n            })),\n            _ =\u003e return None,\n        })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]\npub enum PayloadVariable {\n    Tables(Vec\u003cString\u003e),\n    Functions(Vec\u003cString\u003e),\n    Version(String),\n}\n\npub async fn execute\u003cT: GStore + GStoreMut\u003e(\n    storage: \u0026mut T,\n    statement: \u0026Statement,\n) -\u003e Result\u003cPayload\u003e {\n    if matches!(\n        statement,\n        Statement::StartTransaction | Statement::Rollback | Statement::Commit\n    ) {\n        return execute_inner(storage, statement).await;\n    }\n\n    let autocommit = storage.begin(true).await?;\n    let result = execute_inner(storage, statement).await;\n\n    if !autocommit {\n        return result;\n    }\n\n    match result {\n        Ok(payload) =\u003e storage.commit().await.map(|_| payload),\n        Err(error) =\u003e {\n            storage.rollback().await?;\n\n            Err(error)\n        }\n    }\n}\n\nasync fn execute_inner\u003cT: GStore + GStoreMut\u003e(\n    storage: \u0026mut T,\n    statement: \u0026Statement,\n) -\u003e Result\u003cPayload\u003e {\n    match statement {\n        //- Modification\n        //-- Tables\n        Statement::CreateTable {\n            name,\n            columns,\n            if_not_exists,\n            source,\n            engine,\n            foreign_keys,\n            comment,\n        } =\u003e {\n            let options = CreateTableOptions {\n                target_table_name: name,\n                column_defs: columns.as_ref().map(Vec::as_slice),\n                if_not_exists: *if_not_exists,\n                source,\n                engine,\n                foreign_keys,\n                comment,\n            };\n\n            create_table(storage, options)\n                .await\n                .map(|_| Payload::Create)\n        }\n        Statement::DropTable {\n            names,\n            if_exists,\n            cascade,\n            ..\n        } =\u003e drop_table(storage, names, *if_exists, *cascade)\n            .await\n            .map(Payload::DropTable),\n        Statement::AlterTable { name, operation } =\u003e alter_table(storage, name, operation)\n            .await\n            .map(|_| Payload::AlterTable),\n        Statement::CreateIndex {\n            name,\n            table_name,\n            column,\n        } =\u003e create_index(storage, table_name, name, column)\n            .await\n            .map(|_| Payload::CreateIndex),\n        Statement::DropIndex { name, table_name } =\u003e storage\n            .drop_index(table_name, name)\n            .await\n            .map(|_| Payload::DropIndex),\n        //- Transaction\n        Statement::StartTransaction =\u003e storage\n            .begin(false)\n            .await\n            .map(|_| Payload::StartTransaction),\n        Statement::Commit =\u003e storage.commit().await.map(|_| Payload::Commit),\n        Statement::Rollback =\u003e storage.rollback().await.map(|_| Payload::Rollback),\n        //-- Rows\n        Statement::Insert {\n            table_name,\n            columns,\n            source,\n        } =\u003e insert(storage, table_name, columns, source)\n            .await\n            .map(Payload::Insert),\n        Statement::Update {\n            table_name,\n            selection,\n            assignments,\n        } =\u003e {\n            let Schema {\n                column_defs,\n                foreign_keys,\n                ..\n            } = storage\n                .fetch_schema(table_name)\n                .await?\n                .ok_or_else(|| ExecuteError::TableNotFound(table_name.to_owned()))?;\n\n            let all_columns = column_defs.as_deref().map(|columns| {\n                columns\n                    .iter()\n                    .map(|col_def| col_def.name.to_owned())\n                    .collect()\n            });\n            let columns_to_update: Vec\u003cString\u003e = assignments\n                .iter()\n                .map(|assignment| assignment.id.to_owned())\n                .collect();\n\n            let update = Update::new(storage, table_name, assignments, column_defs.as_deref())?;\n\n            let foreign_keys = Rc::new(foreign_keys);\n\n            let rows = fetch(storage, table_name, all_columns, selection.as_ref())\n                .await?\n                .and_then(|item| {\n                    let update = \u0026update;\n                    let (key, row) = item;\n\n                    let foreign_keys = Rc::clone(\u0026foreign_keys);\n                    async move {\n                        let row = update.apply(row, foreign_keys.as_ref()).await?;\n\n                        Ok((key, row))\n                    }\n                })\n                .try_collect::\u003cVec\u003c(Key, Row)\u003e\u003e()\n                .await?;\n\n            if let Some(column_defs) = column_defs {\n                let column_validation =\n                    ColumnValidation::SpecifiedColumns(\u0026column_defs, columns_to_update);\n                let rows = rows.iter().filter_map(|(_, row)| match row {\n                    Row::Vec { values, .. } =\u003e Some(values.as_slice()),\n                    Row::Map(_) =\u003e None,\n                });\n\n                validate_unique(storage, table_name, column_validation, rows).await?;\n            }\n\n            let num_rows = rows.len();\n            let rows = rows\n                .into_iter()\n                .map(|(key, row)| (key, row.into()))\n                .collect();\n\n            storage\n                .insert_data(table_name, rows)\n                .await\n                .map(|_| Payload::Update(num_rows))\n        }\n        Statement::Delete {\n            table_name,\n            selection,\n        } =\u003e delete(storage, table_name, selection).await,\n\n        //- Selection\n        Statement::Query(query) =\u003e {\n            let (labels, rows) = select_with_labels(storage, query, None).await?;\n\n            match labels {\n                Some(labels) =\u003e rows\n                    .map(|row| row?.try_into_vec())\n                    .try_collect::\u003cVec\u003c_\u003e\u003e()\n                    .await\n                    .map(|rows| Payload::Select { labels, rows }),\n                None =\u003e rows\n                    .map(|row| row?.try_into_map())\n                    .try_collect::\u003cVec\u003c_\u003e\u003e()\n                    .await\n                    .map(Payload::SelectMap),\n            }\n        }\n        Statement::ShowColumns { table_name } =\u003e {\n            let Schema { column_defs, .. } = storage\n                .fetch_schema(table_name)\n                .await?\n                .ok_or_else(|| ExecuteError::TableNotFound(table_name.to_owned()))?;\n\n            let output: Vec\u003c(String, DataType)\u003e = column_defs\n                .unwrap_or_default()\n                .into_iter()\n                .map(|key| (key.name, key.data_type))\n                .collect();\n\n            Ok(Payload::ShowColumns(output))\n        }\n        Statement::ShowIndexes(table_name) =\u003e {\n            let query = Query {\n                body: SetExpr::Select(Box::new(crate::ast::Select {\n                    projection: vec![SelectItem::Wildcard],\n                    from: TableWithJoins {\n                        relation: TableFactor::Dictionary {\n                            dict: Dictionary::GlueIndexes,\n                            alias: TableAlias {\n                                name: \"GLUE_INDEXES\".to_owned(),\n                                columns: Vec::new(),\n                            },\n                        },\n                        joins: Vec::new(),\n                    },\n                    selection: Some(Expr::BinaryOp {\n                        left: Box::new(Expr::Identifier(\"TABLE_NAME\".to_owned())),\n                        op: BinaryOperator::Eq,\n                        right: Box::new(Expr::Literal(AstLiteral::QuotedString(\n                            table_name.to_owned(),\n                        ))),\n                    }),\n                    group_by: Vec::new(),\n                    having: None,\n                })),\n                order_by: Vec::new(),\n                limit: None,\n                offset: None,\n            };\n\n            let (labels, rows) = select_with_labels(storage, \u0026query, None).await?;\n            let labels = labels.unwrap_or_default();\n            let rows = rows\n                .map(|row| row?.try_into_vec())\n                .try_collect::\u003cVec\u003c_\u003e\u003e()\n                .await?;\n\n            if rows.is_empty() {\n                return Err(ExecuteError::TableNotFound(table_name.to_owned()).into());\n            }\n\n            Ok(Payload::Select { labels, rows })\n        }\n        Statement::ShowVariable(variable) =\u003e match variable {\n            Variable::Tables =\u003e {\n                let query = Query {\n                    body: SetExpr::Select(Box::new(crate::ast::Select {\n                        projection: vec![SelectItem::Expr {\n                            expr: Expr::Identifier(\"TABLE_NAME\".to_owned()),\n                            label: \"TABLE_NAME\".to_owned(),\n                        }],\n                        from: TableWithJoins {\n                            relation: TableFactor::Dictionary {\n                                dict: Dictionary::GlueTables,\n                                alias: TableAlias {\n                                    name: \"GLUE_TABLES\".to_owned(),\n                                    columns: Vec::new(),\n                                },\n                            },\n                            joins: Vec::new(),\n                        },\n                        selection: None,\n                        group_by: Vec::new(),\n                        having: None,\n                    })),\n                    order_by: Vec::new(),\n                    limit: None,\n                    offset: None,\n                };\n\n                let table_names = select(storage, \u0026query, None)\n                    .await?\n                    .map(|row| row?.try_into_vec())\n                    .try_collect::\u003cVec\u003cVec\u003cValue\u003e\u003e\u003e()\n                    .await?\n                    .iter()\n                    .flat_map(|values| values.iter().map(|value| value.into()))\n                    .collect::\u003cVec\u003c_\u003e\u003e();\n\n                Ok(Payload::ShowVariable(PayloadVariable::Tables(table_names)))\n            }\n            Variable::Functions =\u003e {\n                let mut function_desc: Vec\u003c_\u003e = storage\n                    .fetch_all_functions()\n                    .await?\n                    .iter()\n                    .map(|f| f.to_str())\n                    .collect();\n                function_desc.sort();\n                Ok(Payload::ShowVariable(PayloadVariable::Functions(\n                    function_desc,\n                )))\n            }\n            Variable::Version =\u003e {\n                let version = var(\"CARGO_PKG_VERSION\")\n                    .unwrap_or_else(|_| env!(\"CARGO_PKG_VERSION\").to_owned());\n                let payload = Payload::ShowVariable(PayloadVariable::Version(version));\n\n                Ok(payload)\n            }\n        },\n        Statement::CreateFunction {\n            or_replace,\n            name,\n            args,\n            return_,\n        } =\u003e insert_function(storage, name, args, *or_replace, return_)\n            .await\n            .map(|_| Payload::Create),\n        Statement::DropFunction { if_exists, names } =\u003e delete_function(storage, names, *if_exists)\n            .await\n            .map(|_| Payload::DropFunction),\n    }\n}\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":190},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","fetch.rs"],"content":"use {\n    super::{context::RowContext, evaluate::evaluate_stateless, filter::check_expr},\n    crate::{\n        ast::{\n            ColumnDef, ColumnUniqueOption, Dictionary, Expr, IndexItem, Join, Query, Select,\n            SelectItem, SetExpr, TableAlias, TableFactor, TableWithJoins, ToSql, ToSqlUnquoted,\n            Values,\n        },\n        data::{Key, Row, Value, get_alias, get_index},\n        executor::{\n            evaluate::{Evaluated, evaluate},\n            select::select,\n        },\n        result::Result,\n        store::{DataRow, GStore},\n    },\n    async_recursion::async_recursion,\n    futures::{\n        future,\n        stream::{self, Stream, StreamExt, TryStreamExt},\n    },\n    serde::Serialize,\n    std::{borrow::Cow, collections::HashMap, fmt::Debug, iter, rc::Rc},\n    thiserror::Error as ThisError,\n};\n\n#[derive(ThisError, Serialize, Debug, PartialEq, Eq)]\npub enum FetchError {\n    #[error(\"table not found: {0}\")]\n    TableNotFound(String),\n\n    #[error(\"table alias not found: {0}\")]\n    TableAliasNotFound(String),\n\n    #[error(\"SERIES has wrong size: {0}\")]\n    SeriesSizeWrong(i64),\n\n    #[error(\"table '{0}' has {1} columns available but {2} column aliases specified\")]\n    TooManyColumnAliases(String, usize, usize),\n\n    #[error(\"unreachable\")]\n    Unreachable,\n}\n\npub async fn fetch\u003c'a, T: GStore\u003e(\n    storage: \u0026'a T,\n    table_name: \u0026'a str,\n    columns: Option\u003cRc\u003c[String]\u003e\u003e,\n    where_clause: Option\u003c\u0026'a Expr\u003e,\n) -\u003e Result\u003cimpl Stream\u003cItem = Result\u003c(Key, Row)\u003e\u003e + 'a\u003e {\n    let columns = columns.unwrap_or_else(|| Rc::from([]));\n    let rows = storage\n        .scan_data(table_name)\n        .await?\n        .try_filter_map(move |(key, data_row)| {\n            let row = match data_row {\n                DataRow::Vec(values) =\u003e Row::Vec {\n                    columns: Rc::clone(\u0026columns),\n                    values,\n                },\n                DataRow::Map(values) =\u003e Row::Map(values),\n            };\n\n            async move {\n                let expr = match where_clause {\n                    None =\u003e {\n                        return Ok(Some((key, row)));\n                    }\n                    Some(expr) =\u003e expr,\n                };\n\n                let context = RowContext::new(table_name, Cow::Borrowed(\u0026row), None);\n\n                check_expr(storage, Some(Rc::new(context)), None, expr)\n                    .await\n                    .map(|pass| pass.then_some((key, row)))\n            }\n        });\n\n    Ok(rows)\n}\n\n#[derive(futures_enum::Stream)]\npub enum Rows\u003cI1, I2, I3, I4\u003e {\n    Derived(I1),\n    Table(I2),\n    Series(I3),\n    Dictionary(I4),\n}\n\npub async fn fetch_relation_rows\u003c'a, T: GStore\u003e(\n    storage: \u0026'a T,\n    table_factor: \u0026'a TableFactor,\n    filter_context: \u0026Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n) -\u003e Result\u003cimpl Stream\u003cItem = Result\u003cRow\u003e\u003e + 'a\u003e {\n    let columns = Rc::from(\n        fetch_relation_columns(storage, table_factor)\n            .await?\n            .unwrap_or_default(),\n    );\n\n    match table_factor {\n        TableFactor::Derived { subquery, .. } =\u003e {\n            let filter_context = filter_context.as_ref().map(Rc::clone);\n            let rows =\n                select(storage, subquery, filter_context)\n                    .await?\n                    .map_ok(move |row| match row {\n                        Row::Vec { values, .. } =\u003e Row::Vec {\n                            columns: Rc::clone(\u0026columns),\n                            values,\n                        },\n                        Row::Map(values) =\u003e Row::Map(values),\n                    });\n\n            Ok(Rows::Derived(rows))\n        }\n        TableFactor::Table { name, .. } =\u003e {\n            let rows = {\n                #[derive(futures_enum::Stream)]\n                enum Rows\u003cI1, I2, I3, I4\u003e {\n                    Indexed(I1),\n                    PrimaryKey(I2),\n                    PrimaryKeyEmpty(I3),\n                    FullScan(I4),\n                }\n\n                match get_index(table_factor) {\n                    Some(IndexItem::NonClustered {\n                        name: index_name,\n                        asc,\n                        cmp_expr,\n                    }) =\u003e {\n                        let cmp_value = match cmp_expr {\n                            Some((op, expr)) =\u003e {\n                                let evaluated = evaluate(storage, None, None, expr).await?;\n\n                                Some((op, evaluated.try_into()?))\n                            }\n                            None =\u003e None,\n                        };\n\n                        let rows = storage\n                            .scan_indexed_data(name, index_name, *asc, cmp_value)\n                            .await?\n                            .map_ok(move |(_, data_row)| match data_row {\n                                DataRow::Vec(values) =\u003e Row::Vec {\n                                    columns: Rc::clone(\u0026columns),\n                                    values,\n                                },\n                                DataRow::Map(values) =\u003e Row::Map(values),\n                            });\n\n                        Rows::Indexed(rows)\n                    }\n                    Some(IndexItem::PrimaryKey(expr)) =\u003e {\n                        let schema = storage\n                            .fetch_schema(name)\n                            .await?\n                            .ok_or(FetchError::Unreachable)?;\n\n                        let filter_context = filter_context.as_ref().map(Rc::clone);\n                        let evaluated = evaluate(storage, filter_context, None, expr).await?;\n\n                        let value = match evaluated {\n                            Evaluated::Literal(literal) =\u003e {\n                                let data_type = schema\n                                    .column_defs\n                                    .as_ref()\n                                    .and_then(|column_defs| {\n                                        column_defs.iter().find(|column_def| {\n                                            column_def.unique.map(|u| u.is_primary) == Some(true)\n                                        })\n                                    })\n                                    .map(|column_def| \u0026column_def.data_type)\n                                    .ok_or(FetchError::Unreachable)?;\n\n                                Value::try_from_literal(data_type, \u0026literal)\n                            }\n                            eval =\u003e eval.try_into(),\n                        }?;\n                        let key = Key::try_from(value)?;\n\n                        match storage.fetch_data(name, \u0026key).await? {\n                            Some(data_row) =\u003e {\n                                let row = match data_row {\n                                    DataRow::Vec(values) =\u003e Row::Vec {\n                                        columns: Rc::clone(\u0026columns),\n                                        values,\n                                    },\n                                    DataRow::Map(values) =\u003e Row::Map(values),\n                                };\n\n                                Rows::PrimaryKey(stream::once(future::ready(Ok(row))))\n                            }\n                            None =\u003e Rows::PrimaryKeyEmpty(stream::empty()),\n                        }\n                    }\n                    _ =\u003e {\n                        let rows = storage.scan_data(name).await?.map_ok(move |(_, data_row)| {\n                            match data_row {\n                                DataRow::Vec(values) =\u003e Row::Vec {\n                                    columns: Rc::clone(\u0026columns),\n                                    values,\n                                },\n                                DataRow::Map(values) =\u003e Row::Map(values),\n                            }\n                        });\n\n                        Rows::FullScan(rows)\n                    }\n                }\n            };\n\n            Ok(Rows::Table(rows))\n        }\n        TableFactor::Series { size, .. } =\u003e {\n            let value: Value = evaluate_stateless(None, size).await?.try_into()?;\n            let size: i64 = value.try_into()?;\n            let size = match size {\n                n if n \u003e= 0 =\u003e size,\n                n =\u003e return Err(FetchError::SeriesSizeWrong(n).into()),\n            };\n\n            let columns = Rc::from(vec![\"N\".to_owned()]);\n            let rows = (1..=size).map(move |v| {\n                Ok(Row::Vec {\n                    columns: Rc::clone(\u0026columns),\n                    values: vec![Value::I64(v)],\n                })\n            });\n\n            Ok(Rows::Series(stream::iter(rows)))\n        }\n        TableFactor::Dictionary { dict, .. } =\u003e {\n            let rows = {\n                #[derive(futures_enum::Stream)]\n                enum Rows\u003cI1, I2, I3, I4\u003e {\n                    Tables(I1),\n                    TableColumns(I2),\n                    Indexes(I3),\n                    Objects(I4),\n                }\n\n                match dict {\n                    Dictionary::GlueObjects =\u003e {\n                        let schemas = storage.fetch_all_schemas().await?;\n                        let table_metas = storage\n                            .scan_table_meta()\n                            .await?\n                            .collect::\u003cResult\u003cHashMap\u003c_, _\u003e\u003e\u003e()?;\n                        let rows = schemas.into_iter().flat_map(move |schema| {\n                            let meta = table_metas\n                                .iter()\n                                .find_map(|(table_name, hash_map)| {\n                                    (table_name == \u0026schema.table_name).then(|| hash_map.clone())\n                                })\n                                .unwrap_or_default();\n\n                            let table_rows = HashMap::from([\n                                (\"OBJECT_NAME\".to_owned(), Value::Str(schema.table_name)),\n                                (\"OBJECT_TYPE\".to_owned(), Value::Str(\"TABLE\".to_owned())),\n                            ])\n                            .into_iter()\n                            .chain(meta)\n                            .collect::\u003cHashMap\u003c_, _\u003e\u003e();\n\n                            let index_rows = schema.indexes.into_iter().map(|index| {\n                                HashMap::from([\n                                    (\"OBJECT_NAME\".to_owned(), Value::Str(index.name)),\n                                    (\"OBJECT_TYPE\".to_owned(), Value::Str(\"INDEX\".to_owned())),\n                                ])\n                            });\n\n                            iter::once(table_rows)\n                                .chain(index_rows)\n                                .map(|hash_map| Ok(Row::Map(hash_map)))\n                        });\n\n                        Rows::Objects(stream::iter(rows))\n                    }\n                    Dictionary::GlueTables =\u003e {\n                        let schemas = storage.fetch_all_schemas().await?;\n                        let rows = schemas.into_iter().map(move |schema| {\n                            Ok(Row::Vec {\n                                columns: Rc::clone(\u0026columns),\n                                values: vec![\n                                    Value::Str(schema.table_name),\n                                    schema.comment.map(Value::Str).unwrap_or(Value::Null),\n                                ],\n                            })\n                        });\n\n                        Rows::Tables(stream::iter(rows))\n                    }\n                    Dictionary::GlueTableColumns =\u003e {\n                        let schemas = storage.fetch_all_schemas().await?;\n                        let rows = schemas.into_iter().flat_map(move |schema| {\n                            let columns = Rc::clone(\u0026columns);\n                            let table_name = schema.table_name;\n\n                            schema\n                                .column_defs\n                                .unwrap_or_default()\n                                .into_iter()\n                                .enumerate()\n                                .map(move |(index, column_def)| {\n                                    let values = vec![\n                                        Value::Str(table_name.clone()),\n                                        Value::Str(column_def.name),\n                                        Value::I64(index as i64 + 1),\n                                        Value::Bool(column_def.nullable),\n                                        column_def\n                                            .unique\n                                            .map(|unique| Value::Str(unique.to_sql()))\n                                            .unwrap_or(Value::Null),\n                                        column_def\n                                            .default\n                                            .map(|expr| Value::Str(expr.to_sql()))\n                                            .unwrap_or(Value::Null),\n                                        column_def.comment.map(Value::Str).unwrap_or(Value::Null),\n                                    ];\n\n                                    Ok(Row::Vec {\n                                        columns: Rc::clone(\u0026columns),\n                                        values,\n                                    })\n                                })\n                        });\n\n                        Rows::TableColumns(stream::iter(rows))\n                    }\n                    Dictionary::GlueIndexes =\u003e {\n                        let schemas = storage.fetch_all_schemas().await?;\n                        let rows = schemas.into_iter().flat_map(move |schema| {\n                            let column_defs = schema.column_defs.unwrap_or_default();\n                            let primary_column = column_defs.iter().find_map(|column_def| {\n                                let ColumnDef { name, unique, .. } = column_def;\n\n                                (unique == \u0026Some(ColumnUniqueOption { is_primary: true }))\n                                    .then_some(name)\n                            });\n\n                            let clustered = match primary_column {\n                                Some(column_name) =\u003e {\n                                    let values = vec![\n                                        Value::Str(schema.table_name.clone()),\n                                        Value::Str(\"PRIMARY\".to_owned()),\n                                        Value::Str(\"BOTH\".to_owned()),\n                                        Value::Str(column_name.to_owned()),\n                                        Value::Bool(true),\n                                    ];\n\n                                    let row = Row::Vec {\n                                        columns: Rc::clone(\u0026columns),\n                                        values,\n                                    };\n\n                                    vec![Ok(row)]\n                                }\n                                None =\u003e Vec::new(),\n                            };\n\n                            let columns = Rc::clone(\u0026columns);\n                            let non_clustered = schema.indexes.into_iter().map(move |index| {\n                                let values = vec![\n                                    Value::Str(schema.table_name.clone()),\n                                    Value::Str(index.name),\n                                    Value::Str(index.order.to_string()),\n                                    Value::Str(index.expr.to_sql_unquoted()),\n                                    Value::Bool(false),\n                                ];\n\n                                Ok(Row::Vec {\n                                    columns: Rc::clone(\u0026columns),\n                                    values,\n                                })\n                            });\n\n                            clustered.into_iter().chain(non_clustered)\n                        });\n\n                        Rows::Indexes(stream::iter(rows))\n                    }\n                }\n            };\n\n            Ok(Rows::Dictionary(rows))\n        }\n    }\n}\n\npub async fn fetch_columns\u003cT: GStore\u003e(\n    storage: \u0026T,\n    table_name: \u0026str,\n) -\u003e Result\u003cOption\u003cVec\u003cString\u003e\u003e\u003e {\n    let columns = storage\n        .fetch_schema(table_name)\n        .await?\n        .ok_or_else(|| FetchError::TableNotFound(table_name.to_owned()))?\n        .column_defs\n        .map(|column_defs| {\n            column_defs\n                .into_iter()\n                .map(|column_def| column_def.name)\n                .collect()\n        });\n\n    Ok(columns)\n}\n\n#[async_recursion(?Send)]\npub async fn fetch_relation_columns\u003cT\u003e(\n    storage: \u0026T,\n    table_factor: \u0026TableFactor,\n) -\u003e Result\u003cOption\u003cVec\u003cString\u003e\u003e\u003e\nwhere\n    T: GStore,\n{\n    match table_factor {\n        TableFactor::Table { name, alias, .. } =\u003e {\n            let columns = fetch_columns(storage, name).await?;\n            match (columns, alias) {\n                (columns, None) =\u003e Ok(columns),\n                (None, Some(_)) =\u003e Ok(None),\n                (Some(columns), Some(alias)) if alias.columns.len() \u003e columns.len() =\u003e {\n                    Err(FetchError::TooManyColumnAliases(\n                        name.to_string(),\n                        columns.len(),\n                        alias.columns.len(),\n                    )\n                    .into())\n                }\n                (Some(columns), Some(alias)) =\u003e Ok(Some(\n                    alias\n                        .columns\n                        .iter()\n                        .cloned()\n                        .chain(columns[alias.columns.len()..columns.len()].to_vec())\n                        .collect(),\n                )),\n            }\n        }\n        TableFactor::Series { .. } =\u003e Ok(Some(vec![\"N\".to_owned()])),\n        TableFactor::Dictionary { dict, .. } =\u003e Ok(Some(match dict {\n            Dictionary::GlueObjects =\u003e vec![\n                \"OBJECT_NAME\".to_owned(),\n                \"OBJECT_TYPE\".to_owned(),\n                \"CREATED\".to_owned(),\n            ],\n            Dictionary::GlueTables =\u003e vec![\"TABLE_NAME\".to_owned(), \"COMMENT\".to_owned()],\n            Dictionary::GlueTableColumns =\u003e vec![\n                \"TABLE_NAME\".to_owned(),\n                \"COLUMN_NAME\".to_owned(),\n                \"COLUMN_ID\".to_owned(),\n                \"NULLABLE\".to_owned(),\n                \"KEY\".to_owned(),\n                \"DEFAULT\".to_owned(),\n                \"COMMENT\".to_owned(),\n            ],\n            Dictionary::GlueIndexes =\u003e vec![\n                \"TABLE_NAME\".to_owned(),\n                \"INDEX_NAME\".to_owned(),\n                \"ORDER\".to_owned(),\n                \"EXPRESSION\".to_owned(),\n                \"UNIQUENESS\".to_owned(),\n            ],\n        })),\n        TableFactor::Derived {\n            subquery: Query { body, .. },\n            alias:\n                TableAlias {\n                    columns: alias_columns,\n                    name,\n                },\n        } =\u003e match body {\n            SetExpr::Select(statement) =\u003e {\n                let Select {\n                    from:\n                        TableWithJoins {\n                            relation, joins, ..\n                        },\n                    projection,\n                    ..\n                } = statement.as_ref();\n\n                let labels = fetch_labels(storage, relation, joins, projection).await?;\n                match labels {\n                    None =\u003e Ok(None),\n                    Some(labels) if alias_columns.is_empty() =\u003e Ok(Some(labels)),\n                    Some(labels) if alias_columns.len() \u003e labels.len() =\u003e {\n                        Err(FetchError::TooManyColumnAliases(\n                            name.to_string(),\n                            labels.len(),\n                            alias_columns.len(),\n                        )\n                        .into())\n                    }\n                    Some(labels) =\u003e Ok(Some(\n                        alias_columns\n                            .iter()\n                            .cloned()\n                            .chain(labels[alias_columns.len()..labels.len()].to_vec())\n                            .collect(),\n                    )),\n                }\n            }\n            SetExpr::Values(Values(values_list)) =\u003e {\n                let total_len = values_list[0].len();\n                let alias_len = alias_columns.len();\n                if alias_len \u003e total_len {\n                    return Err(FetchError::TooManyColumnAliases(\n                        name.into(),\n                        total_len,\n                        alias_len,\n                    )\n                    .into());\n                }\n                let labels = (alias_len + 1..=total_len).map(|i| format!(\"column{}\", i));\n                let labels = alias_columns\n                    .iter()\n                    .cloned()\n                    .chain(labels)\n                    .collect::\u003cVec\u003c_\u003e\u003e();\n\n                Ok(Some(labels))\n            }\n        },\n    }\n}\n\nasync fn fetch_join_columns\u003c'a, T: GStore\u003e(\n    storage: \u0026T,\n    joins: \u0026'a [Join],\n) -\u003e Result\u003cOption\u003cVec\u003c(\u0026'a String, Vec\u003cString\u003e)\u003e\u003e\u003e {\n    let columns = stream::iter(joins)\n        .filter_map(|join| async {\n            let relation = \u0026join.relation;\n            let alias = get_alias(relation);\n\n            fetch_relation_columns(storage, relation)\n                .await\n                .map(|columns| Some((alias, columns?)))\n                .transpose()\n        })\n        .try_collect::\u003cVec\u003c_\u003e\u003e()\n        .await?;\n\n    Ok((columns.len() == joins.len()).then_some(columns))\n}\n\npub async fn fetch_labels\u003cT: GStore\u003e(\n    storage: \u0026T,\n    relation: \u0026TableFactor,\n    joins: \u0026[Join],\n    projection: \u0026[SelectItem],\n) -\u003e Result\u003cOption\u003cVec\u003cString\u003e\u003e\u003e {\n    let table_alias = get_alias(relation);\n    let columns = fetch_relation_columns(storage, relation).await?;\n    let join_columns = fetch_join_columns(storage, joins).await?;\n\n    if (columns.is_none() || join_columns.is_none())\n        \u0026\u0026 projection.iter().any(|item| {\n            matches!(\n                item,\n                SelectItem::Wildcard | SelectItem::QualifiedWildcard(_)\n            )\n        })\n    {\n        return Ok(None);\n    }\n\n    let columns = columns.unwrap_or_default();\n    let join_columns = join_columns.unwrap_or_default();\n\n    projection\n        .iter()\n        .flat_map(|item| match item {\n            SelectItem::Wildcard =\u003e {\n                let columns = columns.iter().cloned();\n                let join_columns = join_columns.iter().flat_map(|(_, columns)| columns.clone());\n\n                columns.chain(join_columns).map(Ok).collect()\n            }\n            SelectItem::QualifiedWildcard(target_table_alias) =\u003e {\n                if table_alias == target_table_alias {\n                    return columns.iter().cloned().map(Ok).collect();\n                }\n\n                let labels = join_columns\n                    .iter()\n                    .find(|(table_alias, _)| table_alias == \u0026target_table_alias)\n                    .map(|(_, columns)| columns.clone());\n\n                match labels {\n                    Some(columns) =\u003e columns.into_iter().map(Ok).collect(),\n                    None =\u003e {\n                        vec![Err(FetchError::TableAliasNotFound(\n                            target_table_alias.to_owned(),\n                        )\n                        .into())]\n                    }\n                }\n            }\n            SelectItem::Expr { label, .. } =\u003e vec![Ok(label.to_owned())],\n        })\n        .collect::\u003cResult\u003c_\u003e\u003e()\n        .map(Some)\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":346},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","filter.rs"],"content":"use {\n    super::{context::RowContext, evaluate::evaluate},\n    crate::{\n        ast::{Aggregate, Expr},\n        data::Value,\n        result::Result,\n        store::GStore,\n    },\n    im_rc::HashMap,\n    std::rc::Rc,\n};\n\npub struct Filter\u003c'a, T: GStore\u003e {\n    storage: \u0026'a T,\n    where_clause: Option\u003c\u0026'a Expr\u003e,\n    context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n    aggregated: Option\u003cRc\u003cHashMap\u003c\u0026'a Aggregate, Value\u003e\u003e\u003e,\n}\n\nimpl\u003c'a, T: GStore\u003e Filter\u003c'a, T\u003e {\n    pub fn new(\n        storage: \u0026'a T,\n        where_clause: Option\u003c\u0026'a Expr\u003e,\n        context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n        aggregated: Option\u003cRc\u003cHashMap\u003c\u0026'a Aggregate, Value\u003e\u003e\u003e,\n    ) -\u003e Self {\n        Self {\n            storage,\n            where_clause,\n            context,\n            aggregated,\n        }\n    }\n\n    pub async fn check(\u0026self, project_context: Rc\u003cRowContext\u003c'a\u003e\u003e) -\u003e Result\u003cbool\u003e {\n        match self.where_clause {\n            Some(expr) =\u003e {\n                let context = match \u0026self.context {\n                    Some(context) =\u003e {\n                        Rc::new(RowContext::concat(project_context, Rc::clone(context)))\n                    }\n                    None =\u003e project_context,\n                };\n                let context = Some(context);\n                let aggregated = self.aggregated.as_ref().map(Rc::clone);\n\n                check_expr(self.storage, context, aggregated, expr).await\n            }\n            None =\u003e Ok(true),\n        }\n    }\n}\n\npub async fn check_expr\u003c'a, T: GStore\u003e(\n    storage: \u0026'a T,\n    context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n    aggregated: Option\u003cRc\u003cHashMap\u003c\u0026'a Aggregate, Value\u003e\u003e\u003e,\n    expr: \u0026'a Expr,\n) -\u003e Result\u003cbool\u003e {\n    evaluate(storage, context, aggregated, expr)\n        .await\n        .map(|evaluated| evaluated.try_into())?\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","insert.rs"],"content":"use {\n    super::{\n        select::select,\n        validate::{ColumnValidation, validate_unique},\n    },\n    crate::{\n        ast::{ColumnDef, ColumnUniqueOption, Expr, ForeignKey, Query, SetExpr, Values},\n        data::{Key, Row, Schema, Value},\n        executor::{evaluate::evaluate_stateless, limit::Limit},\n        result::Result,\n        store::{DataRow, GStore, GStoreMut},\n    },\n    futures::stream::{self, StreamExt, TryStreamExt},\n    serde::Serialize,\n    std::{fmt::Debug, rc::Rc},\n    thiserror::Error as ThisError,\n};\n\n#[derive(ThisError, Serialize, Debug, PartialEq, Eq)]\npub enum InsertError {\n    #[error(\"table not found: {0}\")]\n    TableNotFound(String),\n\n    #[error(\"lack of required column: {0}\")]\n    LackOfRequiredColumn(String),\n\n    #[error(\"wrong column name: {0}\")]\n    WrongColumnName(String),\n\n    #[error(\"column and values not matched\")]\n    ColumnAndValuesNotMatched,\n\n    #[error(\"literals have more values than target columns\")]\n    TooManyValues,\n\n    #[error(\"only single value accepted for schemaless row insert\")]\n    OnlySingleValueAcceptedForSchemalessRow,\n\n    #[error(\"map type required: {0}\")]\n    MapTypeValueRequired(String),\n\n    #[error(\n        \"cannot find referenced value on {table_name}.{column_name} with value {referenced_value:?}\"\n    )]\n    CannotFindReferencedValue {\n        table_name: String,\n        column_name: String,\n        referenced_value: String,\n    },\n\n    #[error(\"unreachable referencing column name: {0}\")]\n    ConflictReferencingColumnName(String),\n}\n\nenum RowsData {\n    Append(Vec\u003cDataRow\u003e),\n    Insert(Vec\u003c(Key, DataRow)\u003e),\n}\n\npub async fn insert\u003cT: GStore + GStoreMut\u003e(\n    storage: \u0026mut T,\n    table_name: \u0026str,\n    columns: \u0026[String],\n    source: \u0026Query,\n) -\u003e Result\u003cusize\u003e {\n    let Schema {\n        column_defs,\n        foreign_keys,\n        ..\n    } = storage\n        .fetch_schema(table_name)\n        .await?\n        .ok_or_else(|| InsertError::TableNotFound(table_name.to_owned()))?;\n\n    let rows = match column_defs {\n        Some(column_defs) =\u003e {\n            fetch_vec_rows(\n                storage,\n                table_name,\n                column_defs,\n                columns,\n                source,\n                foreign_keys,\n            )\n            .await\n        }\n        None =\u003e fetch_map_rows(storage, source).await.map(RowsData::Append),\n    }?;\n\n    match rows {\n        RowsData::Append(rows) =\u003e {\n            let num_rows = rows.len();\n\n            storage\n                .append_data(table_name, rows)\n                .await\n                .map(|_| num_rows)\n        }\n        RowsData::Insert(rows) =\u003e {\n            let num_rows = rows.len();\n\n            storage\n                .insert_data(table_name, rows)\n                .await\n                .map(|_| num_rows)\n        }\n    }\n}\n\nasync fn fetch_vec_rows\u003cT: GStore\u003e(\n    storage: \u0026T,\n    table_name: \u0026str,\n    column_defs: Vec\u003cColumnDef\u003e,\n    columns: \u0026[String],\n    source: \u0026Query,\n    foreign_keys: Vec\u003cForeignKey\u003e,\n) -\u003e Result\u003cRowsData\u003e {\n    let labels = Rc::from(\n        column_defs\n            .iter()\n            .map(|column_def| column_def.name.to_owned())\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n    );\n    let column_defs = Rc::from(column_defs);\n    let column_validation = ColumnValidation::All(\u0026column_defs);\n\n    #[derive(futures_enum::Stream)]\n    enum Rows\u003cI1, I2\u003e {\n        Values(I1),\n        Select(I2),\n    }\n\n    let rows = match \u0026source.body {\n        SetExpr::Values(Values(values_list)) =\u003e {\n            let limit = Limit::new(source.limit.as_ref(), source.offset.as_ref()).await?;\n            let rows = stream::iter(values_list).then(|values| {\n                let column_defs = Rc::clone(\u0026column_defs);\n                let labels = Rc::clone(\u0026labels);\n\n                async move {\n                    Ok(Row::Vec {\n                        columns: labels,\n                        values: fill_values(\u0026column_defs, columns, values).await?,\n                    })\n                }\n            });\n            let rows = limit.apply(rows);\n            let rows = rows.map(|row| row?.try_into_vec());\n\n            Rows::Values(rows)\n        }\n        SetExpr::Select(_) =\u003e {\n            let rows = select(storage, source, None).await?.map(|row| {\n                let values = row?.try_into_vec()?;\n\n                column_defs\n                    .iter()\n                    .zip(values.iter())\n                    .try_for_each(|(column_def, value)| {\n                        let ColumnDef {\n                            data_type,\n                            nullable,\n                            ..\n                        } = column_def;\n\n                        value.validate_type(data_type)?;\n                        value.validate_null(*nullable)\n                    })?;\n\n                Ok(values)\n            });\n\n            Rows::Select(rows)\n        }\n    }\n    .try_collect::\u003cVec\u003cVec\u003cValue\u003e\u003e\u003e()\n    .await?;\n\n    validate_unique(\n        storage,\n        table_name,\n        column_validation,\n        rows.iter().map(|values| values.as_slice()),\n    )\n    .await?;\n\n    validate_foreign_key(storage, \u0026column_defs, foreign_keys, \u0026rows).await?;\n\n    let primary_key = column_defs.iter().position(|ColumnDef { unique, .. }| {\n        unique == \u0026Some(ColumnUniqueOption { is_primary: true })\n    });\n\n    match primary_key {\n        Some(i) =\u003e rows\n            .into_iter()\n            .filter_map(|values| {\n                values\n                    .get(i)\n                    .map(Key::try_from)\n                    .map(|result| result.map(|key| (key, values.into())))\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n            .map(RowsData::Insert),\n        None =\u003e Ok(RowsData::Append(rows.into_iter().map(Into::into).collect())),\n    }\n}\n\nasync fn validate_foreign_key\u003cT: GStore\u003e(\n    storage: \u0026T,\n    column_defs: \u0026Rc\u003c[ColumnDef]\u003e,\n    foreign_keys: Vec\u003cForeignKey\u003e,\n    rows: \u0026[Vec\u003cValue\u003e],\n) -\u003e Result\u003c()\u003e {\n    for foreign_key in foreign_keys {\n        let ForeignKey {\n            referencing_column_name,\n            referenced_table_name,\n            referenced_column_name,\n            ..\n        } = \u0026foreign_key;\n\n        let target_index = column_defs\n            .iter()\n            .enumerate()\n            .find(|(_, c)| \u0026c.name == referencing_column_name)\n            .ok_or_else(|| {\n                InsertError::ConflictReferencingColumnName(referencing_column_name.to_owned())\n            })?;\n\n        for row in rows.iter() {\n            let value =\n                row.get(target_index.0)\n                    .ok_or(InsertError::ConflictReferencingColumnName(\n                        referencing_column_name.to_owned(),\n                    ))?;\n\n            if value == \u0026Value::Null {\n                continue;\n            }\n\n            let no_referenced = storage\n                .fetch_data(referenced_table_name, \u0026Key::try_from(value)?)\n                .await?\n                .is_none();\n\n            if no_referenced {\n                return Err(InsertError::CannotFindReferencedValue {\n                    table_name: referenced_table_name.to_owned(),\n                    column_name: referenced_column_name.to_owned(),\n                    referenced_value: String::from(value),\n                }\n                .into());\n            }\n        }\n    }\n\n    Ok(())\n}\n\nasync fn fetch_map_rows\u003cT: GStore\u003e(storage: \u0026T, source: \u0026Query) -\u003e Result\u003cVec\u003cDataRow\u003e\u003e {\n    #[derive(futures_enum::Stream)]\n    enum Rows\u003cI1, I2\u003e {\n        Values(I1),\n        Select(I2),\n    }\n\n    let rows = match \u0026source.body {\n        SetExpr::Values(Values(values_list)) =\u003e {\n            let limit = Limit::new(source.limit.as_ref(), source.offset.as_ref()).await?;\n            let rows = stream::iter(values_list).then(|values| async move {\n                if values.len() \u003e 1 {\n                    return Err(InsertError::OnlySingleValueAcceptedForSchemalessRow.into());\n                }\n\n                evaluate_stateless(None, \u0026values[0])\n                    .await?\n                    .try_into()\n                    .map(Row::Map)\n            });\n            let rows = limit.apply(rows);\n            let rows = rows.map_ok(Into::into);\n\n            Rows::Values(rows)\n        }\n        SetExpr::Select(_) =\u003e {\n            let rows = select(storage, source, None).await?.map(|row| {\n                let row = row?;\n\n                if let Row::Vec { values, .. } = \u0026row {\n                    if values.len() \u003e 1 {\n                        return Err(InsertError::OnlySingleValueAcceptedForSchemalessRow.into());\n                    } else if !matches!(\u0026values[0], Value::Map(_)) {\n                        return Err(InsertError::MapTypeValueRequired((\u0026values[0]).into()).into());\n                    }\n                }\n\n                Ok(row.into())\n            });\n\n            Rows::Select(rows)\n        }\n    }\n    .try_collect::\u003cVec\u003cDataRow\u003e\u003e()\n    .await?;\n\n    Ok(rows)\n}\n\nasync fn fill_values(\n    column_defs: \u0026[ColumnDef],\n    columns: \u0026[String],\n    values: \u0026[Expr],\n) -\u003e Result\u003cVec\u003cValue\u003e\u003e {\n    if !columns.is_empty() \u0026\u0026 values.len() != columns.len() {\n        return Err(InsertError::ColumnAndValuesNotMatched.into());\n    } else if values.len() \u003e column_defs.len() {\n        return Err(InsertError::TooManyValues.into());\n    }\n\n    if let Some(wrong_column_name) = columns.iter().find(|column_name| {\n        !column_defs\n            .iter()\n            .any(|column_def| \u0026\u0026column_def.name == column_name)\n    }) {\n        return Err(InsertError::WrongColumnName(wrong_column_name.to_owned()).into());\n    }\n\n    #[derive(iter_enum::Iterator)]\n    enum Columns\u003cI1, I2\u003e {\n        All(I1),\n        Specified(I2),\n    }\n\n    let columns = if columns.is_empty() {\n        Columns::All(column_defs.iter().map(|ColumnDef { name, .. }| name))\n    } else {\n        Columns::Specified(columns.iter())\n    };\n\n    let column_name_value_list = columns.zip(values.iter()).collect::\u003cVec\u003c(_, _)\u003e\u003e();\n\n    let values = stream::iter(column_defs)\n        .then(|column_def| {\n            let column_name_value_list = \u0026column_name_value_list;\n\n            async move {\n                let ColumnDef {\n                    name: def_name,\n                    data_type,\n                    nullable,\n                    ..\n                } = column_def;\n\n                let value = column_name_value_list\n                    .iter()\n                    .find(|(name, _)| name == \u0026def_name)\n                    .map(|(_, value)| value);\n\n                match (value, \u0026column_def.default, nullable) {\n                    (Some(\u0026expr), _, _) | (None, Some(expr), _) =\u003e evaluate_stateless(None, expr)\n                        .await?\n                        .try_into_value(data_type, *nullable),\n                    (None, None, true) =\u003e Ok(Value::Null),\n                    (None, None, false) =\u003e {\n                        Err(InsertError::LackOfRequiredColumn(def_name.to_owned()).into())\n                    }\n                }\n            }\n        })\n        .try_collect::\u003cVec\u003cValue\u003e\u003e()\n        .await?;\n\n    Ok(values)\n}\n","traces":[{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":177},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","join.rs"],"content":"use {\n    super::fetch::{fetch_relation_columns, fetch_relation_rows},\n    crate::{\n        ast::{\n            Expr, Join as AstJoin, JoinConstraint, JoinExecutor as AstJoinExecutor,\n            JoinOperator as AstJoinOperator, TableFactor,\n        },\n        data::{Key, Row, Value, get_alias},\n        executor::{context::RowContext, evaluate::evaluate, filter::check_expr},\n        result::Result,\n        store::GStore,\n    },\n    futures::{\n        future,\n        stream::{self, Stream, StreamExt, TryStreamExt, empty, once},\n    },\n    itertools::Itertools,\n    std::{borrow::Cow, collections::HashMap, pin::Pin, rc::Rc},\n    utils::OrStream,\n};\n\npub struct Join\u003c'a, T: GStore\u003e {\n    storage: \u0026'a T,\n    join_clauses: \u0026'a [AstJoin],\n    filter_context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n}\n\ntype JoinItem\u003c'a\u003e = Rc\u003cRowContext\u003c'a\u003e\u003e;\ntype Joined\u003c'a\u003e = Pin\u003cBox\u003cdyn Stream\u003cItem = Result\u003cJoinItem\u003c'a\u003e\u003e\u003e + 'a\u003e\u003e;\n\nimpl\u003c'a, T: GStore\u003e Join\u003c'a, T\u003e {\n    pub fn new(\n        storage: \u0026'a T,\n        join_clauses: \u0026'a [AstJoin],\n        filter_context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n    ) -\u003e Self {\n        Self {\n            storage,\n            join_clauses,\n            filter_context,\n        }\n    }\n\n    pub async fn apply(\n        self,\n        rows: impl Stream\u003cItem = Result\u003cRowContext\u003c'a\u003e\u003e\u003e + 'a,\n    ) -\u003e Result\u003cJoined\u003c'a\u003e\u003e {\n        let init_rows: Joined = Box::pin(rows.map(|row| row.map(Rc::new)));\n\n        stream::iter(self.join_clauses)\n            .map(Ok)\n            .try_fold(init_rows, |rows, join_clause| {\n                let filter_context = self.filter_context.as_ref().map(Rc::clone);\n\n                async move { join(self.storage, filter_context, join_clause, rows).await }\n            })\n            .await\n    }\n}\n\nasync fn join\u003c'a, T: GStore\u003e(\n    storage: \u0026'a T,\n    filter_context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n    ast_join: \u0026'a AstJoin,\n    left_rows: impl Stream\u003cItem = Result\u003cJoinItem\u003c'a\u003e\u003e\u003e + 'a,\n) -\u003e Result\u003cJoined\u003c'a\u003e\u003e {\n    let AstJoin {\n        relation,\n        join_operator,\n        join_executor,\n    } = ast_join;\n\n    let table_alias = get_alias(relation);\n    let join_executor = JoinExecutor::new(\n        storage,\n        relation,\n        filter_context.as_ref().map(Rc::clone),\n        join_executor,\n    )\n    .await\n    .map(Rc::new)?;\n\n    let (join_operator, where_clause) = match join_operator {\n        AstJoinOperator::Inner(JoinConstraint::None) =\u003e (JoinOperator::Inner, None),\n        AstJoinOperator::Inner(JoinConstraint::On(where_clause)) =\u003e {\n            (JoinOperator::Inner, Some(where_clause))\n        }\n        AstJoinOperator::LeftOuter(JoinConstraint::None) =\u003e (JoinOperator::LeftOuter, None),\n        AstJoinOperator::LeftOuter(JoinConstraint::On(where_clause)) =\u003e {\n            (JoinOperator::LeftOuter, Some(where_clause))\n        }\n    };\n\n    let columns = fetch_relation_columns(storage, relation)\n        .await?\n        .map(Rc::from);\n    let rows = left_rows.and_then(move |project_context| {\n        let init_context = {\n            let init_row = match columns.as_ref() {\n                Some(columns) =\u003e Row::Vec {\n                    columns: Rc::clone(columns),\n                    values: columns.iter().map(|_| Value::Null).collect(),\n                },\n                None =\u003e Row::Map(HashMap::new()),\n            };\n\n            Rc::new(RowContext::new(\n                table_alias,\n                Cow::Owned(init_row),\n                Some(Rc::clone(\u0026project_context)),\n            ))\n        };\n        let filter_context = filter_context.as_ref().map(Rc::clone);\n        let join_executor = Rc::clone(\u0026join_executor);\n\n        async move {\n            let filter_context = match filter_context {\n                Some(filter_context) =\u003e Rc::new(RowContext::concat(\n                    Rc::clone(\u0026project_context),\n                    Rc::clone(\u0026filter_context),\n                )),\n                None =\u003e Rc::clone(\u0026project_context),\n            };\n            let filter_context = Some(filter_context);\n\n            #[derive(futures_enum::Stream)]\n            enum Rows\u003cI1, I2, I3\u003e {\n                NestedLoop(I1),\n                Hash(I2),\n                Empty(I3),\n            }\n            let rows = match join_executor.as_ref() {\n                JoinExecutor::NestedLoop =\u003e {\n                    let rows = fetch_relation_rows(storage, relation, \u0026filter_context)\n                        .await?\n                        .and_then(|row| future::ok(Cow::Owned(row)))\n                        .try_filter_map(move |row| {\n                            check_where_clause(\n                                storage,\n                                table_alias,\n                                filter_context.as_ref().map(Rc::clone),\n                                Some(Rc::clone(\u0026project_context)),\n                                where_clause,\n                                row,\n                            )\n                        });\n                    Rows::NestedLoop(rows)\n                }\n                JoinExecutor::Hash {\n                    rows_map,\n                    value_expr,\n                } =\u003e {\n                    let rows = evaluate(\n                        storage,\n                        filter_context.as_ref().map(Rc::clone),\n                        None,\n                        value_expr,\n                    )\n                    .await\n                    .map(Key::try_from)?\n                    .map(|hash_key| rows_map.get(\u0026hash_key))?;\n\n                    match rows {\n                        None =\u003e Rows::Empty(empty()),\n                        Some(rows) =\u003e {\n                            let rows = stream::iter(rows)\n                                .filter_map(|row| {\n                                    let filter_context = filter_context.as_ref().map(Rc::clone);\n                                    let project_context = Some(Rc::clone(\u0026project_context));\n\n                                    async {\n                                        check_where_clause(\n                                            storage,\n                                            table_alias,\n                                            filter_context,\n                                            project_context,\n                                            where_clause,\n                                            Cow::Borrowed(row),\n                                        )\n                                        .await\n                                        .transpose()\n                                    }\n                                })\n                                .collect::\u003cVec\u003c_\u003e\u003e()\n                                .await;\n\n                            Rows::Hash(stream::iter(rows))\n                        }\n                    }\n                }\n            };\n\n            let rows: Joined = match join_operator {\n                JoinOperator::Inner =\u003e Box::pin(rows),\n                JoinOperator::LeftOuter =\u003e {\n                    let init_rows = once(async { Ok(init_context) });\n\n                    Box::pin(OrStream::new(rows, init_rows))\n                }\n            };\n\n            Ok(rows)\n        }\n    });\n\n    Ok(Box::pin(rows.try_flatten()))\n}\n\n#[derive(Copy, Clone)]\nenum JoinOperator {\n    Inner,\n    LeftOuter,\n}\n\nenum JoinExecutor\u003c'a\u003e {\n    NestedLoop,\n    Hash {\n        rows_map: HashMap\u003cKey, Vec\u003cRow\u003e\u003e,\n        value_expr: \u0026'a Expr,\n    },\n}\n\nimpl\u003c'a\u003e JoinExecutor\u003c'a\u003e {\n    async fn new\u003cT: GStore\u003e(\n        storage: \u0026'a T,\n        relation: \u0026TableFactor,\n        filter_context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n        ast_join_executor: \u0026'a AstJoinExecutor,\n    ) -\u003e Result\u003cJoinExecutor\u003c'a\u003e\u003e {\n        let (key_expr, value_expr, where_clause) = match ast_join_executor {\n            AstJoinExecutor::NestedLoop =\u003e return Ok(Self::NestedLoop),\n            AstJoinExecutor::Hash {\n                key_expr,\n                value_expr,\n                where_clause,\n            } =\u003e (key_expr, value_expr, where_clause),\n        };\n\n        let rows_map = fetch_relation_rows(storage, relation, \u0026filter_context)\n            .await?\n            .try_filter_map(|row| {\n                let filter_context = filter_context.as_ref().map(Rc::clone);\n\n                async move {\n                    let filter_context = Rc::new(RowContext::new(\n                        get_alias(relation),\n                        Cow::Borrowed(\u0026row),\n                        filter_context,\n                    ));\n\n                    let hash_key: Key =\n                        evaluate(storage, Some(Rc::clone(\u0026filter_context)), None, key_expr)\n                            .await?\n                            .try_into()?;\n\n                    if matches!(hash_key, Key::None) {\n                        return Ok(None);\n                    }\n\n                    match where_clause {\n                        Some(expr) =\u003e check_expr(storage, Some(filter_context), None, expr)\n                            .await\n                            .map(|pass| pass.then_some((hash_key, row))),\n                        None =\u003e Ok(Some((hash_key, row))),\n                    }\n                }\n            })\n            .try_collect::\u003cVec\u003c_\u003e\u003e()\n            .await?\n            .into_iter()\n            .into_group_map();\n        Ok(Self::Hash {\n            rows_map,\n            value_expr,\n        })\n    }\n}\n\nasync fn check_where_clause\u003c'a, 'b, T: GStore\u003e(\n    storage: \u0026'a T,\n    table_alias: \u0026'a str,\n    filter_context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n    project_context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n    where_clause: Option\u003c\u0026'a Expr\u003e,\n    row: Cow\u003c'b, Row\u003e,\n) -\u003e Result\u003cOption\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e\u003e {\n    let filter_context = RowContext::new(table_alias, Cow::Borrowed(\u0026row), filter_context);\n    let filter_context = Some(Rc::new(filter_context));\n\n    match where_clause {\n        Some(expr) =\u003e check_expr(storage, filter_context, None, expr).await?,\n        None =\u003e true,\n    }\n    .then(|| RowContext::new(table_alias, Cow::Owned(row.into_owned()), project_context))\n    .map(Rc::new)\n    .map(Ok)\n    .transpose()\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":151},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","limit.rs"],"content":"use {\n    super::evaluate::evaluate_stateless,\n    crate::{\n        ast::Expr,\n        data::{Row, Value},\n        result::{Error, Result},\n    },\n    futures::stream::{Stream, StreamExt},\n};\n\npub struct Limit {\n    limit: Option\u003cusize\u003e,\n    offset: Option\u003cusize\u003e,\n}\n\nimpl Limit {\n    pub async fn new(limit: Option\u003c\u0026Expr\u003e, offset: Option\u003c\u0026Expr\u003e) -\u003e Result\u003cSelf\u003e {\n        let eval = |expr| async move {\n            let expr = match expr {\n                Some(expr) =\u003e expr,\n                None =\u003e return Ok(None),\n            };\n\n            let evaluated = evaluate_stateless(None, expr).await?;\n            let size: usize = Value::try_from(evaluated)?.try_into()?;\n\n            Result::\u003cOption\u003cusize\u003e, Error\u003e::Ok(Some(size))\n        };\n\n        let limit = eval(limit).await?;\n        let offset = eval(offset).await?;\n\n        Ok(Self { limit, offset })\n    }\n\n    pub fn apply\u003c'a, T: Stream\u003cItem = Result\u003cRow\u003e\u003e + 'a\u003e(\n        \u0026self,\n        rows: T,\n    ) -\u003e impl Stream\u003cItem = Result\u003cRow\u003e\u003e + 'a + use\u003c'a, T\u003e {\n        #[derive(futures_enum::Stream)]\n        enum S\u003cS1, S2, S3, S4\u003e {\n            Both(S3),\n            Offset(S2),\n            Limit(S1),\n            None(S4),\n        }\n\n        match (self.offset, self.limit) {\n            (Some(offset), Some(limit)) =\u003e S::Both(rows.skip(offset).take(limit)),\n            (Some(offset), None) =\u003e S::Offset(rows.skip(offset)),\n            (None, Some(limit)) =\u003e S::Limit(rows.take(limit)),\n            (None, None) =\u003e S::None(rows),\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","select","error.rs"],"content":"use {serde::Serialize, std::fmt::Debug, thiserror::Error};\n\n#[derive(Error, Serialize, Debug, PartialEq, Eq)]\npub enum SelectError {\n    #[error(\"VALUES lists must all be the same length\")]\n    NumberOfValuesDifferent,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","select","project.rs"],"content":"use {\n    crate::{\n        ast::{Aggregate, SelectItem},\n        data::{Row, Value},\n        executor::{context::RowContext, evaluate::evaluate},\n        result::Result,\n        store::GStore,\n    },\n    futures::stream::{self, StreamExt, TryStreamExt},\n    im_rc::HashMap,\n    std::rc::Rc,\n};\n\npub struct Project\u003c'a, T: GStore\u003e {\n    storage: \u0026'a T,\n    context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n    fields: \u0026'a [SelectItem],\n}\n\nimpl\u003c'a, T: GStore\u003e Project\u003c'a, T\u003e {\n    pub fn new(\n        storage: \u0026'a T,\n        context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n        fields: \u0026'a [SelectItem],\n    ) -\u003e Self {\n        Self {\n            storage,\n            context,\n            fields,\n        }\n    }\n\n    pub async fn apply(\n        \u0026self,\n        aggregated: Option\u003cRc\u003cHashMap\u003c\u0026'a Aggregate, Value\u003e\u003e\u003e,\n        labels: Option\u003cRc\u003c[String]\u003e\u003e,\n        context: Rc\u003cRowContext\u003c'a\u003e\u003e,\n    ) -\u003e Result\u003cRow\u003e {\n        let filter_context = match \u0026self.context {\n            Some(filter_context) =\u003e Rc::new(RowContext::concat(\n                Rc::clone(\u0026context),\n                Rc::clone(filter_context),\n            )),\n            None =\u003e Rc::clone(\u0026context),\n        };\n        let filter_context = Some(filter_context);\n        let context = \u0026context;\n\n        let entries = stream::iter(self.fields)\n            .then(|item| {\n                let filter_context = filter_context.as_ref().map(Rc::clone);\n                let aggregated = aggregated.as_ref().map(Rc::clone);\n\n                async move {\n                    match item {\n                        SelectItem::Wildcard =\u003e Ok(context.get_all_entries()),\n                        SelectItem::QualifiedWildcard(table_alias) =\u003e {\n                            Ok(context.get_alias_entries(table_alias).unwrap_or_default())\n                        }\n                        SelectItem::Expr { expr, label } =\u003e {\n                            evaluate(self.storage, filter_context, aggregated, expr)\n                                .await\n                                .map(|evaluated| evaluated.try_into())?\n                                .map(|v| vec![(label, v)])\n                        }\n                    }\n                }\n            })\n            .try_collect::\u003cVec\u003cVec\u003c(\u0026String, Value)\u003e\u003e\u003e()\n            .await?\n            .concat();\n\n        Ok(match labels {\n            Some(labels) =\u003e Row::Vec {\n                columns: Rc::clone(\u0026labels),\n                values: entries.into_iter().map(|(_, v)| v).collect(),\n            },\n            None =\u003e Row::Map(entries.into_iter().map(|(k, v)| (k.clone(), v)).collect()),\n        })\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","select.rs"],"content":"mod error;\nmod project;\n\npub use error::SelectError;\n\nuse {\n    self::project::Project,\n    super::{\n        aggregate,\n        context::{AggregateContext, RowContext},\n        evaluate::evaluate_stateless,\n        fetch::{fetch_labels, fetch_relation_rows},\n        filter::Filter,\n        join::Join,\n        limit::Limit,\n        sort::Sort,\n    },\n    crate::{\n        ast::{Expr, OrderByExpr, Query, Select, SetExpr, TableWithJoins, Values},\n        data::{Key, Row, Value, get_alias},\n        result::Result,\n        store::GStore,\n    },\n    async_recursion::async_recursion,\n    futures::stream::{self, Stream, StreamExt, TryStreamExt},\n    std::{borrow::Cow, rc::Rc},\n    utils::Vector,\n};\n\nasync fn rows_with_labels(exprs_list: \u0026[Vec\u003cExpr\u003e]) -\u003e Result\u003c(Vec\u003cRow\u003e, Vec\u003cString\u003e)\u003e {\n    let first_len = exprs_list[0].len();\n    let labels = (1..=first_len)\n        .map(|i| format!(\"column{}\", i))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    let columns = Rc::from(labels.clone());\n\n    let mut column_types = vec![None; first_len];\n    let mut rows = Vec::with_capacity(exprs_list.len());\n\n    for exprs in exprs_list {\n        if exprs.len() != first_len {\n            return Err(SelectError::NumberOfValuesDifferent.into());\n        }\n\n        let mut values = Vec::with_capacity(exprs.len());\n\n        for (i, expr) in exprs.iter().enumerate() {\n            let evaluated = evaluate_stateless(None, expr).await?;\n\n            let value = match column_types[i] {\n                Some(ref data_type) =\u003e evaluated.try_into_value(data_type, true)?,\n                None =\u003e {\n                    let value: Value = evaluated.try_into()?;\n                    column_types[i] = value.get_type();\n\n                    value\n                }\n            };\n\n            values.push(value);\n        }\n\n        rows.push(Row::Vec {\n            columns: Rc::clone(\u0026columns),\n            values,\n        });\n    }\n\n    Ok((rows, labels))\n}\n\nasync fn sort_stateless(rows: Vec\u003cRow\u003e, order_by: \u0026[OrderByExpr]) -\u003e Result\u003cVec\u003cRow\u003e\u003e {\n    let sorted = stream::iter(rows.into_iter())\n        .then(|row| async move {\n            stream::iter(order_by)\n                .then(|OrderByExpr { expr, asc }| {\n                    let row = Some(\u0026row);\n\n                    async move {\n                        evaluate_stateless(row.map(Row::as_context), expr)\n                            .await\n                            .and_then(Value::try_from)\n                            .and_then(Key::try_from)\n                            .map(|key| (key, *asc))\n                    }\n                })\n                .try_collect::\u003cVec\u003c_\u003e\u003e()\n                .await\n                .map(|keys| (keys, row))\n        })\n        .try_collect::\u003cVec\u003c_\u003e\u003e()\n        .await\n        .map(Vector::from)?\n        .sort_by(|(keys_a, _), (keys_b, _)| super::sort::sort_by(keys_a, keys_b))\n        .into_iter()\n        .map(|(_, row)| row)\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    Ok(sorted)\n}\n\n#[async_recursion(?Send)]\npub async fn select_with_labels\u003c'a, T\u003e(\n    storage: \u0026'a T,\n    query: \u0026'a Query,\n    filter_context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n) -\u003e Result\u003c(Option\u003cVec\u003cString\u003e\u003e, impl Stream\u003cItem = Result\u003cRow\u003e\u003e + 'a)\u003e\nwhere\n    T: GStore,\n{\n    #[derive(futures_enum::Stream)]\n    enum Row\u003cS1, S2\u003e {\n        Select(S2),\n        Values(S1),\n    }\n\n    let Select {\n        from: table_with_joins,\n        selection: where_clause,\n        projection,\n        group_by,\n        having,\n    } = match \u0026query.body {\n        SetExpr::Select(statement) =\u003e statement.as_ref(),\n        SetExpr::Values(Values(values_list)) =\u003e {\n            let limit = Limit::new(query.limit.as_ref(), query.offset.as_ref()).await?;\n            let (rows, labels) = rows_with_labels(values_list).await?;\n            let rows = sort_stateless(rows, \u0026query.order_by).await?;\n            let rows = stream::iter(rows.into_iter().map(Ok));\n            let rows = limit.apply(rows);\n\n            return Ok((Some(labels), Row::Values(rows)));\n        }\n    };\n\n    let TableWithJoins { relation, joins } = \u0026table_with_joins;\n    let rows = fetch_relation_rows(storage, relation, \u0026None)\n        .await?\n        .map(move |row| {\n            let row = row?;\n            let alias = get_alias(relation);\n\n            Ok(RowContext::new(alias, Cow::Owned(row), None))\n        });\n\n    let join = Join::new(storage, joins, filter_context.as_ref().map(Rc::clone));\n    let filter = Rc::new(Filter::new(\n        storage,\n        where_clause.as_ref(),\n        filter_context.as_ref().map(Rc::clone),\n        None,\n    ));\n    let limit = Limit::new(query.limit.as_ref(), query.offset.as_ref()).await?;\n    let sort = Sort::new(\n        storage,\n        filter_context.as_ref().map(Rc::clone),\n        \u0026query.order_by,\n    );\n\n    let rows = join.apply(rows).await?;\n    let rows = rows.try_filter_map(move |project_context| {\n        let filter = Rc::clone(\u0026filter);\n\n        async move {\n            filter\n                .check(Rc::clone(\u0026project_context))\n                .await\n                .map(|pass| pass.then_some(project_context))\n        }\n    });\n\n    let rows = aggregate::apply(\n        storage,\n        projection,\n        group_by,\n        having.as_ref(),\n        filter_context.as_ref().map(Rc::clone),\n        rows,\n    )\n    .await?;\n\n    let labels = fetch_labels(storage, relation, joins, projection)\n        .await?\n        .map(Rc::from);\n\n    let project = Rc::new(Project::new(storage, filter_context, projection));\n    let project_labels = labels.as_ref().map(Rc::clone);\n    let rows = rows.and_then(move |aggregate_context| {\n        let labels = project_labels.as_ref().map(Rc::clone);\n        let project = Rc::clone(\u0026project);\n        let AggregateContext { aggregated, next } = aggregate_context;\n        let aggregated = aggregated.map(Rc::new);\n\n        async move {\n            let row = project\n                .apply(aggregated.as_ref().map(Rc::clone), labels, Rc::clone(\u0026next))\n                .await?;\n\n            Ok((aggregated, next, row))\n        }\n    });\n\n    let rows = sort.apply(rows, get_alias(relation)).await?;\n    let rows = limit.apply(rows);\n    let labels = labels.map(|labels| labels.iter().cloned().collect());\n\n    Ok((labels, Row::Select(rows)))\n}\n\npub async fn select\u003c'a, T: GStore\u003e(\n    storage: \u0026'a T,\n    query: \u0026'a Query,\n    filter_context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n) -\u003e Result\u003cimpl Stream\u003cItem = Result\u003cRow\u003e\u003e + 'a\u003e {\n    select_with_labels(storage, query, filter_context)\n        .await\n        .map(|(_, rows)| rows)\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":113},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","sort.rs"],"content":"use {\n    super::{context::RowContext, evaluate::evaluate},\n    crate::{\n        ast::{Aggregate, AstLiteral, Expr, OrderByExpr, UnaryOperator},\n        data::{Key, Row, Value},\n        result::{Error, Result},\n        store::GStore,\n    },\n    bigdecimal::ToPrimitive,\n    futures::stream::{self, Stream, StreamExt, TryStreamExt},\n    im_rc::HashMap,\n    serde::Serialize,\n    std::{borrow::Cow, cmp::Ordering, fmt::Debug, rc::Rc},\n    thiserror::Error as ThisError,\n    utils::Vector,\n};\n\n#[derive(ThisError, Serialize, Debug, PartialEq, Eq)]\npub enum SortError {\n    #[error(\"ORDER BY COLUMN_INDEX must be within SELECT-list but: {0}\")]\n    ColumnIndexOutOfRange(usize),\n    #[error(\"Unreachable ORDER BY Clause\")]\n    Unreachable,\n}\n\npub struct Sort\u003c'a, T: GStore\u003e {\n    storage: \u0026'a T,\n    context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n    order_by: \u0026'a [OrderByExpr],\n}\n\nimpl\u003c'a, T: GStore\u003e Sort\u003c'a, T\u003e {\n    pub fn new(\n        storage: \u0026'a T,\n        context: Option\u003cRc\u003cRowContext\u003c'a\u003e\u003e\u003e,\n        order_by: \u0026'a [OrderByExpr],\n    ) -\u003e Self {\n        Self {\n            storage,\n            context,\n            order_by,\n        }\n    }\n\n    pub async fn apply\u003c\n        U: Stream\u003c\n                Item = Result\u003c(\n                    Option\u003cRc\u003cHashMap\u003c\u0026'a Aggregate, Value\u003e\u003e\u003e,\n                    Rc\u003cRowContext\u003c'a\u003e\u003e,\n                    Row,\n                )\u003e,\n            \u003e + 'a,\n    \u003e(\n        \u0026self,\n        rows: U,\n        table_alias: \u0026'a str,\n    ) -\u003e Result\u003cimpl Stream\u003cItem = Result\u003cRow\u003e\u003e + 'a + use\u003c'a, T, U\u003e\u003e {\n        #[derive(futures_enum::Stream)]\n        enum Rows\u003cI1, I2\u003e {\n            NonOrderBy(I1),\n            OrderBy(I2),\n        }\n\n        if self.order_by.is_empty() {\n            let rows = rows.map_ok(|(.., row)| row);\n\n            return Ok(Rows::NonOrderBy(Box::pin(rows)));\n        }\n\n        let rows = rows\n            .and_then(|(aggregated, next, row)| {\n                enum SortType\u003c'a\u003e {\n                    Value(Value),\n                    Expr(\u0026'a Expr),\n                }\n\n                let order_by = self.order_by;\n                let order_by = order_by\n                    .iter()\n                    .map(|OrderByExpr { expr, asc }| -\u003e Result\u003c_\u003e {\n                        let big_decimal = match expr {\n                            Expr::Literal(AstLiteral::Number(n)) =\u003e Some(n),\n                            Expr::UnaryOp {\n                                op: UnaryOperator::Plus,\n                                expr,\n                            } =\u003e match expr.as_ref() {\n                                Expr::Literal(AstLiteral::Number(n)) =\u003e Some(n),\n                                _ =\u003e None,\n                            },\n                            _ =\u003e None,\n                        };\n\n                        match (big_decimal, \u0026row) {\n                            (Some(n), Row::Vec { values, .. }) =\u003e {\n                                let index = n\n                                    .to_usize()\n                                    .ok_or_else(|| -\u003e Error { SortError::Unreachable.into() })?;\n                                let zero_based = index.checked_sub(1).ok_or_else(|| -\u003e Error {\n                                    SortError::ColumnIndexOutOfRange(index).into()\n                                })?;\n                                let value = values.get(zero_based).ok_or_else(|| -\u003e Error {\n                                    SortError::ColumnIndexOutOfRange(index).into()\n                                })?;\n\n                                Ok((SortType::Value(value.clone()), *asc))\n                            }\n                            _ =\u003e Ok((SortType::Expr(expr), *asc)),\n                        }\n                    })\n                    .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e();\n\n                let filter_context = match \u0026self.context {\n                    Some(context) =\u003e {\n                        Rc::new(RowContext::concat(Rc::clone(\u0026next), Rc::clone(context)))\n                    }\n                    None =\u003e Rc::clone(\u0026next),\n                };\n\n                async move {\n                    let context = RowContext::new(table_alias, Cow::Borrowed(\u0026row), None);\n                    let label_context = Rc::new(context);\n                    let filter_context = Rc::new(RowContext::concat(\n                        filter_context,\n                        Rc::clone(\u0026label_context),\n                    ));\n\n                    let keys = order_by\n                        .map(stream::iter)?\n                        .then(|(sort_type, asc)| {\n                            let context = Some(Rc::clone(\u0026filter_context));\n                            let aggregated = aggregated.as_ref().map(Rc::clone);\n\n                            async move {\n                                match sort_type {\n                                    SortType::Value(value) =\u003e value,\n                                    SortType::Expr(expr) =\u003e {\n                                        evaluate(self.storage, context, aggregated, expr)\n                                            .await?\n                                            .try_into()?\n                                    }\n                                }\n                                .try_into()\n                                .map(|key| (key, asc))\n                            }\n                        })\n                        .try_collect::\u003cVec\u003c_\u003e\u003e()\n                        .await?;\n\n                    drop(label_context);\n                    drop(filter_context);\n\n                    Ok((keys, row))\n                }\n            })\n            .try_collect::\u003cVec\u003c(Vec\u003c(Key, Option\u003cbool\u003e)\u003e, Row)\u003e\u003e()\n            .await\n            .map(Vector::from)?\n            .sort_by(|(keys_a, ..), (keys_b, ..)| sort_by(keys_a, keys_b))\n            .into_iter()\n            .map(|(.., row)| Ok(row));\n\n        Ok(Rows::OrderBy(stream::iter(rows)))\n    }\n}\n\npub fn sort_by(keys_a: \u0026[(Key, Option\u003cbool\u003e)], keys_b: \u0026[(Key, Option\u003cbool\u003e)]) -\u003e Ordering {\n    let pairs = keys_a\n        .iter()\n        .map(|(a, _)| a)\n        .zip(keys_b.iter())\n        .map(|(a, (b, asc))| (a, b, asc.unwrap_or(true)));\n\n    for (key_a, key_b, asc) in pairs {\n        match (key_a.cmp(key_b), asc) {\n            (Ordering::Equal, _) =\u003e continue,\n            (ord, true) =\u003e return ord,\n            (ord, false) =\u003e return ord.reverse(),\n        }\n    }\n\n    Ordering::Equal\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":80},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","update.rs"],"content":"use {\n    super::{\n        context::RowContext,\n        evaluate::{Evaluated, evaluate},\n    },\n    crate::{\n        ast::{Assignment, ColumnDef, ColumnUniqueOption, ForeignKey},\n        data::{Key, Row, Value},\n        result::{Error, Result},\n        store::GStore,\n    },\n    futures::stream::{self, StreamExt, TryStreamExt},\n    serde::Serialize,\n    std::{borrow::Cow, fmt::Debug, rc::Rc},\n    thiserror::Error,\n    utils::HashMapExt,\n};\n\n#[derive(Error, Serialize, Debug, PartialEq, Eq)]\npub enum UpdateError {\n    #[error(\"column not found {0}\")]\n    ColumnNotFound(String),\n\n    #[error(\"update on primary key is not supported: {0}\")]\n    UpdateOnPrimaryKeyNotSupported(String),\n\n    #[error(\"conflict on schema, row data does not fit to schema\")]\n    ConflictOnSchema,\n\n    #[error(\n        \"cannot find referenced value on {table_name}.{column_name} with value {referenced_value:?}\"\n    )]\n    CannotFindReferencedValue {\n        table_name: String,\n        column_name: String,\n        referenced_value: String,\n    },\n}\n\npub struct Update\u003c'a, T: GStore\u003e {\n    storage: \u0026'a T,\n    table_name: \u0026'a str,\n    fields: \u0026'a [Assignment],\n    column_defs: Option\u003c\u0026'a [ColumnDef]\u003e,\n}\n\nimpl\u003c'a, T: GStore\u003e Update\u003c'a, T\u003e {\n    pub fn new(\n        storage: \u0026'a T,\n        table_name: \u0026'a str,\n        fields: \u0026'a [Assignment],\n        column_defs: Option\u003c\u0026'a [ColumnDef]\u003e,\n    ) -\u003e Result\u003cSelf\u003e {\n        if let Some(column_defs) = column_defs {\n            for assignment in fields.iter() {\n                let Assignment { id, .. } = assignment;\n\n                if column_defs.iter().all(|col_def| \u0026col_def.name != id) {\n                    return Err(UpdateError::ColumnNotFound(id.to_owned()).into());\n                } else if column_defs.iter().any(|ColumnDef { name, unique, .. }| {\n                    name == id \u0026\u0026 matches!(unique, Some(ColumnUniqueOption { is_primary: true }))\n                }) {\n                    return Err(UpdateError::UpdateOnPrimaryKeyNotSupported(id.to_owned()).into());\n                }\n            }\n        }\n\n        Ok(Self {\n            storage,\n            table_name,\n            fields,\n            column_defs,\n        })\n    }\n\n    pub async fn apply(\u0026self, row: Row, foreign_keys: \u0026[ForeignKey]) -\u003e Result\u003cRow\u003e {\n        let context = RowContext::new(self.table_name, Cow::Borrowed(\u0026row), None);\n        let context = Some(Rc::new(context));\n\n        let assignments = stream::iter(self.fields.iter())\n            .then(|assignment| {\n                let Assignment {\n                    id,\n                    value: value_expr,\n                } = assignment;\n                let context = context.as_ref().map(Rc::clone);\n\n                async move {\n                    let evaluated = evaluate(self.storage, context, None, value_expr).await?;\n                    let value = match self.column_defs {\n                        Some(column_defs) =\u003e {\n                            let ColumnDef {\n                                data_type,\n                                nullable,\n                                ..\n                            } = column_defs\n                                .iter()\n                                .find(|column_def| id == \u0026column_def.name)\n                                .ok_or(UpdateError::ConflictOnSchema)?;\n\n                            let value = match evaluated {\n                                Evaluated::Literal(v) =\u003e Value::try_from_literal(data_type, \u0026v)?,\n                                Evaluated::Value(v) =\u003e {\n                                    v.validate_type(data_type)?;\n                                    v\n                                }\n                                Evaluated::StrSlice {\n                                    source: s,\n                                    range: r,\n                                } =\u003e Value::Str(s[r].to_owned()),\n                            };\n\n                            value.validate_null(*nullable)?;\n                            value\n                        }\n                        None =\u003e evaluated.try_into()?,\n                    };\n\n                    Ok::\u003c_, Error\u003e((id.as_ref(), value))\n                }\n            })\n            .and_then(|(id, value)| async move {\n                if value == Value::Null {\n                    return Ok((id, value));\n                }\n\n                for foreign_key in foreign_keys {\n                    let ForeignKey {\n                        referencing_column_name,\n                        referenced_table_name,\n                        referenced_column_name,\n                        ..\n                    } = foreign_key;\n\n                    if referencing_column_name != id {\n                        continue;\n                    }\n\n                    let no_referenced = self\n                        .storage\n                        .fetch_data(referenced_table_name, \u0026Key::try_from(\u0026value)?)\n                        .await?\n                        .is_none();\n\n                    if no_referenced {\n                        return Err(UpdateError::CannotFindReferencedValue {\n                            table_name: referenced_table_name.to_owned(),\n                            column_name: referenced_column_name.to_owned(),\n                            referenced_value: String::from(value),\n                        }\n                        .into());\n                    }\n                }\n\n                Ok((id, value))\n            })\n            .try_collect::\u003cVec\u003c(\u0026str, Value)\u003e\u003e()\n            .await?;\n\n        Ok(match row {\n            Row::Vec { columns, values } =\u003e {\n                let values = columns\n                    .iter()\n                    .zip(values)\n                    .map(|(column, value)| {\n                        assignments\n                            .iter()\n                            .find_map(|(id, new_value)| (column == id).then_some(new_value.clone()))\n                            .unwrap_or(value)\n                    })\n                    .collect();\n\n                Row::Vec { columns, values }\n            }\n            Row::Map(values) =\u003e {\n                let assignments = assignments\n                    .into_iter()\n                    .map(|(id, value)| (id.to_owned(), value));\n\n                Row::Map(values.concat(assignments))\n            }\n        })\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":91},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor","validate.rs"],"content":"use {\n    crate::{\n        ast::{ColumnDef, ColumnUniqueOption},\n        data::{Key, Value},\n        result::Result,\n        store::{DataRow, Store},\n    },\n    futures::stream::TryStreamExt,\n    im_rc::HashSet,\n    serde::Serialize,\n    std::fmt::Debug,\n    thiserror::Error as ThisError,\n    utils::Vector,\n};\n\n#[derive(ThisError, Debug, PartialEq, Serialize)]\npub enum ValidateError {\n    #[error(\"conflict! storage row has no column on index {0}\")]\n    ConflictOnStorageColumnIndex(usize),\n\n    #[error(\"conflict! schemaless row found in schema based data\")]\n    ConflictOnUnexpectedSchemalessRowFound,\n\n    #[error(\"duplicate entry '{}' for unique column '{1}'\", String::from(.0))]\n    DuplicateEntryOnUniqueField(Value, String),\n\n    #[error(\"duplicate entry '{0:?}' for primary_key field\")]\n    DuplicateEntryOnPrimaryKeyField(Key),\n}\n\npub enum ColumnValidation\u003c'column_def\u003e {\n    /// `INSERT`\n    All(\u0026'column_def [ColumnDef]),\n    /// `UPDATE`\n    SpecifiedColumns(\u0026'column_def [ColumnDef], Vec\u003cString\u003e),\n}\n\n#[derive(Debug)]\nstruct UniqueConstraint {\n    column_index: usize,\n    column_name: String,\n    keys: HashSet\u003cKey\u003e,\n}\n\nimpl UniqueConstraint {\n    fn new(column_index: usize, column_name: String) -\u003e Self {\n        Self {\n            column_index,\n            column_name,\n            keys: HashSet::new(),\n        }\n    }\n\n    fn add(self, value: \u0026Value) -\u003e Result\u003cSelf\u003e {\n        let new_key = self.check(value)?;\n\n        if matches!(new_key, Key::None) {\n            return Ok(self);\n        }\n\n        let keys = self.keys.update(new_key);\n\n        Ok(Self {\n            column_index: self.column_index,\n            column_name: self.column_name,\n            keys,\n        })\n    }\n\n    fn check(\u0026self, value: \u0026Value) -\u003e Result\u003cKey\u003e {\n        let key = Key::try_from(value)?;\n\n        if !self.keys.contains(\u0026key) {\n            Ok(key)\n        } else {\n            Err(ValidateError::DuplicateEntryOnUniqueField(\n                value.clone(),\n                self.column_name.to_owned(),\n            )\n            .into())\n        }\n    }\n}\n\npub async fn validate_unique\u003cT: Store\u003e(\n    storage: \u0026T,\n    table_name: \u0026str,\n    column_validation: ColumnValidation\u003c'_\u003e,\n    row_iter: impl Iterator\u003cItem = \u0026[Value]\u003e + Clone,\n) -\u003e Result\u003c()\u003e {\n    enum Columns {\n        /// key index\n        PrimaryKeyOnly(usize),\n        /// `[(key_index, table_name)]`\n        All(Vec\u003c(usize, String)\u003e),\n    }\n\n    let columns = match \u0026column_validation {\n        ColumnValidation::All(column_defs) =\u003e {\n            let primary_key_index = column_defs\n                .iter()\n                .enumerate()\n                .find(|(_, ColumnDef { unique, .. })| {\n                    unique == \u0026Some(ColumnUniqueOption { is_primary: true })\n                })\n                .map(|(i, _)| i);\n            let other_unique_column_def_count = column_defs\n                .iter()\n                .filter(|ColumnDef { unique, .. }| {\n                    unique == \u0026Some(ColumnUniqueOption { is_primary: false })\n                })\n                .count();\n\n            match (primary_key_index, other_unique_column_def_count) {\n                (Some(primary_key_index), 0) =\u003e Columns::PrimaryKeyOnly(primary_key_index),\n                _ =\u003e Columns::All(fetch_all_unique_columns(column_defs)),\n            }\n        }\n        ColumnValidation::SpecifiedColumns(column_defs, specified_columns) =\u003e Columns::All(\n            fetch_specified_unique_columns(column_defs, specified_columns),\n        ),\n    };\n\n    match columns {\n        Columns::PrimaryKeyOnly(primary_key_index) =\u003e {\n            for primary_key in\n                row_iter.filter_map(|row| row.get(primary_key_index).map(Key::try_from))\n            {\n                let key = primary_key?;\n\n                if storage.fetch_data(table_name, \u0026key).await?.is_some() {\n                    return Err(ValidateError::DuplicateEntryOnPrimaryKeyField(key).into());\n                }\n            }\n\n            Ok(())\n        }\n        Columns::All(columns) =\u003e {\n            let unique_constraints: Vec\u003c_\u003e = create_unique_constraints(columns, row_iter)?.into();\n            if unique_constraints.is_empty() {\n                return Ok(());\n            }\n\n            let unique_constraints = \u0026unique_constraints;\n            storage\n                .scan_data(table_name)\n                .await?\n                .try_for_each(|(_, data_row)| async {\n                    let values = match data_row {\n                        DataRow::Vec(values) =\u003e values,\n                        DataRow::Map(_) =\u003e {\n                            return Err(\n                                ValidateError::ConflictOnUnexpectedSchemalessRowFound.into()\n                            );\n                        }\n                    };\n\n                    unique_constraints.iter().try_for_each(|constraint| {\n                        let col_idx = constraint.column_index;\n                        let val = values\n                            .get(col_idx)\n                            .ok_or(ValidateError::ConflictOnStorageColumnIndex(col_idx))?;\n\n                        constraint.check(val)?;\n\n                        Ok(())\n                    })\n                })\n                .await\n        }\n    }\n}\n\nfn create_unique_constraints\u003c'a\u003e(\n    unique_columns: Vec\u003c(usize, String)\u003e,\n    row_iter: impl Iterator\u003cItem = \u0026'a [Value]\u003e + Clone,\n) -\u003e Result\u003cVector\u003cUniqueConstraint\u003e\u003e {\n    unique_columns\n        .into_iter()\n        .try_fold(Vector::new(), |constraints, col| {\n            let (col_idx, col_name) = col;\n            let new_constraint = UniqueConstraint::new(col_idx, col_name);\n            let new_constraint = row_iter\n                .clone()\n                .try_fold(new_constraint, |constraint, row| {\n                    let val = row\n                        .get(col_idx)\n                        .ok_or(ValidateError::ConflictOnStorageColumnIndex(col_idx))?;\n\n                    constraint.add(val)\n                })?;\n            Ok(constraints.push(new_constraint))\n        })\n}\n\nfn fetch_all_unique_columns(column_defs: \u0026[ColumnDef]) -\u003e Vec\u003c(usize, String)\u003e {\n    column_defs\n        .iter()\n        .enumerate()\n        .filter_map(|(i, table_col)| table_col.unique.map(|_| (i, table_col.name.to_owned())))\n        .collect()\n}\n\nfn fetch_specified_unique_columns(\n    all_column_defs: \u0026[ColumnDef],\n    specified_columns: \u0026[String],\n) -\u003e Vec\u003c(usize, String)\u003e {\n    all_column_defs\n        .iter()\n        .enumerate()\n        .filter_map(|(i, table_col)| {\n            (table_col.unique.is_some()\n                \u0026\u0026 specified_columns.iter().any(|col| col == \u0026table_col.name))\n            .then_some((i, table_col.name.to_owned()))\n        })\n        .collect()\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":84},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","executor.rs"],"content":"mod aggregate;\nmod alter;\nmod context;\nmod delete;\nmod evaluate;\nmod execute;\nmod fetch;\nmod filter;\nmod insert;\nmod join;\nmod limit;\nmod select;\nmod sort;\nmod update;\nmod validate;\n\npub use {\n    alter::{AlterError, Referencing},\n    context::RowContext,\n    delete::DeleteError,\n    evaluate::{EvaluateError, evaluate_stateless},\n    execute::{ExecuteError, Payload, PayloadVariable, execute},\n    fetch::FetchError,\n    insert::InsertError,\n    select::SelectError,\n    sort::SortError,\n    update::UpdateError,\n    validate::ValidateError,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","glue.rs"],"content":"use {\n    crate::{\n        ast::Statement,\n        executor::{Payload, execute},\n        parse_sql::parse,\n        plan::plan,\n        result::Result,\n        store::{GStore, GStoreMut},\n        translate::translate,\n    },\n    futures::{\n        TryStreamExt,\n        stream::{self, StreamExt},\n    },\n};\n\n#[derive(Debug)]\npub struct Glue\u003cT: GStore + GStoreMut\u003e {\n    pub storage: T,\n}\n\nimpl\u003cT: GStore + GStoreMut\u003e Glue\u003cT\u003e {\n    pub fn new(storage: T) -\u003e Self {\n        Self { storage }\n    }\n\n    pub async fn plan\u003cSql: AsRef\u003cstr\u003e\u003e(\u0026mut self, sql: Sql) -\u003e Result\u003cVec\u003cStatement\u003e\u003e {\n        let parsed = parse(sql)?;\n        let storage = \u0026self.storage;\n        stream::iter(parsed)\n            .map(|p| translate(\u0026p))\n            .then(|statement| async move { plan(storage, statement?).await })\n            .try_collect()\n            .await\n    }\n\n    pub async fn execute_stmt(\u0026mut self, statement: \u0026Statement) -\u003e Result\u003cPayload\u003e {\n        execute(\u0026mut self.storage, statement).await\n    }\n\n    pub async fn execute\u003cSql: AsRef\u003cstr\u003e\u003e(\u0026mut self, sql: Sql) -\u003e Result\u003cVec\u003cPayload\u003e\u003e {\n        let statements = self.plan(sql).await?;\n        let mut payloads = Vec::\u003cPayload\u003e::new();\n        for statement in statements.iter() {\n            let payload = self.execute_stmt(statement).await?;\n            payloads.push(payload);\n        }\n\n        Ok(payloads)\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","lib.rs"],"content":"#![deny(clippy::str_to_string)]\n\n// re-export\npub use {chrono, sqlparser};\n\nmod glue;\nmod mock;\nmod result;\n\npub mod ast;\npub mod ast_builder;\npub mod data;\npub mod executor;\npub mod parse_sql;\npub mod plan;\npub mod store;\npub mod translate;\n\npub mod prelude {\n    pub use crate::{\n        ast::DataType,\n        data::{Key, Value},\n        executor::{Payload, PayloadVariable, execute},\n        glue::Glue,\n        parse_sql::parse,\n        plan::plan,\n        result::{Error, Result},\n        translate::translate,\n    };\n}\n\npub mod error {\n    pub use crate::result::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","mock.rs"],"content":"use {\n    crate::{\n        data::{Key, Schema},\n        result::{Error, Result},\n        store::{\n            AlterTable, CustomFunction, CustomFunctionMut, DataRow, Index, IndexMut, Metadata,\n            RowIter, Store, StoreMut, Transaction,\n        },\n    },\n    async_trait::async_trait,\n    std::collections::HashMap,\n};\n\n#[cfg(test)]\nuse {\n    crate::{executor::execute, parse_sql::parse, translate::translate},\n    futures::executor::block_on,\n};\n\n#[cfg(test)]\npub fn run(sql: \u0026str) -\u003e MockStorage {\n    let mut storage = MockStorage::default();\n\n    for parsed in parse(sql).unwrap() {\n        let statement = translate(\u0026parsed).unwrap();\n\n        block_on(execute(\u0026mut storage, \u0026statement)).unwrap();\n    }\n\n    storage\n}\n\n#[derive(Default, Debug)]\npub struct MockStorage {\n    schema_map: HashMap\u003cString, Schema\u003e,\n}\n\n#[async_trait(?Send)]\nimpl CustomFunction for MockStorage {}\n\n#[async_trait(?Send)]\nimpl CustomFunctionMut for MockStorage {}\n\n#[async_trait(?Send)]\nimpl Store for MockStorage {\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        if table_name == \"__Err__\" {\n            return Err(Error::StorageMsg(\n                \"[MockStorage] fetch_schema - user triggered error\".to_owned(),\n            ));\n        }\n\n        self.schema_map\n            .get(table_name)\n            .map(|schema| Ok(schema.clone()))\n            .transpose()\n    }\n\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let msg = \"[Storage] fetch_all_schemas not supported\".to_owned();\n\n        Err(Error::StorageMsg(msg))\n    }\n\n    async fn fetch_data(\u0026self, _table_name: \u0026str, _key: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        Err(Error::StorageMsg(\n            \"[MockStorage] fetch_data not supported\".to_owned(),\n        ))\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, _table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        Err(Error::StorageMsg(\n            \"[MockStorage] scan_data not supported\".to_owned(),\n        ))\n    }\n}\n\n#[async_trait(?Send)]\nimpl StoreMut for MockStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let table_name = schema.table_name.clone();\n        let schema = schema.clone();\n\n        self.schema_map.insert(table_name, schema);\n        Ok(())\n    }\n}\n\nimpl AlterTable for MockStorage {}\nimpl Index for MockStorage {}\nimpl IndexMut for MockStorage {}\nimpl Transaction for MockStorage {}\nimpl Metadata for MockStorage {}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::MockStorage,\n        crate::{\n            ast::{ColumnDef, DataType, Expr, OrderByExpr},\n            data::Key,\n            store::{AlterTable, Index, IndexMut, Transaction},\n            store::{Store, StoreMut},\n        },\n        futures::executor::block_on,\n    };\n\n    #[test]\n    fn empty() {\n        let mut storage = MockStorage::default();\n\n        // Store \u0026 StoreMut\n        assert!(block_on(storage.scan_data(\"Foo\")).is_err());\n        assert!(block_on(storage.fetch_data(\"Foo\", \u0026Key::None)).is_err());\n        assert!(block_on(storage.fetch_schema(\"__Err__\")).is_err());\n        assert!(block_on(storage.delete_schema(\"Foo\")).is_err());\n        assert!(block_on(storage.append_data(\"Foo\", Vec::new())).is_err());\n        assert!(block_on(storage.insert_data(\"Foo\", Vec::new())).is_err());\n        assert!(block_on(storage.delete_data(\"Foo\", Vec::new())).is_err());\n\n        // AlterTable\n        assert!(block_on(storage.rename_schema(\"Foo\", \"Bar\")).is_err());\n        assert!(block_on(storage.rename_column(\"Foo\", \"col_old\", \"col_new\")).is_err());\n        assert!(\n            block_on(storage.add_column(\n                \"Foo\",\n                \u0026ColumnDef {\n                    name: \"new_col\".to_owned(),\n                    data_type: DataType::Boolean,\n                    nullable: false,\n                    default: None,\n                    unique: None,\n                    comment: None,\n                },\n            ))\n            .is_err()\n        );\n        assert!(block_on(storage.drop_column(\"Foo\", \"col\", false)).is_err());\n\n        // Index \u0026 IndexMut\n        assert!(block_on(storage.scan_indexed_data(\"Foo\", \"idx_col\", None, None)).is_err());\n        assert!(\n            block_on(storage.create_index(\n                \"Foo\",\n                \"idx_col\",\n                \u0026OrderByExpr {\n                    expr: Expr::TypedString {\n                        data_type: DataType::Boolean,\n                        value: \"true\".to_owned(),\n                    },\n                    asc: None,\n                },\n            ))\n            .is_err()\n        );\n        assert!(block_on(storage.drop_index(\"Foo\", \"idx_col\")).is_err());\n\n        // Transaction\n        assert!(block_on(storage.begin(false)).is_err());\n        assert!(block_on(storage.rollback()).is_ok());\n        assert!(block_on(storage.commit()).is_ok());\n\n        assert!(matches!(block_on(storage.fetch_schema(\"Foo\")), Ok(None)));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","parse_sql.rs"],"content":"use {\n    crate::result::{Error, Result},\n    sqlparser::{\n        ast::{\n            Assignment as SqlAssignment, ColumnDef as SqlColumnDef, DataType as SqlDataType,\n            Expr as SqlExpr, Ident as SqlIdent, OrderByExpr as SqlOrderByExpr, Query as SqlQuery,\n            SelectItem as SqlSelectItem, Statement as SqlStatement,\n        },\n        dialect::PostgreSqlDialect,\n        parser::Parser,\n        tokenizer::Tokenizer,\n    },\n};\n\nconst DIALECT: PostgreSqlDialect = PostgreSqlDialect {};\n\npub fn parse\u003cSql: AsRef\u003cstr\u003e\u003e(sql: Sql) -\u003e Result\u003cVec\u003cSqlStatement\u003e\u003e {\n    Parser::parse_sql(\u0026DIALECT, sql.as_ref()).map_err(|e| Error::Parser(format!(\"{:#?}\", e)))\n}\n\nmacro_rules! generate_parse_fn {\n    ($fn_name: ident, $output_type: ty) =\u003e {\n        pub fn $fn_name\u003cSql: AsRef\u003cstr\u003e\u003e(sql_expr: Sql) -\u003e Result\u003c$output_type\u003e {\n            let tokens = Tokenizer::new(\u0026DIALECT, sql_expr.as_ref())\n                .tokenize()\n                .map_err(|e| Error::Parser(format!(\"{:#?}\", e)))?;\n\n            Parser::new(\u0026DIALECT)\n                .with_tokens(tokens)\n                .$fn_name()\n                .map_err(|e| Error::Parser(format!(\"{:#?}\", e)))\n        }\n    };\n    ($fn_name: ident, $parse_fn_name: ident, $parse_fn_arg: ident, $output_type: ty) =\u003e {\n        pub fn $fn_name\u003cSql: AsRef\u003cstr\u003e\u003e(sql_expr: Sql) -\u003e Result\u003c$output_type\u003e {\n            let tokens = Tokenizer::new(\u0026DIALECT, sql_expr.as_ref())\n                .tokenize()\n                .map_err(|e| Error::Parser(format!(\"{:#?}\", e)))?;\n\n            Parser::new(\u0026DIALECT)\n                .with_tokens(tokens)\n                .$parse_fn_name(Parser::$parse_fn_arg)\n                .map_err(|e| Error::Parser(format!(\"{:#?}\", e)))\n        }\n    };\n}\n\ngenerate_parse_fn!(parse_query, Box\u003cSqlQuery\u003e);\ngenerate_parse_fn!(parse_expr, SqlExpr);\ngenerate_parse_fn!(\n    parse_comma_separated_exprs,\n    parse_comma_separated,\n    parse_expr,\n    Vec\u003cSqlExpr\u003e\n);\ngenerate_parse_fn!(parse_select_item, SqlSelectItem);\ngenerate_parse_fn!(\n    parse_select_items,\n    parse_comma_separated,\n    parse_select_item,\n    Vec\u003cSqlSelectItem\u003e\n);\ngenerate_parse_fn!(parse_interval, SqlExpr);\ngenerate_parse_fn!(parse_order_by_expr, SqlOrderByExpr);\ngenerate_parse_fn!(\n    parse_order_by_exprs,\n    parse_comma_separated,\n    parse_order_by_expr,\n    Vec\u003cSqlOrderByExpr\u003e\n);\ngenerate_parse_fn!(parse_column_def, SqlColumnDef);\ngenerate_parse_fn!(parse_data_type, SqlDataType);\ngenerate_parse_fn!(parse_assignment, SqlAssignment);\ngenerate_parse_fn!(parse_identifiers, Vec\u003cSqlIdent\u003e);\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan","context.rs"],"content":"use std::rc::Rc;\n\npub enum Context\u003c'a\u003e {\n    Data {\n        alias: String,\n        columns: Vec\u003c\u0026'a str\u003e,\n        primary_key: Option\u003c\u0026'a str\u003e,\n        next: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n    },\n    Bridge {\n        left: Rc\u003cContext\u003c'a\u003e\u003e,\n        right: Rc\u003cContext\u003c'a\u003e\u003e,\n    },\n}\n\nimpl\u003c'a\u003e Context\u003c'a\u003e {\n    pub fn new(\n        alias: String,\n        columns: Vec\u003c\u0026'a str\u003e,\n        primary_key: Option\u003c\u0026'a str\u003e,\n        next: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n    ) -\u003e Self {\n        Context::Data {\n            alias,\n            columns,\n            primary_key,\n            next,\n        }\n    }\n\n    pub fn concat(\n        left: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n        right: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n    ) -\u003e Option\u003cRc\u003cSelf\u003e\u003e {\n        match (left, right) {\n            (Some(left), Some(right)) =\u003e Some(Rc::new(Self::Bridge { left, right })),\n            (context @ Some(_), None) | (None, context @ Some(_)) =\u003e context,\n            (None, None) =\u003e None,\n        }\n    }\n\n    pub fn contains_alias(\u0026self, target: \u0026str) -\u003e bool {\n        match self {\n            Self::Data { alias, .. } if alias == target =\u003e true,\n            Self::Data { next, .. } =\u003e next\n                .as_ref()\n                .map(|next| next.contains_alias(target))\n                .unwrap_or(false),\n            Self::Bridge { left, right } =\u003e {\n                left.contains_alias(target) || right.contains_alias(target)\n            }\n        }\n    }\n\n    pub fn contains_column(\u0026self, target: \u0026str) -\u003e bool {\n        match self {\n            Self::Data { columns, .. } if columns.iter().any(|column| column == \u0026target) =\u003e true,\n            Self::Data { next, .. } =\u003e next\n                .as_ref()\n                .map(|next| next.contains_column(target))\n                .unwrap_or(false),\n            Self::Bridge { left, right } =\u003e {\n                left.contains_column(target) || right.contains_column(target)\n            }\n        }\n    }\n\n    pub fn contains_aliased_column(\u0026self, target_alias: \u0026str, target_column: \u0026str) -\u003e bool {\n        match self {\n            Self::Data { alias, columns, .. } if alias == target_alias =\u003e {\n                columns.iter().any(|column| column == \u0026target_column)\n            }\n            Self::Data { next, .. } =\u003e next\n                .as_ref()\n                .map(|next| next.contains_aliased_column(target_alias, target_column))\n                .unwrap_or(false),\n            Self::Bridge { left, right } =\u003e {\n                left.contains_aliased_column(target_alias, target_column)\n                    || right.contains_aliased_column(target_alias, target_column)\n            }\n        }\n    }\n\n    pub fn contains_primary_key(\u0026self, target_column: \u0026str) -\u003e bool {\n        match self {\n            Self::Data {\n                primary_key: Some(primary_key),\n                ..\n            } if primary_key == \u0026target_column =\u003e true,\n            Self::Data { next, .. } =\u003e next\n                .as_ref()\n                .map(|next| next.contains_primary_key(target_column))\n                .unwrap_or(false),\n            Self::Bridge { left, right } =\u003e {\n                left.contains_primary_key(target_column)\n                    || right.contains_primary_key(target_column)\n            }\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":40},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan","error.rs"],"content":"use {serde::Serialize, std::fmt::Debug, thiserror::Error as ThisError};\n\n#[derive(ThisError, Serialize, Debug, PartialEq, Eq)]\npub enum PlanError {\n    /// Error that that omits when user projects common column name from multiple tables in `JOIN`\n    /// situation.\n    #[error(\"column reference {0} is ambiguous, please specify the table name\")]\n    ColumnReferenceAmbiguous(String),\n\n    #[error(\"unreachable\")]\n    Unreachable,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan","evaluable.rs"],"content":"use {\n    super::{context::Context, expr::PlanExpr},\n    crate::ast::{\n        Expr, Join, JoinConstraint, JoinOperator, Query, Select, SelectItem, SetExpr, TableAlias,\n        TableFactor, TableWithJoins, Values,\n    },\n    std::rc::Rc,\n};\n\npub fn check_expr(context: Option\u003cRc\u003cContext\u003c'_\u003e\u003e\u003e, expr: \u0026Expr) -\u003e bool {\n    match expr.into() {\n        PlanExpr::None =\u003e true,\n        PlanExpr::Identifier(ident) =\u003e context.map(|c| c.contains_column(ident)).unwrap_or(false),\n        PlanExpr::CompoundIdentifier { alias, ident } =\u003e {\n            let table_alias = \u0026alias;\n            let column = \u0026ident;\n\n            context\n                .map(|c| c.contains_aliased_column(table_alias, column))\n                .unwrap_or(false)\n        }\n        PlanExpr::Expr(expr) =\u003e check_expr(context, expr),\n        PlanExpr::TwoExprs(expr, expr2) =\u003e {\n            check_expr(context.as_ref().map(Rc::clone), expr) \u0026\u0026 check_expr(context, expr2)\n        }\n        PlanExpr::ThreeExprs(expr, expr2, expr3) =\u003e {\n            check_expr(context.as_ref().map(Rc::clone), expr)\n                \u0026\u0026 check_expr(context.as_ref().map(Rc::clone), expr2)\n                \u0026\u0026 check_expr(context, expr3)\n        }\n        PlanExpr::MultiExprs(exprs) =\u003e exprs\n            .iter()\n            .all(|expr| check_expr(context.as_ref().map(Rc::clone), expr)),\n        PlanExpr::Query(query) =\u003e check_query(context, query),\n        PlanExpr::QueryAndExpr { query, expr } =\u003e {\n            check_query(context.as_ref().map(Rc::clone), query) \u0026\u0026 check_expr(context, expr)\n        }\n    }\n}\n\nfn check_query(context: Option\u003cRc\u003cContext\u003c'_\u003e\u003e\u003e, query: \u0026Query) -\u003e bool {\n    let Query {\n        body,\n        order_by,\n        limit,\n        offset,\n    } = query;\n\n    let body = match body {\n        SetExpr::Select(select) =\u003e check_select(context.as_ref().map(Rc::clone), select),\n        SetExpr::Values(Values(rows)) =\u003e rows\n            .iter()\n            .flatten()\n            .all(|expr| check_expr(context.as_ref().map(Rc::clone), expr)),\n    };\n\n    if !body {\n        return false;\n    }\n\n    let order_by = order_by\n        .iter()\n        .map(|order_by| \u0026order_by.expr)\n        .all(|expr| check_expr(context.as_ref().map(Rc::clone), expr));\n    if !order_by {\n        return false;\n    }\n\n    limit\n        .iter()\n        .chain(offset.iter())\n        .all(|expr| check_expr(context.as_ref().map(Rc::clone), expr))\n}\n\nfn check_select(context: Option\u003cRc\u003cContext\u003c'_\u003e\u003e\u003e, select: \u0026Select) -\u003e bool {\n    let Select {\n        projection,\n        from,\n        selection,\n        group_by,\n        having,\n    } = select;\n\n    if !projection.iter().all(|select_item| match select_item {\n        SelectItem::Expr { expr, .. } =\u003e check_expr(context.as_ref().map(Rc::clone), expr),\n        SelectItem::QualifiedWildcard(_) | SelectItem::Wildcard =\u003e true,\n    }) {\n        return false;\n    }\n\n    let TableWithJoins { relation, joins } = from;\n\n    if !check_table_factor(context.as_ref().map(Rc::clone), relation) {\n        return false;\n    }\n\n    if !joins.iter().all(|join| {\n        let Join {\n            relation,\n            join_operator,\n            ..\n        } = join;\n\n        if !check_table_factor(context.as_ref().map(Rc::clone), relation) {\n            return false;\n        }\n\n        match join_operator {\n            JoinOperator::Inner(JoinConstraint::On(expr))\n            | JoinOperator::LeftOuter(JoinConstraint::On(expr)) =\u003e {\n                check_expr(context.as_ref().map(Rc::clone), expr)\n            }\n            JoinOperator::Inner(JoinConstraint::None)\n            | JoinOperator::LeftOuter(JoinConstraint::None) =\u003e true,\n        }\n    }) {\n        return false;\n    }\n\n    selection\n        .iter()\n        .chain(group_by.iter())\n        .chain(having.iter())\n        .all(|expr| check_expr(context.as_ref().map(Rc::clone), expr))\n}\n\nfn check_table_factor(context: Option\u003cRc\u003cContext\u003c'_\u003e\u003e\u003e, table_factor: \u0026TableFactor) -\u003e bool {\n    let alias = match table_factor {\n        TableFactor::Table { name, alias, .. } =\u003e alias\n            .as_ref()\n            .map(|TableAlias { name, .. }| name)\n            .unwrap_or_else(|| name),\n        TableFactor::Derived { alias, .. }\n        | TableFactor::Series { alias, .. }\n        | TableFactor::Dictionary { alias, .. } =\u003e \u0026alias.name,\n    };\n\n    context\n        .map(|context| context.contains_alias(alias))\n        .unwrap_or(false)\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::{Context, check_expr},\n        crate::{parse_sql::parse_expr, translate::translate_expr},\n        std::rc::Rc,\n    };\n\n    fn test(context: Option\u003cRc\u003cContext\u003c'_\u003e\u003e\u003e, sql: \u0026str, expected: bool) {\n        let parsed = parse_expr(sql).unwrap();\n        let expr = translate_expr(\u0026parsed);\n        let actual = match expr {\n            Ok(expr) =\u003e check_expr(context, \u0026expr),\n            Err(_) =\u003e false,\n        };\n\n        assert_eq!(actual, expected, \"{sql}\");\n    }\n\n    #[test]\n    fn evaluable() {\n        let context = {\n            let left_child = Context::new(\"Empty\".to_owned(), Vec::new(), None, None);\n            let left = Context::new(\n                \"Foo\".to_owned(),\n                vec![\"id\", \"name\"],\n                None,\n                Some(Rc::new(left_child)),\n            );\n            let right_child = Context::new(\"Src\".to_owned(), Vec::new(), None, None);\n            let right = Context::new(\n                \"Bar\".to_owned(),\n                vec![\"id\", \"rate\"],\n                None,\n                Some(Rc::new(right_child)),\n            );\n\n            Context::concat(Some(Rc::new(left)), Some(Rc::new(right)))\n        };\n\n        macro_rules! test {\n            ($sql: literal, $expected: expr) =\u003e {\n                test(context.as_ref().map(Rc::clone), $sql, $expected);\n            };\n        }\n\n        // PlanExpr::None\n        test!(\"DATE '2011-01-09'\", true);\n        test!(\"'hello world'\", true);\n\n        // PlanExpr::Identifier\n        test!(\"id\", true);\n        test!(\"name\", true);\n        test!(\"new_column\", false);\n\n        // PlanExpr::CompoundIdentifier\n        test!(\"Foo.id\", true);\n        test!(\"B.rate\", false);\n        test!(\"Bar.rate\", true);\n        test!(\"Foo.rate\", false);\n        test!(\"Rand.id\", false);\n        test!(\"a.b.c\", false);\n\n        // PlanExpr::Expr\n        test!(\"-10\", true);\n        test!(\"rate!\", true);\n        test!(\"-wow\", false);\n        test!(\"('hello' || 'world')\", true);\n        test!(\"(name)\", true);\n        test!(\"(1 + cat)\", false);\n        test!(\"CAST(id AS DECIMAL)\", true);\n        test!(\"CAST(Hello.world AS BOOLEAN)\", false);\n        test!(\"EXTRACT(YEAR FROM DATE '2022-03-01')\", true);\n        test!(\"EXTRACT(YEAR FROM rate)\", true);\n        test!(\"EXTRACT(HOUR FROM virtual_env)\", false);\n        test!(\"rate IS NULL\", true);\n        test!(\"30 IS NULL\", true);\n        test!(\"rate IS NOT NULL\", true);\n        test!(\"taste IS NULL\", false);\n        test!(\"(1 + random) IS NOT NULL\", false);\n        test!(\"SUM(1)\", true);\n        test!(\"COUNT(*)\", true);\n        test!(\"MAX(rate)\", true);\n        test!(\"MIN(anywhere)\", false);\n        test!(\"AVG(countable)\", false);\n\n        // PlanExpr::TwoExprs\n        test!(\"1 + 2\", true);\n        test!(\"1 + name\", true);\n        test!(\"mic - 30\", false);\n\n        // PlanExpr::ThreeExprs\n        test!(\"30 BETWEEN 10 AND 20\", true);\n        test!(\"id BETWEEN rate AND 102\", true);\n        test!(\"margin BETWEEN 1 AND 2\", false);\n\n        // PlanExpr::MultiExprs\n        test!(\"1 IN (1, 2, 3)\", true);\n        test!(\"id IN (1, 30, 4)\", true);\n        test!(\"rate IN (id, 1, 2)\", true);\n        test!(\"9 IN (id, 1, 2)\", true);\n        test!(\"lab IN (100, 101)\", false);\n        test!(\"id IN (lab, 101)\", false);\n        test!(\"tree IN (something, 101)\", false);\n        test!(\"ROUND(1.54)\", true);\n        test!(\"TRIM(LEADING 'a' FROM name)\", true);\n        test!(\"LOWER(icecream)\", false);\n\n        // PlanExpr::Query\n        test!(\n            \"(\n                SELECT Bar.*, id, *\n                FROM Foo\n                JOIN Bar ON True\n                LEFT JOIN Empty ON True\n                WHERE Foo.id = 1\n                LIMIT 1 OFFSET 1\n            )\",\n            true\n        );\n        test!(\"(SELECT * FROM Foo JOIN Bar)\", true);\n        test!(\"(SELECT * FROM Foo JOIN Berry)\", false);\n        test!(\"(SELECT id FROM Carry)\", false);\n        test!(\"(SELECT id FROM Carry AS Foo)\", true);\n        test!(\"(SELECT T.id FROM Carry AS Bar)\", false);\n\n        // PlanExpr::QueryAndExpr\n        test!(\n            \"1 IN (\n                SELECT id, SUM(rate)\n                FROM Bar\n                GROUP BY id\n                HAVING True\n            )\",\n            true\n        );\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":85},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan","expr","aggregate.rs"],"content":"use crate::ast::{Aggregate, CountArgExpr, Expr};\n\nimpl Aggregate {\n    pub fn as_expr(\u0026self) -\u003e Option\u003c\u0026Expr\u003e {\n        match self {\n            Aggregate::Count(CountArgExpr::Wildcard) =\u003e None,\n            Aggregate::Count(CountArgExpr::Expr(expr))\n            | Aggregate::Sum(expr)\n            | Aggregate::Max(expr)\n            | Aggregate::Min(expr)\n            | Aggregate::Avg(expr)\n            | Aggregate::Variance(expr)\n            | Aggregate::Stdev(expr) =\u003e Some(expr),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::{Aggregate, Expr},\n        parse_sql::parse_expr,\n        translate::translate_expr,\n    };\n\n    fn parse(sql: \u0026str) -\u003e Aggregate {\n        let parsed = parse_expr(sql).unwrap();\n        let expr = translate_expr(\u0026parsed).unwrap();\n\n        match expr {\n            Expr::Aggregate(aggregate) =\u003e *aggregate,\n            _ =\u003e unreachable!(\"only for aggregate tests\"),\n        }\n    }\n\n    #[test]\n    fn as_expr() {\n        assert_eq!(parse(\"COUNT(*)\").as_expr(), None);\n\n        let actual = parse(\"COUNT(id)\");\n        let expected = Expr::Identifier(\"id\".to_owned());\n        assert_eq!(actual.as_expr(), Some(\u0026expected));\n\n        let actual = parse(\"SUM(id)\");\n        let expected = Expr::Identifier(\"id\".to_owned());\n        assert_eq!(actual.as_expr(), Some(\u0026expected));\n\n        let actual = parse(\"MAX(id)\");\n        let expected = Expr::Identifier(\"id\".to_owned());\n        assert_eq!(actual.as_expr(), Some(\u0026expected));\n\n        let actual = parse(\"MIN(id)\");\n        let expected = Expr::Identifier(\"id\".to_owned());\n        assert_eq!(actual.as_expr(), Some(\u0026expected));\n\n        let actual = parse(\"AVG(id)\");\n        let expected = Expr::Identifier(\"id\".to_owned());\n        assert_eq!(actual.as_expr(), Some(\u0026expected));\n\n        let actual = parse(\"VARIANCE(id)\");\n        let expected = Expr::Identifier(\"id\".to_owned());\n        assert_eq!(actual.as_expr(), Some(\u0026expected));\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan","expr","function.rs"],"content":"use {\n    crate::ast::{Expr, Function},\n    std::iter::{empty, once},\n};\n\nimpl Function {\n    pub fn as_exprs(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Expr\u003e {\n        #[derive(iter_enum::Iterator)]\n        enum Exprs\u003cI0, I1, I2, I3, I4, I5, I6\u003e {\n            Empty(I0),\n            Single(I1),\n            Double(I2),\n            Triple(I3),\n            VariableArgs(I4),\n            VariableArgsWithSingle(I5),\n            Quadruple(I6),\n        }\n\n        match self {\n            Self::Now()\n            | Function::Pi()\n            | Function::GenerateUuid()\n            | Self::Rand(None)\n            | Function::CurrentDate()\n            | Function::CurrentTime()\n            | Function::CurrentTimestamp() =\u003e Exprs::Empty(empty()),\n            Self::Lower(expr)\n            | Self::Length(expr)\n            | Self::Initcap(expr)\n            | Self::Upper(expr)\n            | Self::Sin(expr)\n            | Self::Cos(expr)\n            | Self::Tan(expr)\n            | Self::Asin(expr)\n            | Self::Acos(expr)\n            | Self::Atan(expr)\n            | Self::Radians(expr)\n            | Self::Degrees(expr)\n            | Self::Ceil(expr)\n            | Self::Rand(Some(expr))\n            | Self::Round(expr)\n            | Self::Floor(expr)\n            | Self::Exp(expr)\n            | Self::Ln(expr)\n            | Self::Log2(expr)\n            | Self::Log10(expr)\n            | Self::Sqrt(expr)\n            | Self::Abs(expr)\n            | Self::Sign(expr)\n            | Self::Ascii(expr)\n            | Self::Chr(expr)\n            | Self::Md5(expr)\n            | Self::Hex(expr)\n            | Self::LastDay(expr)\n            | Self::Ltrim { expr, chars: None }\n            | Self::Rtrim { expr, chars: None }\n            | Self::Trim {\n                expr,\n                filter_chars: None,\n                ..\n            }\n            | Self::Reverse(expr)\n            | Self::Cast { expr, .. }\n            | Self::Extract { expr, .. }\n            | Self::GetX(expr)\n            | Self::GetY(expr)\n            | Self::IsEmpty(expr)\n            | Self::Sort { expr, order: None }\n            | Self::Dedup(expr)\n            | Self::Entries(expr)\n            | Self::Keys(expr)\n            | Self::Values(expr) =\u003e Exprs::Single([expr].into_iter()),\n            Self::Left { expr, size: expr2 }\n            | Self::Right { expr, size: expr2 }\n            | Self::Lpad {\n                expr,\n                size: expr2,\n                fill: None,\n            }\n            | Self::Rpad {\n                expr,\n                size: expr2,\n                fill: None,\n            }\n            | Self::Trim {\n                expr,\n                filter_chars: Some(expr2),\n                ..\n            }\n            | Self::Log {\n                antilog: expr,\n                base: expr2,\n            }\n            | Self::Div {\n                dividend: expr,\n                divisor: expr2,\n            }\n            | Self::Mod {\n                dividend: expr,\n                divisor: expr2,\n            }\n            | Self::Gcd {\n                left: expr,\n                right: expr2,\n            }\n            | Self::Lcm {\n                left: expr,\n                right: expr2,\n            }\n            | Self::Format {\n                expr,\n                format: expr2,\n            }\n            | Self::ToDate {\n                expr,\n                format: expr2,\n            }\n            | Self::ToTimestamp {\n                expr,\n                format: expr2,\n            }\n            | Self::ToTime {\n                expr,\n                format: expr2,\n            }\n            | Self::Power { expr, power: expr2 }\n            | Self::Ltrim {\n                expr,\n                chars: Some(expr2),\n            }\n            | Self::Rtrim {\n                expr,\n                chars: Some(expr2),\n            }\n            | Self::Repeat { expr, num: expr2 }\n            | Self::Substr {\n                expr,\n                start: expr2,\n                count: None,\n            }\n            | Self::IfNull { expr, then: expr2 }\n            | Self::NullIf { expr1: expr, expr2 }\n            | Self::Unwrap {\n                expr,\n                selector: expr2,\n            }\n            | Self::Position {\n                from_expr: expr2,\n                sub_expr: expr,\n            }\n            | Self::FindIdx {\n                from_expr: expr,\n                sub_expr: expr2,\n                start: None,\n            }\n            | Self::Append { expr, value: expr2 }\n            | Self::Prepend { expr, value: expr2 }\n            | Self::Skip { expr, size: expr2 }\n            | Self::Sort {\n                expr,\n                order: Some(expr2),\n            }\n            | Self::Take { expr, size: expr2 }\n            | Self::Point { x: expr, y: expr2 }\n            | Self::CalcDistance {\n                geometry1: expr,\n                geometry2: expr2,\n            }\n            | Self::AddMonth { expr, size: expr2 } =\u003e Exprs::Double([expr, expr2].into_iter()),\n\n            Self::Lpad {\n                expr,\n                size: expr2,\n                fill: Some(expr3),\n            }\n            | Self::Rpad {\n                expr,\n                size: expr2,\n                fill: Some(expr3),\n            }\n            | Self::Substr {\n                expr,\n                start: expr2,\n                count: Some(expr3),\n            }\n            | Self::Iif {\n                cond: expr,\n                then: expr2,\n                else_result: expr3,\n            }\n            | Self::Replace {\n                expr,\n                old: expr2,\n                new: expr3,\n            }\n            | Self::Slice {\n                expr,\n                start: expr2,\n                length: expr3,\n            }\n            | Self::FindIdx {\n                from_expr: expr,\n                sub_expr: expr2,\n                start: Some(expr3),\n            }\n            | Self::Splice {\n                list_data: expr,\n                begin_index: expr2,\n                end_index: expr3,\n                values: None,\n            } =\u003e Exprs::Triple([expr, expr2, expr3].into_iter()),\n            Self::Custom { name: _, exprs } =\u003e Exprs::VariableArgs(exprs.iter()),\n            Self::Coalesce(exprs) =\u003e Exprs::VariableArgs(exprs.iter()),\n            Self::Concat(exprs) =\u003e Exprs::VariableArgs(exprs.iter()),\n            Self::ConcatWs { separator, exprs } =\u003e {\n                Exprs::VariableArgsWithSingle(once(separator).chain(exprs.iter()))\n            }\n            Self::Greatest(exprs) =\u003e Exprs::VariableArgs(exprs.iter()),\n            Self::Splice {\n                list_data: expr,\n                begin_index: expr2,\n                end_index: expr3,\n                values: Some(expr4),\n            } =\u003e Exprs::Quadruple([expr, expr2, expr3, expr4].into_iter()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{ast::Expr, parse_sql::parse_expr, translate::translate_expr};\n\n    fn expr(sql: \u0026str) -\u003e Expr {\n        let parsed = parse_expr(sql).expect(sql);\n\n        translate_expr(\u0026parsed).expect(sql)\n    }\n\n    fn test(sql: \u0026str, expected: \u0026[\u0026str]) {\n        let function = match expr(sql) {\n            Expr::Function(function) =\u003e *function,\n            _ =\u003e unreachable!(\"only for function tests\"),\n        };\n        let actual = function.as_exprs();\n        let actual = actual.collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(actual.len(), expected.len(), \"{sql}\");\n\n        for (expected, actual) in expected.iter().zip(actual.into_iter()) {\n            assert_eq!(actual, \u0026expr(expected), \"{sql}\");\n        }\n    }\n\n    #[test]\n    fn as_exprs() {\n        // Empty\n        test(\"NOW()\", \u0026[]);\n        test(\"CURRENT_DATE()\", \u0026[]);\n        test(\"CURRENT_TIME()\", \u0026[]);\n        test(\"CURRENT_TIMESTAMP()\", \u0026[]);\n        test(\"PI()\", \u0026[]);\n        test(\"GENERATE_UUID()\", \u0026[]);\n        test(\"RAND()\", \u0026[]);\n        test(\"CUSTOM_FUNC()\", \u0026[]);\n\n        // Single\n        test(\"LOWER(id)\", \u0026[\"id\"]);\n        test(\"INITCAP(id)\", \u0026[\"id\"]);\n        test(r#\"UPPER(\"Hello\")\"#, \u0026[r#\"\"Hello\"\"#]);\n        test(\"SIN(3.14)\", \u0026[\"3.14\"]);\n        test(\"COS(3.14)\", \u0026[\"3.14\"]);\n        test(\"TAN(3.14)\", \u0026[\"3.14\"]);\n        test(\"ASIN(3.14)\", \u0026[\"3.14\"]);\n        test(\"ACOS(3.14)\", \u0026[\"3.14\"]);\n        test(\"ATAN(3.14)\", \u0026[\"3.14\"]);\n        test(\"RADIANS(180)\", \u0026[\"180\"]);\n        test(\"DEGREES(3.14)\", \u0026[\"3.14\"]);\n        test(\"CEIL(1.23)\", \u0026[\"1.23\"]);\n        test(\"Rand(1.23)\", \u0026[\"1.23\"]);\n        test(\"ROUND(1.23)\", \u0026[\"1.23\"]);\n        test(\"FLOOR(1.23)\", \u0026[\"1.23\"]);\n        test(\"EXP(1.23)\", \u0026[\"1.23\"]);\n        test(\"LN(col + 1)\", \u0026[\"col + 1\"]);\n        test(\"LOG2(16)\", \u0026[\"16\"]);\n        test(\"LOG10(150 - 50)\", \u0026[\"150 - 50\"]);\n        test(\"SQRT(144)\", \u0026[\"144\"]);\n        test(\"LASTDAY(DATE '2020-01-01')\", \u0026[r#\"DATE '2020-01-01'\"#]);\n        test(r#\"LTRIM(\"  hello\")\"#, \u0026[r#\"\"  hello\"\"#]);\n        test(r#\"RTRIM(\"world  \")\"#, \u0026[r#\"\"world  \"\"#]);\n        test(r#\"TRIM(\"  rust  \")\"#, \u0026[r#\"\"  rust  \"\"#]);\n        test(r#\"REVERSE(\"abcde\")\"#, \u0026[r#\"\"abcde\"\"#]);\n        test(r#\"CAST(1 AS BOOLEAN)\"#, \u0026[\"1\"]);\n        test(r#\"IS_EMPTY(col)\"#, \u0026[\"col\"]);\n        test(r#\"VALUES(col)\"#, \u0026[\"col\"]);\n        test(r#\"HEX(10)\"#, \u0026[\"10\"]);\n\n        test(r#\"ABS(1)\"#, \u0026[\"1\"]);\n        test(r#\"ABS(-1)\"#, \u0026[\"-1\"]);\n        test(r#\"ABS(2)\"#, \u0026[\"2\"]);\n        test(r#\"ABS(-2)\"#, \u0026[\"-2\"]);\n        test(r#\"ABS(3.0)\"#, \u0026[\"3.0\"]);\n        test(r#\"ABS(-3.0)\"#, \u0026[\"-3.0\"]);\n\n        test(r#\"SIGN(1)\"#, \u0026[\"1\"]);\n        test(r#\"SIGN(-1)\"#, \u0026[\"-1\"]);\n        test(r#\"SIGN(2)\"#, \u0026[\"2\"]);\n        test(r#\"SIGN(-2)\"#, \u0026[\"-2\"]);\n        test(r#\"SIGN(3.0)\"#, \u0026[\"3.0\"]);\n        test(r#\"SIGN(-3.0)\"#, \u0026[\"-3.0\"]);\n\n        test(r#\"DEDUP(list)\"#, \u0026[\"list\"]);\n\n        // Double\n        test(r#\"LEFT(\"hello\", 2)\"#, \u0026[r#\"\"hello\"\"#, \"2\"]);\n        test(r#\"RIGHT(\"hello\", 2)\"#, \u0026[r#\"\"hello\"\"#, \"2\"]);\n        test(r#\"FIND_IDX(\"Calzone\", \"zone\")\"#, \u0026[r#\"Calzone\"#, r#\"zone\"#]);\n        test(r#\"TAKE(list, 3)\"#, \u0026[r#\"list\"#, r#\"3\"#]);\n        test(r#\"LPAD(value, 5)\"#, \u0026[\"value\", \"5\"]);\n        test(r#\"RPAD(value, 5)\"#, \u0026[\"value\", \"5\"]);\n        test(\n            r#\"TRIM(LEADING \"_\" FROM \"__hello\")\"#,\n            \u0026[r#\"\"__hello\"\"#, r#\"\"_\"\"#],\n        );\n        test(\"LOG(rate, 2)\", \u0026[\"rate\", \"2\"]);\n        test(\"DIV(6, 2)\", \u0026[\"6\", \"2\"]);\n        test(\"MOD(6, 2)\", \u0026[\"6\", \"2\"]);\n        test(\"GCD(6, 2)\", \u0026[\"6\", \"2\"]);\n        test(\"LCM(6, 2)\", \u0026[\"6\", \"2\"]);\n        test(\"POWER(base, 10)\", \u0026[\"base\", \"10\"]);\n        test(r#\"LTRIM(name, \"xyz\")\"#, \u0026[\"name\", r#\"\"xyz\"\"#]);\n        test(r#\"RTRIM(name, \"xyz\")\"#, \u0026[\"name\", r#\"\"xyz\"\"#]);\n        test(\"REPEAT(col || col2, 3)\", \u0026[\"col || col2\", \"3\"]);\n        test(\"REPEAT(column, 2)\", \u0026[\"column\", \"2\"]);\n        test(r#\"UNWRAP(field, \"foo.1\")\"#, \u0026[\"field\", r#\"\"foo.1\"\"#]);\n        test(r#\"SKIP(list, 2)\"#, \u0026[r#\"\"list\"\"#, r#\"2\"#]);\n\n        // Triple\n        test(\n            r#\"LPAD(name, 20, '\u003e\")++++\u003c')\"#,\n            \u0026[\"name\", \"20\", r#\"'\u003e\")++++\u003c'\"#],\n        );\n        test(\n            r#\"RPAD(name, 20, '\u003e\")++++\u003c')\"#,\n            \u0026[\"name\", \"20\", r#\"'\u003e\")++++\u003c'\"#],\n        );\n        test(\n            r#\"SUBSTR('   \u003e++++(\"\u003c   ', 3, 11)\"#,\n            \u0026[r#\"'   \u003e++++(\"\u003c   '\"#, \"3\", \"11\"],\n        );\n        test(r#\"SPLICE(list, 2, 4)\"#, \u0026[\"list\", \"2\", \"4\"]);\n\n        // Quadruple\n        test(\n            r#\"SPLICE(list, 3, 5, values)\"#,\n            \u0026[\"list\", \"3\", \"5\", \"values\"],\n        );\n\n        //VariableArgs\n        test(r#\"COALESCE(\"test\")\"#, \u0026[r#\"\"test\"\"#]);\n\n        test(r#\"COALESCE(NULL, \"test\")\"#, \u0026[\"NULL\", r#\"\"test\"\"#]);\n\n        test(r#\"CONCAT(\"abc\")\"#, \u0026[r#\"\"abc\"\"#]);\n\n        test(r#\"CONCAT(\"abc\", \"123\")\"#, \u0026[r#\"\"abc\"\"#, r#\"\"123\"\"#]);\n\n        test(r#\"CONCAT(\"a\", \"b\", \"c\")\"#, \u0026[r#\"\"a\"\"#, r#\"\"b\"\"#, r#\"\"c\"\"#]);\n\n        test(\n            r#\"CUSTOM_FUNC(\"a\", \"b\", \"c\")\"#,\n            \u0026[r#\"\"a\"\"#, r#\"\"b\"\"#, r#\"\"c\"\"#],\n        );\n\n        test(\n            r#\"CONCAT(\"gluesql\", \" \", \"is\", \" \", \"cool\")\"#,\n            \u0026[r#\"\"gluesql\"\"#, r#\"\" \"\"#, r#\"\"is\"\"#, r#\"\" \"\"#, r#\"\"cool\"\"#],\n        );\n\n        test(r#\"POSITION(\"men\" IN \"ramen\")\"#, \u0026[r#\"\"men\"\"#, r#\"\"ramen\"\"#]);\n        test(r#\"POSITION(\"men\" IN ramen)\"#, \u0026[r#\"\"men\"\"#, \"ramen\"]);\n\n        //TypedStringVariableArgs\n        test(\n            r#\"CONCAT_WS(\",\", \"gluesql\", \"is\", \"cool\")\"#,\n            \u0026[r#\"\",\"\"#, r#\"\"gluesql\"\"#, r#\"\"is\"\"#, r#\"\"cool\"\"#],\n        );\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":133},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan","expr.rs"],"content":"mod aggregate;\nmod function;\n\nuse {\n    crate::ast::{Expr, Query},\n    std::iter::once,\n};\n\n#[derive(Debug, PartialEq, Eq)]\npub enum PlanExpr\u003c'a\u003e {\n    None,\n    Identifier(\u0026'a str),\n    CompoundIdentifier { alias: \u0026'a str, ident: \u0026'a str },\n    Expr(\u0026'a Expr),\n    TwoExprs(\u0026'a Expr, \u0026'a Expr),\n    ThreeExprs(\u0026'a Expr, \u0026'a Expr, \u0026'a Expr),\n    MultiExprs(Vec\u003c\u0026'a Expr\u003e),\n    Query(\u0026'a Query),\n    QueryAndExpr { query: \u0026'a Query, expr: \u0026'a Expr },\n}\n\nimpl\u003c'a\u003e From\u003c\u0026'a Expr\u003e for PlanExpr\u003c'a\u003e {\n    fn from(expr: \u0026'a Expr) -\u003e Self {\n        match expr {\n            Expr::Literal(_) | Expr::TypedString { .. } =\u003e PlanExpr::None,\n            Expr::Identifier(ident) =\u003e PlanExpr::Identifier(ident),\n            Expr::CompoundIdentifier { alias, ident } =\u003e {\n                PlanExpr::CompoundIdentifier { alias, ident }\n            }\n            Expr::Nested(expr)\n            | Expr::UnaryOp { expr, .. }\n            | Expr::IsNull(expr)\n            | Expr::IsNotNull(expr)\n            | Expr::Interval { expr, .. } =\u003e PlanExpr::Expr(expr),\n            Expr::Aggregate(aggregate) =\u003e match aggregate.as_expr() {\n                Some(expr) =\u003e PlanExpr::Expr(expr),\n                None =\u003e PlanExpr::None,\n            },\n            Expr::BinaryOp { left, right, .. } =\u003e PlanExpr::TwoExprs(left, right),\n            Expr::Like { expr, pattern, .. } | Expr::ILike { expr, pattern, .. } =\u003e {\n                PlanExpr::TwoExprs(expr, pattern)\n            }\n            Expr::Between {\n                expr, low, high, ..\n            } =\u003e PlanExpr::ThreeExprs(expr, low, high),\n            Expr::InList { expr, list, .. } =\u003e {\n                let exprs = list.iter().chain(once(expr.as_ref())).collect();\n\n                PlanExpr::MultiExprs(exprs)\n            }\n            Expr::Case {\n                operand,\n                when_then,\n                else_result,\n            } =\u003e {\n                let (when, then): (Vec\u003c\u0026Expr\u003e, Vec\u003c_\u003e) =\n                    when_then.iter().map(|(expr, expr2)| (expr, expr2)).unzip();\n\n                let exprs = when\n                    .into_iter()\n                    .chain(then)\n                    .chain(operand.iter().map(AsRef::as_ref))\n                    .chain(else_result.iter().map(AsRef::as_ref))\n                    .collect();\n\n                PlanExpr::MultiExprs(exprs)\n            }\n            Expr::ArrayIndex { obj, indexes } =\u003e {\n                let exprs = indexes.iter().chain(once(obj.as_ref())).collect();\n                PlanExpr::MultiExprs(exprs)\n            }\n            Expr::Array { elem } =\u003e {\n                let exprs = elem.iter().collect();\n                PlanExpr::MultiExprs(exprs)\n            }\n            Expr::Function(function) =\u003e PlanExpr::MultiExprs(function.as_exprs().collect()),\n            Expr::Subquery(subquery) | Expr::Exists { subquery, .. } =\u003e PlanExpr::Query(subquery),\n            Expr::InSubquery {\n                expr,\n                subquery: query,\n                ..\n            } =\u003e PlanExpr::QueryAndExpr { expr, query },\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::PlanExpr,\n        crate::{\n            ast::{Expr, Query},\n            parse_sql::{parse_expr, parse_query},\n            translate::{translate_expr, translate_query},\n        },\n    };\n\n    fn expr(sql: \u0026str) -\u003e Expr {\n        let parsed = parse_expr(sql).expect(sql);\n\n        translate_expr(\u0026parsed).expect(sql)\n    }\n\n    fn query(sql: \u0026str) -\u003e Query {\n        let parsed = parse_query(sql).expect(sql);\n\n        translate_query(\u0026parsed).expect(sql)\n    }\n\n    #[test]\n    fn expr_to_plan_expr() {\n        macro_rules! test {\n            ($actual: expr, $expected: expr) =\u003e {\n                assert_eq!(PlanExpr::from(\u0026$actual), $expected);\n            };\n        }\n\n        // PlanExpr::None\n        assert_eq!(\n            PlanExpr::from(\u0026expr(r#\"DATE \"2022-03-09\"\"#)),\n            PlanExpr::None\n        );\n        assert_eq!(PlanExpr::from(\u0026expr(\"100\")), PlanExpr::None);\n        assert_eq!(PlanExpr::from(\u0026expr(\"COUNT(*)\")), PlanExpr::None);\n\n        // PlanExpr::Identifier\n        let actual = expr(\"id\");\n        let expected = PlanExpr::Identifier(\"id\");\n        test!(actual, expected);\n\n        // PlanExpr::CompoundIdentifier\n        let actual = expr(\"Foo.id\");\n        let expected = PlanExpr::CompoundIdentifier {\n            alias: \"Foo\",\n            ident: \"id\",\n        };\n        test!(actual, expected);\n\n        // PlanExpr::Expr\n        let actual = expr(\"SUM(id)\");\n        let expected = expr(\"id\");\n        let expected = PlanExpr::Expr(\u0026expected);\n        test!(actual, expected);\n\n        let actual = expr(\"(100)\");\n        let expected = expr(\"100\");\n        let expected = PlanExpr::Expr(\u0026expected);\n        test!(actual, expected);\n\n        let actual = expr(\"-100\");\n        let expected = expr(\"100\");\n        let expected = PlanExpr::Expr(\u0026expected);\n        test!(actual, expected);\n\n        let actual = expr(\"2048 IS NULL\");\n        let expected = expr(\"2048\");\n        let expected = PlanExpr::Expr(\u0026expected);\n        test!(actual, expected);\n\n        let actual = expr(\"1989 IS NOT NULL\");\n        let expected = expr(\"1989\");\n        let expected = PlanExpr::Expr(\u0026expected);\n        test!(actual, expected);\n\n        // PlanExpr::TwoExprs\n        let actual = expr(\"100 * rate\");\n        let left = expr(\"100\");\n        let right = expr(\"rate\");\n        let expected = PlanExpr::TwoExprs(\u0026left, \u0026right);\n        test!(actual, expected);\n\n        let actual = expr(\"name LIKE '_foo%'\");\n        let target = expr(\"name\");\n        let pattern = expr(\"'_foo%'\");\n        let expected = PlanExpr::TwoExprs(\u0026target, \u0026pattern);\n        test!(actual, expected);\n\n        let actual = expr(\"name ILIKE '_foo%'\");\n        let target = expr(\"name\");\n        let pattern = expr(\"'_foo%'\");\n        let expected = PlanExpr::TwoExprs(\u0026target, \u0026pattern);\n        test!(actual, expected);\n\n        // PlanExpr::ThreeExprs\n        let actual = expr(\"100 BETWEEN min_score AND max_score\");\n        let target = expr(\"100\");\n        let low = expr(\"min_score\");\n        let high = expr(\"max_score\");\n        let expected = PlanExpr::ThreeExprs(\u0026target, \u0026low, \u0026high);\n        test!(actual, expected);\n\n        let actual = expr(\"field IN (1, 2, 3, 4, 5)\");\n        let expected = [\"1\", \"2\", \"3\", \"4\", \"5\", \"field\"]\n            .into_iter()\n            .map(expr)\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let expected = PlanExpr::MultiExprs(expected.iter().collect());\n        test!(actual, expected);\n\n        let actual = expr(\n            \"\n            CASE id\n                WHEN 10 THEN col1\n                WHEN 20 THEN col2\n                ELSE col3\n            END\n        \",\n        );\n        let expected = [\"10\", \"20\", \"col1\", \"col2\", \"id\", \"col3\"]\n            .into_iter()\n            .map(expr)\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let expected = PlanExpr::MultiExprs(expected.iter().collect());\n        test!(actual, expected);\n\n        let actual = expr(r#\"TRIM(LEADING \"x\" FROM \"xxx\" || field)\"#);\n        let expected = [r#\"\"xxx\" || field\"#, r#\"\"x\"\"#]\n            .into_iter()\n            .map(expr)\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let expected = PlanExpr::MultiExprs(expected.iter().collect());\n        test!(actual, expected);\n\n        let actual = expr(\"CAST(0 AS BOOLEAN)\");\n        let expected = [\"0\"].into_iter().map(expr).collect::\u003cVec\u003c_\u003e\u003e();\n        let expected = PlanExpr::MultiExprs(expected.iter().collect());\n        test!(actual, expected);\n\n        let actual = expr(r#\"EXTRACT(YEAR FROM \"2000-01-01\")\"#);\n        let expected = [r#\"\"2000-01-01\"\"#]\n            .into_iter()\n            .map(expr)\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let expected = PlanExpr::MultiExprs(expected.iter().collect());\n        test!(actual, expected);\n\n        let actual = Expr::Subquery(Box::new(query(\"SELECT id FROM Foo\")));\n        let expected = query(\"SELECT id FROM Foo\");\n        let expected = PlanExpr::Query(\u0026expected);\n        test!(actual, expected);\n\n        let actual = expr(\"1 IN (SELECT id FROM Foo)\");\n        let target = expr(\"1\");\n        let subquery = query(\"SELECT id FROM Foo\");\n        let expected = PlanExpr::QueryAndExpr {\n            expr: \u0026target,\n            query: \u0026subquery,\n        };\n        test!(actual, expected);\n\n        let actual = expr(r#\"[\"GlueSql\",\"Rust\"]\"#);\n        let expected = [\"GlueSql\", \"Rust\"]\n            .into_iter()\n            .map(expr)\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let expected = PlanExpr::MultiExprs(expected.iter().collect());\n        test!(actual, expected);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan","index.rs"],"content":"use {\n    super::PlanError,\n    crate::{\n        ast::{\n            AstLiteral, BinaryOperator, Expr, Function, IndexItem, IndexOperator, OrderByExpr,\n            Query, Select, SetExpr, Statement, TableAlias, TableFactor, TableWithJoins,\n        },\n        data::{Schema, SchemaIndex, SchemaIndexOrd},\n        result::Result,\n    },\n    std::collections::HashMap,\n    utils::Vector,\n};\n\npub fn plan(schema_map: \u0026HashMap\u003cString, Schema\u003e, statement: Statement) -\u003e Result\u003cStatement\u003e {\n    match statement {\n        Statement::Query(query) =\u003e plan_query(schema_map, query).map(Statement::Query),\n        _ =\u003e Ok(statement),\n    }\n}\n\nstruct Indexes(Vec\u003cSchemaIndex\u003e);\n\nimpl Indexes {\n    fn find(\u0026self, target: \u0026Expr) -\u003e Option\u003cString\u003e {\n        self.0\n            .iter()\n            .find(|SchemaIndex { expr, .. }| expr == target)\n            .map(|SchemaIndex { name, .. }| name.to_owned())\n    }\n\n    fn find_ordered(\u0026self, target: \u0026OrderByExpr) -\u003e Option\u003cString\u003e {\n        self.0\n            .iter()\n            .find(|SchemaIndex { expr, order, .. }| {\n                if expr != \u0026target.expr {\n                    return false;\n                }\n\n                matches!(\n                    (target.asc, order),\n                    (_, SchemaIndexOrd::Both)\n                        | (Some(true), SchemaIndexOrd::Asc)\n                        | (None, SchemaIndexOrd::Asc)\n                        | (Some(false), SchemaIndexOrd::Desc)\n                )\n            })\n            .map(|SchemaIndex { name, .. }| name.to_owned())\n    }\n}\n\nfn plan_query(schema_map: \u0026HashMap\u003cString, Schema\u003e, query: Query) -\u003e Result\u003cQuery\u003e {\n    let Query {\n        body,\n        order_by,\n        limit,\n        offset,\n    } = query;\n\n    let select = match body {\n        SetExpr::Select(select) =\u003e select,\n        SetExpr::Values(_) =\u003e {\n            return Ok(Query {\n                body,\n                order_by,\n                limit,\n                offset,\n            });\n        }\n    };\n\n    let TableWithJoins { relation, .. } = \u0026select.from;\n    let table_name = match relation {\n        TableFactor::Table { name, .. } =\u003e name,\n        TableFactor::Derived { .. } =\u003e {\n            return Ok(Query {\n                body: SetExpr::Select(select),\n                order_by,\n                limit,\n                offset,\n            });\n        }\n        TableFactor::Series {\n            alias: TableAlias { name, .. },\n            ..\n        } =\u003e name,\n        TableFactor::Dictionary {\n            alias: TableAlias { name, .. },\n            ..\n        } =\u003e name,\n    };\n\n    let indexes = match schema_map.get(table_name) {\n        Some(Schema { indexes, .. }) =\u003e Indexes(indexes.clone()),\n        None =\u003e {\n            return Ok(Query {\n                body: SetExpr::Select(select),\n                order_by,\n                limit,\n                offset,\n            });\n        }\n    };\n\n    let index = order_by.last().and_then(|value_expr| {\n        indexes\n            .find_ordered(value_expr)\n            .map(|name| IndexItem::NonClustered {\n                name,\n                asc: value_expr.asc,\n                cmp_expr: None,\n            })\n    });\n\n    if index.is_some() {\n        let Select {\n            projection,\n            from,\n            selection,\n            group_by,\n            having,\n        } = *select;\n\n        let TableWithJoins { relation, joins } = from;\n        let (name, alias) = match relation {\n            TableFactor::Table { name, alias, .. } =\u003e (name, alias),\n            TableFactor::Derived { .. }\n            | TableFactor::Series { .. }\n            | TableFactor::Dictionary { .. } =\u003e {\n                return Err(PlanError::Unreachable.into());\n            }\n        };\n\n        let from = TableWithJoins {\n            relation: TableFactor::Table { name, alias, index },\n            joins,\n        };\n\n        let select = Select {\n            projection,\n            from,\n            selection,\n            group_by,\n            having,\n        };\n\n        Ok(Query {\n            body: SetExpr::Select(Box::new(select)),\n            order_by: Vector::from(order_by).pop().0.into(),\n            limit,\n            offset,\n        })\n    } else {\n        let select = plan_select(schema_map, \u0026indexes, *select)?;\n        let body = SetExpr::Select(Box::new(select));\n        let query = Query {\n            body,\n            order_by,\n            limit,\n            offset,\n        };\n\n        Ok(query)\n    }\n}\n\nfn plan_select(\n    schema_map: \u0026HashMap\u003cString, Schema\u003e,\n    indexes: \u0026Indexes,\n    select: Select,\n) -\u003e Result\u003cSelect\u003e {\n    let Select {\n        projection,\n        from,\n        selection,\n        group_by,\n        having,\n    } = select;\n\n    let selection = match selection {\n        Some(expr) =\u003e expr,\n        None =\u003e {\n            return Ok(Select {\n                projection,\n                from,\n                selection,\n                group_by,\n                having,\n            });\n        }\n    };\n\n    match plan_index(schema_map, indexes, selection)? {\n        Planned::Expr(selection) =\u003e Ok(Select {\n            projection,\n            from,\n            selection: Some(selection),\n            group_by,\n            having,\n        }),\n        Planned::IndexedExpr {\n            index_name,\n            index_op,\n            index_value_expr,\n            selection,\n        } =\u003e {\n            let TableWithJoins { relation, joins } = from;\n            let (name, alias) = match relation {\n                TableFactor::Table { name, alias, .. } =\u003e (name, alias),\n                TableFactor::Derived { .. }\n                | TableFactor::Series { .. }\n                | TableFactor::Dictionary { .. } =\u003e {\n                    return Err(PlanError::Unreachable.into());\n                }\n            };\n\n            let index = Some(IndexItem::NonClustered {\n                name: index_name,\n                asc: None,\n                cmp_expr: Some((index_op, index_value_expr)),\n            });\n            let from = TableWithJoins {\n                relation: TableFactor::Table { name, alias, index },\n                joins,\n            };\n\n            Ok(Select {\n                projection,\n                from,\n                selection,\n                group_by,\n                having,\n            })\n        }\n    }\n}\n\nenum Planned {\n    IndexedExpr {\n        index_name: String,\n        index_op: IndexOperator,\n        index_value_expr: Expr,\n        selection: Option\u003cExpr\u003e,\n    },\n    Expr(Expr),\n}\n\nfn plan_index(\n    schema_map: \u0026HashMap\u003cString, Schema\u003e,\n    indexes: \u0026Indexes,\n    selection: Expr,\n) -\u003e Result\u003cPlanned\u003e {\n    match selection {\n        Expr::Nested(expr) =\u003e plan_index(schema_map, indexes, *expr),\n        Expr::IsNull(expr) =\u003e Ok(search_is_null(indexes, true, expr)),\n        Expr::IsNotNull(expr) =\u003e Ok(search_is_null(indexes, false, expr)),\n        Expr::Subquery(query) =\u003e plan_query(schema_map, *query)\n            .map(Box::new)\n            .map(Expr::Subquery)\n            .map(Planned::Expr),\n        Expr::Exists { subquery, negated } =\u003e plan_query(schema_map, *subquery)\n            .map(Box::new)\n            .map(|subquery| Expr::Exists { subquery, negated })\n            .map(Planned::Expr),\n        Expr::InSubquery {\n            expr,\n            subquery,\n            negated,\n        } =\u003e plan_query(schema_map, *subquery)\n            .map(Box::new)\n            .map(|subquery| Expr::InSubquery {\n                expr,\n                subquery,\n                negated,\n            })\n            .map(Planned::Expr),\n        Expr::BinaryOp {\n            left,\n            op: BinaryOperator::And,\n            right,\n        } =\u003e {\n            let left = match plan_index(schema_map, indexes, *left)? {\n                Planned::Expr(selection) =\u003e selection,\n                Planned::IndexedExpr {\n                    index_name,\n                    index_value_expr,\n                    index_op,\n                    selection,\n                } =\u003e {\n                    let selection = match selection {\n                        Some(expr) =\u003e Expr::BinaryOp {\n                            left: Box::new(expr),\n                            op: BinaryOperator::And,\n                            right,\n                        },\n                        None =\u003e *right,\n                    };\n\n                    return Ok(Planned::IndexedExpr {\n                        index_name,\n                        index_op,\n                        index_value_expr,\n                        selection: Some(selection),\n                    });\n                }\n            };\n\n            match plan_index(schema_map, indexes, *right)? {\n                Planned::Expr(expr) =\u003e Ok(Planned::Expr(Expr::BinaryOp {\n                    left: Box::new(left),\n                    op: BinaryOperator::And,\n                    right: Box::new(expr),\n                })),\n                Planned::IndexedExpr {\n                    index_name,\n                    index_op,\n                    index_value_expr,\n                    selection,\n                } =\u003e {\n                    let selection = match selection {\n                        Some(expr) =\u003e Expr::BinaryOp {\n                            left: Box::new(left),\n                            op: BinaryOperator::And,\n                            right: Box::new(expr),\n                        },\n                        None =\u003e left,\n                    };\n\n                    Ok(Planned::IndexedExpr {\n                        index_name,\n                        index_value_expr,\n                        index_op,\n                        selection: Some(selection),\n                    })\n                }\n            }\n        }\n        Expr::BinaryOp {\n            left,\n            op: BinaryOperator::Gt,\n            right,\n        } =\u003e Ok(search_index_op(indexes, IndexOperator::Gt, left, right)),\n        Expr::BinaryOp {\n            left,\n            op: BinaryOperator::Lt,\n            right,\n        } =\u003e Ok(search_index_op(indexes, IndexOperator::Lt, left, right)),\n        Expr::BinaryOp {\n            left,\n            op: BinaryOperator::GtEq,\n            right,\n        } =\u003e Ok(search_index_op(indexes, IndexOperator::GtEq, left, right)),\n        Expr::BinaryOp {\n            left,\n            op: BinaryOperator::LtEq,\n            right,\n        } =\u003e Ok(search_index_op(indexes, IndexOperator::LtEq, left, right)),\n        Expr::BinaryOp {\n            left,\n            op: BinaryOperator::Eq,\n            right,\n        } =\u003e Ok(search_index_op(indexes, IndexOperator::Eq, left, right)),\n        _ =\u003e Ok(Planned::Expr(selection)),\n    }\n}\n\nfn search_is_null(indexes: \u0026Indexes, null: bool, expr: Box\u003cExpr\u003e) -\u003e Planned {\n    match indexes.find(expr.as_ref()) {\n        Some(index_name) =\u003e {\n            let index_op = if null {\n                IndexOperator::Eq\n            } else {\n                IndexOperator::Lt\n            };\n\n            Planned::IndexedExpr {\n                index_name,\n                index_op,\n                index_value_expr: Expr::Literal(AstLiteral::Null),\n                selection: None,\n            }\n        }\n        None =\u003e {\n            let expr = if null {\n                Expr::IsNull(expr)\n            } else {\n                Expr::IsNotNull(expr)\n            };\n\n            Planned::Expr(expr)\n        }\n    }\n}\n\nfn search_index_op(\n    indexes: \u0026Indexes,\n    index_op: IndexOperator,\n    left: Box\u003cExpr\u003e,\n    right: Box\u003cExpr\u003e,\n) -\u003e Planned {\n    if let Some(index_name) = indexes\n        .find(left.as_ref())\n        .and_then(|index_name| is_stateless(right.as_ref()).then_some(index_name))\n    {\n        Planned::IndexedExpr {\n            index_name,\n            index_op,\n            index_value_expr: *right,\n            selection: None,\n        }\n    } else if let Some(index_name) = indexes\n        .find(right.as_ref())\n        .and_then(|index_name| is_stateless(left.as_ref()).then_some(index_name))\n    {\n        Planned::IndexedExpr {\n            index_name,\n            index_op: index_op.reverse(),\n            index_value_expr: *left,\n            selection: None,\n        }\n    } else if let Expr::Nested(left) = *left {\n        search_index_op(indexes, index_op, left, right)\n    } else if let Expr::Nested(right) = *right {\n        search_index_op(indexes, index_op, left, right)\n    } else {\n        Planned::Expr(Expr::BinaryOp {\n            left,\n            op: index_op.into(),\n            right,\n        })\n    }\n}\n\nfn is_stateless(expr: \u0026Expr) -\u003e bool {\n    match expr {\n        Expr::Literal(AstLiteral::Null) =\u003e false,\n        Expr::Literal(_) =\u003e true,\n        Expr::TypedString { .. } =\u003e true,\n        Expr::IsNull(expr)\n        | Expr::IsNotNull(expr)\n        | Expr::UnaryOp { expr, .. }\n        | Expr::Nested(expr) =\u003e is_stateless(expr.as_ref()),\n        Expr::Function(func) =\u003e match func.as_ref() {\n            Function::Cast { expr, .. } =\u003e is_stateless(expr),\n            _ =\u003e false,\n        },\n        Expr::BinaryOp { left, right, .. } =\u003e {\n            is_stateless(left.as_ref()) \u0026\u0026 is_stateless(right.as_ref())\n        }\n        _ =\u003e false,\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":244},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan","join.rs"],"content":"use {\n    super::{context::Context, evaluable::check_expr as check_evaluable, planner::Planner},\n    crate::{\n        ast::{\n            BinaryOperator, Expr, Join, JoinConstraint, JoinExecutor, JoinOperator, Query, Select,\n            SetExpr, Statement, TableWithJoins,\n        },\n        data::Schema,\n    },\n    std::{collections::HashMap, rc::Rc},\n    utils::Vector,\n};\n\npub fn plan(schema_map: \u0026HashMap\u003cString, Schema\u003e, statement: Statement) -\u003e Statement {\n    let planner = JoinPlanner { schema_map };\n\n    match statement {\n        Statement::Query(query) =\u003e {\n            let query = planner.query(None, query);\n\n            Statement::Query(query)\n        }\n        _ =\u003e statement,\n    }\n}\n\nstruct JoinPlanner\u003c'a\u003e {\n    schema_map: \u0026'a HashMap\u003cString, Schema\u003e,\n}\n\nimpl\u003c'a\u003e Planner\u003c'a\u003e for JoinPlanner\u003c'a\u003e {\n    fn query(\u0026self, outer_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e, query: Query) -\u003e Query {\n        let Query {\n            body,\n            order_by,\n            limit,\n            offset,\n        } = query;\n\n        let body = match body {\n            SetExpr::Select(select) =\u003e {\n                let select = self.select(outer_context, *select);\n\n                SetExpr::Select(Box::new(select))\n            }\n            SetExpr::Values(_) =\u003e body,\n        };\n\n        Query {\n            body,\n            order_by,\n            limit,\n            offset,\n        }\n    }\n\n    fn get_schema(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026'a Schema\u003e {\n        self.schema_map.get(name)\n    }\n}\n\nimpl\u003c'a\u003e JoinPlanner\u003c'a\u003e {\n    fn select(\u0026self, outer_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e, select: Select) -\u003e Select {\n        let Select {\n            projection,\n            from,\n            selection,\n            group_by,\n            having,\n        } = select;\n\n        let (outer_context, from) = self.table_with_joins(outer_context, from);\n        let selection = selection.map(|expr| self.subquery_expr(outer_context, expr));\n\n        Select {\n            projection,\n            from,\n            selection,\n            group_by,\n            having,\n        }\n    }\n\n    fn table_with_joins(\n        \u0026self,\n        outer_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n        table_with_joins: TableWithJoins,\n    ) -\u003e (Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e, TableWithJoins) {\n        let TableWithJoins { relation, joins } = table_with_joins;\n        let init_context = self.update_context(None, \u0026relation);\n        let (context, joins) =\n            joins\n                .into_iter()\n                .fold((init_context, Vector::new()), |(context, joins), join| {\n                    let outer_context = outer_context.as_ref().map(Rc::clone);\n                    let (context, join) = self.join(outer_context, context, join);\n                    let joins = joins.push(join);\n\n                    (context, joins)\n                });\n        let joins = joins.into();\n        let context = Context::concat(context, outer_context);\n\n        (context, TableWithJoins { relation, joins })\n    }\n\n    fn join(\n        \u0026self,\n        outer_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n        inner_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n        join: Join,\n    ) -\u003e (Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e, Join) {\n        let Join {\n            relation,\n            join_operator,\n            join_executor,\n        } = join;\n\n        if matches!(join_executor, JoinExecutor::Hash { .. }) {\n            let context = self.update_context(inner_context, \u0026relation);\n            let join = Join {\n                relation,\n                join_operator,\n                join_executor,\n            };\n\n            return (context, join);\n        }\n\n        enum JoinOp {\n            Inner,\n            LeftOuter,\n        }\n\n        let (join_op, expr) = match join_operator {\n            JoinOperator::Inner(JoinConstraint::On(expr)) =\u003e (JoinOp::Inner, expr),\n            JoinOperator::LeftOuter(JoinConstraint::On(expr)) =\u003e (JoinOp::LeftOuter, expr),\n            JoinOperator::Inner(JoinConstraint::None)\n            | JoinOperator::LeftOuter(JoinConstraint::None) =\u003e {\n                let context = self.update_context(inner_context, \u0026relation);\n                let join = Join {\n                    relation,\n                    join_operator,\n                    join_executor,\n                };\n\n                return (context, join);\n            }\n        };\n\n        let current_context = self.update_context(None, \u0026relation);\n        let (join_executor, expr) = self.join_expr(\n            outer_context,\n            inner_context.as_ref().map(Rc::clone),\n            current_context,\n            expr,\n        );\n\n        let join_operator = match (join_op, expr) {\n            (JoinOp::Inner, Some(expr)) =\u003e JoinOperator::Inner(JoinConstraint::On(expr)),\n            (JoinOp::Inner, None) =\u003e JoinOperator::Inner(JoinConstraint::None),\n            (JoinOp::LeftOuter, Some(expr)) =\u003e JoinOperator::LeftOuter(JoinConstraint::On(expr)),\n            (JoinOp::LeftOuter, None) =\u003e JoinOperator::LeftOuter(JoinConstraint::None),\n        };\n\n        let context = self.update_context(inner_context, \u0026relation);\n        let join = Join {\n            relation,\n            join_operator,\n            join_executor,\n        };\n\n        (context, join)\n    }\n\n    fn join_expr(\n        \u0026self,\n        outer_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n        inner_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n        current_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n        expr: Expr,\n    ) -\u003e (JoinExecutor, Option\u003cExpr\u003e) {\n        match expr {\n            Expr::BinaryOp {\n                left,\n                op: BinaryOperator::Eq,\n                right,\n            } =\u003e {\n                let key_context = {\n                    let current = current_context.as_ref().map(Rc::clone);\n                    let outer = outer_context.as_ref().map(Rc::clone);\n\n                    Context::concat(current, outer)\n                };\n                let value_context = {\n                    let context = Context::concat(current_context, inner_context);\n\n                    Context::concat(context, outer_context)\n                };\n\n                let left_as_key = check_evaluable(key_context.as_ref().map(Rc::clone), \u0026left);\n                let right_as_value = check_evaluable(value_context.as_ref().map(Rc::clone), \u0026right);\n\n                if left_as_key \u0026\u0026 right_as_value {\n                    let join_executor = JoinExecutor::Hash {\n                        key_expr: *left,\n                        value_expr: *right,\n                        where_clause: None,\n                    };\n\n                    return (join_executor, None);\n                }\n\n                let right_as_key = check_evaluable(key_context, \u0026right);\n                let left_as_value = left_as_key || check_evaluable(value_context, \u0026left);\n\n                if right_as_key \u0026\u0026 left_as_value {\n                    let join_executor = JoinExecutor::Hash {\n                        key_expr: *right,\n                        value_expr: *left,\n                        where_clause: None,\n                    };\n\n                    return (join_executor, None);\n                }\n\n                let expr = Expr::BinaryOp {\n                    left,\n                    op: BinaryOperator::Eq,\n                    right,\n                };\n\n                (JoinExecutor::NestedLoop, Some(expr))\n            }\n            Expr::BinaryOp {\n                left,\n                op: BinaryOperator::And,\n                right,\n            } =\u003e {\n                let (join_executor, left) = self.join_expr(\n                    outer_context.as_ref().map(Rc::clone),\n                    inner_context.as_ref().map(Rc::clone),\n                    current_context.as_ref().map(Rc::clone),\n                    *left,\n                );\n\n                if let JoinExecutor::Hash {\n                    key_expr,\n                    value_expr,\n                    where_clause,\n                } = join_executor\n                {\n                    let context = {\n                        let current = current_context.as_ref().map(Rc::clone);\n                        let outer = outer_context.as_ref().map(Rc::clone);\n\n                        Context::concat(current, outer)\n                    };\n\n                    let expr = match left {\n                        Some(left) =\u003e Expr::BinaryOp {\n                            left: Box::new(left),\n                            op: BinaryOperator::And,\n                            right,\n                        },\n                        None =\u003e *right,\n                    };\n\n                    let (evaluable_expr, expr) = find_evaluable(context, expr);\n\n                    let where_clause = match (where_clause, evaluable_expr) {\n                        (Some(expr), Some(expr2)) =\u003e Some(Expr::BinaryOp {\n                            left: Box::new(expr),\n                            op: BinaryOperator::And,\n                            right: Box::new(expr2),\n                        }),\n                        (Some(expr), None) | (None, Some(expr)) =\u003e Some(expr),\n                        (None, None) =\u003e None,\n                    };\n\n                    let join_executor = JoinExecutor::Hash {\n                        key_expr,\n                        value_expr,\n                        where_clause,\n                    };\n\n                    return (join_executor, expr);\n                }\n\n                let (join_executor, right) = self.join_expr(\n                    outer_context.as_ref().map(Rc::clone),\n                    inner_context,\n                    current_context.as_ref().map(Rc::clone),\n                    *right,\n                );\n\n                let expr = match (left, right) {\n                    (Some(left), Some(right)) =\u003e Some(Expr::BinaryOp {\n                        left: Box::new(left),\n                        op: BinaryOperator::And,\n                        right: Box::new(right),\n                    }),\n                    (expr @ Some(_), None) | (None, expr @ Some(_)) =\u003e expr,\n                    // (None,None) -\u003e unreachable\n                    // To resolve this,\n                    // join_expr should return an enum of\n                    //   Consumed(Option\u003cExpr\u003e) or NotConsumed(Expr)\n                    (None, None) =\u003e None,\n                };\n\n                match join_executor {\n                    JoinExecutor::NestedLoop =\u003e (join_executor, expr),\n                    JoinExecutor::Hash {\n                        key_expr,\n                        value_expr,\n                        where_clause,\n                    } =\u003e {\n                        let context = Context::concat(current_context, outer_context);\n                        let (evaluable_expr, expr) = expr\n                            .map(|expr| find_evaluable(context, expr))\n                            .unwrap_or((None, None));\n\n                        let where_clause = match (where_clause, evaluable_expr) {\n                            (Some(expr), Some(expr2)) =\u003e Some(Expr::BinaryOp {\n                                left: Box::new(expr),\n                                op: BinaryOperator::And,\n                                right: Box::new(expr2),\n                            }),\n                            (Some(expr), None) | (None, Some(expr)) =\u003e Some(expr),\n                            (None, None) =\u003e None,\n                        };\n\n                        let join_executor = JoinExecutor::Hash {\n                            key_expr,\n                            value_expr,\n                            where_clause,\n                        };\n\n                        (join_executor, expr)\n                    }\n                }\n            }\n            Expr::Nested(expr) =\u003e {\n                self.join_expr(outer_context, inner_context, current_context, *expr)\n            }\n            Expr::Subquery(query) =\u003e {\n                let context = Context::concat(current_context, inner_context);\n                let context = Context::concat(context, outer_context);\n\n                let query = self.query(context, *query);\n                let expr = Some(Expr::Subquery(Box::new(query)));\n\n                (JoinExecutor::NestedLoop, expr)\n            }\n            Expr::InSubquery {\n                expr,\n                subquery,\n                negated,\n            } =\u003e {\n                let context = Context::concat(current_context, inner_context);\n                let context = Context::concat(context, outer_context);\n\n                let subquery = self.query(context, *subquery);\n                let expr = Some(Expr::InSubquery {\n                    expr,\n                    subquery: Box::new(subquery),\n                    negated,\n                });\n                (JoinExecutor::NestedLoop, expr)\n            }\n            Expr::Exists { subquery, negated } =\u003e {\n                let context = Context::concat(current_context, inner_context);\n                let context = Context::concat(context, outer_context);\n\n                let subquery = self.query(context, *subquery);\n                let expr = Some(Expr::Exists {\n                    subquery: Box::new(subquery),\n                    negated,\n                });\n                (JoinExecutor::NestedLoop, expr)\n            }\n            _ =\u003e (JoinExecutor::NestedLoop, Some(expr)),\n        }\n    }\n}\n\ntype EvaluableExpr = Option\u003cExpr\u003e;\ntype RemainderExpr = Option\u003cExpr\u003e;\n\nfn find_evaluable(context: Option\u003cRc\u003cContext\u003c'_\u003e\u003e\u003e, expr: Expr) -\u003e (EvaluableExpr, RemainderExpr) {\n    match expr {\n        Expr::BinaryOp {\n            left,\n            op: BinaryOperator::And,\n            right,\n        } =\u003e {\n            let (evaluable, remainder) = find_evaluable(context.as_ref().map(Rc::clone), *left);\n            let (evaluable2, remainder2) = find_evaluable(context, *right);\n\n            let merge = |expr, expr2| match (expr, expr2) {\n                (Some(expr), Some(expr2)) =\u003e Some(Expr::BinaryOp {\n                    left: Box::new(expr),\n                    op: BinaryOperator::And,\n                    right: Box::new(expr2),\n                }),\n                (Some(expr), None) | (None, Some(expr)) =\u003e Some(expr),\n                (None, None) =\u003e None,\n            };\n\n            let evaluable_expr = merge(evaluable, evaluable2);\n            let remainder_expr = merge(remainder, remainder2);\n\n            (evaluable_expr, remainder_expr)\n        }\n        _ if check_evaluable(context, \u0026expr) =\u003e (Some(expr), None),\n        _ =\u003e (None, Some(expr)),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::plan,\n        crate::{\n            ast::{DateTimeField, Statement},\n            ast_builder::{Build, QueryNode, col, exists, num, subquery, table},\n            mock::{MockStorage, run},\n            parse_sql::parse,\n            plan::fetch_schema_map,\n            translate::translate,\n        },\n        futures::executor::block_on,\n    };\n\n    fn plan_join(storage: \u0026MockStorage, sql: \u0026str) -\u003e Statement {\n        let parsed = parse(sql).expect(sql).into_iter().next().unwrap();\n        let statement = translate(\u0026parsed).unwrap();\n        let schema_map = block_on(fetch_schema_map(storage, \u0026statement)).unwrap();\n\n        plan(\u0026schema_map, statement)\n    }\n\n    macro_rules! test {\n        ($actual: expr, $expected: expr, $name: literal) =\u003e {\n            let expected = $expected.build().unwrap();\n\n            assert_eq!($actual, expected, $name);\n        };\n    }\n\n    #[test]\n    fn basic() {\n        let storage = run(\"\n            CREATE TABLE Player (\n                id INTEGER,\n                name TEXT\n            );\n            CREATE TABLE PlayerItem (\n                user_id INTEGER,\n                item_id INTEGER,\n                amount INTEGER\n            );\n        \");\n\n        let sql = \"SELECT * FROM Player;\";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\").select();\n        test!(actual, expected, \"basic select:\\n{sql}\");\n\n        let sql = \"DELETE FROM Player WHERE id = 1;\";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\").delete().filter(\"id = 1\");\n        test!(actual, expected, \"plan not covered:\\n{sql}\");\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            JOIN PlayerItem ON PlayerItem.user_id != Player.id\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .on(\"PlayerItem.user_id != Player.id\");\n        test!(actual, expected, \"basic nested loop join:\\n{sql}\");\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            LEFT JOIN PlayerItem ON PlayerItem.amount \u003e 2\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .left_join(\"PlayerItem\")\n            .on(\"PlayerItem.amount \u003e 2\");\n        test!(actual, expected, \"basic nested loop join 2:\\n{sql}\");\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            JOIN Empty u2\n            LEFT JOIN Player u3;\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .join_as(\"Empty\", \"u2\")\n            .left_join_as(\"Player\", \"u3\");\n        test!(actual, expected, \"self multiple joins:\\n{sql}\");\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            JOIN PlayerItem ON PlayerItem.user_id = Player.id\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\");\n        test!(actual, expected, \"basic hash join query:\\n{sql}\");\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            JOIN PlayerItem ON PlayerItem.user_id = Player.id\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let actual = {\n            let schema_map = block_on(fetch_schema_map(\u0026storage, \u0026actual)).unwrap();\n\n            plan(\u0026schema_map, actual)\n        };\n        let expected = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\");\n        test!(\n            actual,\n            expected,\n            \"redundant plan does not change the plan result:\\n{sql}\"\n        );\n\n        let sql = \"\n            SELECT * FROM Player\n            JOIN PlayerItem ON (SELECT * FROM Player u2)\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .on(\"(SELECT * FROM Player u2)\");\n        test!(actual, expected, \"subquery in join_constraint:\\n{sql}\");\n    }\n\n    #[test]\n    fn hash_join() {\n        let storage = run(\"\n            CREATE TABLE Player (\n                id INTEGER,\n                name TEXT\n            );\n            CREATE TABLE Item (\n                id INTEGER,\n                name TEXT\n            );\n            CREATE TABLE PlayerItem (\n                user_id INTEGER,\n                item_id INTEGER,\n                amount INTEGER\n            );\n        \");\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            LEFT JOIN PlayerItem ON\n                PlayerItem.amount \u003e 10 AND\n                PlayerItem.user_id = Player.id\n            WHERE True;\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .left_join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .hash_filter(\"PlayerItem.amount \u003e 10\")\n            .filter(true);\n        test!(actual, expected, \"where_clause AND hash_join expr:\\n{sql}\");\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            JOIN PlayerItem ON\n                (PlayerItem.user_id = Player.id) AND\n                Player.name = 'abcd' AND\n                Player.name != 'barcode'\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .on(\"Player.name = 'abcd' AND Player.name != 'barcode'\");\n        test!(\n            actual,\n            expected,\n            \"nested expr \u0026 remaining join constraint:\\n{sql}\"\n        );\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            LEFT JOIN PlayerItem ON\n                PlayerItem.amount \u003e 10 AND\n                PlayerItem.amount * 3 \u003c= 2 AND\n                PlayerItem.user_id = Player.id\n            WHERE True;\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .left_join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .hash_filter(\"PlayerItem.amount \u003e 10 AND PlayerItem.amount * 3 \u003c= 2\")\n            .filter(true);\n        test!(actual, expected, \"complex where_clause:\\n{sql}\");\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            JOIN PlayerItem ON\n                Player.id = PlayerItem.user_id AND\n                PlayerItem.amount \u003e 10\n            WHERE True;\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .hash_filter(\"PlayerItem.amount \u003e 10\")\n            .filter(true);\n        test!(actual, expected, \"hash_join expr AND where_clause:\\n{sql}\");\n\n        let sql = \"\n            SELECT *\n            FROM Player u1\n            LEFT OUTER JOIN Player u2\n            WHERE u2.id = (\n                SELECT u3.id\n                FROM Player u3\n                JOIN Player u4 ON\n                    u4.id = u3.id AND\n                    u4.id = u1.id\n            );\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .alias_as(\"u1\")\n            .select()\n            .left_join_as(\"Player\", \"u2\")\n            .filter(\n                col(\"u2.id\").eq(subquery(\n                    table(\"Player\")\n                        .alias_as(\"u3\")\n                        .select()\n                        .join_as(\"Player\", \"u4\")\n                        .hash_executor(\"u4.id\", \"u3.id\")\n                        .hash_filter(\"u4.id = u1.id\")\n                        .project(\"u3.id\"),\n                )),\n            );\n        test!(actual, expected, \"hash join in subquery:\\n{sql}\");\n\n        let sql = \"\n            SELECT * FROM Player u1\n            WHERE u1.id = (\n                SELECT * FROM Player u2\n                WHERE u2.id = (\n                    SELECT * FROM Player u3\n                    JOIN Player u4 ON\n                        u4.id = u3.id + u1.id\n                )\n            );\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\").alias_as(\"u1\").select().filter(\n            col(\"u1.id\").eq(subquery(\n                table(\"Player\").alias_as(\"u2\").select().filter(\n                    col(\"u2.id\").eq(subquery(\n                        table(\"Player\")\n                            .alias_as(\"u3\")\n                            .select()\n                            .join_as(\"Player\", \"u4\")\n                            .hash_executor(col(\"u4.id\"), col(\"u3.id\").add(\"u1.id\")),\n                    )),\n                ),\n            )),\n        );\n        test!(actual, expected, \"hash join in nested subquery:\\n{sql}\");\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            JOIN PlayerItem ON\n                Player.id = PlayerItem.user_id AND\n                Player.id \u003e 10 AND\n                PlayerItem.item_id IS NOT NULL AND\n                PlayerItem.amount \u003e 10\n            WHERE True;\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .hash_filter(\"PlayerItem.item_id IS NOT NULL\")\n            .hash_filter(\"PlayerItem.amount \u003e 10\")\n            .on(\"Player.id \u003e 10\")\n            .filter(true);\n        test!(\n            actual,\n            expected,\n            \"hash join with join_constraint AND where_clause:\\n{sql}\"\n        );\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            JOIN PlayerItem ON\n                Player.id \u003e Player.id + PlayerItem.user_id AND\n                Player.id = PlayerItem.user_id AND\n                PlayerItem.item_id IS NOT NULL AND\n                PlayerItem.amount \u003e 10\n            WHERE True;\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n            .hash_filter(\"PlayerItem.item_id IS NOT NULL\")\n            .hash_filter(\"PlayerItem.amount \u003e 10\")\n            .on(\"Player.id \u003e Player.id + PlayerItem.user_id\")\n            .filter(true);\n        test!(\n            actual,\n            expected,\n            \"hash join with join_constraint AND where_clause 2:\\n{sql}\"\n        );\n\n        let sql = \"\n            SELECT * \n            FROM Player\n            JOIN PlayerItem ON \n                (SELECT * FROM Player JOIN PlayerItem ON Player.id = PlayerItem.user_id)\n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\").select().join(\"PlayerItem\").on(subquery(\n            table(\"Player\")\n                .select()\n                .join(\"PlayerItem\")\n                .hash_executor(\"Player.id\", \"PlayerItem.user_id\"),\n        ));\n        test!(\n            actual,\n            expected,\n            \"hash join with join_constraint subquery:\\n{sql}\"\n        );\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            JOIN PlayerItem ON\n                1 IN (SELECT * FROM PlayerItem JOIN Player ON PlayerItem.user_id = Player.id)\n            WHERE True    \n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .on(num(1).in_list(\n                table(\"PlayerItem\")\n                    .select()\n                    .join(\"Player\")\n                    .hash_executor(\"PlayerItem.user_id\", \"Player.id\"),\n            ))\n            .filter(true);\n        test!(\n            actual,\n            expected,\n            \"hash join with join constraint in subquery\"\n        );\n\n        let sql = \"\n            SELECT *\n            FROM Player\n            JOIN PlayerItem ON\n                EXISTS (SELECT * FROM PlayerItem JOIN Player ON PlayerItem.user_id = Player.id WHERE Player.id \u003e 3)\n            WHERE True    \n        \";\n        let actual = plan_join(\u0026storage, sql);\n        let expected = table(\"Player\")\n            .select()\n            .join(\"PlayerItem\")\n            .on(exists(\n                table(\"PlayerItem\")\n                    .select()\n                    .join(\"Player\")\n                    .hash_executor(\"PlayerItem.user_id\", \"Player.id\")\n                    .filter(\"Player.id \u003e 3\"),\n            ))\n            .filter(true);\n        test!(\n            actual,\n            expected,\n            \"hash join with join constraint in subquery\"\n        );\n    }\n\n    #[test]\n    fn hash_join_in_subquery() {\n        let storage = run(\"\n            CREATE TABLE Player (\n                id INTEGER,\n                name TEXT\n            );\n            CREATE TABLE Flag (\n                id INTEGER,\n                user_id INTEGER,\n                name TEXT\n            );\n        \");\n\n        let subquery_sql = \"\n            SELECT u.id\n            FROM Player u\n            JOIN Flag f ON f.user_id = u.id\n        \";\n        let subquery_node = || -\u003e QueryNode {\n            table(\"Player\")\n                .alias_as(\"u\")\n                .select()\n                .join_as(\"Flag\", \"f\")\n                .hash_executor(\"f.user_id\", \"u.id\")\n                .project(\"u.id\")\n                .into()\n        };\n\n        let sql = format!(\"SELECT * FROM Player WHERE id = ({subquery_sql})\");\n        let actual = plan_join(\u0026storage, \u0026sql);\n        let expected = table(\"Player\")\n            .select()\n            .filter(col(\"id\").eq(subquery_node()));\n        test!(actual, expected, \"binary operator:\\n{sql}\");\n\n        let sql = format!(\"SELECT * FROM Player WHERE -({subquery_sql}) IN ({subquery_sql})\");\n        let actual = plan_join(\u0026storage, \u0026sql);\n        let expected = table(\"Player\")\n            .select()\n            .filter(subquery(subquery_node()).minus().in_list(subquery_node()));\n        test!(actual, expected, \"unary operator and in subquery:\\n{sql}\");\n\n        let sql = format!(\n            \"\n            SELECT * FROM Player\n            WHERE\n                CAST(({subquery_sql}) AS INTEGER) IN (1, 2, 3)\n        \"\n        );\n        let actual = plan_join(\u0026storage, \u0026sql);\n        let expected = table(\"Player\")\n            .select()\n            .filter(subquery(subquery_node()).cast(\"INTEGER\").in_list(\"1, 2, 3\"));\n        test!(actual, expected, \"cast and in list:\\n{sql}\");\n\n        let sql = format!(\n            \"\n            SELECT * FROM Player\n            WHERE \n                ({subquery_sql}) IS NULL\n                OR\n                ({subquery_sql}) IS NOT NULL\n        \"\n        );\n        let actual = plan_join(\u0026storage, \u0026sql);\n        let expected = table(\"Player\").select().filter(\n            subquery(subquery_node())\n                .is_null()\n                .or(subquery(subquery_node()).is_not_null()),\n        );\n        test!(actual, expected, \"is null and is not null:\\n{sql}\");\n\n        let sql = format!(\"SELECT * FROM Player WHERE EXISTS({subquery_sql})\");\n        let actual = plan_join(\u0026storage, \u0026sql);\n        let expected = table(\"Player\").select().filter(exists(subquery_node()));\n        test!(actual, expected, \"exists:\\n{sql}\");\n\n        let sql = format!(\n            \"\n            SELECT * FROM Player\n            WHERE ({subquery_sql}) BETWEEN ({subquery_sql}) AND 100;\n        \"\n        );\n        let actual = plan_join(\u0026storage, \u0026sql);\n        let expected = table(\"Player\")\n            .select()\n            .filter(subquery(subquery_node()).between(subquery_node(), num(100)));\n        test!(actual, expected, \"between:\\n{sql}\");\n\n        let sql = format!(\n            \"\n            SELECT * FROM Player\n            WHERE EXTRACT(HOUR FROM (({subquery_sql}))) IS NULL\n        \"\n        );\n        let actual = plan_join(\u0026storage, \u0026sql);\n        let expected = table(\"Player\").select().filter(\n            subquery(subquery_node())\n                .nested()\n                .extract(DateTimeField::Hour)\n                .is_null(),\n        );\n        test!(actual, expected, \"extract and nested:\\n{sql}\");\n\n        let sql = format!(\n            \"\n            SELECT * FROM Player\n            WHERE\n                CASE ({subquery_sql})\n                    WHEN 10 THEN True\n                    WHEN 20 THEN ({subquery_sql}) IS NULL\n                    ELSE col3\n                END\n        \"\n        );\n        let actual = plan_join(\u0026storage, \u0026sql);\n        let expected = table(\"Player\").select().filter(\n            subquery(subquery_node())\n                .case()\n                .when_then(10, true)\n                .when_then(20, subquery(subquery_node()).is_null())\n                .or_else(\"col3\"),\n        );\n        test!(actual, expected, \"case expr:\\n{sql}\");\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":209},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan","planner.rs"],"content":"use {\n    super::context::Context,\n    crate::{\n        ast::{ColumnDef, ColumnUniqueOption, Expr, Function, Query, TableAlias, TableFactor},\n        data::Schema,\n    },\n    std::rc::Rc,\n};\n\npub trait Planner\u003c'a\u003e {\n    fn get_schema(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026'a Schema\u003e;\n\n    fn query(\u0026self, outer_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e, query: Query) -\u003e Query;\n\n    fn subquery_expr(\u0026self, outer_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e, expr: Expr) -\u003e Expr {\n        match expr {\n            Expr::Identifier(_)\n            | Expr::CompoundIdentifier { .. }\n            | Expr::Literal(_)\n            | Expr::TypedString { .. } =\u003e expr,\n            Expr::IsNull(expr) =\u003e Expr::IsNull(Box::new(self.subquery_expr(outer_context, *expr))),\n            Expr::IsNotNull(expr) =\u003e {\n                Expr::IsNotNull(Box::new(self.subquery_expr(outer_context, *expr)))\n            }\n            Expr::InList {\n                expr,\n                list,\n                negated,\n            } =\u003e {\n                let list = list\n                    .into_iter()\n                    .map(|expr| self.subquery_expr(outer_context.as_ref().map(Rc::clone), expr))\n                    .collect();\n                let expr = Box::new(self.subquery_expr(outer_context, *expr));\n\n                Expr::InList {\n                    expr,\n                    list,\n                    negated,\n                }\n            }\n            Expr::Subquery(query) =\u003e Expr::Subquery(Box::new(self.query(outer_context, *query))),\n            Expr::Exists { subquery, negated } =\u003e Expr::Exists {\n                subquery: Box::new(self.query(outer_context, *subquery)),\n                negated,\n            },\n            Expr::InSubquery {\n                expr,\n                subquery,\n                negated,\n            } =\u003e {\n                let expr =\n                    Box::new(self.subquery_expr(outer_context.as_ref().map(Rc::clone), *expr));\n                let subquery = Box::new(self.query(outer_context, *subquery));\n\n                Expr::InSubquery {\n                    expr,\n                    subquery,\n                    negated,\n                }\n            }\n            Expr::Between {\n                expr,\n                negated,\n                low,\n                high,\n            } =\u003e {\n                let expr =\n                    Box::new(self.subquery_expr(outer_context.as_ref().map(Rc::clone), *expr));\n                let low = Box::new(self.subquery_expr(outer_context.as_ref().map(Rc::clone), *low));\n                let high = Box::new(self.subquery_expr(outer_context, *high));\n\n                Expr::Between {\n                    expr,\n                    negated,\n                    low,\n                    high,\n                }\n            }\n            Expr::Like {\n                expr,\n                negated,\n                pattern,\n            } =\u003e {\n                let expr =\n                    Box::new(self.subquery_expr(outer_context.as_ref().map(Rc::clone), *expr));\n                let pattern =\n                    Box::new(self.subquery_expr(outer_context.as_ref().map(Rc::clone), *pattern));\n\n                Expr::Like {\n                    expr,\n                    negated,\n                    pattern,\n                }\n            }\n            Expr::ILike {\n                expr,\n                negated,\n                pattern,\n            } =\u003e {\n                let expr =\n                    Box::new(self.subquery_expr(outer_context.as_ref().map(Rc::clone), *expr));\n                let pattern =\n                    Box::new(self.subquery_expr(outer_context.as_ref().map(Rc::clone), *pattern));\n\n                Expr::ILike {\n                    expr,\n                    negated,\n                    pattern,\n                }\n            }\n            Expr::BinaryOp { left, op, right } =\u003e Expr::BinaryOp {\n                left: Box::new(self.subquery_expr(outer_context.as_ref().map(Rc::clone), *left)),\n                op,\n                right: Box::new(self.subquery_expr(outer_context, *right)),\n            },\n            Expr::UnaryOp { op, expr } =\u003e Expr::UnaryOp {\n                op,\n                expr: Box::new(self.subquery_expr(outer_context, *expr)),\n            },\n            Expr::Nested(expr) =\u003e Expr::Nested(Box::new(self.subquery_expr(outer_context, *expr))),\n            Expr::Case {\n                operand,\n                when_then,\n                else_result,\n            } =\u003e {\n                let operand = operand.map(|expr| {\n                    Box::new(self.subquery_expr(outer_context.as_ref().map(Rc::clone), *expr))\n                });\n                let when_then = when_then\n                    .into_iter()\n                    .map(|(when, then)| {\n                        let when = self.subquery_expr(outer_context.as_ref().map(Rc::clone), when);\n                        let then = self.subquery_expr(outer_context.as_ref().map(Rc::clone), then);\n\n                        (when, then)\n                    })\n                    .collect();\n                let else_result =\n                    else_result.map(|expr| Box::new(self.subquery_expr(outer_context, *expr)));\n\n                Expr::Case {\n                    operand,\n                    when_then,\n                    else_result,\n                }\n            }\n            Expr::ArrayIndex { obj, indexes } =\u003e {\n                let indexes = indexes\n                    .into_iter()\n                    .map(|expr| self.subquery_expr(outer_context.as_ref().map(Rc::clone), expr))\n                    .collect();\n                let obj = Box::new(self.subquery_expr(outer_context, *obj));\n                Expr::ArrayIndex { obj, indexes }\n            }\n            Expr::Array { elem } =\u003e {\n                let elem = elem\n                    .into_iter()\n                    .map(|expr| self.subquery_expr(outer_context.as_ref().map(Rc::clone), expr))\n                    .collect();\n                Expr::Array { elem }\n            }\n            Expr::Interval {\n                expr,\n                leading_field,\n                last_field,\n            } =\u003e Expr::Interval {\n                expr: Box::new(self.subquery_expr(outer_context, *expr)),\n                leading_field,\n                last_field,\n            },\n            Expr::Function(func) =\u003e match *func {\n                Function::Cast { expr, data_type } =\u003e Expr::Function(Box::new(Function::Cast {\n                    expr: self.subquery_expr(outer_context, expr),\n                    data_type,\n                })),\n                Function::Extract { field, expr } =\u003e Expr::Function(Box::new(Function::Extract {\n                    field,\n                    expr: self.subquery_expr(outer_context, expr),\n                })),\n                _ =\u003e Expr::Function(func),\n            },\n            Expr::Aggregate(_) =\u003e expr,\n        }\n    }\n\n    fn update_context(\n        \u0026self,\n        next: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n        table_factor: \u0026TableFactor,\n    ) -\u003e Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e {\n        let (name, alias) = match table_factor {\n            TableFactor::Table { name, alias, .. } =\u003e {\n                let alias = alias.as_ref().map(|TableAlias { name, .. }| name.clone());\n\n                (name, alias)\n            }\n            TableFactor::Derived { .. }\n            | TableFactor::Series { .. }\n            | TableFactor::Dictionary { .. } =\u003e return next,\n        };\n\n        let column_defs = match self.get_schema(name) {\n            Some(Schema { column_defs, .. }) =\u003e column_defs,\n            None =\u003e return next,\n        };\n\n        let column_defs = match column_defs {\n            Some(column_defs) =\u003e column_defs,\n            None =\u003e return next,\n        };\n\n        let columns = column_defs\n            .iter()\n            .map(|ColumnDef { name, .. }| name.as_str())\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let primary_key = column_defs\n            .iter()\n            .find_map(|ColumnDef { name, unique, .. }| {\n                (unique == \u0026Some(ColumnUniqueOption { is_primary: true })).then_some(name.as_str())\n            });\n\n        let context = Context::new(\n            alias.unwrap_or_else(|| name.to_owned()),\n            columns,\n            primary_key,\n            next,\n        );\n        Some(Rc::new(context))\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":118},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan","primary_key.rs"],"content":"use {\n    super::{context::Context, evaluable::check_expr as check_evaluable, planner::Planner},\n    crate::{\n        ast::{\n            BinaryOperator, Expr, IndexItem, Query, Select, SetExpr, Statement, TableFactor,\n            TableWithJoins,\n        },\n        data::Schema,\n    },\n    std::{collections::HashMap, rc::Rc},\n};\n\npub fn plan(schema_map: \u0026HashMap\u003cString, Schema\u003e, statement: Statement) -\u003e Statement {\n    let planner = PrimaryKeyPlanner { schema_map };\n\n    match statement {\n        Statement::Query(query) =\u003e {\n            let query = planner.query(None, query);\n\n            Statement::Query(query)\n        }\n        _ =\u003e statement,\n    }\n}\n\nstruct PrimaryKeyPlanner\u003c'a\u003e {\n    schema_map: \u0026'a HashMap\u003cString, Schema\u003e,\n}\n\nimpl\u003c'a\u003e Planner\u003c'a\u003e for PrimaryKeyPlanner\u003c'a\u003e {\n    fn query(\u0026self, outer_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e, query: Query) -\u003e Query {\n        let body = match query.body {\n            SetExpr::Select(select) =\u003e {\n                let select = self.select(outer_context, *select);\n\n                SetExpr::Select(Box::new(select))\n            }\n            SetExpr::Values(_) =\u003e query.body,\n        };\n\n        Query { body, ..query }\n    }\n\n    fn get_schema(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026'a Schema\u003e {\n        self.schema_map.get(name)\n    }\n}\n\nenum PrimaryKey {\n    Found {\n        index_item: IndexItem,\n        expr: Option\u003cExpr\u003e,\n    },\n    NotFound(Expr),\n}\n\nimpl\u003c'a\u003e PrimaryKeyPlanner\u003c'a\u003e {\n    fn select(\u0026self, outer_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e, select: Select) -\u003e Select {\n        let current_context = self.update_context(None, \u0026select.from.relation);\n        let current_context = select\n            .from\n            .joins\n            .iter()\n            .fold(current_context, |context, join| {\n                self.update_context(context, \u0026join.relation)\n            });\n\n        let (index, selection) = select\n            .selection\n            .map(|expr| self.expr(outer_context, current_context, expr))\n            .map(|primary_key| match primary_key {\n                PrimaryKey::Found { index_item, expr } =\u003e (Some(index_item), expr),\n                PrimaryKey::NotFound(expr) =\u003e (None, Some(expr)),\n            })\n            .unwrap_or((None, None));\n\n        if let TableFactor::Table {\n            name,\n            alias,\n            index: None,\n        } = select.from.relation\n        {\n            let from = TableWithJoins {\n                relation: TableFactor::Table { name, alias, index },\n                ..select.from\n            };\n\n            Select {\n                selection,\n                from,\n                ..select\n            }\n        } else {\n            Select {\n                selection,\n                ..select\n            }\n        }\n    }\n\n    fn expr(\n        \u0026self,\n        outer_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n        current_context: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n        expr: Expr,\n    ) -\u003e PrimaryKey {\n        let check_primary_key = |key: \u0026Expr| {\n            let key = match key {\n                Expr::Identifier(ident) =\u003e ident,\n                Expr::CompoundIdentifier { ident, .. } =\u003e ident,\n                _ =\u003e return false,\n            };\n\n            current_context\n                .as_ref()\n                .map(|context| context.contains_primary_key(key))\n                .unwrap_or(false)\n        };\n\n        match expr {\n            Expr::BinaryOp {\n                left: key,\n                op: BinaryOperator::Eq,\n                right: value,\n            }\n            | Expr::BinaryOp {\n                left: value,\n                op: BinaryOperator::Eq,\n                right: key,\n            } if check_primary_key(key.as_ref())\n                \u0026\u0026 check_evaluable(current_context.as_ref().map(Rc::clone), \u0026key)\n                \u0026\u0026 check_evaluable(None, \u0026value) =\u003e\n            {\n                let index_item = IndexItem::PrimaryKey(*value);\n\n                PrimaryKey::Found {\n                    index_item,\n                    expr: None,\n                }\n            }\n            Expr::BinaryOp {\n                left,\n                op: BinaryOperator::And,\n                right,\n            } =\u003e {\n                let primary_key = self.expr(\n                    outer_context.as_ref().map(Rc::clone),\n                    current_context.as_ref().map(Rc::clone),\n                    *left,\n                );\n\n                let left = match primary_key {\n                    PrimaryKey::Found { index_item, expr } =\u003e {\n                        let expr = match expr {\n                            Some(left) =\u003e Expr::BinaryOp {\n                                left: Box::new(left),\n                                op: BinaryOperator::And,\n                                right,\n                            },\n                            None =\u003e *right,\n                        };\n\n                        return PrimaryKey::Found {\n                            index_item,\n                            expr: Some(expr),\n                        };\n                    }\n                    PrimaryKey::NotFound(expr) =\u003e expr,\n                };\n\n                match self.expr(outer_context, current_context, *right) {\n                    PrimaryKey::Found { index_item, expr } =\u003e {\n                        let expr = match expr {\n                            Some(right) =\u003e Expr::BinaryOp {\n                                left: Box::new(left),\n                                op: BinaryOperator::And,\n                                right: Box::new(right),\n                            },\n                            None =\u003e left,\n                        };\n\n                        PrimaryKey::Found {\n                            index_item,\n                            expr: Some(expr),\n                        }\n                    }\n                    PrimaryKey::NotFound(expr) =\u003e {\n                        let expr = Expr::BinaryOp {\n                            left: Box::new(left),\n                            op: BinaryOperator::And,\n                            right: Box::new(expr),\n                        };\n\n                        PrimaryKey::NotFound(expr)\n                    }\n                }\n            }\n            Expr::Nested(expr) =\u003e match self.expr(outer_context, current_context, *expr) {\n                PrimaryKey::Found { index_item, expr } =\u003e {\n                    let expr = expr.map(Box::new).map(Expr::Nested);\n\n                    PrimaryKey::Found { index_item, expr }\n                }\n                PrimaryKey::NotFound(expr) =\u003e PrimaryKey::NotFound(Expr::Nested(Box::new(expr))),\n            },\n            _ =\u003e {\n                let outer_context = Context::concat(current_context, outer_context);\n                let expr = self.subquery_expr(outer_context, expr);\n\n                PrimaryKey::NotFound(expr)\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::plan as plan_primary_key,\n        crate::{\n            ast::{\n                AstLiteral, BinaryOperator, Expr, IndexItem, Join, JoinConstraint, JoinExecutor,\n                JoinOperator, Query, Select, SelectItem, SetExpr, Statement, TableFactor,\n                TableWithJoins, Values,\n            },\n            mock::{MockStorage, run},\n            parse_sql::{parse, parse_expr},\n            plan::fetch_schema_map,\n            translate::{translate, translate_expr},\n        },\n        futures::executor::block_on,\n    };\n\n    fn plan(storage: \u0026MockStorage, sql: \u0026str) -\u003e Statement {\n        let parsed = parse(sql).expect(sql).into_iter().next().unwrap();\n        let statement = translate(\u0026parsed).unwrap();\n        let schema_map = block_on(fetch_schema_map(storage, \u0026statement)).unwrap();\n\n        plan_primary_key(\u0026schema_map, statement)\n    }\n\n    fn select(select: Select) -\u003e Statement {\n        Statement::Query(Query {\n            body: SetExpr::Select(Box::new(select)),\n            limit: None,\n            offset: None,\n            order_by: Vec::new(),\n        })\n    }\n\n    fn expr(sql: \u0026str) -\u003e Expr {\n        let parsed = parse_expr(sql).expect(sql);\n\n        translate_expr(\u0026parsed).expect(sql)\n    }\n\n    #[test]\n    fn where_expr() {\n        let storage = run(\"\n            CREATE TABLE Player (\n                id INTEGER PRIMARY KEY,\n                name TEXT\n            );\n        \");\n\n        let sql = \"SELECT * FROM Player WHERE id = 1;\";\n        let actual = plan(\u0026storage, sql);\n        let expected = select(Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"Player\".to_owned(),\n                    alias: None,\n                    index: Some(IndexItem::PrimaryKey(expr(\"1\"))),\n                },\n                joins: Vec::new(),\n            },\n            selection: None,\n            group_by: Vec::new(),\n            having: None,\n        });\n        assert_eq!(actual, expected, \"primary key in lhs:\\n{sql}\");\n\n        let sql = \"SELECT * FROM Player WHERE 1 = id;\";\n        let actual = plan(\u0026storage, sql);\n        let expected = select(Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"Player\".to_owned(),\n                    alias: None,\n                    index: Some(IndexItem::PrimaryKey(expr(\"1\"))),\n                },\n                joins: Vec::new(),\n            },\n            selection: None,\n            group_by: Vec::new(),\n            having: None,\n        });\n        assert_eq!(actual, expected, \"primary key in rhs:\\n{sql}\");\n\n        let sql = \"SELECT * FROM Player WHERE id = 1 AND True;\";\n        let actual = plan(\u0026storage, sql);\n        let expected = select(Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"Player\".to_owned(),\n                    alias: None,\n                    index: Some(IndexItem::PrimaryKey(expr(\"1\"))),\n                },\n                joins: Vec::new(),\n            },\n            selection: Some(expr(\"True\")),\n            group_by: Vec::new(),\n            having: None,\n        });\n        assert_eq!(actual, expected, \"AND binary op:\\n{sql}\");\n\n        let sql = \"\n            SELECT * FROM Player\n            WHERE\n                name IS NOT NULL\n                AND id = 1\n                AND True;\n        \";\n        let actual = plan(\u0026storage, sql);\n        let expected = select(Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"Player\".to_owned(),\n                    alias: None,\n                    index: Some(IndexItem::PrimaryKey(expr(\"1\"))),\n                },\n                joins: Vec::new(),\n            },\n            selection: Some(expr(\"name IS NOT NULL AND True\")),\n            group_by: Vec::new(),\n            having: None,\n        });\n        assert_eq!(actual, expected, \"AND binary op 2:\\n{sql}\");\n\n        let sql = \"\n            SELECT * FROM Player\n            WHERE\n                name IS NOT NULL\n                AND True\n                AND id = 1;\n        \";\n        let actual = plan(\u0026storage, sql);\n        assert_eq!(actual, expected, \"AND binary op 3:\\n{sql}\");\n\n        let sql = \"\n            SELECT * FROM Player\n            WHERE\n                name IS NOT NULL\n                AND (True AND id = 1);\n        \";\n        let actual = plan(\u0026storage, sql);\n        let expected = select(Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"Player\".to_owned(),\n                    alias: None,\n                    index: Some(IndexItem::PrimaryKey(expr(\"1\"))),\n                },\n                joins: Vec::new(),\n            },\n            selection: Some(expr(\"name IS NOT NULL AND (True)\")),\n            group_by: Vec::new(),\n            having: None,\n        });\n        assert_eq!(actual, expected, \"AND binary op 3:\\n{sql}\");\n    }\n\n    #[test]\n    fn join_and_nested() {\n        let storage = run(\"\n            CREATE TABLE Player (\n                id INTEGER PRIMARY KEY,\n                name TEXT\n            );\n            CREATE TABLE Badge (\n                title TEXT PRIMARY KEY,\n                user_id INTEGER\n            );\n        \");\n\n        let sql = \"SELECT * FROM Player JOIN Badge WHERE Player.id = 1\";\n        let actual = plan(\u0026storage, sql);\n        let expected = select(Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"Player\".to_owned(),\n                    alias: None,\n                    index: Some(IndexItem::PrimaryKey(expr(\"1\"))),\n                },\n                joins: vec![Join {\n                    relation: TableFactor::Table {\n                        name: \"Badge\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    join_operator: JoinOperator::Inner(JoinConstraint::None),\n                    join_executor: JoinExecutor::NestedLoop,\n                }],\n            },\n            selection: None,\n            group_by: Vec::new(),\n            having: None,\n        });\n        assert_eq!(actual, expected, \"basic inner join:\\n{sql}\");\n\n        let sql = \"SELECT * FROM Player JOIN Badge WHERE Player.id = Badge.user_id\";\n        let actual = plan(\u0026storage, sql);\n        let expected = select(Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"Player\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                joins: vec![Join {\n                    relation: TableFactor::Table {\n                        name: \"Badge\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    join_operator: JoinOperator::Inner(JoinConstraint::None),\n                    join_executor: JoinExecutor::NestedLoop,\n                }],\n            },\n            selection: Some(expr(\"Player.id = Badge.user_id\")),\n            group_by: Vec::new(),\n            having: None,\n        });\n        assert_eq!(actual, expected, \"join but no primary key:\\n{sql}\");\n\n        let sql = \"\n            SELECT * FROM Player\n            WHERE name IN (\n                SELECT * FROM Player WHERE id = 1\n            )\";\n        let actual = plan(\u0026storage, sql);\n        let expected = {\n            let subquery = Query {\n                body: SetExpr::Select(Box::new(Select {\n                    projection: vec![SelectItem::Wildcard],\n                    from: TableWithJoins {\n                        relation: TableFactor::Table {\n                            name: \"Player\".to_owned(),\n                            alias: None,\n                            index: Some(IndexItem::PrimaryKey(expr(\"1\"))),\n                        },\n                        joins: Vec::new(),\n                    },\n                    selection: None,\n                    group_by: Vec::new(),\n                    having: None,\n                })),\n                limit: None,\n                offset: None,\n                order_by: Vec::new(),\n            };\n\n            select(Select {\n                projection: vec![SelectItem::Wildcard],\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: Vec::new(),\n                },\n                selection: Some(Expr::InSubquery {\n                    expr: Box::new(expr(\"name\")),\n                    subquery: Box::new(subquery),\n                    negated: false,\n                }),\n                group_by: Vec::new(),\n                having: None,\n            })\n        };\n        assert_eq!(actual, expected, \"nested select:\\n{sql}\");\n    }\n\n    #[test]\n    fn not_found() {\n        let storage = run(\"\n            CREATE TABLE Player (\n                id INTEGER PRIMARY KEY,\n                name TEXT\n            );\n        \");\n\n        let sql = \"SELECT * FROM Player WHERE name = (SELECT name FROM Player LIMIT 1);\";\n        let actual = plan(\u0026storage, sql);\n        let expected = {\n            let subquery = Query {\n                body: SetExpr::Select(Box::new(Select {\n                    projection: vec![SelectItem::Expr {\n                        expr: Expr::Identifier(\"name\".to_owned()),\n                        label: \"name\".to_owned(),\n                    }],\n                    from: TableWithJoins {\n                        relation: TableFactor::Table {\n                            name: \"Player\".to_owned(),\n                            alias: None,\n                            index: None,\n                        },\n                        joins: Vec::new(),\n                    },\n                    selection: None,\n                    group_by: Vec::new(),\n                    having: None,\n                })),\n                limit: Some(expr(\"1\")),\n                offset: None,\n                order_by: Vec::new(),\n            };\n\n            select(Select {\n                projection: vec![SelectItem::Wildcard],\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: Vec::new(),\n                },\n                selection: Some(Expr::BinaryOp {\n                    left: Box::new(Expr::Identifier(\"name\".to_owned())),\n                    op: BinaryOperator::Eq,\n                    right: Box::new(Expr::Subquery(Box::new(subquery))),\n                }),\n                group_by: Vec::new(),\n                having: None,\n            })\n        };\n        assert_eq!(actual, expected, \"name is not primary key:\\n{sql}\");\n\n        let sql = \"\n            SELECT * FROM Player WHERE id IN (\n                SELECT id FROM Player WHERE id = id\n            );\n        \";\n        let actual = plan(\u0026storage, sql);\n        let expected = {\n            let subquery = Query {\n                body: SetExpr::Select(Box::new(Select {\n                    projection: vec![SelectItem::Expr {\n                        expr: Expr::Identifier(\"id\".to_owned()),\n                        label: \"id\".to_owned(),\n                    }],\n                    from: TableWithJoins {\n                        relation: TableFactor::Table {\n                            name: \"Player\".to_owned(),\n                            alias: None,\n                            index: None,\n                        },\n                        joins: Vec::new(),\n                    },\n                    selection: Some(expr(\"id = id\")),\n                    group_by: Vec::new(),\n                    having: None,\n                })),\n                limit: None,\n                offset: None,\n                order_by: Vec::new(),\n            };\n\n            select(Select {\n                projection: vec![SelectItem::Wildcard],\n                from: TableWithJoins {\n                    relation: TableFactor::Table {\n                        name: \"Player\".to_owned(),\n                        alias: None,\n                        index: None,\n                    },\n                    joins: Vec::new(),\n                },\n                selection: Some(Expr::InSubquery {\n                    expr: Box::new(Expr::Identifier(\"id\".to_owned())),\n                    subquery: Box::new(subquery),\n                    negated: false,\n                }),\n                group_by: Vec::new(),\n                having: None,\n            })\n        };\n        assert_eq!(actual, expected, \"ambiguous nested contexts:\\n{sql}\");\n\n        let sql = \"DELETE FROM Player WHERE id = 1;\";\n        let actual = plan(\u0026storage, sql);\n        let expected = Statement::Delete {\n            table_name: \"Player\".to_owned(),\n            selection: Some(Expr::BinaryOp {\n                left: Box::new(Expr::Identifier(\"id\".to_owned())),\n                op: BinaryOperator::Eq,\n                right: Box::new(Expr::Literal(AstLiteral::Number(1.into()))),\n            }),\n        };\n        assert_eq!(actual, expected, \"delete statement:\\n{sql}\");\n\n        let sql = \"VALUES (1), (2);\";\n        let actual = plan(\u0026storage, sql);\n        let expected = Statement::Query(Query {\n            body: SetExpr::Values(Values(vec![\n                vec![Expr::Literal(AstLiteral::Number(1.into()))],\n                vec![Expr::Literal(AstLiteral::Number(2.into()))],\n            ])),\n            limit: None,\n            offset: None,\n            order_by: Vec::new(),\n        });\n        assert_eq!(actual, expected, \"values:\\n{sql}\");\n\n        let sql = \"SELECT * FROM Player WHERE (name);\";\n        let actual = plan(\u0026storage, sql);\n        let expected = select(Select {\n            projection: vec![SelectItem::Wildcard],\n            from: TableWithJoins {\n                relation: TableFactor::Table {\n                    name: \"Player\".to_owned(),\n                    alias: None,\n                    index: None,\n                },\n                joins: Vec::new(),\n            },\n            selection: Some(Expr::Nested(Box::new(expr(\"name\")))),\n            group_by: Vec::new(),\n            having: None,\n        });\n        assert_eq!(actual, expected, \"nested:\\n{sql}\");\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":93},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan","schema.rs"],"content":"use {\n    super::expr::PlanExpr,\n    crate::{\n        ast::{\n            Expr, Join, JoinConstraint, JoinOperator, Query, Select, SelectItem, SetExpr,\n            Statement, TableFactor, TableWithJoins,\n        },\n        data::Schema,\n        result::Result,\n        store::Store,\n    },\n    async_recursion::async_recursion,\n    futures::stream::{self, StreamExt, TryStreamExt},\n    std::collections::HashMap,\n};\n\npub async fn fetch_schema_map\u003cT: Store\u003e(\n    storage: \u0026T,\n    statement: \u0026Statement,\n) -\u003e Result\u003cHashMap\u003cString, Schema\u003e\u003e {\n    match statement {\n        Statement::Query(query) =\u003e scan_query(storage, query).await,\n        Statement::Insert {\n            table_name, source, ..\n        } =\u003e {\n            let table_schema = storage\n                .fetch_schema(table_name)\n                .await?\n                .map(|schema| HashMap::from([(table_name.to_owned(), schema)]))\n                .unwrap_or_else(HashMap::new);\n            let source_schema_list = scan_query(storage, source).await?;\n            let schema_list = table_schema.into_iter().chain(source_schema_list).collect();\n\n            Ok(schema_list)\n        }\n        Statement::CreateTable { name, source, .. } =\u003e {\n            let table_schema = storage\n                .fetch_schema(name)\n                .await?\n                .map(|schema| HashMap::from([(name.to_owned(), schema)]))\n                .unwrap_or_else(HashMap::new);\n            let source_schema_list = match source {\n                Some(source) =\u003e scan_query(storage, source).await?,\n                None =\u003e HashMap::new(),\n            };\n            let schema_list = table_schema.into_iter().chain(source_schema_list).collect();\n\n            Ok(schema_list)\n        }\n        Statement::DropTable { names, .. } =\u003e {\n            stream::iter(names)\n                .filter_map(|table_name| async {\n                    storage\n                        .fetch_schema(table_name)\n                        .await\n                        .map(|schema| Some((table_name.clone(), schema?)))\n                        .transpose()\n                })\n                .try_collect()\n                .await\n        }\n        _ =\u003e Ok(HashMap::new()),\n    }\n}\n\nasync fn scan_query\u003cT: Store\u003e(storage: \u0026T, query: \u0026Query) -\u003e Result\u003cHashMap\u003cString, Schema\u003e\u003e {\n    let Query {\n        body,\n        limit,\n        offset,\n        ..\n    } = query;\n\n    let schema_list = match body {\n        SetExpr::Select(select) =\u003e scan_select(storage, select).await?,\n        SetExpr::Values(_) =\u003e HashMap::new(),\n    };\n\n    let schema_list = match (limit, offset) {\n        (Some(limit), Some(offset)) =\u003e schema_list\n            .into_iter()\n            .chain(scan_expr(storage, limit).await?)\n            .chain(scan_expr(storage, offset).await?)\n            .collect(),\n        (Some(expr), None) | (None, Some(expr)) =\u003e schema_list\n            .into_iter()\n            .chain(scan_expr(storage, expr).await?)\n            .collect(),\n        (None, None) =\u003e schema_list,\n    };\n\n    Ok(schema_list)\n}\n\nasync fn scan_select\u003cT: Store\u003e(storage: \u0026T, select: \u0026Select) -\u003e Result\u003cHashMap\u003cString, Schema\u003e\u003e {\n    let Select {\n        projection,\n        from,\n        selection,\n        group_by,\n        having,\n    } = select;\n\n    let projection = stream::iter(projection)\n        .then(|select_item| async move {\n            match select_item {\n                SelectItem::Expr { expr, .. } =\u003e scan_expr(storage, expr).await,\n                SelectItem::QualifiedWildcard(_) | SelectItem::Wildcard =\u003e Ok(HashMap::new()),\n            }\n        })\n        .try_collect::\u003cVec\u003cHashMap\u003cString, Schema\u003e\u003e\u003e()\n        .await?\n        .into_iter()\n        .flatten();\n\n    let from = scan_table_with_joins(storage, from).await?;\n\n    let exprs = selection.iter().chain(group_by.iter()).chain(having.iter());\n\n    Ok(stream::iter(exprs)\n        .then(|expr| scan_expr(storage, expr))\n        .try_collect::\u003cVec\u003cHashMap\u003cString, Schema\u003e\u003e\u003e()\n        .await?\n        .into_iter()\n        .flatten()\n        .chain(projection)\n        .chain(from)\n        .collect())\n}\n\nasync fn scan_table_with_joins\u003cT: Store\u003e(\n    storage: \u0026T,\n    table_with_joins: \u0026TableWithJoins,\n) -\u003e Result\u003cHashMap\u003cString, Schema\u003e\u003e {\n    let TableWithJoins { relation, joins } = table_with_joins;\n    let schema_list = scan_table_factor(storage, relation).await?;\n\n    Ok(stream::iter(joins)\n        .then(|join| scan_join(storage, join))\n        .try_collect::\u003cVec\u003cHashMap\u003cString, Schema\u003e\u003e\u003e()\n        .await?\n        .into_iter()\n        .flatten()\n        .chain(schema_list)\n        .collect())\n}\n\nasync fn scan_join\u003cT: Store\u003e(storage: \u0026T, join: \u0026Join) -\u003e Result\u003cHashMap\u003cString, Schema\u003e\u003e {\n    let Join {\n        relation,\n        join_operator,\n        ..\n    } = join;\n\n    let schema_list = scan_table_factor(storage, relation).await?;\n    let schema_list = match join_operator {\n        JoinOperator::Inner(JoinConstraint::On(expr))\n        | JoinOperator::LeftOuter(JoinConstraint::On(expr)) =\u003e scan_expr(storage, expr)\n            .await?\n            .into_iter()\n            .chain(schema_list)\n            .collect(),\n        JoinOperator::Inner(JoinConstraint::None)\n        | JoinOperator::LeftOuter(JoinConstraint::None) =\u003e schema_list,\n    };\n\n    Ok(schema_list)\n}\n\n#[async_recursion(?Send)]\nasync fn scan_table_factor\u003cT\u003e(\n    storage: \u0026T,\n    table_factor: \u0026TableFactor,\n) -\u003e Result\u003cHashMap\u003cString, Schema\u003e\u003e\nwhere\n    T: Store,\n{\n    match table_factor {\n        TableFactor::Table { name, .. } =\u003e {\n            let schema = storage.fetch_schema(name).await?;\n            let schema_list: HashMap\u003cString, Schema\u003e = schema.map_or_else(HashMap::new, |schema| {\n                HashMap::from([(name.to_owned(), schema)])\n            });\n\n            Ok(schema_list)\n        }\n        TableFactor::Derived { subquery, .. } =\u003e scan_query(storage, subquery).await,\n        TableFactor::Series { .. } | TableFactor::Dictionary { .. } =\u003e Ok(HashMap::new()),\n    }\n}\n\n#[async_recursion(?Send)]\nasync fn scan_expr\u003cT\u003e(storage: \u0026T, expr: \u0026Expr) -\u003e Result\u003cHashMap\u003cString, Schema\u003e\u003e\nwhere\n    T: Store,\n{\n    let schema_list = match expr.into() {\n        PlanExpr::None | PlanExpr::Identifier(_) | PlanExpr::CompoundIdentifier { .. } =\u003e {\n            HashMap::new()\n        }\n        PlanExpr::Expr(expr) =\u003e scan_expr(storage, expr).await?,\n        PlanExpr::TwoExprs(expr, expr2) =\u003e scan_expr(storage, expr)\n            .await?\n            .into_iter()\n            .chain(scan_expr(storage, expr2).await?)\n            .collect(),\n        PlanExpr::ThreeExprs(expr, expr2, expr3) =\u003e scan_expr(storage, expr)\n            .await?\n            .into_iter()\n            .chain(scan_expr(storage, expr2).await?)\n            .chain(scan_expr(storage, expr3).await?)\n            .collect(),\n        PlanExpr::MultiExprs(exprs) =\u003e stream::iter(exprs)\n            .then(|expr| scan_expr(storage, expr))\n            .try_collect::\u003cVec\u003cHashMap\u003cString, Schema\u003e\u003e\u003e()\n            .await?\n            .into_iter()\n            .flatten()\n            .collect(),\n        PlanExpr::Query(query) =\u003e scan_query(storage, query).await?,\n        PlanExpr::QueryAndExpr { query, expr } =\u003e scan_query(storage, query)\n            .await?\n            .into_iter()\n            .chain(scan_expr(storage, expr).await?)\n            .collect(),\n    };\n\n    Ok(schema_list)\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::fetch_schema_map,\n        crate::{\n            mock::{MockStorage, run},\n            parse_sql::parse,\n            result::Result,\n            translate::translate,\n        },\n        futures::executor::block_on,\n        utils::Vector,\n    };\n\n    fn plan(storage: \u0026MockStorage, sql: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let parsed = parse(sql).expect(sql).into_iter().next().unwrap();\n        let statement = translate(\u0026parsed).unwrap();\n        let schema_map = block_on(fetch_schema_map(storage, \u0026statement));\n\n        Ok(schema_map?\n            .into_keys()\n            .collect::\u003cVector\u003cString\u003e\u003e()\n            .sort()\n            .into())\n    }\n\n    fn run_test(storage: \u0026MockStorage, sql: \u0026str, expected: \u0026[\u0026str]) {\n        let actual = plan(storage, sql).unwrap();\n        let actual = actual.as_slice();\n\n        assert_eq!(actual, expected, \"{sql}\");\n    }\n\n    #[test]\n    fn basic() {\n        let storage = run(\"\n            CREATE TABLE Foo (id INTEGER);\n            CREATE TABLE Bar (name TEXT);\n        \");\n\n        let test = |sql, expected| run_test(\u0026storage, sql, expected);\n\n        test(\"SELECT * FROM Foo\", \u0026[\"Foo\"]);\n        test(\"INSERT INTO Foo VALUES (1), (2), (3);\", \u0026[\"Foo\"]);\n        test(\"DROP TABLE Foo, Bar;\", \u0026[\"Bar\", \"Foo\"]);\n\n        // Unimplemented\n        test(\"DELETE FROM Foo;\", \u0026[]);\n    }\n\n    #[test]\n    fn expr() {\n        let storage = run(\"\n            CREATE TABLE Foo (id INTEGER);\n            CREATE TABLE Bar (name TEXT);\n        \");\n        let test = |sql, expected| run_test(\u0026storage, sql, expected);\n\n        // PlanExpr::None\n        test(\n            r#\"SELECT Foo.*, * FROM Foo WHERE id = DATE \"2021-01-01\";\"#,\n            \u0026[\"Foo\"],\n        );\n\n        // PlanExpr::Expr\n        test(\n            \"\n            SELECT * FROM Foo\n            WHERE\n                Foo.id IS NULL\n                AND id IS NOT NULL\n                OR (id IS NULL)\n        \",\n            \u0026[\"Foo\"],\n        );\n\n        // PlanExpr::TwoExprs\n        test(\"SELECT * FROM Foo WHERE id = 1\", \u0026[\"Foo\"]);\n\n        // PlanExpr::ThreeExprs\n        test(\"SELECT * FROM Foo WHERE id BETWEEN 1 AND 20\", \u0026[\"Foo\"]);\n\n        // PlanExpr::MultiExprs\n        test(\"SELECT * FROM Foo WHERE id IN (1, 2, 3)\", \u0026[\"Foo\"]);\n\n        // PlanExpr::Query\n        test(\n            \"\n            SELECT * FROM Bar\n            WHERE\n                EXISTS(SELECT id FROM Foo)\n                AND Bar.id = (SELECT id FROM Bar LIMIT 1);\n        \",\n            \u0026[\"Bar\", \"Foo\"],\n        );\n\n        // PlanExpr::QueryAndExpr\n        test(\n            \"SELECT * FROM Foo WHERE Foo.id IN (SELECT 1 FROM Bar);\",\n            \u0026[\"Bar\", \"Foo\"],\n        );\n    }\n\n    #[test]\n    fn select() {\n        let storage = run(\"\n            CREATE TABLE Foo (id INTEGER);\n            CREATE TABLE Bar (\n                id INTEGER,\n                foo_id INTEGER\n            );\n            CREATE TABLE Baz (flag BOOLEAN);\n        \");\n\n        let test = |sql, expected| run_test(\u0026storage, sql, expected);\n\n        test(\n            \"\n            SELECT foo_id, COUNT(*)\n            FROM Bar\n            WHERE id IS NOT NULL\n            GROUP BY foo_id\n            HAVING foo_id \u003e 10;\n            \",\n            \u0026[\"Bar\"],\n        );\n        test(\n            \"SELECT * FROM Foo JOIN Bar ORDER BY Foo.id\",\n            \u0026[\"Bar\", \"Foo\"],\n        );\n        test(\"SELECT * FROM Foo LEFT OUTER JOIN Bar\", \u0026[\"Bar\", \"Foo\"]);\n        test(\n            \"SELECT * FROM Foo LEFT JOIN Bar ON Bar.foo_id = Foo.id\",\n            \u0026[\"Bar\", \"Foo\"],\n        );\n        test(\n            \"\n            SELECT * FROM Foo\n            INNER JOIN Bar ON Bar.id = Foo.bar_id\n            LEFT JOIN Baz ON False;\n        \",\n            \u0026[\"Bar\", \"Baz\", \"Foo\"],\n        );\n        test(\n            \"\n            SELECT Bar.*, id, *\n            FROM Foo\n            JOIN Bar ON True\n            LEFT JOIN Baz ON True\n            WHERE Foo.id = 1\n            LIMIT 1 OFFSET 1\n            \",\n            \u0026[\"Bar\", \"Baz\", \"Foo\"],\n        );\n\n        // ignore rather than returning error\n        test(\"SELECT * FROM Railway\", \u0026[]);\n        test(\"SELECT * FROM Foo WHERE Foo.id = Lab.foo_id\", \u0026[\"Foo\"]);\n    }\n\n    #[test]\n    fn storage_err() {\n        let storage = run(\"\n            CREATE TABLE Foo (id INTEGER);\n            CREATE TABLE Bar (id INTEGER);\n            CREATE TABLE Baz (flag BOOLEAN);\n        \");\n\n        let test = |sql| assert!(plan(\u0026storage, sql).is_err(), \"{sql}\");\n\n        test(\"SELECT * FROM __Err__\");\n        test(\"INSERT INTO __Err__ VALUES (1), (2)\");\n        test(\"DROP TABLE __Err__\");\n\n        test(\"SELECT * FROM Foo WHERE id = (SELECT foo_id FROM __Err__ LIMIT 1)\");\n        test(\"SELECT * FROM Foo WHERE (SELECT foo_id FROM __Err__ LIMIT 1) = id\");\n        test(\"SELECT * FROM Foo WHERE id BETWEEN (SELECT foo_id FROM __Err__ LIMIT 1) AND 100\");\n        test(\"SELECT * FROM Foo WHERE (SELECT id FROM __Err__ LIMIT 1) BETWEEN 20 AND 50\");\n        test(\"SELECT * FROM Foo WHERE id IN (1, 2, (SELECT foo_id FROM __Err__ LIMIT 1), 5)\");\n        test(\"SELECT * FROM Foo WHERE id IN (SELECT * FROM __Err__)\");\n        test(\"SELECT * FROM Foo LEFT JOIN Bar ON Bar.id = (SELECT id FROM __Err__ LIMIT 1)\");\n        test(\"SELECT id, (SELECT id FROM __Err__ LIMIT 1) AS cc FROM Foo;\");\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":131},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan","validate.rs"],"content":"use {\n    super::PlanError,\n    crate::{\n        ast::{Expr, Join, Query, SelectItem, SetExpr, Statement, TableFactor, TableWithJoins},\n        data::Schema,\n        result::Result,\n    },\n    std::{collections::HashMap, rc::Rc},\n};\n\ntype SchemaMap = HashMap\u003cString, Schema\u003e;\n/// Validate user select column should not be ambiguous\npub fn validate(schema_map: \u0026SchemaMap, statement: \u0026Statement) -\u003e Result\u003c()\u003e {\n    let query = match statement {\n        Statement::Query(query) =\u003e Some(query),\n        Statement::Insert { source, .. } =\u003e Some(source),\n        Statement::CreateTable { source, .. } =\u003e source.as_deref(),\n        _ =\u003e None,\n    };\n\n    if let Some(query) = query {\n        if let Query {\n            body: SetExpr::Select(select),\n            ..\n        } = query\n        {\n            for select_item in \u0026select.projection {\n                if let SelectItem::Expr {\n                    expr: Expr::Identifier(ident),\n                    ..\n                } = select_item\n                {\n                    if let Some(context) = contextualize_query(schema_map, query) {\n                        context.validate_duplicated(ident)?;\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\nenum Context\u003c'a\u003e {\n    Data {\n        labels: Option\u003cVec\u003c\u0026'a str\u003e\u003e,\n        next: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e,\n    },\n    Bridge {\n        left: Rc\u003cContext\u003c'a\u003e\u003e,\n        right: Rc\u003cContext\u003c'a\u003e\u003e,\n    },\n}\n\nimpl\u003c'a\u003e Context\u003c'a\u003e {\n    fn new(labels: Option\u003cVec\u003c\u0026'a str\u003e\u003e, next: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e) -\u003e Self {\n        Self::Data { labels, next }\n    }\n\n    fn concat(left: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e, right: Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e) -\u003e Option\u003cRc\u003cSelf\u003e\u003e {\n        match (left, right) {\n            (Some(left), Some(right)) =\u003e Some(Rc::new(Self::Bridge { left, right })),\n            (context @ Some(_), None) | (None, context @ Some(_)) =\u003e context,\n            (None, None) =\u003e None,\n        }\n    }\n\n    fn validate_duplicated(\u0026self, column_name: \u0026str) -\u003e Result\u003c()\u003e {\n        fn validate(context: \u0026Context, column_name: \u0026str) -\u003e Result\u003cbool\u003e {\n            let (left, right) = match context {\n                Context::Data { labels, next, .. } =\u003e {\n                    let current = labels\n                        .as_ref()\n                        .map(|labels| labels.contains(\u0026column_name))\n                        .unwrap_or(false);\n\n                    let next = next\n                        .as_ref()\n                        .map(|next| validate(next, column_name))\n                        .unwrap_or(Ok(false))?;\n\n                    (current, next)\n                }\n                Context::Bridge { left, right } =\u003e {\n                    let left = validate(left, column_name)?;\n                    let right = validate(right, column_name)?;\n\n                    (left, right)\n                }\n            };\n\n            if left \u0026\u0026 right {\n                Err(PlanError::ColumnReferenceAmbiguous(column_name.to_owned()).into())\n            } else {\n                Ok(left || right)\n            }\n        }\n\n        validate(self, column_name).map(|_| ())\n    }\n}\n\nfn get_labels(schema: \u0026Schema) -\u003e Option\u003cVec\u003c\u0026str\u003e\u003e {\n    schema.column_defs.as_ref().map(|column_defs| {\n        column_defs\n            .iter()\n            .map(|column_def| column_def.name.as_str())\n            .collect::\u003cVec\u003c_\u003e\u003e()\n    })\n}\n\nfn contextualize_query\u003c'a\u003e(schema_map: \u0026'a SchemaMap, query: \u0026'a Query) -\u003e Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e {\n    let Query { body, .. } = query;\n    match body {\n        SetExpr::Select(select) =\u003e {\n            let TableWithJoins { relation, joins } = \u0026select.from;\n            let by_table = contextualize_table_factor(schema_map, relation);\n            let by_joins = joins\n                .iter()\n                .map(|Join { relation, .. }| contextualize_table_factor(schema_map, relation))\n                .fold(None, Context::concat);\n\n            Context::concat(by_table, by_joins)\n        }\n        SetExpr::Values(_) =\u003e None,\n    }\n}\n\nfn contextualize_table_factor\u003c'a\u003e(\n    schema_map: \u0026'a SchemaMap,\n    table_factor: \u0026'a TableFactor,\n) -\u003e Option\u003cRc\u003cContext\u003c'a\u003e\u003e\u003e {\n    match table_factor {\n        TableFactor::Table { name, .. } =\u003e {\n            let schema = schema_map.get(name);\n            schema.map(|schema| Rc::from(Context::new(get_labels(schema), None)))\n        }\n        TableFactor::Derived { subquery, .. } =\u003e contextualize_query(schema_map, subquery),\n        TableFactor::Series { .. } | TableFactor::Dictionary { .. } =\u003e None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        crate::{\n            mock::run,\n            plan::{fetch_schema_map, validate},\n            prelude::{parse, translate},\n        },\n        futures::executor::block_on,\n    };\n\n    #[test]\n    fn validate_test() {\n        let storage = run(\"\n            CREATE TABLE Users (\n                id INTEGER,\n                name TEXT\n            );\n        \");\n\n        let cases = [\n            (\"SELECT * FROM (SELECT * FROM Users) AS Sub\", true),\n            (\"SELECT * FROM SERIES(3)\", true),\n            (\"SELECT id FROM Users A JOIN Users B on A.id = B.id\", false),\n            (\n                \"INSERT INTO Users SELECT id FROM Users A JOIN Users B on A.id = B.id\",\n                false,\n            ),\n            (\n                \"CREATE TABLE Ids AS SELECT id FROM Users A JOIN Users B on A.id = B.id\",\n                false,\n            ),\n        ];\n\n        for (sql, expected) in cases {\n            let parsed = parse(sql).expect(sql).into_iter().next().unwrap();\n            let statement = translate(\u0026parsed).unwrap();\n            let schema_map = block_on(fetch_schema_map(\u0026storage, \u0026statement)).unwrap();\n            let actual = validate(\u0026schema_map, \u0026statement).is_ok();\n\n            assert_eq!(actual, expected)\n        }\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":62},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","plan.rs"],"content":"mod context;\nmod error;\nmod evaluable;\nmod expr;\nmod index;\nmod join;\nmod planner;\nmod primary_key;\nmod schema;\nmod validate;\n\nuse crate::{ast::Statement, result::Result, store::Store};\n\npub use {\n    self::validate::validate, error::*, index::plan as plan_index, join::plan as plan_join,\n    primary_key::plan as plan_primary_key, schema::fetch_schema_map,\n};\n\npub async fn plan\u003cT: Store\u003e(storage: \u0026T, statement: Statement) -\u003e Result\u003cStatement\u003e {\n    let schema_map = fetch_schema_map(storage, \u0026statement).await?;\n    validate(\u0026schema_map, \u0026statement)?;\n    let statement = plan_primary_key(\u0026schema_map, statement);\n    let statement = plan_index(\u0026schema_map, statement)?;\n    let statement = plan_join(\u0026schema_map, statement);\n\n    Ok(statement)\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","result.rs"],"content":"use {serde::Serialize, std::fmt::Debug, thiserror::Error as ThisError};\n\npub use crate::{\n    ast_builder::AstBuilderError,\n    data::{\n        ConvertError, IntervalError, KeyError, LiteralError, RowError, SchemaParseError,\n        StringExtError, TableError, ValueError,\n    },\n    executor::{\n        AlterError, DeleteError, EvaluateError, ExecuteError, FetchError, InsertError, SelectError,\n        SortError, UpdateError, ValidateError,\n    },\n    plan::PlanError,\n    store::{AlterTableError, IndexError},\n    translate::TranslateError,\n};\n\n#[derive(ThisError, Serialize, Debug, PartialEq)]\npub enum Error {\n    #[error(\"storage: {0}\")]\n    StorageMsg(String),\n\n    #[error(\"parser: {0}\")]\n    Parser(String),\n\n    #[error(\"translate: {0}\")]\n    Translate(#[from] TranslateError),\n\n    #[error(\"ast-builder: {0}\")]\n    AstBuilder(#[from] AstBuilderError),\n\n    #[error(\"alter-table: {0}\")]\n    AlterTable(#[from] AlterTableError),\n    #[error(\"index: {0}\")]\n    Index(#[from] IndexError),\n    #[error(\"execute: {0}\")]\n    Execute(#[from] ExecuteError),\n    #[error(\"alter: {0}\")]\n    Alter(Box\u003cAlterError\u003e),\n    #[error(\"fetch: {0}\")]\n    Fetch(#[from] FetchError),\n    #[error(\"select: {0}\")]\n    Select(#[from] SelectError),\n    #[error(\"evaluate: {0}\")]\n    Evaluate(#[from] EvaluateError),\n    #[error(\"sort: {0}\")]\n    Sort(#[from] SortError),\n    #[error(\"insert: {0}\")]\n    Insert(#[from] InsertError),\n    #[error(\"update: {0}\")]\n    Delete(#[from] DeleteError),\n    #[error(\"delete: {0}\")]\n    Update(#[from] UpdateError),\n    #[error(\"table: {0}\")]\n    Table(#[from] TableError),\n    #[error(\"validate: {0}\")]\n    Validate(#[from] ValidateError),\n    #[error(\"row: {0}\")]\n    Row(#[from] RowError),\n    #[error(\"key: {0}\")]\n    Key(#[from] KeyError),\n    #[error(\"value: {0}\")]\n    Value(Box\u003cValueError\u003e),\n    #[error(\"convert: {0}\")]\n    Convert(#[from] ConvertError),\n    #[error(\"literal: {0}\")]\n    Literal(#[from] LiteralError),\n    #[error(\"interval: {0}\")]\n    Interval(#[from] IntervalError),\n    #[error(\"string-ext: {0}\")]\n    StringExt(#[from] StringExtError),\n    #[error(\"plan: {0}\")]\n    Plan(#[from] PlanError),\n    #[error(\"schema-parse: {0}\")]\n    Schema(#[from] SchemaParseError),\n}\n\npub type Result\u003cT, E = Error\u003e = std::result::Result\u003cT, E\u003e;\n\nimpl From\u003cAlterError\u003e for Error {\n    fn from(e: AlterError) -\u003e Error {\n        Error::Alter(Box::new(e))\n    }\n}\n\nimpl From\u003cValueError\u003e for Error {\n    fn from(e: ValueError) -\u003e Error {\n        Error::Value(Box::new(e))\n    }\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","store","alter_table.rs"],"content":"use {\n    super::{DataRow, Store, StoreMut},\n    crate::{ast::ColumnDef, data::Value, executor::evaluate_stateless, result::Result},\n    async_trait::async_trait,\n    futures::TryStreamExt,\n    serde::Serialize,\n    std::fmt::Debug,\n    thiserror::Error,\n};\n\n#[derive(Error, Serialize, Debug, PartialEq, Eq)]\npub enum AlterTableError {\n    #[error(\"Table not found: {0}\")]\n    TableNotFound(String),\n\n    #[error(\"Renaming column not found\")]\n    RenamingColumnNotFound,\n\n    #[error(\"Default value is required: {0:#?}\")]\n    DefaultValueRequired(ColumnDef),\n\n    #[error(\"Already existing column: {0}\")]\n    AlreadyExistingColumn(String),\n\n    #[error(\"Dropping column not found: {0}\")]\n    DroppingColumnNotFound(String),\n\n    #[error(\"Schemaless table does not support ALTER TABLE: {0}\")]\n    SchemalessTableFound(String),\n\n    #[error(\"conflict - Vec expected but Map row found\")]\n    ConflictOnUnexpectedMapRowFound,\n}\n\n#[async_trait(?Send)]\npub trait AlterTable: Store + StoreMut {\n    async fn rename_schema(\u0026mut self, table_name: \u0026str, new_table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let mut schema = self\n            .fetch_schema(table_name)\n            .await?\n            .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()))?;\n        schema.table_name = new_table_name.to_owned();\n        self.insert_schema(\u0026schema).await?;\n\n        let rows = self\n            .scan_data(table_name)\n            .await?\n            .try_collect::\u003cVec\u003c_\u003e\u003e()\n            .await?;\n\n        self.insert_data(new_table_name, rows).await?;\n        self.delete_schema(table_name).await\n    }\n\n    async fn rename_column(\n        \u0026mut self,\n        table_name: \u0026str,\n        old_column_name: \u0026str,\n        new_column_name: \u0026str,\n    ) -\u003e Result\u003c()\u003e {\n        let mut schema = self\n            .fetch_schema(table_name)\n            .await?\n            .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()))?;\n\n        let column_defs = schema\n            .column_defs\n            .as_mut()\n            .ok_or_else(|| AlterTableError::SchemalessTableFound(table_name.to_owned()))?;\n\n        if column_defs\n            .iter()\n            .any(|column_def| column_def.name == new_column_name)\n        {\n            return Err(AlterTableError::AlreadyExistingColumn(new_column_name.to_owned()).into());\n        }\n\n        column_defs\n            .iter_mut()\n            .find(|column_def| column_def.name == old_column_name)\n            .ok_or(AlterTableError::RenamingColumnNotFound)?\n            .name = new_column_name.to_owned();\n\n        let rows = self\n            .scan_data(table_name)\n            .await?\n            .try_collect::\u003cVec\u003c_\u003e\u003e()\n            .await?;\n\n        self.insert_schema(\u0026schema).await?;\n        self.insert_data(table_name, rows).await\n    }\n\n    async fn add_column(\u0026mut self, table_name: \u0026str, column_def: \u0026ColumnDef) -\u003e Result\u003c()\u003e {\n        let mut schema = self\n            .fetch_schema(table_name)\n            .await?\n            .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()))?;\n\n        let default_value = match (column_def.default.as_ref(), column_def.nullable) {\n            (Some(default), _) =\u003e evaluate_stateless(None, default).await?.try_into()?,\n            (None, true) =\u003e Value::Null,\n            (None, false) =\u003e {\n                return Err(AlterTableError::DefaultValueRequired(column_def.clone()).into());\n            }\n        };\n\n        let column_defs = schema\n            .column_defs\n            .as_mut()\n            .ok_or_else(|| AlterTableError::SchemalessTableFound(table_name.to_owned()))?;\n\n        if column_defs.iter().any(|def| def.name == column_def.name) {\n            return Err(AlterTableError::AlreadyExistingColumn(column_def.name.clone()).into());\n        }\n\n        column_defs.push(column_def.clone());\n\n        let rows = self\n            .scan_data(table_name)\n            .await?\n            .and_then(|(key, mut data_row)| {\n                let default_value = default_value.clone();\n\n                async move {\n                    match \u0026mut data_row {\n                        DataRow::Map(_) =\u003e {\n                            Err(AlterTableError::ConflictOnUnexpectedMapRowFound.into())\n                        }\n                        DataRow::Vec(rows) =\u003e {\n                            rows.push(default_value);\n\n                            Ok((key, data_row))\n                        }\n                    }\n                }\n            })\n            .try_collect::\u003cVec\u003c_\u003e\u003e()\n            .await?;\n\n        self.insert_schema(\u0026schema).await?;\n        self.insert_data(table_name, rows).await\n    }\n\n    async fn drop_column(\n        \u0026mut self,\n        table_name: \u0026str,\n        column_name: \u0026str,\n        if_exists: bool,\n    ) -\u003e Result\u003c()\u003e {\n        let mut schema = self\n            .fetch_schema(table_name)\n            .await?\n            .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()))?;\n\n        let column_defs = schema\n            .column_defs\n            .as_mut()\n            .ok_or_else(|| AlterTableError::SchemalessTableFound(table_name.to_owned()))?;\n\n        let i = match column_defs\n            .iter()\n            .position(|column_def| column_def.name == column_name)\n        {\n            Some(i) =\u003e i,\n            None if if_exists =\u003e return Ok(()),\n            None =\u003e {\n                return Err(AlterTableError::DroppingColumnNotFound(column_name.to_owned()).into());\n            }\n        };\n\n        column_defs.retain(|column_def| column_def.name != column_name);\n\n        let rows = self\n            .scan_data(table_name)\n            .await?\n            .and_then(|(key, mut data_row)| async move {\n                match \u0026mut data_row {\n                    DataRow::Map(_) =\u003e Err(AlterTableError::ConflictOnUnexpectedMapRowFound.into()),\n                    DataRow::Vec(rows) =\u003e {\n                        rows.remove(i);\n\n                        Ok((key, data_row))\n                    }\n                }\n            })\n            .try_collect::\u003cVec\u003c_\u003e\u003e()\n            .await?;\n\n        self.insert_schema(\u0026schema).await?;\n        self.insert_data(table_name, rows).await\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":92},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","store","data_row.rs"],"content":"use {\n    crate::{\n        data::{Row, Value},\n        executor::RowContext,\n    },\n    serde::{Deserialize, Serialize},\n    std::collections::HashMap,\n};\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum DataRow {\n    Vec(Vec\u003cValue\u003e),\n    Map(HashMap\u003cString, Value\u003e),\n}\n\nimpl From\u003cRow\u003e for DataRow {\n    fn from(row: Row) -\u003e Self {\n        match row {\n            Row::Vec { values, .. } =\u003e Self::Vec(values),\n            Row::Map(values) =\u003e Self::Map(values),\n        }\n    }\n}\n\nimpl From\u003cVec\u003cValue\u003e\u003e for DataRow {\n    fn from(values: Vec\u003cValue\u003e) -\u003e Self {\n        Self::Vec(values)\n    }\n}\n\nimpl DataRow {\n    pub fn len(\u0026self) -\u003e usize {\n        match self {\n            Self::Vec(values) =\u003e values.len(),\n            Self::Map(values) =\u003e values.len(),\n        }\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        match self {\n            Self::Vec(values) =\u003e values.is_empty(),\n            Self::Map(values) =\u003e values.is_empty(),\n        }\n    }\n\n    pub fn as_context\u003c'a\u003e(\u0026'a self, columns: Option\u003c\u0026'a [String]\u003e) -\u003e RowContext\u003c'a\u003e {\n        match self {\n            Self::Vec(values) =\u003e RowContext::RefVecData {\n                columns: columns.unwrap_or(\u0026[]),\n                values,\n            },\n            Self::Map(values) =\u003e RowContext::RefMapData(values),\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","store","function.rs"],"content":"use {\n    crate::{\n        data::CustomFunction as StructCustomFunction,\n        result::{Error, Result},\n    },\n    async_trait::async_trait,\n};\n\n#[async_trait(?Send)]\npub trait CustomFunction {\n    async fn fetch_function\u003c'a\u003e(\n        \u0026'a self,\n        _func_name: \u0026str,\n    ) -\u003e Result\u003cOption\u003c\u0026'a StructCustomFunction\u003e\u003e {\n        Err(Error::StorageMsg(\n            \"[Storage] CustomFunction is not supported\".to_owned(),\n        ))\n    }\n\n    async fn fetch_all_functions\u003c'a\u003e(\u0026'a self) -\u003e Result\u003cVec\u003c\u0026'a StructCustomFunction\u003e\u003e {\n        Err(Error::StorageMsg(\n            \"[Storage] CustomFunction is not supported\".to_owned(),\n        ))\n    }\n}\n\n#[async_trait(?Send)]\npub trait CustomFunctionMut {\n    async fn insert_function(\u0026mut self, _func: StructCustomFunction) -\u003e Result\u003c()\u003e {\n        Err(Error::StorageMsg(\n            \"[Storage] CustomFunction is not supported\".to_owned(),\n        ))\n    }\n\n    async fn delete_function(\u0026mut self, _func_name: \u0026str) -\u003e Result\u003c()\u003e {\n        Err(Error::StorageMsg(\n            \"[Storage] CustomFunction is not supported\".to_owned(),\n        ))\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","store","index.rs"],"content":"use {\n    super::RowIter,\n    crate::{\n        ast::{IndexOperator, OrderByExpr},\n        data::Value,\n        result::{Error, Result},\n    },\n    async_trait::async_trait,\n    serde::Serialize,\n    std::fmt::Debug,\n    thiserror::Error as ThisError,\n};\n\n#[derive(ThisError, Serialize, Debug, PartialEq, Eq)]\npub enum IndexError {\n    #[error(\"table not found: {0}\")]\n    TableNotFound(String),\n\n    #[error(\"index name already exists: {0}\")]\n    IndexNameAlreadyExists(String),\n\n    #[error(\"index name does not exist: {0}\")]\n    IndexNameDoesNotExist(String),\n\n    #[error(\"conflict - table not found: {0}\")]\n    ConflictTableNotFound(String),\n\n    #[error(\"conflict - update failed - index value\")]\n    ConflictOnEmptyIndexValueUpdate,\n\n    #[error(\"conflict - delete failed - index value\")]\n    ConflictOnEmptyIndexValueDelete,\n\n    #[error(\"conflict - scan failed - index value\")]\n    ConflictOnEmptyIndexValueScan,\n\n    #[error(\"conflict - index sync - delete index data\")]\n    ConflictOnIndexDataDeleteSync,\n}\n\n#[async_trait(?Send)]\npub trait Index {\n    async fn scan_indexed_data\u003c'a\u003e(\n        \u0026'a self,\n        _table_name: \u0026str,\n        _index_name: \u0026str,\n        _asc: Option\u003cbool\u003e,\n        _cmp_value: Option\u003c(\u0026IndexOperator, Value)\u003e,\n    ) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        Err(Error::StorageMsg(\n            \"[Storage] Index::scan_indexed_data is not supported\".to_owned(),\n        ))\n    }\n}\n\n#[async_trait(?Send)]\npub trait IndexMut {\n    async fn create_index(\n        \u0026mut self,\n        _table_name: \u0026str,\n        _index_name: \u0026str,\n        _column: \u0026OrderByExpr,\n    ) -\u003e Result\u003c()\u003e {\n        let msg = \"[Storage] Index::create_index is not supported\".to_owned();\n\n        Err(Error::StorageMsg(msg))\n    }\n\n    async fn drop_index(\u0026mut self, _table_name: \u0026str, _index_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let msg = \"[Storage] Index::drop_index is not supported\".to_owned();\n\n        Err(Error::StorageMsg(msg))\n    }\n}\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","store","metadata.rs"],"content":"use {\n    crate::{prelude::Value, result::Result},\n    async_trait::async_trait,\n    std::{collections::HashMap, iter::empty},\n};\n\ntype ObjectName = String;\npub type MetaIter = Box\u003cdyn Iterator\u003cItem = Result\u003c(ObjectName, HashMap\u003cString, Value\u003e)\u003e\u003e\u003e;\n\n#[async_trait(?Send)]\npub trait Metadata {\n    async fn scan_table_meta(\u0026self) -\u003e Result\u003cMetaIter\u003e {\n        Ok(Box::new(empty()))\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","store","transaction.rs"],"content":"use {\n    crate::result::{Error, Result},\n    async_trait::async_trait,\n};\n\n#[async_trait(?Send)]\npub trait Transaction {\n    async fn begin(\u0026mut self, autocommit: bool) -\u003e Result\u003cbool\u003e {\n        if autocommit {\n            return Ok(false);\n        }\n\n        Err(Error::StorageMsg(\n            \"[Storage] Transaction::begin is not supported\".to_owned(),\n        ))\n    }\n\n    async fn rollback(\u0026mut self) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n\n    async fn commit(\u0026mut self) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","store.rs"],"content":"mod alter_table;\nmod data_row;\nmod function;\nmod index;\nmod metadata;\nmod transaction;\n\npub trait GStore: Store + Index + Metadata + CustomFunction {}\nimpl\u003cS: Store + Index + Metadata + CustomFunction\u003e GStore for S {}\n\npub trait GStoreMut:\n    StoreMut + IndexMut + AlterTable + Transaction + CustomFunction + CustomFunctionMut\n{\n}\nimpl\u003cS: StoreMut + IndexMut + AlterTable + Transaction + CustomFunction + CustomFunctionMut\u003e\n    GStoreMut for S\n{\n}\n\npub use {\n    alter_table::{AlterTable, AlterTableError},\n    data_row::DataRow,\n    function::{CustomFunction, CustomFunctionMut},\n    index::{Index, IndexError, IndexMut},\n    metadata::{MetaIter, Metadata},\n    transaction::Transaction,\n};\n\nuse {\n    crate::{\n        data::{Key, Schema},\n        executor::Referencing,\n        result::{Error, Result},\n    },\n    async_trait::async_trait,\n    futures::stream::Stream,\n    std::pin::Pin,\n};\n\npub type RowIter\u003c'a\u003e = Pin\u003cBox\u003cdyn Stream\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e + 'a\u003e\u003e;\n\n/// By implementing `Store` trait, you can run `SELECT` query.\n#[async_trait(?Send)]\npub trait Store {\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e;\n\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e;\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, key: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e;\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e;\n\n    async fn fetch_referencings(\u0026self, table_name: \u0026str) -\u003e Result\u003cVec\u003cReferencing\u003e\u003e {\n        let schemas = self.fetch_all_schemas().await?;\n\n        Ok(schemas\n            .into_iter()\n            .flat_map(|schema| {\n                let Schema {\n                    table_name: referencing_table_name,\n                    foreign_keys,\n                    ..\n                } = schema;\n\n                foreign_keys.into_iter().filter_map(move |foreign_key| {\n                    (foreign_key.referenced_table_name == table_name\n                        \u0026\u0026 referencing_table_name != table_name)\n                        .then_some(Referencing {\n                            table_name: referencing_table_name.clone(),\n                            foreign_key,\n                        })\n                })\n            })\n            .collect())\n    }\n}\n\n/// By implementing `StoreMut` trait,\n/// you can run `INSERT`, `CREATE TABLE`, `DELETE`, `UPDATE` and `DROP TABLE` queries.\n#[async_trait(?Send)]\npub trait StoreMut {\n    async fn insert_schema(\u0026mut self, _schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let msg = \"[Storage] StoreMut::insert_schema is not supported\".to_owned();\n\n        Err(Error::StorageMsg(msg))\n    }\n\n    async fn delete_schema(\u0026mut self, _table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let msg = \"[Storage] StoreMut::delete_schema is not supported\".to_owned();\n\n        Err(Error::StorageMsg(msg))\n    }\n\n    async fn append_data(\u0026mut self, _table_name: \u0026str, _rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let msg = \"[Storage] StoreMut::append_data is not supported\".to_owned();\n\n        Err(Error::StorageMsg(msg))\n    }\n\n    async fn insert_data(\u0026mut self, _table_name: \u0026str, _rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        let msg = \"[Storage] StoreMut::insert_data is not supported\".to_owned();\n\n        Err(Error::StorageMsg(msg))\n    }\n\n    async fn delete_data(\u0026mut self, _table_name: \u0026str, _keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        let msg = \"[Storage] StoreMut::delete_data is not supported\".to_owned();\n\n        Err(Error::StorageMsg(msg))\n    }\n}\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","translate","ast_literal.rs"],"content":"use {\n    super::TranslateError,\n    crate::{\n        ast::{AstLiteral, DateTimeField, TrimWhereField},\n        result::Result,\n    },\n    sqlparser::ast::{\n        DateTimeField as SqlDateTimeField, TrimWhereField as SqlTrimWhereField, Value as SqlValue,\n    },\n};\n\npub fn translate_ast_literal(sql_value: \u0026SqlValue) -\u003e Result\u003cAstLiteral\u003e {\n    Ok(match sql_value {\n        SqlValue::Boolean(v) =\u003e AstLiteral::Boolean(*v),\n        SqlValue::Number(v, _) =\u003e AstLiteral::Number(v.clone()),\n        SqlValue::SingleQuotedString(v) =\u003e AstLiteral::QuotedString(v.clone()),\n        SqlValue::HexStringLiteral(v) =\u003e AstLiteral::HexString(v.clone()),\n        SqlValue::Null =\u003e AstLiteral::Null,\n        _ =\u003e {\n            return Err(TranslateError::UnsupportedAstLiteral(sql_value.to_string()).into());\n        }\n    })\n}\n\npub fn translate_datetime_field(sql_datetime_field: \u0026SqlDateTimeField) -\u003e Result\u003cDateTimeField\u003e {\n    Ok(match sql_datetime_field {\n        SqlDateTimeField::Year =\u003e DateTimeField::Year,\n        SqlDateTimeField::Month =\u003e DateTimeField::Month,\n        SqlDateTimeField::Day =\u003e DateTimeField::Day,\n        SqlDateTimeField::Hour =\u003e DateTimeField::Hour,\n        SqlDateTimeField::Minute =\u003e DateTimeField::Minute,\n        SqlDateTimeField::Second =\u003e DateTimeField::Second,\n        _ =\u003e {\n            return Err(\n                TranslateError::UnsupportedDateTimeField(sql_datetime_field.to_string()).into(),\n            );\n        }\n    })\n}\n\npub fn translate_trim_where_field(sql_trim_where_field: \u0026SqlTrimWhereField) -\u003e TrimWhereField {\n    use TrimWhereField::*;\n    match sql_trim_where_field {\n        SqlTrimWhereField::Both =\u003e Both,\n        SqlTrimWhereField::Leading =\u003e Leading,\n        SqlTrimWhereField::Trailing =\u003e Trailing,\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","translate","data_type.rs"],"content":"use {\n    super::TranslateError,\n    crate::{ast::DataType, result::Result},\n    sqlparser::ast::{\n        DataType as SqlDataType, ExactNumberInfo as SqlExactNumberInfo,\n        TimezoneInfo as SqlTimezoneInfo,\n    },\n};\n\npub fn translate_data_type(sql_data_type: \u0026SqlDataType) -\u003e Result\u003cDataType\u003e {\n    match sql_data_type {\n        SqlDataType::Boolean =\u003e Ok(DataType::Boolean),\n        SqlDataType::Int(None) | SqlDataType::Integer(None) | SqlDataType::Int64 =\u003e {\n            Ok(DataType::Int)\n        }\n        SqlDataType::Int8(None) =\u003e Ok(DataType::Int8),\n        SqlDataType::Int16 =\u003e Ok(DataType::Int16),\n        SqlDataType::Int32 =\u003e Ok(DataType::Int32),\n        SqlDataType::Int128 =\u003e Ok(DataType::Int128),\n        SqlDataType::UInt8 =\u003e Ok(DataType::Uint8),\n        SqlDataType::UInt16 =\u003e Ok(DataType::Uint16),\n        SqlDataType::UInt32 =\u003e Ok(DataType::Uint32),\n        SqlDataType::UInt64 =\u003e Ok(DataType::Uint64),\n        SqlDataType::UInt128 =\u003e Ok(DataType::Uint128),\n\n        SqlDataType::Float32 =\u003e Ok(DataType::Float32),\n        SqlDataType::Float64 =\u003e Ok(DataType::Float),\n\n        SqlDataType::UnsignedInt(None) | SqlDataType::UnsignedInteger(None) =\u003e Ok(DataType::Uint64),\n        SqlDataType::UnsignedInt8(None) =\u003e Ok(DataType::Uint8),\n\n        SqlDataType::Float(None) | SqlDataType::Float(Some(64)) =\u003e Ok(DataType::Float),\n\n        SqlDataType::Text =\u003e Ok(DataType::Text),\n        SqlDataType::Bytea =\u003e Ok(DataType::Bytea),\n        SqlDataType::Date =\u003e Ok(DataType::Date),\n        SqlDataType::Timestamp(None, SqlTimezoneInfo::None) =\u003e Ok(DataType::Timestamp),\n        SqlDataType::Time(None, SqlTimezoneInfo::None) =\u003e Ok(DataType::Time),\n        SqlDataType::Interval =\u003e Ok(DataType::Interval),\n        SqlDataType::Uuid =\u003e Ok(DataType::Uuid),\n        SqlDataType::Decimal(SqlExactNumberInfo::None) =\u003e Ok(DataType::Decimal),\n        SqlDataType::Custom(name, _idents) =\u003e {\n            let name = name.0.first().map(|v| v.value.to_uppercase());\n\n            match name.as_deref() {\n                Some(\"MAP\") =\u003e Ok(DataType::Map),\n                Some(\"LIST\") =\u003e Ok(DataType::List),\n                Some(\"POINT\") =\u003e Ok(DataType::Point),\n                Some(\"INET\") =\u003e Ok(DataType::Inet),\n\n                _ =\u003e Err(TranslateError::UnsupportedDataType(sql_data_type.to_string()).into()),\n            }\n        }\n        _ =\u003e Err(TranslateError::UnsupportedDataType(sql_data_type.to_string()).into()),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {super::*, crate::parse_sql::parse_data_type, sqlparser::ast::ObjectName};\n\n    #[test]\n    fn support_data_type() {\n        macro_rules! test {\n            ($text:literal =\u003e $parser:expr =\u003e $gluesql: expr) =\u003e {\n                assert_eq!(parse_data_type($text), Ok($parser));\n                assert_eq!(translate_data_type(\u0026$parser), $gluesql);\n            };\n        }\n\n        test!(\"BOOLEAN\" =\u003e SqlDataType::Boolean =\u003e Ok(DataType::Boolean));\n\n        test!(\"INT\" =\u003e SqlDataType::Int(None) =\u003e Ok(DataType::Int));\n        test!(\"INTEGER\" =\u003e SqlDataType::Integer(None) =\u003e Ok(DataType::Int));\n        test!(\"INT64\" =\u003e SqlDataType::Int64 =\u003e Ok(DataType::Int));\n\n        test!(\"INT8\" =\u003e SqlDataType::Int8(None) =\u003e Ok(DataType::Int8));\n\n        test!(\"INT UNSIGNED\" =\u003e SqlDataType::UnsignedInt(None) =\u003e Ok(DataType::Uint64));\n        test!(\"INTEGER UNSIGNED\" =\u003e SqlDataType::UnsignedInteger(None) =\u003e Ok(DataType::Uint64));\n\n        test!(\"INT8 UNSIGNED\" =\u003e SqlDataType::UnsignedInt8(None) =\u003e Ok(DataType::Uint8));\n\n        test!(\"FLOAT\" =\u003e SqlDataType::Float(None) =\u003e Ok(DataType::Float));\n        test!(\"FLOAT(64)\" =\u003e SqlDataType::Float(Some(64)) =\u003e Ok(DataType::Float));\n\n        test!(\"TEXT\" =\u003e SqlDataType::Text =\u003e Ok(DataType::Text));\n\n        test!(\"BYTEA\" =\u003e SqlDataType::Bytea =\u003e Ok(DataType::Bytea));\n\n        test!(\"DATE\" =\u003e SqlDataType::Date =\u003e Ok(DataType::Date));\n        test!(\"TIMESTAMP\" =\u003e SqlDataType::Timestamp(None, SqlTimezoneInfo::None) =\u003e Ok(DataType::Timestamp));\n        test!(\"TIME\" =\u003e SqlDataType::Time(None, SqlTimezoneInfo::None) =\u003e  Ok(DataType::Time));\n        test!(\"INTERVAL\" =\u003e SqlDataType::Interval =\u003e Ok(DataType::Interval));\n        test!(\"UUID\" =\u003e SqlDataType::Uuid =\u003e Ok(DataType::Uuid));\n        test!(\"DECIMAL\" =\u003e SqlDataType::Decimal(SqlExactNumberInfo::None) =\u003e Ok(DataType::Decimal));\n    }\n\n    #[test]\n    fn support_custom_data_type() {\n        macro_rules! test {\n            ($text:literal =\u003e $gluesql: expr) =\u003e {\n                assert_eq!(\n                    translate_data_type(\u0026SqlDataType::Custom(\n                        ObjectName(vec![$text.into()]),\n                        vec![]\n                    )),\n                    $gluesql\n                );\n            };\n        }\n\n        test!(\"MAP\" =\u003e Ok(DataType::Map));\n        test!(\"LIST\" =\u003e Ok(DataType::List));\n        test!(\"POINT\" =\u003e Ok(DataType::Point));\n        test!(\"INET\" =\u003e Ok(DataType::Inet));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":35},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","translate","ddl.rs"],"content":"use {\n    super::{\n        TranslateError, data_type::translate_data_type, expr::translate_expr, translate_object_name,\n    },\n    crate::{\n        ast::{AlterTableOperation, ColumnDef, ColumnUniqueOption, OperateFunctionArg},\n        result::Result,\n    },\n    sqlparser::ast::{\n        AlterTableOperation as SqlAlterTableOperation, ColumnDef as SqlColumnDef,\n        ColumnOption as SqlColumnOption, ColumnOptionDef as SqlColumnOptionDef,\n        OperateFunctionArg as SqlOperateFunctionArg,\n    },\n};\n\npub fn translate_alter_table_operation(\n    sql_alter_table_operation: \u0026SqlAlterTableOperation,\n) -\u003e Result\u003cAlterTableOperation\u003e {\n    match sql_alter_table_operation {\n        SqlAlterTableOperation::AddColumn { column_def, .. } =\u003e {\n            Ok(AlterTableOperation::AddColumn {\n                column_def: translate_column_def(column_def)?,\n            })\n        }\n        SqlAlterTableOperation::DropColumn {\n            column_name,\n            if_exists,\n            ..\n        } =\u003e Ok(AlterTableOperation::DropColumn {\n            column_name: column_name.value.to_owned(),\n            if_exists: *if_exists,\n        }),\n        SqlAlterTableOperation::RenameColumn {\n            old_column_name,\n            new_column_name,\n        } =\u003e Ok(AlterTableOperation::RenameColumn {\n            old_column_name: old_column_name.value.to_owned(),\n            new_column_name: new_column_name.value.to_owned(),\n        }),\n        SqlAlterTableOperation::RenameTable { table_name } =\u003e {\n            Ok(AlterTableOperation::RenameTable {\n                table_name: translate_object_name(table_name)?,\n            })\n        }\n        _ =\u003e Err(TranslateError::UnsupportedAlterTableOperation(\n            sql_alter_table_operation.to_string(),\n        )\n        .into()),\n    }\n}\n\npub fn translate_column_def(sql_column_def: \u0026SqlColumnDef) -\u003e Result\u003cColumnDef\u003e {\n    let SqlColumnDef {\n        name,\n        data_type,\n        options,\n        ..\n    } = sql_column_def;\n\n    let (nullable, default, unique, comment) = options.iter().try_fold(\n        (true, None, None, None),\n        |(nullable, default, unique, comment), SqlColumnOptionDef { option, .. }| -\u003e Result\u003c_\u003e {\n            match option {\n                SqlColumnOption::Null =\u003e Ok((nullable, default, unique, comment)),\n                SqlColumnOption::NotNull =\u003e Ok((false, default, unique, comment)),\n                SqlColumnOption::Default(default) =\u003e {\n                    let default = translate_expr(default).map(Some)?;\n\n                    Ok((nullable, default, unique, comment))\n                }\n                SqlColumnOption::Unique { is_primary, .. } =\u003e {\n                    let nullable = if *is_primary { false } else { nullable };\n                    let unique = Some(ColumnUniqueOption {\n                        is_primary: *is_primary,\n                    });\n\n                    Ok((nullable, default, unique, comment))\n                }\n                SqlColumnOption::Comment(comment) =\u003e {\n                    Ok((nullable, default, unique, Some(comment.to_string())))\n                }\n                _ =\u003e Err(TranslateError::UnsupportedColumnOption(option.to_string()).into()),\n            }\n        },\n    )?;\n\n    Ok(ColumnDef {\n        name: name.value.to_owned(),\n        data_type: translate_data_type(data_type)?,\n        nullable,\n        default,\n        unique,\n        comment,\n    })\n}\n\npub fn translate_operate_function_arg(arg: \u0026SqlOperateFunctionArg) -\u003e Result\u003cOperateFunctionArg\u003e {\n    let name = arg\n        .name\n        .as_ref()\n        .map(|v| v.value.to_owned())\n        .ok_or(TranslateError::UnNamedFunctionArgNotSupported)?;\n    let data_type = translate_data_type(\u0026arg.data_type)?;\n    let default = arg.default_expr.as_ref().map(translate_expr).transpose()?;\n    Ok(OperateFunctionArg {\n        name,\n        data_type,\n        default,\n    })\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":57},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","translate","error.rs"],"content":"use {serde::Serialize, std::fmt::Debug, thiserror::Error};\n\n#[derive(Error, Serialize, Debug, PartialEq, Eq)]\npub enum TranslateError {\n    #[error(\"unimplemented - select on two or more than tables are not supported\")]\n    TooManyTables,\n\n    #[error(\"unimplemented - select distinct is not supported\")]\n    SelectDistinctNotSupported,\n\n    #[error(\"unimplemented - composite index is not supported\")]\n    CompositeIndexNotSupported,\n\n    #[error(\"unimplemented - join on update not supported\")]\n    JoinOnUpdateNotSupported,\n\n    #[error(\"unimplemented - compound identifier on update not supported: {0}\")]\n    CompoundIdentOnUpdateNotSupported(String),\n\n    #[error(\"unimplemented - tuple assigment on update is not supported: {0}\")]\n    TupleAssignmentOnUpdateNotSupported(String),\n\n    #[error(\"too many params in drop index\")]\n    TooManyParamsInDropIndex,\n\n    #[error(\"invalid params in drop index, expected: table_name.index_name\")]\n    InvalidParamsInDropIndex,\n\n    #[error(\"function args.length not matching: {name}, expected: {expected}, found: {found}\")]\n    FunctionArgsLengthNotMatching {\n        name: String,\n        expected: usize,\n        found: usize,\n    },\n\n    #[error(\"function {name} requires at least {expected_minimum} argument(s), found: {found}\")]\n    FunctionArgsLengthNotMatchingMin {\n        name: String,\n        expected_minimum: usize,\n        found: usize,\n    },\n\n    #[error(\n        \"function args.length not matching: {name}, expected: {expected_minimum} ~ {expected_maximum}, found: {found}\"\n    )]\n    FunctionArgsLengthNotWithinRange {\n        name: String,\n        expected_minimum: usize,\n        expected_maximum: usize,\n        found: usize,\n    },\n\n    #[error(\"named function arg is not supported\")]\n    NamedFunctionArgNotSupported,\n\n    #[error(\"unnamed function arg is not supported\")]\n    UnNamedFunctionArgNotSupported,\n\n    #[error(\"subquery function arg is not supported\")]\n    UnreachableSubqueryFunctionArgNotSupported,\n\n    #[error(\"INSERT INTO {0} DEFAULT VALUES is not supported\")]\n    DefaultValuesOnInsertNotSupported(String),\n\n    #[error(\"empty function body is not supported\")]\n    UnsupportedEmptyFunctionBody,\n\n    #[error(\"unsupported unnamed index\")]\n    UnsupportedUnnamedIndex,\n\n    #[error(\n        \"unsupported trim chars: expected: `TRIM((BOTH | LEADING | TRAILING) \u003ctext\u003e FROM \u003cexpr\u003e)`, got: `TRIM(\u003cexpr\u003e [\u003cchars\u003e, ..])` syntax\"\n    )]\n    UnsupportedTrimChars,\n\n    #[error(\"unsupported CAST format: {0}\")]\n    UnsupportedCastFormat(String),\n\n    #[error(\"TRY_CAST(..) is not supported\")]\n    TryCastNotSupported,\n\n    #[error(\"SAFE_CAST(..) is not supported\")]\n    SafeCastNotSupported,\n\n    #[error(\n        \"unsupported multiple alter table operations, expected: `ALTER TABLE \u003ctable\u003e \u003coperation\u003e`, got: `ALTER TABLE \u003ctable\u003e \u003coperation\u003e, \u003coperation\u003e, ..`\"\n    )]\n    UnsupportedMultipleAlterTableOperations,\n\n    #[error(\"unreachable empty alter table operation\")]\n    UnreachableEmptyAlterTableOperation,\n\n    #[error(\"unsupported `GROUP BY (ALL)`\")]\n    UnsupportedGroupByAll,\n\n    #[error(\"wildcard function arg is not accepted\")]\n    WildcardFunctionArgNotAccepted,\n\n    #[error(\"qualified wildcard is not supported - COUNT({0})\")]\n    QualifiedWildcardInCountNotSupported(String),\n\n    #[error(\"order by - NULLS (FIRST | LAST) is not supported\")]\n    OrderByNullsFirstOrLastNotSupported,\n\n    #[error(\"unsupported SHOW VARIABLE keyword: {0}\")]\n    UnsupportedShowVariableKeyword(String),\n\n    #[error(\"unsupported SHOW VARIABLE statement: {0}\")]\n    UnsupportedShowVariableStatement(String),\n\n    #[error(\"unsupported statement: {0}\")]\n    UnsupportedStatement(String),\n\n    #[error(\"unsupported expr: {0}\")]\n    UnsupportedExpr(String),\n\n    #[error(\"unsupported data type: {0}\")]\n    UnsupportedDataType(String),\n\n    #[error(\"unsupported datetime field: {0}\")]\n    UnsupportedDateTimeField(String),\n\n    #[error(\"unsupported ast literal: {0}\")]\n    UnsupportedAstLiteral(String),\n\n    #[error(\"unreachable unary operator: {0}\")]\n    UnreachableUnaryOperator(String),\n\n    #[error(\"unreachable empty ident\")]\n    UnreachableEmptyIdent,\n\n    #[error(\"unsupported binary operator: {0}\")]\n    UnsupportedBinaryOperator(String),\n\n    #[error(\"unsupported query set expr: {0}\")]\n    UnsupportedQuerySetExpr(String),\n\n    #[error(\"unsupported query table factor: {0}\")]\n    UnsupportedQueryTableFactor(String),\n\n    #[error(\"unsupported join constraint: {0}\")]\n    UnsupportedJoinConstraint(String),\n\n    #[error(\"unsupported join operator: {0}\")]\n    UnsupportedJoinOperator(String),\n\n    #[error(\"unsupported column option: {0}\")]\n    UnsupportedColumnOption(String),\n\n    #[error(\"unsupported alter table operation: {0}\")]\n    UnsupportedAlterTableOperation(String),\n\n    #[error(\"unsupported table factor: {0}\")]\n    UnsupportedTableFactor(String),\n\n    #[error(\"Every derived table must have its own alias\")]\n    LackOfAlias,\n\n    #[error(\"Series should have size\")]\n    LackOfArgs,\n\n    #[error(\"unreachable empty object\")]\n    UnreachableEmptyObject,\n\n    #[error(\"unreachable empty table\")]\n    UnreachableEmptyTable,\n\n    #[error(\"unreachable - FROM cannot be ommitted in DELETE statement\")]\n    UnreachableOmittingFromInDelete,\n\n    #[error(\"unimplemented - compound object is supported: {0}\")]\n    CompoundObjectNotSupported(String),\n\n    #[error(\"cannot create index with reserved name: {0}\")]\n    ReservedIndexName(String),\n\n    #[error(\"cannot drop primary index\")]\n    CannotDropPrimary,\n\n    #[error(\"unreachable - empty columns\")]\n    UnreachableForeignKeyColumns(String),\n\n    #[error(\"unsupported constraint: {0}\")]\n    UnsupportedConstraint(String),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","translate","expr.rs"],"content":"use {\n    super::{\n        TranslateError,\n        ast_literal::{translate_ast_literal, translate_datetime_field},\n        data_type::translate_data_type,\n        function::{\n            translate_cast, translate_ceil, translate_extract, translate_floor, translate_function,\n            translate_position,\n        },\n        operator::{translate_binary_operator, translate_unary_operator},\n        translate_idents, translate_query,\n    },\n    crate::{\n        ast::{Expr, OrderByExpr},\n        result::Result,\n        translate::function::translate_trim,\n    },\n    sqlparser::ast::{\n        Array, CeilFloorKind as SqlCeilFloorKind, DateTimeField as SqlDateTimeField,\n        Expr as SqlExpr, Interval as SqlInterval, OrderByExpr as SqlOrderByExpr,\n        Subscript as SqlSubscript,\n    },\n};\n\n/// # Description\n/// Returns [`Expr`] in the form required for `GlueSQL` from [`SqlExpr`] provided by `sqlparser-rs`. \u003cbr\u003e\n/// Among them, there are functions that are translated to a lower level of [`Expr`] rather than [`Expr::Function`]\n/// - e.g) `cast`, `extract`\n///\n/// This is because it follows the parsed result of `sqlparser-rs` as it is. \u003cbr\u003e\n/// It is ambiguous whether the parsed tokens will be classified as a lower level of [`Expr`] or a lower level of [`Expr::Function`]. \u003cbr\u003e\n/// In `GlueSQL`, if an argument is received wrapped in `( )` in the sql statement, the standard is set to translate in the form of `Expr::Function(Box\u003cFunction::Cast\u003e)` rather than `Expr::Cast`.\npub fn translate_expr(sql_expr: \u0026SqlExpr) -\u003e Result\u003cExpr\u003e {\n    match sql_expr {\n        SqlExpr::Identifier(ident) =\u003e Ok(Expr::Identifier(ident.value.clone())),\n        SqlExpr::CompoundIdentifier(idents) =\u003e (idents.len() == 2)\n            .then(|| Expr::CompoundIdentifier {\n                alias: idents[0].value.clone(),\n                ident: idents[1].value.clone(),\n            })\n            .ok_or_else(|| {\n                TranslateError::UnsupportedExpr(translate_idents(idents).join(\".\")).into()\n            }),\n        SqlExpr::IsNull(expr) =\u003e translate_expr(expr).map(Box::new).map(Expr::IsNull),\n        SqlExpr::IsNotNull(expr) =\u003e translate_expr(expr).map(Box::new).map(Expr::IsNotNull),\n        SqlExpr::InList {\n            expr,\n            list,\n            negated,\n        } =\u003e Ok(Expr::InList {\n            expr: translate_expr(expr).map(Box::new)?,\n            list: list.iter().map(translate_expr).collect::\u003cResult\u003c_\u003e\u003e()?,\n            negated: *negated,\n        }),\n        SqlExpr::InSubquery {\n            expr,\n            subquery,\n            negated,\n        } =\u003e Ok(Expr::InSubquery {\n            expr: translate_expr(expr).map(Box::new)?,\n            subquery: translate_query(subquery).map(Box::new)?,\n            negated: *negated,\n        }),\n        SqlExpr::Between {\n            expr,\n            negated,\n            low,\n            high,\n        } =\u003e Ok(Expr::Between {\n            expr: translate_expr(expr).map(Box::new)?,\n            negated: *negated,\n            low: translate_expr(low).map(Box::new)?,\n            high: translate_expr(high).map(Box::new)?,\n        }),\n        SqlExpr::Like {\n            expr,\n            negated,\n            pattern,\n            escape_char: None,\n            ..\n        } =\u003e Ok(Expr::Like {\n            expr: translate_expr(expr).map(Box::new)?,\n            negated: *negated,\n            pattern: translate_expr(pattern).map(Box::new)?,\n        }),\n        SqlExpr::ILike {\n            expr,\n            negated,\n            pattern,\n            escape_char: None,\n            ..\n        } =\u003e Ok(Expr::ILike {\n            expr: translate_expr(expr).map(Box::new)?,\n            negated: *negated,\n            pattern: translate_expr(pattern).map(Box::new)?,\n        }),\n        SqlExpr::BinaryOp { left, op, right } =\u003e Ok(Expr::BinaryOp {\n            left: translate_expr(left).map(Box::new)?,\n            op: translate_binary_operator(op)?,\n            right: translate_expr(right).map(Box::new)?,\n        }),\n        SqlExpr::UnaryOp { op, expr } =\u003e Ok(Expr::UnaryOp {\n            op: translate_unary_operator(op)?,\n            expr: translate_expr(expr).map(Box::new)?,\n        }),\n        SqlExpr::Extract { field, expr, .. } =\u003e translate_extract(field, expr),\n        SqlExpr::Nested(expr) =\u003e translate_expr(expr).map(Box::new).map(Expr::Nested),\n        SqlExpr::Value(value) =\u003e translate_ast_literal(value).map(Expr::Literal),\n        SqlExpr::TypedString { data_type, value } =\u003e Ok(Expr::TypedString {\n            data_type: translate_data_type(data_type)?,\n            value: value.to_owned(),\n        }),\n        SqlExpr::Function(function) =\u003e translate_function(function),\n        SqlExpr::Trim {\n            expr,\n            trim_where,\n            trim_what,\n            trim_characters,\n        } =\u003e {\n            if trim_characters.is_some() {\n                return Err(TranslateError::UnsupportedTrimChars.into());\n            }\n\n            translate_trim(expr, trim_where, trim_what)\n        }\n        SqlExpr::Floor { expr, field } =\u003e {\n            if !matches!(\n                field,\n                SqlCeilFloorKind::DateTimeField(SqlDateTimeField::NoDateTime)\n            ) {\n                return Err(TranslateError::UnsupportedExpr(sql_expr.to_string()).into());\n            }\n\n            translate_floor(expr)\n        }\n        SqlExpr::Ceil { expr, field } =\u003e {\n            if !matches!(\n                field,\n                SqlCeilFloorKind::DateTimeField(SqlDateTimeField::NoDateTime)\n            ) {\n                return Err(TranslateError::UnsupportedExpr(sql_expr.to_string()).into());\n            }\n\n            translate_ceil(expr)\n        }\n        SqlExpr::Exists { subquery, negated } =\u003e Ok(Expr::Exists {\n            subquery: translate_query(subquery).map(Box::new)?,\n            negated: *negated,\n        }),\n        SqlExpr::Subquery(query) =\u003e translate_query(query).map(Box::new).map(Expr::Subquery),\n        SqlExpr::Case {\n            operand,\n            conditions,\n            results,\n            else_result,\n        } =\u003e Ok(Expr::Case {\n            operand: operand\n                .as_ref()\n                .map(|expr| translate_expr(expr.as_ref()).map(Box::new))\n                .transpose()?,\n            when_then: conditions\n                .iter()\n                .zip(results)\n                .map(|(when, then)| {\n                    let when = translate_expr(when)?;\n                    let then = translate_expr(then)?;\n\n                    Ok((when, then))\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n            else_result: else_result\n                .as_ref()\n                .map(|expr| translate_expr(expr.as_ref()).map(Box::new))\n                .transpose()?,\n        }),\n        SqlExpr::Subscript { expr, subscript } =\u003e match subscript.as_ref() {\n            SqlSubscript::Index { index } =\u003e Ok(Expr::ArrayIndex {\n                obj: translate_expr(expr).map(Box::new)?,\n                indexes: vec![translate_expr(index)?],\n            }),\n            SqlSubscript::Slice { .. } =\u003e {\n                Err(TranslateError::UnsupportedExpr(sql_expr.to_string()).into())\n            }\n        },\n        SqlExpr::Array(Array { elem, .. }) =\u003e Ok(Expr::Array {\n            elem: elem.iter().map(translate_expr).collect::\u003cResult\u003c_\u003e\u003e()?,\n        }),\n        SqlExpr::Position { expr, r#in } =\u003e translate_position(expr, r#in),\n        SqlExpr::Interval(SqlInterval {\n            value,\n            leading_field,\n            last_field,\n            ..\n        }) =\u003e Ok(Expr::Interval {\n            expr: translate_expr(value).map(Box::new)?,\n            leading_field: leading_field\n                .as_ref()\n                .map(translate_datetime_field)\n                .transpose()?,\n            last_field: last_field\n                .as_ref()\n                .map(translate_datetime_field)\n                .transpose()?,\n        }),\n        SqlExpr::Cast {\n            expr,\n            data_type,\n            format,\n            kind,\n        } =\u003e translate_cast(kind, expr, data_type, format.as_ref()),\n\n        _ =\u003e Err(TranslateError::UnsupportedExpr(sql_expr.to_string()).into()),\n    }\n}\n\npub fn translate_order_by_expr(sql_order_by_expr: \u0026SqlOrderByExpr) -\u003e Result\u003cOrderByExpr\u003e {\n    let SqlOrderByExpr {\n        expr,\n        asc,\n        nulls_first,\n        ..\n    } = sql_order_by_expr;\n\n    if nulls_first.is_some() {\n        return Err(TranslateError::OrderByNullsFirstOrLastNotSupported.into());\n    }\n\n    Ok(OrderByExpr {\n        expr: translate_expr(expr)?,\n        asc: *asc,\n    })\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":148},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","translate","function.rs"],"content":"use {\n    super::{\n        TranslateError,\n        ast_literal::{translate_datetime_field, translate_trim_where_field},\n        expr::translate_expr,\n        translate_data_type, translate_object_name,\n    },\n    crate::{\n        ast::{Aggregate, CountArgExpr, Expr, Function},\n        result::Result,\n    },\n    sqlparser::ast::{\n        CastFormat as SqlCastFormat, CastKind as SqlCastKind, DataType as SqlDataType,\n        DateTimeField as SqlDateTimeField, Expr as SqlExpr, Function as SqlFunction,\n        FunctionArg as SqlFunctionArg, FunctionArgExpr as SqlFunctionArgExpr,\n        FunctionArguments as SqlFunctionArguments, TrimWhereField as SqlTrimWhereField,\n    },\n};\n\npub fn translate_trim(\n    expr: \u0026SqlExpr,\n    trim_where: \u0026Option\u003cSqlTrimWhereField\u003e,\n    trim_what: \u0026Option\u003cBox\u003cSqlExpr\u003e\u003e,\n) -\u003e Result\u003cExpr\u003e {\n    let expr = translate_expr(expr)?;\n    let trim_where_field = trim_where.as_ref().map(translate_trim_where_field);\n    let filter_chars = trim_what\n        .as_ref()\n        .map(|expr| translate_expr(expr.as_ref()))\n        .transpose()?;\n\n    Ok(Expr::Function(Box::new(Function::Trim {\n        expr,\n        filter_chars,\n        trim_where_field,\n    })))\n}\n\npub fn translate_floor(expr: \u0026SqlExpr) -\u003e Result\u003cExpr\u003e {\n    let expr = translate_expr(expr)?;\n\n    Ok(Expr::Function(Box::new(Function::Floor(expr))))\n}\n\npub fn translate_ceil(expr: \u0026SqlExpr) -\u003e Result\u003cExpr\u003e {\n    let expr = translate_expr(expr)?;\n\n    Ok(Expr::Function(Box::new(Function::Ceil(expr))))\n}\n\npub fn translate_position(sub_expr: \u0026SqlExpr, from_expr: \u0026SqlExpr) -\u003e Result\u003cExpr\u003e {\n    let from_expr = translate_expr(from_expr)?;\n    let sub_expr = translate_expr(sub_expr)?;\n    Ok(Expr::Function(Box::new(Function::Position {\n        from_expr,\n        sub_expr,\n    })))\n}\n\npub fn translate_cast(\n    kind: \u0026SqlCastKind,\n    expr: \u0026SqlExpr,\n    data_type: \u0026SqlDataType,\n    format: Option\u003c\u0026SqlCastFormat\u003e,\n) -\u003e Result\u003cExpr\u003e {\n    if kind == \u0026SqlCastKind::TryCast {\n        return Err(TranslateError::TryCastNotSupported.into());\n    } else if kind == \u0026SqlCastKind::SafeCast {\n        return Err(TranslateError::SafeCastNotSupported.into());\n    } else if let Some(format) = format {\n        return Err(TranslateError::UnsupportedCastFormat(format.to_string()).into());\n    }\n\n    let expr = translate_expr(expr)?;\n    let data_type = translate_data_type(data_type)?;\n    Ok(Expr::Function(Box::new(Function::Cast { expr, data_type })))\n}\n\npub fn translate_extract(field: \u0026SqlDateTimeField, expr: \u0026SqlExpr) -\u003e Result\u003cExpr\u003e {\n    let field = translate_datetime_field(field)?;\n    let expr = translate_expr(expr)?;\n    Ok(Expr::Function(Box::new(Function::Extract { field, expr })))\n}\n\nfn check_len(name: String, found: usize, expected: usize) -\u003e Result\u003c()\u003e {\n    if found == expected {\n        Ok(())\n    } else {\n        Err(TranslateError::FunctionArgsLengthNotMatching {\n            name,\n            found,\n            expected,\n        }\n        .into())\n    }\n}\n\nfn check_len_range(\n    name: String,\n    found: usize,\n    expected_minimum: usize,\n    expected_maximum: usize,\n) -\u003e Result\u003c()\u003e {\n    if found \u003e= expected_minimum \u0026\u0026 found \u003c= expected_maximum {\n        Ok(())\n    } else {\n        Err(TranslateError::FunctionArgsLengthNotWithinRange {\n            name,\n            expected_minimum,\n            expected_maximum,\n            found,\n        }\n        .into())\n    }\n}\n\nfn check_len_min(name: String, found: usize, expected_minimum: usize) -\u003e Result\u003c()\u003e {\n    if found \u003e= expected_minimum {\n        Ok(())\n    } else {\n        Err(TranslateError::FunctionArgsLengthNotMatchingMin {\n            name,\n            expected_minimum,\n            found,\n        }\n        .into())\n    }\n}\n\nfn translate_function_zero_arg(func: Function, args: Vec\u003c\u0026SqlExpr\u003e, name: String) -\u003e Result\u003cExpr\u003e {\n    check_len(name, args.len(), 0)?;\n\n    Ok(Expr::Function(Box::new(func)))\n}\n\nfn translate_function_one_arg\u003cT: FnOnce(Expr) -\u003e Function\u003e(\n    func: T,\n    args: Vec\u003c\u0026SqlExpr\u003e,\n    name: String,\n) -\u003e Result\u003cExpr\u003e {\n    check_len(name, args.len(), 1)?;\n\n    translate_expr(args[0])\n        .map(func)\n        .map(Box::new)\n        .map(Expr::Function)\n}\n\nfn translate_aggregate_one_arg\u003cT: FnOnce(Expr) -\u003e Aggregate\u003e(\n    func: T,\n    args: Vec\u003c\u0026SqlExpr\u003e,\n    name: String,\n) -\u003e Result\u003cExpr\u003e {\n    check_len(name, args.len(), 1)?;\n\n    translate_expr(args[0])\n        .map(func)\n        .map(Box::new)\n        .map(Expr::Aggregate)\n}\n\nfn translate_function_trim\u003cT: FnOnce(Expr, Option\u003cExpr\u003e) -\u003e Function\u003e(\n    func: T,\n    args: Vec\u003c\u0026SqlExpr\u003e,\n    name: String,\n) -\u003e Result\u003cExpr\u003e {\n    check_len_range(name, args.len(), 1, 2)?;\n\n    let expr = translate_expr(args[0])?;\n    let chars = if args.len() == 1 {\n        None\n    } else {\n        Some(translate_expr(args[1])?)\n    };\n\n    let result = func(expr, chars);\n\n    Ok(Expr::Function(Box::new(result)))\n}\n\npub fn translate_function_arg_exprs(\n    function_arg_exprs: Vec\u003c\u0026SqlFunctionArgExpr\u003e,\n) -\u003e Result\u003cVec\u003c\u0026SqlExpr\u003e\u003e {\n    function_arg_exprs\n        .into_iter()\n        .map(|function_arg| match function_arg {\n            SqlFunctionArgExpr::Expr(expr) =\u003e Ok(expr),\n            SqlFunctionArgExpr::Wildcard | SqlFunctionArgExpr::QualifiedWildcard(_) =\u003e {\n                Err(TranslateError::WildcardFunctionArgNotAccepted.into())\n            }\n        })\n        .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n}\n\npub fn translate_function(sql_function: \u0026SqlFunction) -\u003e Result\u003cExpr\u003e {\n    let SqlFunction { name, args, .. } = sql_function;\n    let name = translate_object_name(name)?.to_uppercase();\n    let args = match args {\n        SqlFunctionArguments::None =\u003e Vec::new(),\n        SqlFunctionArguments::Subquery(_) =\u003e {\n            return Err(TranslateError::UnreachableSubqueryFunctionArgNotSupported.into());\n        }\n        SqlFunctionArguments::List(list) =\u003e list.args.iter().collect(),\n    };\n\n    let function_arg_exprs = args\n        .iter()\n        .map(|arg| match arg {\n            SqlFunctionArg::Named { .. } =\u003e {\n                Err(TranslateError::NamedFunctionArgNotSupported.into())\n            }\n            SqlFunctionArg::Unnamed(arg_expr) =\u003e Ok(arg_expr),\n        })\n        .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n    if name.as_str() == \"COUNT\" {\n        check_len(name, args.len(), 1)?;\n\n        let count_arg = match function_arg_exprs[0] {\n            SqlFunctionArgExpr::Expr(expr) =\u003e CountArgExpr::Expr(translate_expr(expr)?),\n            SqlFunctionArgExpr::QualifiedWildcard(idents) =\u003e {\n                let table_name = translate_object_name(idents)?;\n                let idents = format!(\"{}.*\", table_name);\n\n                return Err(TranslateError::QualifiedWildcardInCountNotSupported(idents).into());\n            }\n            SqlFunctionArgExpr::Wildcard =\u003e CountArgExpr::Wildcard,\n        };\n\n        return Ok(Expr::Aggregate(Box::new(Aggregate::Count(count_arg))));\n    }\n\n    let args = translate_function_arg_exprs(function_arg_exprs)?;\n\n    match name.as_str() {\n        \"SUM\" =\u003e translate_aggregate_one_arg(Aggregate::Sum, args, name),\n        \"MIN\" =\u003e translate_aggregate_one_arg(Aggregate::Min, args, name),\n        \"MAX\" =\u003e translate_aggregate_one_arg(Aggregate::Max, args, name),\n        \"AVG\" =\u003e translate_aggregate_one_arg(Aggregate::Avg, args, name),\n        \"VARIANCE\" =\u003e translate_aggregate_one_arg(Aggregate::Variance, args, name),\n        \"STDEV\" =\u003e translate_aggregate_one_arg(Aggregate::Stdev, args, name),\n        \"COALESCE\" =\u003e {\n            let exprs = args\n                .into_iter()\n                .map(translate_expr)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n            Ok(Expr::Function(Box::new(Function::Coalesce(exprs))))\n        }\n        \"CONCAT\" =\u003e {\n            let exprs = args\n                .into_iter()\n                .map(translate_expr)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n            Ok(Expr::Function(Box::new(Function::Concat(exprs))))\n        }\n        \"CONCAT_WS\" =\u003e {\n            check_len_min(name, args.len(), 2)?;\n            let separator = translate_expr(args[0])?;\n            let exprs = args\n                .into_iter()\n                .skip(1)\n                .map(translate_expr)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n            Ok(Expr::Function(Box::new(Function::ConcatWs {\n                separator,\n                exprs,\n            })))\n        }\n        \"IIF\" =\u003e {\n            check_len(name, args.len(), 3)?;\n            let cond = translate_expr(args[0])?;\n            let then = translate_expr(args[1])?;\n            let else_result = translate_expr(args[2])?;\n            Ok(Expr::Function(Box::new(Function::Iif {\n                cond,\n                then,\n                else_result,\n            })))\n        }\n        \"FIND_IDX\" =\u003e {\n            check_len_range(name, args.len(), 2, 3)?;\n\n            let from_expr = translate_expr(args[0])?;\n            let sub_expr = translate_expr(args[1])?;\n            let start = (args.len() \u003e 2)\n                .then(|| translate_expr(args[2]))\n                .transpose()?;\n\n            Ok(Expr::Function(Box::new(Function::FindIdx {\n                from_expr,\n                sub_expr,\n                start,\n            })))\n        }\n        \"LOWER\" =\u003e translate_function_one_arg(Function::Lower, args, name),\n        \"INITCAP\" =\u003e translate_function_one_arg(Function::Initcap, args, name),\n        \"UPPER\" =\u003e translate_function_one_arg(Function::Upper, args, name),\n        \"LEFT\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let expr = translate_expr(args[0])?;\n            let size = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Left { expr, size })))\n        }\n        \"IFNULL\" =\u003e {\n            check_len(name, args.len(), 2)?;\n            let expr = translate_expr(args[0])?;\n            let then = translate_expr(args[1])?;\n            Ok(Expr::Function(Box::new(Function::IfNull { expr, then })))\n        }\n        \"NULLIF\" =\u003e {\n            check_len(name, args.len(), 2)?;\n            let expr1 = translate_expr(args[0])?;\n            let expr2 = translate_expr(args[1])?;\n            Ok(Expr::Function(Box::new(Function::NullIf { expr1, expr2 })))\n        }\n        \"RIGHT\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let expr = translate_expr(args[0])?;\n            let size = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Right { expr, size })))\n        }\n        \"SQRT\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            translate_expr(args[0])\n                .map(Function::Sqrt)\n                .map(Box::new)\n                .map(Expr::Function)\n        }\n        \"POWER\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let expr = translate_expr(args[0])?;\n            let power = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Power { expr, power })))\n        }\n        \"LPAD\" =\u003e {\n            check_len_range(name, args.len(), 2, 3)?;\n\n            let expr = translate_expr(args[0])?;\n            let size = translate_expr(args[1])?;\n            let fill = if args.len() == 2 {\n                None\n            } else {\n                Some(translate_expr(args[2])?)\n            };\n\n            Ok(Expr::Function(Box::new(Function::Lpad {\n                expr,\n                size,\n                fill,\n            })))\n        }\n        \"RPAD\" =\u003e {\n            check_len_range(name, args.len(), 2, 3)?;\n\n            let expr = translate_expr(args[0])?;\n            let size = translate_expr(args[1])?;\n            let fill = if args.len() == 2 {\n                None\n            } else {\n                Some(translate_expr(args[2])?)\n            };\n\n            Ok(Expr::Function(Box::new(Function::Rpad {\n                expr,\n                size,\n                fill,\n            })))\n        }\n        \"RAND\" =\u003e {\n            check_len_range(name, args.len(), 0, 1)?;\n            let v = if args.is_empty() {\n                None\n            } else {\n                Some(translate_expr(args[0])?)\n            };\n            Ok(Expr::Function(Box::new(Function::Rand(v))))\n        }\n        \"ROUND\" =\u003e translate_function_one_arg(Function::Round, args, name),\n        \"EXP\" =\u003e translate_function_one_arg(Function::Exp, args, name),\n        \"LN\" =\u003e translate_function_one_arg(Function::Ln, args, name),\n        \"LOG\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let antilog = translate_expr(args[0])?;\n            let base = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Log { antilog, base })))\n        }\n        \"LOG2\" =\u003e translate_function_one_arg(Function::Log2, args, name),\n        \"LOG10\" =\u003e translate_function_one_arg(Function::Log10, args, name),\n        \"SIN\" =\u003e translate_function_one_arg(Function::Sin, args, name),\n        \"COS\" =\u003e translate_function_one_arg(Function::Cos, args, name),\n        \"TAN\" =\u003e translate_function_one_arg(Function::Tan, args, name),\n        \"ASIN\" =\u003e translate_function_one_arg(Function::Asin, args, name),\n        \"ACOS\" =\u003e translate_function_one_arg(Function::Acos, args, name),\n        \"ATAN\" =\u003e translate_function_one_arg(Function::Atan, args, name),\n        \"RADIANS\" =\u003e translate_function_one_arg(Function::Radians, args, name),\n        \"DEGREES\" =\u003e translate_function_one_arg(Function::Degrees, args, name),\n        \"PI\" =\u003e translate_function_zero_arg(Function::Pi(), args, name),\n        \"NOW\" =\u003e translate_function_zero_arg(Function::Now(), args, name),\n        \"CURRENT_DATE\" =\u003e translate_function_zero_arg(Function::CurrentDate(), args, name),\n        \"CURRENT_TIME\" =\u003e translate_function_zero_arg(Function::CurrentTime(), args, name),\n        \"CURRENT_TIMESTAMP\" =\u003e {\n            translate_function_zero_arg(Function::CurrentTimestamp(), args, name)\n        }\n        \"GCD\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let left = translate_expr(args[0])?;\n            let right = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Gcd { left, right })))\n        }\n        \"LAST_DAY\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            let expr = translate_expr(args[0])?;\n\n            Ok(Expr::Function(Box::new(Function::LastDay(expr))))\n        }\n        \"LCM\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let left = translate_expr(args[0])?;\n            let right = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Lcm { left, right })))\n        }\n        \"LTRIM\" =\u003e {\n            translate_function_trim(|expr, chars| Function::Ltrim { expr, chars }, args, name)\n        }\n        \"RTRIM\" =\u003e {\n            translate_function_trim(|expr, chars| Function::Rtrim { expr, chars }, args, name)\n        }\n        \"DIV\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let dividend = translate_expr(args[0])?;\n            let divisor = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Div {\n                dividend,\n                divisor,\n            })))\n        }\n        \"MOD\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let dividend = translate_expr(args[0])?;\n            let divisor = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Mod {\n                dividend,\n                divisor,\n            })))\n        }\n        \"REVERSE\" =\u003e translate_function_one_arg(Function::Reverse, args, name),\n        \"REPLACE\" =\u003e {\n            check_len(name, args.len(), 3)?;\n            let expr = translate_expr(args[0])?;\n            let old = translate_expr(args[1])?;\n            let new = translate_expr(args[2])?;\n\n            Ok(Expr::Function(Box::new(Function::Replace {\n                expr,\n                old,\n                new,\n            })))\n        }\n        \"REPEAT\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let expr = translate_expr(args[0])?;\n            let num = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Repeat { expr, num })))\n        }\n        \"SUBSTR\" =\u003e {\n            check_len_range(name, args.len(), 2, 3)?;\n\n            let expr = translate_expr(args[0])?;\n            let start = translate_expr(args[1])?;\n            let count = (args.len() \u003e 2)\n                .then(|| translate_expr(args[2]))\n                .transpose()?;\n\n            Ok(Expr::Function(Box::new(Function::Substr {\n                expr,\n                start,\n                count,\n            })))\n        }\n        \"UNWRAP\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let expr = translate_expr(args[0])?;\n            let selector = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Unwrap {\n                expr,\n                selector,\n            })))\n        }\n        \"ABS\" =\u003e translate_function_one_arg(Function::Abs, args, name),\n        \"SIGN\" =\u003e translate_function_one_arg(Function::Sign, args, name),\n        \"GENERATE_UUID\" =\u003e translate_function_zero_arg(Function::GenerateUuid(), args, name),\n        \"FORMAT\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let expr = translate_expr(args[0])?;\n            let format = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Format { expr, format })))\n        }\n        \"TO_DATE\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let expr = translate_expr(args[0])?;\n            let format = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::ToDate { expr, format })))\n        }\n\n        \"TO_TIMESTAMP\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let expr = translate_expr(args[0])?;\n            let format = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::ToTimestamp {\n                expr,\n                format,\n            })))\n        }\n        \"TO_TIME\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let expr = translate_expr(args[0])?;\n            let format = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::ToTime { expr, format })))\n        }\n        \"ADD_MONTH\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let expr = translate_expr(args[0])?;\n            let size = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::AddMonth { expr, size })))\n        }\n        \"ASCII\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            let expr = translate_expr(args[0])?;\n            Ok(Expr::Function(Box::new(Function::Ascii(expr))))\n        }\n        \"CHR\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            let expr = translate_expr(args[0])?;\n            Ok(Expr::Function(Box::new(Function::Chr(expr))))\n        }\n        \"MD5\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            let expr = translate_expr(args[0])?;\n            Ok(Expr::Function(Box::new(Function::Md5(expr))))\n        }\n        \"HEX\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            let expr = translate_expr(args[0])?;\n            Ok(Expr::Function(Box::new(Function::Hex(expr))))\n        }\n        \"LENGTH\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            let expr = translate_expr(args[0])?;\n            Ok(Expr::Function(Box::new(Function::Length(expr))))\n        }\n        \"APPEND\" =\u003e {\n            check_len(name, args.len(), 2)?;\n            let expr = translate_expr(args[0])?;\n            let value = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Append { expr, value })))\n        }\n        \"PREPEND\" =\u003e {\n            check_len(name, args.len(), 2)?;\n            let expr = translate_expr(args[0])?;\n            let value = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Prepend { expr, value })))\n        }\n        \"SKIP\" =\u003e {\n            check_len(name, args.len(), 2)?;\n            let expr = translate_expr(args[0])?;\n            let size = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Skip { expr, size })))\n        }\n        \"SORT\" =\u003e {\n            check_len_range(name, args.len(), 1, 2)?;\n            let expr = translate_expr(args[0])?;\n            let order = (args.len() \u003e 1)\n                .then(|| translate_expr(args[1]))\n                .transpose()?;\n\n            Ok(Expr::Function(Box::new(Function::Sort { expr, order })))\n        }\n        \"TAKE\" =\u003e {\n            check_len(name, args.len(), 2)?;\n            let expr = translate_expr(args[0])?;\n            let size = translate_expr(args[1])?;\n\n            Ok(Expr::Function(Box::new(Function::Take { expr, size })))\n        }\n        \"POINT\" =\u003e {\n            check_len(name, args.len(), 2)?;\n            let x = translate_expr(args[0])?;\n            let y = translate_expr(args[1])?;\n            Ok(Expr::Function(Box::new(Function::Point { x, y })))\n        }\n        \"GET_X\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            let expr = translate_expr(args[0])?;\n            Ok(Expr::Function(Box::new(Function::GetX(expr))))\n        }\n        \"GET_Y\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            let expr = translate_expr(args[0])?;\n            Ok(Expr::Function(Box::new(Function::GetY(expr))))\n        }\n        \"CALC_DISTANCE\" =\u003e {\n            check_len(name, args.len(), 2)?;\n\n            let geometry1 = translate_expr(args[0])?;\n            let geometry2 = translate_expr(args[1])?;\n            Ok(Expr::Function(Box::new(Function::CalcDistance {\n                geometry1,\n                geometry2,\n            })))\n        }\n        \"IS_EMPTY\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            let expr = translate_expr(args[0])?;\n            Ok(Expr::Function(Box::new(Function::IsEmpty(expr))))\n        }\n        \"SLICE\" =\u003e {\n            check_len(name, args.len(), 3)?;\n            let expr = translate_expr(args[0])?;\n            let start = translate_expr(args[1])?;\n            let length = translate_expr(args[2])?;\n\n            Ok(Expr::Function(Box::new(Function::Slice {\n                expr,\n                start,\n                length,\n            })))\n        }\n        \"GREATEST\" =\u003e {\n            check_len_min(name, args.len(), 2)?;\n            let exprs = args\n                .into_iter()\n                .map(translate_expr)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n            Ok(Expr::Function(Box::new(Function::Greatest(exprs))))\n        }\n        \"ENTRIES\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            let expr = translate_expr(args[0])?;\n            Ok(Expr::Function(Box::new(Function::Entries(expr))))\n        }\n        \"KEYS\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            let expr = translate_expr(args[0])?;\n            Ok(Expr::Function(Box::new(Function::Keys(expr))))\n        }\n        \"VALUES\" =\u003e {\n            check_len(name, args.len(), 1)?;\n\n            let expr = translate_expr(args[0])?;\n            Ok(Expr::Function(Box::new(Function::Values(expr))))\n        }\n        \"SPLICE\" =\u003e {\n            check_len_range(name, args.len(), 3, 4)?;\n            let list_data = translate_expr(args[0])?;\n            let begin_index = translate_expr(args[1])?;\n            let end_index = translate_expr(args[2])?;\n            let values = if args.len() == 4 {\n                Some(translate_expr(args[3])?)\n            } else {\n                None\n            };\n            Ok(Expr::Function(Box::new(Function::Splice {\n                list_data,\n                begin_index,\n                end_index,\n                values,\n            })))\n        }\n        \"DEDUP\" =\u003e {\n            check_len(name, args.len(), 1)?;\n            let list = translate_expr(args[0])?;\n            Ok(Expr::Function(Box::new(Function::Dedup(list))))\n        }\n        _ =\u003e {\n            let exprs = args\n                .into_iter()\n                .map(translate_expr)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n            Ok(Expr::Function(Box::new(Function::Custom { name, exprs })))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::*,\n        crate::{ast::DataType, parse_sql::parse_expr},\n    };\n\n    #[test]\n    fn cast() {\n        let expr = |sql| parse_expr(sql).and_then(|parsed| translate_expr(\u0026parsed));\n\n        let actual = expr(\"CAST(name AS TEXT)\");\n        let expected = Ok(Expr::Function(Box::new(Function::Cast {\n            expr: Expr::Identifier(\"name\".to_owned()),\n            data_type: DataType::Text,\n        })));\n        assert_eq!(actual, expected);\n\n        let actual = expr(\"name::TEXT\");\n        let expected = Ok(Expr::Function(Box::new(Function::Cast {\n            expr: Expr::Identifier(\"name\".to_owned()),\n            data_type: DataType::Text,\n        })));\n        assert_eq!(actual, expected);\n\n        let actual = expr(\"TRY_CAST(id AS BOOLEAN)\");\n        let expected = Err(TranslateError::TryCastNotSupported.into());\n        assert_eq!(actual, expected);\n\n        let actual = expr(\"SAFE_CAST(id AS UINT8)\");\n        let expected = Err(TranslateError::SafeCastNotSupported.into());\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":341},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","translate","operator.rs"],"content":"use {\n    super::TranslateError,\n    crate::{\n        ast::{BinaryOperator, UnaryOperator},\n        result::Result,\n    },\n    sqlparser::ast::{BinaryOperator as SqlBinaryOperator, UnaryOperator as SqlUnaryOperator},\n};\n\npub fn translate_unary_operator(sql_unary_operator: \u0026SqlUnaryOperator) -\u003e Result\u003cUnaryOperator\u003e {\n    match sql_unary_operator {\n        SqlUnaryOperator::Plus =\u003e Ok(UnaryOperator::Plus),\n        SqlUnaryOperator::Minus =\u003e Ok(UnaryOperator::Minus),\n        SqlUnaryOperator::Not =\u003e Ok(UnaryOperator::Not),\n        SqlUnaryOperator::PGPostfixFactorial =\u003e Ok(UnaryOperator::Factorial),\n        SqlUnaryOperator::PGBitwiseNot =\u003e Ok(UnaryOperator::BitwiseNot),\n        _ =\u003e Err(TranslateError::UnreachableUnaryOperator(sql_unary_operator.to_string()).into()),\n    }\n}\n\npub fn translate_binary_operator(\n    sql_binary_operator: \u0026SqlBinaryOperator,\n) -\u003e Result\u003cBinaryOperator\u003e {\n    match sql_binary_operator {\n        SqlBinaryOperator::Plus =\u003e Ok(BinaryOperator::Plus),\n        SqlBinaryOperator::Minus =\u003e Ok(BinaryOperator::Minus),\n        SqlBinaryOperator::Multiply =\u003e Ok(BinaryOperator::Multiply),\n        SqlBinaryOperator::Divide =\u003e Ok(BinaryOperator::Divide),\n        SqlBinaryOperator::Modulo =\u003e Ok(BinaryOperator::Modulo),\n        SqlBinaryOperator::StringConcat =\u003e Ok(BinaryOperator::StringConcat),\n        SqlBinaryOperator::Gt =\u003e Ok(BinaryOperator::Gt),\n        SqlBinaryOperator::Lt =\u003e Ok(BinaryOperator::Lt),\n        SqlBinaryOperator::GtEq =\u003e Ok(BinaryOperator::GtEq),\n        SqlBinaryOperator::LtEq =\u003e Ok(BinaryOperator::LtEq),\n        SqlBinaryOperator::Eq =\u003e Ok(BinaryOperator::Eq),\n        SqlBinaryOperator::NotEq =\u003e Ok(BinaryOperator::NotEq),\n        SqlBinaryOperator::And =\u003e Ok(BinaryOperator::And),\n        SqlBinaryOperator::Or =\u003e Ok(BinaryOperator::Or),\n        SqlBinaryOperator::Xor =\u003e Ok(BinaryOperator::Xor),\n        SqlBinaryOperator::BitwiseAnd =\u003e Ok(BinaryOperator::BitwiseAnd),\n        SqlBinaryOperator::PGBitwiseShiftLeft =\u003e Ok(BinaryOperator::BitwiseShiftLeft),\n        SqlBinaryOperator::PGBitwiseShiftRight =\u003e Ok(BinaryOperator::BitwiseShiftRight),\n        _ =\u003e Err(TranslateError::UnsupportedBinaryOperator(sql_binary_operator.to_string()).into()),\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","translate","query.rs"],"content":"use {\n    super::{\n        TranslateError, function::translate_function_arg_exprs, translate_expr, translate_idents,\n        translate_object_name, translate_order_by_expr,\n    },\n    crate::{\n        ast::{\n            AstLiteral, Dictionary, Expr, Join, JoinConstraint, JoinExecutor, JoinOperator, Query,\n            Select, SelectItem, SetExpr, TableAlias, TableFactor, TableWithJoins, Values,\n        },\n        result::Result,\n    },\n    sqlparser::ast::{\n        Expr as SqlExpr, FunctionArg as SqlFunctionArg, GroupByExpr as SqlGroupByExpr,\n        Join as SqlJoin, JoinConstraint as SqlJoinConstraint, JoinOperator as SqlJoinOperator,\n        Query as SqlQuery, Select as SqlSelect, SelectItem as SqlSelectItem, SetExpr as SqlSetExpr,\n        TableAlias as SqlTableAlias, TableFactor as SqlTableFactor,\n        TableFunctionArgs as SqlTableFunctionArgs, TableWithJoins as SqlTableWithJoins,\n    },\n};\n\npub fn translate_query(sql_query: \u0026SqlQuery) -\u003e Result\u003cQuery\u003e {\n    let SqlQuery {\n        body,\n        order_by,\n        limit,\n        offset,\n        ..\n    } = sql_query;\n\n    let body = translate_set_expr(body)?;\n    let order_by = order_by\n        .iter()\n        .flat_map(|order_by| order_by.exprs.iter().map(translate_order_by_expr))\n        .collect::\u003cResult\u003c_\u003e\u003e()?;\n    let limit = limit.as_ref().map(translate_expr).transpose()?;\n    let offset = offset\n        .as_ref()\n        .map(|offset| translate_expr(\u0026offset.value))\n        .transpose()?;\n\n    Ok(Query {\n        body,\n        order_by,\n        limit,\n        offset,\n    })\n}\n\nfn translate_set_expr(sql_set_expr: \u0026SqlSetExpr) -\u003e Result\u003cSetExpr\u003e {\n    match sql_set_expr {\n        SqlSetExpr::Select(select) =\u003e translate_select(select).map(Box::new).map(SetExpr::Select),\n        SqlSetExpr::Values(sqlparser::ast::Values { rows, .. }) =\u003e rows\n            .iter()\n            .map(|items| items.iter().map(translate_expr).collect::\u003cResult\u003c_\u003e\u003e())\n            .collect::\u003cResult\u003c_\u003e\u003e()\n            .map(Values)\n            .map(SetExpr::Values),\n        _ =\u003e Err(TranslateError::UnsupportedQuerySetExpr(sql_set_expr.to_string()).into()),\n    }\n}\n\nfn translate_select(sql_select: \u0026SqlSelect) -\u003e Result\u003cSelect\u003e {\n    let SqlSelect {\n        projection,\n        from,\n        selection,\n        group_by,\n        having,\n        distinct,\n        ..\n    } = sql_select;\n\n    if from.len() \u003e 1 {\n        return Err(TranslateError::TooManyTables.into());\n    }\n\n    if distinct.is_some() {\n        return Err(TranslateError::SelectDistinctNotSupported.into());\n    }\n\n    let from = match from.first() {\n        Some(sql_table_with_joins) =\u003e translate_table_with_joins(sql_table_with_joins)?,\n        None =\u003e TableWithJoins {\n            relation: TableFactor::Series {\n                alias: TableAlias {\n                    name: \"Series\".to_owned(),\n                    columns: Vec::new(),\n                },\n                size: Expr::Literal(AstLiteral::Number(1.into())),\n            },\n            joins: vec![],\n        },\n    };\n\n    let group_by = match group_by {\n        SqlGroupByExpr::Expressions(group_by, _group_by_with_modifiers) =\u003e group_by,\n        SqlGroupByExpr::All(_group_by_with_modifiers) =\u003e {\n            return Err(TranslateError::UnsupportedGroupByAll.into());\n        }\n    };\n\n    Ok(Select {\n        projection: projection\n            .iter()\n            .map(translate_select_item)\n            .collect::\u003cResult\u003c_\u003e\u003e()?,\n        from,\n        selection: selection.as_ref().map(translate_expr).transpose()?,\n        group_by: group_by.iter().map(translate_expr).collect::\u003cResult\u003c_\u003e\u003e()?,\n        having: having.as_ref().map(translate_expr).transpose()?,\n    })\n}\n\npub fn translate_select_item(sql_select_item: \u0026SqlSelectItem) -\u003e Result\u003cSelectItem\u003e {\n    match sql_select_item {\n        SqlSelectItem::UnnamedExpr(expr) =\u003e {\n            let label = match expr {\n                SqlExpr::CompoundIdentifier(idents) =\u003e idents\n                    .last()\n                    .map(|ident| ident.value.to_owned())\n                    .unwrap_or_else(|| expr.to_string()),\n                _ =\u003e expr.to_string(),\n            };\n\n            Ok(SelectItem::Expr {\n                expr: translate_expr(expr)?,\n                label,\n            })\n        }\n        SqlSelectItem::ExprWithAlias { expr, alias } =\u003e {\n            translate_expr(expr).map(|expr| SelectItem::Expr {\n                expr,\n                label: alias.value.to_owned(),\n            })\n        }\n        SqlSelectItem::QualifiedWildcard(object_name, _) =\u003e Ok(SelectItem::QualifiedWildcard(\n            translate_object_name(object_name)?,\n        )),\n        SqlSelectItem::Wildcard(_) =\u003e Ok(SelectItem::Wildcard),\n    }\n}\n\nfn translate_table_with_joins(sql_table_with_joins: \u0026SqlTableWithJoins) -\u003e Result\u003cTableWithJoins\u003e {\n    let SqlTableWithJoins { relation, joins } = sql_table_with_joins;\n\n    Ok(TableWithJoins {\n        relation: translate_table_factor(relation)?,\n        joins: joins.iter().map(translate_join).collect::\u003cResult\u003c_\u003e\u003e()?,\n    })\n}\n\nfn translate_table_alias(alias: \u0026Option\u003cSqlTableAlias\u003e) -\u003e Option\u003cTableAlias\u003e {\n    alias\n        .as_ref()\n        .map(|SqlTableAlias { name, columns }| TableAlias {\n            name: name.value.to_owned(),\n            columns: translate_idents(columns),\n        })\n}\n\nfn translate_table_factor(sql_table_factor: \u0026SqlTableFactor) -\u003e Result\u003cTableFactor\u003e {\n    let translate_table_args = |args: \u0026Vec\u003cSqlFunctionArg\u003e| -\u003e Result\u003cExpr\u003e {\n        let function_arg_exprs = args\n            .iter()\n            .map(|arg| match arg {\n                SqlFunctionArg::Named { .. } =\u003e {\n                    Err(TranslateError::NamedFunctionArgNotSupported.into())\n                }\n                SqlFunctionArg::Unnamed(arg_expr) =\u003e Ok(arg_expr),\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        match translate_function_arg_exprs(function_arg_exprs)?.first() {\n            Some(expr) =\u003e Ok(translate_expr(expr)?),\n            None =\u003e Err(TranslateError::LackOfArgs.into()),\n        }\n    };\n\n    match sql_table_factor {\n        SqlTableFactor::Table {\n            name, alias, args, ..\n        } =\u003e {\n            let object_name = translate_object_name(name)?.to_uppercase();\n            let alias = translate_table_alias(alias);\n\n            match (object_name.as_str(), args) {\n                (\"SERIES\", Some(SqlTableFunctionArgs { args, .. })) =\u003e Ok(TableFactor::Series {\n                    alias: alias_or_name(alias, object_name),\n                    size: translate_table_args(args)?,\n                }),\n                (\"GLUE_OBJECTS\", _) =\u003e Ok(TableFactor::Dictionary {\n                    dict: Dictionary::GlueObjects,\n                    alias: alias_or_name(alias, object_name),\n                }),\n                (\"GLUE_TABLES\", _) =\u003e Ok(TableFactor::Dictionary {\n                    dict: Dictionary::GlueTables,\n                    alias: alias_or_name(alias, object_name),\n                }),\n                (\"GLUE_INDEXES\", _) =\u003e Ok(TableFactor::Dictionary {\n                    dict: Dictionary::GlueIndexes,\n                    alias: alias_or_name(alias, object_name),\n                }),\n                (\"GLUE_TABLE_COLUMNS\", _) =\u003e Ok(TableFactor::Dictionary {\n                    dict: Dictionary::GlueTableColumns,\n                    alias: alias_or_name(alias, object_name),\n                }),\n                _ =\u003e {\n                    Ok(TableFactor::Table {\n                        name: translate_object_name(name)?,\n                        alias,\n                        index: None, // query execution plan\n                    })\n                }\n            }\n        }\n        SqlTableFactor::Derived {\n            subquery, alias, ..\n        } =\u003e {\n            if let Some(alias) = alias {\n                Ok(TableFactor::Derived {\n                    subquery: translate_query(subquery)?,\n                    alias: TableAlias {\n                        name: alias.name.value.to_owned(),\n                        columns: translate_idents(\u0026alias.columns),\n                    },\n                })\n            } else {\n                Err(TranslateError::LackOfAlias.into())\n            }\n        }\n        _ =\u003e Err(TranslateError::UnsupportedQueryTableFactor(sql_table_factor.to_string()).into()),\n    }\n}\n\npub fn alias_or_name(alias: Option\u003cTableAlias\u003e, name: String) -\u003e TableAlias {\n    alias.unwrap_or_else(|| TableAlias {\n        name,\n        columns: Vec::new(),\n    })\n}\n\nfn translate_join(sql_join: \u0026SqlJoin) -\u003e Result\u003cJoin\u003e {\n    let SqlJoin {\n        relation,\n        join_operator: sql_join_operator,\n        ..\n    } = sql_join;\n\n    let translate_constraint = |sql_join_constraint: \u0026SqlJoinConstraint| match sql_join_constraint {\n        SqlJoinConstraint::On(expr) =\u003e translate_expr(expr).map(JoinConstraint::On),\n        SqlJoinConstraint::None =\u003e Ok(JoinConstraint::None),\n        SqlJoinConstraint::Using(_) =\u003e {\n            Err(TranslateError::UnsupportedJoinConstraint(\"USING\".to_owned()).into())\n        }\n        SqlJoinConstraint::Natural =\u003e {\n            Err(TranslateError::UnsupportedJoinConstraint(\"NATURAL\".to_owned()).into())\n        }\n    };\n\n    let join_operator = match sql_join_operator {\n        SqlJoinOperator::Inner(sql_join_constraint) =\u003e {\n            translate_constraint(sql_join_constraint).map(JoinOperator::Inner)\n        }\n        SqlJoinOperator::LeftOuter(sql_join_constraint) =\u003e {\n            translate_constraint(sql_join_constraint).map(JoinOperator::LeftOuter)\n        }\n        _ =\u003e {\n            Err(TranslateError::UnsupportedJoinOperator(format!(\"{:?}\", sql_join_operator)).into())\n        }\n    }?;\n\n    Ok(Join {\n        relation: translate_table_factor(relation)?,\n        join_operator,\n        join_executor: JoinExecutor::NestedLoop,\n    })\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":140},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","core","src","translate.rs"],"content":"mod ast_literal;\nmod data_type;\nmod ddl;\nmod error;\nmod expr;\nmod function;\nmod operator;\nmod query;\n\npub use self::{\n    data_type::translate_data_type,\n    ddl::{translate_column_def, translate_operate_function_arg},\n    error::TranslateError,\n    expr::{translate_expr, translate_order_by_expr},\n    query::{alias_or_name, translate_query, translate_select_item},\n};\n\nuse {\n    crate::{\n        ast::{Assignment, ForeignKey, ReferentialAction, Statement, Variable},\n        result::Result,\n    },\n    ddl::translate_alter_table_operation,\n    sqlparser::ast::{\n        Assignment as SqlAssignment, AssignmentTarget as SqlAssignmentTarget,\n        CommentDef as SqlCommentDef, CreateFunctionBody as SqlCreateFunctionBody,\n        CreateIndex as SqlCreateIndex, CreateTable as SqlCreateTable, Delete as SqlDelete,\n        FromTable as SqlFromTable, Ident as SqlIdent, Insert as SqlInsert,\n        ObjectName as SqlObjectName, ObjectType as SqlObjectType,\n        ReferentialAction as SqlReferentialAction, Statement as SqlStatement,\n        TableConstraint as SqlTableConstraint, TableFactor, TableWithJoins,\n    },\n};\n\npub fn translate(sql_statement: \u0026SqlStatement) -\u003e Result\u003cStatement\u003e {\n    match sql_statement {\n        SqlStatement::Query(query) =\u003e translate_query(query).map(Statement::Query),\n        SqlStatement::Insert(SqlInsert {\n            table_name,\n            columns,\n            source,\n            ..\n        }) =\u003e {\n            let table_name = translate_object_name(table_name)?;\n            let columns = translate_idents(columns);\n            let source = source\n                .as_deref()\n                .ok_or_else(|| {\n                    TranslateError::DefaultValuesOnInsertNotSupported(table_name.clone()).into()\n                })\n                .and_then(translate_query)?;\n\n            Ok(Statement::Insert {\n                table_name,\n                columns,\n                source,\n            })\n        }\n        SqlStatement::Update {\n            table,\n            assignments,\n            selection,\n            ..\n        } =\u003e Ok(Statement::Update {\n            table_name: translate_table_with_join(table)?,\n            assignments: assignments\n                .iter()\n                .map(translate_assignment)\n                .collect::\u003cResult\u003c_\u003e\u003e()?,\n            selection: selection.as_ref().map(translate_expr).transpose()?,\n        }),\n        SqlStatement::Delete(SqlDelete {\n            from, selection, ..\n        }) =\u003e {\n            let from = match from {\n                SqlFromTable::WithFromKeyword(from) =\u003e from,\n                SqlFromTable::WithoutKeyword(_) =\u003e {\n                    return Err(TranslateError::UnreachableOmittingFromInDelete.into());\n                }\n            };\n            let table_name = from\n                .iter()\n                .map(translate_table_with_join)\n                .next()\n                .ok_or(TranslateError::UnreachableEmptyTable)??;\n\n            Ok(Statement::Delete {\n                table_name,\n                selection: selection.as_ref().map(translate_expr).transpose()?,\n            })\n        }\n        SqlStatement::CreateTable(SqlCreateTable {\n            if_not_exists,\n            name,\n            columns,\n            query,\n            engine,\n            constraints,\n            comment,\n            ..\n        }) =\u003e {\n            let columns = columns\n                .iter()\n                .map(translate_column_def)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n            let columns = (!columns.is_empty()).then_some(columns);\n\n            let name = translate_object_name(name)?;\n\n            let foreign_keys = constraints\n                .iter()\n                .map(translate_foreign_key)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n            Ok(Statement::CreateTable {\n                if_not_exists: *if_not_exists,\n                name,\n                columns,\n                source: match query {\n                    Some(v) =\u003e Some(translate_query(v).map(Box::new)?),\n                    None =\u003e None,\n                },\n                engine: engine\n                    .as_ref()\n                    .map(|table_engine| table_engine.name.to_owned()),\n                foreign_keys,\n                comment: comment.as_ref().map(|comment| match comment {\n                    SqlCommentDef::WithEq(comment)\n                    | SqlCommentDef::WithoutEq(comment)\n                    | SqlCommentDef::AfterColumnDefsWithoutEq(comment) =\u003e comment.to_owned(),\n                }),\n            })\n        }\n        SqlStatement::AlterTable {\n            name, operations, ..\n        } =\u003e {\n            if operations.len() \u003e 1 {\n                return Err(TranslateError::UnsupportedMultipleAlterTableOperations.into());\n            }\n\n            let operation = operations\n                .iter()\n                .next()\n                .ok_or(TranslateError::UnreachableEmptyAlterTableOperation)?;\n\n            Ok(Statement::AlterTable {\n                name: translate_object_name(name)?,\n                operation: translate_alter_table_operation(operation)?,\n            })\n        }\n        SqlStatement::Drop {\n            object_type: SqlObjectType::Table,\n            if_exists,\n            names,\n            cascade,\n            ..\n        } =\u003e Ok(Statement::DropTable {\n            if_exists: *if_exists,\n            names: names\n                .iter()\n                .map(translate_object_name)\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n            cascade: *cascade,\n        }),\n        SqlStatement::DropFunction {\n            if_exists,\n            func_desc,\n            ..\n        } =\u003e Ok(Statement::DropFunction {\n            if_exists: *if_exists,\n            names: func_desc\n                .iter()\n                .map(|v| translate_object_name(\u0026v.name))\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n        }),\n        SqlStatement::CreateIndex(SqlCreateIndex {\n            name,\n            table_name,\n            columns,\n            ..\n        }) =\u003e {\n            if columns.len() \u003e 1 {\n                return Err(TranslateError::CompositeIndexNotSupported.into());\n            }\n\n            let Some(name) = name else {\n                return Err(TranslateError::UnsupportedUnnamedIndex.into());\n            };\n\n            let name = translate_object_name(name)?;\n\n            if name.to_uppercase() == \"PRIMARY\" {\n                return Err(TranslateError::ReservedIndexName(name).into());\n            };\n\n            Ok(Statement::CreateIndex {\n                name,\n                table_name: translate_object_name(table_name)?,\n                column: translate_order_by_expr(\u0026columns[0])?,\n            })\n        }\n        SqlStatement::Drop {\n            object_type: SqlObjectType::Index,\n            names,\n            ..\n        } =\u003e {\n            if names.len() \u003e 1 {\n                return Err(TranslateError::TooManyParamsInDropIndex.into());\n            }\n\n            let object_name = \u0026names[0].0;\n            if object_name.len() != 2 {\n                return Err(TranslateError::InvalidParamsInDropIndex.into());\n            }\n\n            let table_name = object_name[0].value.to_owned();\n            let name = object_name[1].value.to_owned();\n\n            if name.to_uppercase() == \"PRIMARY\" {\n                return Err(TranslateError::CannotDropPrimary.into());\n            };\n\n            Ok(Statement::DropIndex { name, table_name })\n        }\n        SqlStatement::StartTransaction { .. } =\u003e Ok(Statement::StartTransaction),\n        SqlStatement::Commit { .. } =\u003e Ok(Statement::Commit),\n        SqlStatement::Rollback { .. } =\u003e Ok(Statement::Rollback),\n        SqlStatement::ShowTables {\n            filter: None,\n            db_name: None,\n            ..\n        } =\u003e Ok(Statement::ShowVariable(Variable::Tables)),\n        SqlStatement::ShowFunctions { filter: None } =\u003e {\n            Ok(Statement::ShowVariable(Variable::Functions))\n        }\n        SqlStatement::ShowVariable { variable } =\u003e match (variable.len(), variable.first()) {\n            (1, Some(keyword)) =\u003e match keyword.value.to_uppercase().as_str() {\n                \"VERSION\" =\u003e Ok(Statement::ShowVariable(Variable::Version)),\n                v =\u003e Err(TranslateError::UnsupportedShowVariableKeyword(v.to_owned()).into()),\n            },\n            (3, Some(keyword)) =\u003e match keyword.value.to_uppercase().as_str() {\n                \"INDEXES\" =\u003e match variable.get(2) {\n                    Some(tablename) =\u003e Ok(Statement::ShowIndexes(tablename.value.to_owned())),\n                    _ =\u003e Err(TranslateError::UnsupportedShowVariableStatement(\n                        sql_statement.to_string(),\n                    )\n                    .into()),\n                },\n                _ =\u003e Err(TranslateError::UnsupportedShowVariableStatement(\n                    sql_statement.to_string(),\n                )\n                .into()),\n            },\n            _ =\u003e Err(\n                TranslateError::UnsupportedShowVariableStatement(sql_statement.to_string()).into(),\n            ),\n        },\n        SqlStatement::ShowColumns { table_name, .. } =\u003e Ok(Statement::ShowColumns {\n            table_name: translate_object_name(table_name)?,\n        }),\n        SqlStatement::CreateFunction {\n            or_replace,\n            name,\n            args,\n            function_body: Some(SqlCreateFunctionBody::Return(return_)),\n            ..\n        } =\u003e {\n            let args = args\n                .as_ref()\n                .map(|args| {\n                    args.iter()\n                        .map(translate_operate_function_arg)\n                        .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n                })\n                .transpose()?;\n            Ok(Statement::CreateFunction {\n                or_replace: *or_replace,\n                name: translate_object_name(name)?,\n                args: args.unwrap_or_default(),\n                return_: translate_expr(return_)?,\n            })\n        }\n        SqlStatement::CreateFunction { .. } =\u003e {\n            Err(TranslateError::UnsupportedEmptyFunctionBody.into())\n        }\n        _ =\u003e Err(TranslateError::UnsupportedStatement(sql_statement.to_string()).into()),\n    }\n}\n\npub fn translate_assignment(sql_assignment: \u0026SqlAssignment) -\u003e Result\u003cAssignment\u003e {\n    let SqlAssignment { target, value } = sql_assignment;\n\n    let id = match target {\n        SqlAssignmentTarget::Tuple(_) =\u003e {\n            return Err(TranslateError::TupleAssignmentOnUpdateNotSupported(\n                sql_assignment.to_string(),\n            )\n            .into());\n        }\n        SqlAssignmentTarget::ColumnName(SqlObjectName(id)) =\u003e id,\n    };\n\n    if id.len() \u003e 1 {\n        return Err(\n            TranslateError::CompoundIdentOnUpdateNotSupported(sql_assignment.to_string()).into(),\n        );\n    }\n\n    Ok(Assignment {\n        id: id\n            .first()\n            .ok_or(TranslateError::UnreachableEmptyIdent)?\n            .value\n            .to_owned(),\n        value: translate_expr(value)?,\n    })\n}\n\nfn translate_table_with_join(table: \u0026TableWithJoins) -\u003e Result\u003cString\u003e {\n    if !table.joins.is_empty() {\n        return Err(TranslateError::JoinOnUpdateNotSupported.into());\n    }\n    match \u0026table.relation {\n        TableFactor::Table { name, .. } =\u003e translate_object_name(name),\n        t =\u003e Err(TranslateError::UnsupportedTableFactor(t.to_string()).into()),\n    }\n}\n\nfn translate_object_name(sql_object_name: \u0026SqlObjectName) -\u003e Result\u003cString\u003e {\n    let sql_object_name = \u0026sql_object_name.0;\n    if sql_object_name.len() \u003e 1 {\n        let compound_object_name = translate_idents(sql_object_name).join(\".\");\n        return Err(TranslateError::CompoundObjectNotSupported(compound_object_name).into());\n    }\n\n    sql_object_name\n        .first()\n        .map(|v| v.value.to_owned())\n        .ok_or_else(|| TranslateError::UnreachableEmptyObject.into())\n}\n\npub fn translate_idents(idents: \u0026[SqlIdent]) -\u003e Vec\u003cString\u003e {\n    idents.iter().map(|v| v.value.to_owned()).collect()\n}\n\npub fn translate_referential_action(\n    action: \u0026Option\u003cSqlReferentialAction\u003e,\n) -\u003e Result\u003cReferentialAction\u003e {\n    use SqlReferentialAction::*;\n\n    let action = action.unwrap_or(NoAction);\n\n    match action {\n        NoAction | Restrict =\u003e Ok(ReferentialAction::NoAction),\n        _ =\u003e Err(TranslateError::UnsupportedConstraint(action.to_string()).into()),\n    }\n}\n\npub fn translate_foreign_key(table_constraint: \u0026SqlTableConstraint) -\u003e Result\u003cForeignKey\u003e {\n    match table_constraint {\n        SqlTableConstraint::ForeignKey {\n            name,\n            columns,\n            foreign_table,\n            referred_columns,\n            on_delete,\n            on_update,\n            ..\n        } =\u003e {\n            let referencing_column_name = columns.first().map(|i| i.value.clone()).ok_or(\n                TranslateError::UnreachableForeignKeyColumns(\n                    columns.iter().map(|i| i.to_string()).collect::\u003cString\u003e(),\n                ),\n            )?;\n\n            let referenced_column_name = referred_columns\n                .first()\n                .ok_or(TranslateError::UnreachableForeignKeyColumns(\n                    columns.iter().map(|i| i.to_string()).collect::\u003cString\u003e(),\n                ))?\n                .value\n                .clone();\n\n            let referenced_table_name = translate_object_name(foreign_table)?;\n\n            let name = match name {\n                Some(name) =\u003e name.value.clone(),\n                None =\u003e {\n                    format!(\n                        \"FK_{referencing_column_name}-{referenced_table_name}_{referenced_column_name}\"\n                    )\n                }\n            };\n\n            Ok(ForeignKey {\n                name,\n                referencing_column_name,\n                referenced_table_name,\n                referenced_column_name,\n                on_delete: translate_referential_action(on_delete)?,\n                on_update: translate_referential_action(on_update)?,\n            })\n        }\n        _ =\u003e Err(TranslateError::UnsupportedConstraint(table_constraint.to_string()).into()),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {super::*, crate::parse_sql::parse};\n\n    #[test]\n    fn statement() {\n        let sql = \"INSERT INTO Foo DEFAULT VALUES\";\n        let actual = parse(sql).and_then(|parsed| translate(\u0026parsed[0]));\n        let expected =\n            Err(TranslateError::DefaultValuesOnInsertNotSupported(\"Foo\".to_owned()).into());\n\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    fn test_tuple_assignment_on_update_not_supported() {\n        let sql = \"UPDATE Foo SET (a, b) = (1, 2)\";\n        let actual = parse(sql).and_then(|parsed| translate(\u0026parsed[0]));\n        let expected = Err(TranslateError::TupleAssignmentOnUpdateNotSupported(\n            \"(a, b) = (1, 2)\".to_owned(),\n        )\n        .into());\n\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":192},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","javascript","src","lib.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n\nmod payload;\nmod utils;\n\nuse {\n    gluesql_core::prelude::{execute, parse, plan, translate},\n    gluesql_memory_storage::MemoryStorage,\n    js_sys::Promise,\n    payload::convert,\n    std::{cell::RefCell, rc::Rc},\n    wasm_bindgen::prelude::*,\n    wasm_bindgen_futures::future_to_promise,\n};\n\n#[cfg(not(feature = \"nodejs\"))]\nuse {\n    gluesql_composite_storage::CompositeStorage,\n    gluesql_idb_storage::IdbStorage,\n    gluesql_web_storage::{WebStorage, WebStorageType},\n};\n\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_namespace = console)]\n    fn debug(s: \u0026str);\n}\n\n#[wasm_bindgen]\npub struct Glue {\n    #[cfg(not(feature = \"nodejs\"))]\n    storage: Rc\u003cRefCell\u003cOption\u003cCompositeStorage\u003e\u003e\u003e,\n\n    #[cfg(feature = \"nodejs\")]\n    storage: Rc\u003cRefCell\u003cOption\u003cMemoryStorage\u003e\u003e\u003e,\n}\n\nimpl Default for Glue {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[allow(clippy::unused_unit)]\n#[wasm_bindgen]\nimpl Glue {\n    #[wasm_bindgen(constructor)]\n    pub fn new() -\u003e Self {\n        utils::set_panic_hook();\n\n        #[cfg(not(feature = \"nodejs\"))]\n        let storage = {\n            let mut storage = CompositeStorage::default();\n            storage.push(\"memory\", MemoryStorage::default());\n            storage.push(\"localStorage\", WebStorage::new(WebStorageType::Local));\n            storage.push(\"sessionStorage\", WebStorage::new(WebStorageType::Session));\n            storage.set_default(\"memory\");\n            debug(\"[GlueSQL] loaded: memory, localStorage, sessionStorage\");\n            debug(\"[GlueSQL] default engine: memory\");\n\n            storage\n        };\n        #[cfg(feature = \"nodejs\")]\n        let storage = MemoryStorage::default();\n\n        let storage = Rc::new(RefCell::new(Some(storage)));\n\n        debug(\"[GlueSQL] hello :)\");\n\n        Self { storage }\n    }\n\n    #[cfg(not(feature = \"nodejs\"))]\n    #[wasm_bindgen(js_name = loadIndexedDB)]\n    pub fn load_indexeddb(\u0026mut self, namespace: Option\u003cString\u003e) -\u003e Promise {\n        let cell = Rc::clone(\u0026self.storage);\n\n        future_to_promise(async move {\n            let mut storage = cell.replace(None).unwrap();\n\n            if storage.storages.contains_key(\"indexedDB\") {\n                cell.replace(Some(storage));\n\n                return Err(JsValue::from_str(\"indexedDB storage is already loaded\"));\n            }\n\n            let idb_storage = match IdbStorage::new(namespace).await {\n                Ok(storage) =\u003e storage,\n                Err(error) =\u003e {\n                    cell.replace(Some(storage));\n\n                    return Err(JsValue::from_str(\u0026format!(\"{error}\")));\n                }\n            };\n\n            storage.push(\"indexedDB\", idb_storage);\n            debug(\"[GlueSQL] loaded: indexedDB\");\n\n            cell.replace(Some(storage));\n\n            Ok(JsValue::NULL)\n        })\n    }\n\n    #[cfg(not(feature = \"nodejs\"))]\n    #[wasm_bindgen(js_name = setDefaultEngine)]\n    pub fn set_default_engine(\u0026mut self, default_engine: String) -\u003e Result\u003c(), JsValue\u003e {\n        let cell = Rc::clone(\u0026self.storage);\n        let mut storage = cell.replace(None).unwrap();\n\n        let result = {\n            if ![\"memory\", \"localStorage\", \"sessionStorage\", \"indexedDB\"]\n                .iter()\n                .any(|engine| engine == \u0026default_engine.as_str())\n            {\n                Err(JsValue::from_str(\n                    format!(\"{default_engine} is not supported (options: memory, localStorage, sessionStorage, indexedDB)\").as_str()\n                ))\n            } else if default_engine == \"indexedDB\" \u0026\u0026 !storage.storages.contains_key(\"indexedDB\") {\n                Err(JsValue::from_str(\n                    \"indexedDB is not loaded - run loadIndexedDB() first\",\n                ))\n            } else {\n                storage.set_default(default_engine);\n\n                Ok(())\n            }\n        };\n\n        cell.replace(Some(storage));\n        result\n    }\n\n    pub fn query(\u0026mut self, sql: String) -\u003e Promise {\n        let cell = Rc::clone(\u0026self.storage);\n\n        future_to_promise(async move {\n            let queries = parse(\u0026sql).map_err(|error| JsValue::from_str(\u0026format!(\"{error}\")))?;\n\n            let mut payloads = vec![];\n            let mut storage = cell.replace(None).unwrap();\n\n            for query in queries.iter() {\n                let statement = translate(query);\n                let statement = match statement {\n                    Ok(statement) =\u003e statement,\n                    Err(error) =\u003e {\n                        cell.replace(Some(storage));\n\n                        return Err(JsValue::from_str(\u0026format!(\"{error}\")));\n                    }\n                };\n                let statement = plan(\u0026storage, statement).await;\n                let statement = match statement {\n                    Ok(statement) =\u003e statement,\n                    Err(error) =\u003e {\n                        cell.replace(Some(storage));\n\n                        return Err(JsValue::from_str(\u0026format!(\"{error}\")));\n                    }\n                };\n\n                let result = execute(\u0026mut storage, \u0026statement)\n                    .await\n                    .map_err(|error| JsValue::from_str(\u0026format!(\"{error}\")));\n\n                match result {\n                    Ok(payload) =\u003e {\n                        payloads.push(payload);\n                    }\n                    Err(error) =\u003e {\n                        cell.replace(Some(storage));\n\n                        return Err(error);\n                    }\n                };\n            }\n\n            cell.replace(Some(storage));\n\n            Ok(convert(payloads))\n        })\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","javascript","src","payload.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n\nuse {\n    gloo_utils::format::JsValueSerdeExt,\n    gluesql_core::prelude::{Payload, PayloadVariable},\n    serde_json::{Value as Json, json},\n    wasm_bindgen::prelude::JsValue,\n};\n\npub fn convert(payloads: Vec\u003cPayload\u003e) -\u003e JsValue {\n    let payloads = payloads.into_iter().map(convert_payload).collect();\n    let payloads = Json::Array(payloads);\n\n    JsValue::from_serde(\u0026payloads).unwrap()\n}\n\nfn convert_payload(payload: Payload) -\u003e Json {\n    match payload {\n        Payload::Create =\u003e json!({ \"type\": \"CREATE TABLE\" }),\n        Payload::DropTable(num) =\u003e json!({ \"type\": \"DROP TABLE\", \"affected\": num }),\n        Payload::Select { labels, rows } =\u003e {\n            let rows = rows\n                .into_iter()\n                .map(|values| {\n                    let row = labels\n                        .iter()\n                        .zip(values.into_iter())\n                        .map(|(label, value)| {\n                            let key = label.to_owned();\n                            let value = Json::try_from(value).unwrap();\n\n                            (key, value)\n                        })\n                        .collect();\n\n                    Json::Object(row)\n                })\n                .collect();\n\n            json!({\n                \"type\": \"SELECT\",\n                \"rows\": Json::Array(rows),\n            })\n        }\n        Payload::SelectMap(rows) =\u003e {\n            let rows = rows\n                .into_iter()\n                .map(|row| {\n                    let row = row\n                        .into_iter()\n                        .map(|(key, value)| {\n                            let value = Json::try_from(value).unwrap();\n\n                            (key, value)\n                        })\n                        .collect();\n\n                    Json::Object(row)\n                })\n                .collect();\n\n            json!({\n                \"type\": \"SELECT\",\n                \"rows\": Json::Array(rows),\n            })\n        }\n        Payload::ShowColumns(columns) =\u003e {\n            let columns = columns\n                .into_iter()\n                .map(|(name, data_type)| {\n                    json!({\n                        \"name\": name,\n                        \"type\": data_type.to_string(),\n                    })\n                })\n                .collect();\n\n            json!({\n                \"type\": \"SHOW COLUMNS\",\n                \"columns\": Json::Array(columns),\n            })\n        }\n        Payload::Insert(num) =\u003e json!({\n            \"type\": \"INSERT\",\n            \"affected\": num\n        }),\n        Payload::Update(num) =\u003e json!({\n            \"type\": \"UPDATE\",\n            \"affected\": num\n        }),\n        Payload::Delete(num) =\u003e json!({\n            \"type\": \"DELETE\",\n            \"affected\": num\n        }),\n        Payload::AlterTable =\u003e json!({ \"type\": \"ALTER TABLE\" }),\n        Payload::CreateIndex =\u003e json!({ \"type\": \"CREATE INDEX\" }),\n        Payload::DropIndex =\u003e json!({ \"type\": \"DROP INDEX\" }),\n        Payload::StartTransaction =\u003e json!({ \"type\": \"BEGIN\" }),\n        Payload::Commit =\u003e json!({ \"type\": \"COMMIT\" }),\n        Payload::Rollback =\u003e json!({ \"type\": \"ROLLBACK\" }),\n        Payload::ShowVariable(PayloadVariable::Version(version)) =\u003e {\n            json!({\n                \"type\": \"SHOW VERSION\",\n                \"version\": version\n            })\n        }\n        Payload::ShowVariable(PayloadVariable::Tables(table_names)) =\u003e {\n            json!({\n                \"type\": \"SHOW TABLES\",\n                \"tables\": table_names\n            })\n        }\n        Payload::DropFunction =\u003e json!({ \"type\": \"DROP FUNCTION\" }),\n        Payload::ShowVariable(PayloadVariable::Functions(function_names)) =\u003e {\n            json!({\n                \"type\": \"SHOW FUNCTIONS\",\n                \"functions\": function_names\n            })\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","javascript","src","utils.rs"],"content":"pub fn set_panic_hook() {\n    // When the `console_error_panic_hook` feature is enabled, we can call the\n    // `set_panic_hook` function at least once during initialization, and then\n    // we will get better error messages if our code ever panics.\n    //\n    // For more details see\n    // https://github.com/rustwasm/console_error_panic_hook#readme\n    #[cfg(feature = \"console_error_panic_hook\")]\n    console_error_panic_hook::set_once();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","javascript","tests","composite_storage.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n\nuse {\n    async_trait::async_trait, gluesql_composite_storage::CompositeStorage,\n    gluesql_core::prelude::Glue, gluesql_memory_storage::MemoryStorage, test_suite::*,\n    wasm_bindgen_test::*,\n};\n\nwasm_bindgen_test_configure!(run_in_browser);\n\nstruct CompositeTester {\n    glue: Glue\u003cCompositeStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cCompositeStorage\u003e for CompositeTester {\n    async fn new(_: \u0026str) -\u003e Self {\n        let mut storage = CompositeStorage::default();\n        storage.push(\"memory\", MemoryStorage::default());\n        storage.set_default(\"memory\");\n\n        let glue = Glue::new(storage);\n\n        Self { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cCompositeStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(wasm_bindgen_test, CompositeTester);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","javascript","tests","error.rs"],"content":"#![cfg(all(target_arch = \"wasm32\", not(feature = \"nodejs\")))]\n\nwasm_bindgen_test_configure!(run_in_browser);\n\nuse {\n    gloo_utils::format::JsValueSerdeExt,\n    gluesql_js::Glue,\n    serde_json::{Value as Json, json},\n    wasm_bindgen::prelude::JsValue,\n    wasm_bindgen_futures::JsFuture,\n    wasm_bindgen_test::*,\n};\n\n#[wasm_bindgen_test]\nasync fn error() {\n    let mut glue = Glue::new();\n\n    assert_eq!(\n        glue.set_default_engine(\"something-else\".to_owned()),\n        Err(JsValue::from_str(\n            \"something-else is not supported (options: memory, localStorage, sessionStorage, indexedDB)\",\n        ))\n    );\n\n    assert_eq!(\n        glue.set_default_engine(\"indexedDB\".to_owned()),\n        Err(JsValue::from_str(\n            \"indexedDB is not loaded - run loadIndexedDB() first\",\n        ))\n    );\n\n    let loaded = glue.load_indexeddb(None);\n    JsFuture::from(loaded).await.unwrap();\n    assert_eq!(glue.set_default_engine(\"indexedDB\".to_owned()), Ok(()));\n\n    let loaded = glue.load_indexeddb(None);\n    assert_eq!(\n        JsFuture::from(loaded).await,\n        Err(JsValue::from_str(\"indexedDB storage is already loaded\"))\n    );\n\n    let sql = \"\n        CREATE TABLE Mem (mid INTEGER) ENGINE = memory;\n        CREATE TABLE Loc (lid INTEGER) ENGINE = localStorage;\n        CREATE TABLE Ses (sid INTEGER) ENGINE = sessionStorage;\n        CREATE TABLE Idb (iid INTEGER) ENGINE = indexedDB;\n    \";\n    let actual: Json = JsFuture::from(glue.query(sql.to_owned()))\n        .await\n        .unwrap()\n        .into_serde()\n        .unwrap();\n    let expected = json!([\n          { \"type\": \"CREATE TABLE\" },\n          { \"type\": \"CREATE TABLE\" },\n          { \"type\": \"CREATE TABLE\" },\n          { \"type\": \"CREATE TABLE\" }\n    ]);\n    assert_eq!(actual, expected);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","javascript","tests","join_multiple_storages.rs"],"content":"#![cfg(all(target_arch = \"wasm32\", not(feature = \"nodejs\")))]\n\nwasm_bindgen_test_configure!(run_in_browser);\n\nuse {\n    gloo_utils::format::JsValueSerdeExt,\n    gluesql_js::Glue,\n    serde_json::{Value as Json, json},\n    wasm_bindgen_futures::JsFuture,\n    wasm_bindgen_test::*,\n};\n\n#[wasm_bindgen_test]\nasync fn join_multiple_storages() {\n    let mut glue = Glue::new();\n    let loaded = glue.load_indexeddb(None);\n    JsFuture::from(loaded).await.unwrap();\n\n    let mut test = |sql: \u0026'static str, expected| {\n        let result = glue.query(sql.to_owned());\n\n        async move {\n            let actual: Json = JsFuture::from(result).await.unwrap().into_serde().unwrap();\n\n            assert_eq!(actual, expected, \"{sql}\");\n        }\n    };\n\n    test(\n        \"\n        CREATE TABLE Mem (mid INTEGER) ENGINE = memory;\n        CREATE TABLE Loc (lid INTEGER) ENGINE = localStorage;\n        CREATE TABLE Ses (sid INTEGER) ENGINE = sessionStorage;\n        CREATE TABLE Idb (iid INTEGER) ENGINE = indexedDB;\n        \",\n        json!([\n              { \"type\": \"CREATE TABLE\" },\n              { \"type\": \"CREATE TABLE\" },\n              { \"type\": \"CREATE TABLE\" },\n              { \"type\": \"CREATE TABLE\" }\n        ]),\n    )\n    .await;\n\n    test(\n        \"\n        INSERT INTO Mem VALUES (10), (11);\n        INSERT INTO Loc VALUES (20), (21);\n        INSERT INTO Ses VALUES (30), (31);\n        INSERT INTO Idb VALUES (40), (41);\n        \",\n        json!([\n              { \"type\": \"INSERT\", \"affected\": 2 },\n              { \"type\": \"INSERT\", \"affected\": 2 },\n              { \"type\": \"INSERT\", \"affected\": 2 },\n              { \"type\": \"INSERT\", \"affected\": 2 }\n        ]),\n    )\n    .await;\n\n    test(\n        \"\n        SELECT mid, lid, sid, iid \n        FROM Mem\n        JOIN Loc\n        JOIN Ses\n        JOIN Idb;\n        \",\n        json!([{\n            \"type\": \"SELECT\",\n            \"rows\": [\n                { \"mid\": 10, \"lid\": 20, \"sid\": 30, \"iid\": 40 },\n                { \"mid\": 10, \"lid\": 20, \"sid\": 30, \"iid\": 41 },\n                { \"mid\": 10, \"lid\": 20, \"sid\": 31, \"iid\": 40 },\n                { \"mid\": 10, \"lid\": 20, \"sid\": 31, \"iid\": 41 },\n                { \"mid\": 10, \"lid\": 21, \"sid\": 30, \"iid\": 40 },\n                { \"mid\": 10, \"lid\": 21, \"sid\": 30, \"iid\": 41 },\n                { \"mid\": 10, \"lid\": 21, \"sid\": 31, \"iid\": 40 },\n                { \"mid\": 10, \"lid\": 21, \"sid\": 31, \"iid\": 41 },\n                { \"mid\": 11, \"lid\": 20, \"sid\": 30, \"iid\": 40 },\n                { \"mid\": 11, \"lid\": 20, \"sid\": 30, \"iid\": 41 },\n                { \"mid\": 11, \"lid\": 20, \"sid\": 31, \"iid\": 40 },\n                { \"mid\": 11, \"lid\": 20, \"sid\": 31, \"iid\": 41 },\n                { \"mid\": 11, \"lid\": 21, \"sid\": 30, \"iid\": 40 },\n                { \"mid\": 11, \"lid\": 21, \"sid\": 30, \"iid\": 41 },\n                { \"mid\": 11, \"lid\": 21, \"sid\": 31, \"iid\": 40 },\n                { \"mid\": 11, \"lid\": 21, \"sid\": 31, \"iid\": 41 }\n            ]\n        }]),\n    )\n    .await;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","javascript","tests","payload.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n\nwasm_bindgen_test_configure!(run_in_browser);\n\nuse {\n    gloo_utils::format::JsValueSerdeExt,\n    gluesql_js::Glue,\n    serde_json::{Value as Json, json},\n    wasm_bindgen_futures::JsFuture,\n    wasm_bindgen_test::*,\n};\n\n#[wasm_bindgen_test]\nasync fn queries() {\n    let mut glue = Glue::new();\n\n    let test_cases = [\n        (\n            \"\n            CREATE TABLE Foo (id INTEGER);\n            CREATE TABLE Bar;\n            \",\n            json!([\n                { \"type\": \"CREATE TABLE\" },\n                { \"type\": \"CREATE TABLE\" },\n            ]),\n        ),\n        (\n            \"INSERT INTO Foo VALUES (1), (2), (3)\",\n            json!([{\n                \"type\": \"INSERT\",\n                \"affected\": 3\n            }]),\n        ),\n        (\n            r#\"INSERT INTO Bar VALUES\n                ('{ \"hello\": 1 }'),\n                ('{ \"world\": \"cookie\" }');\n            \"#,\n            json!([{\n                \"type\": \"INSERT\",\n                \"affected\": 2\n            }]),\n        ),\n        (\n            \"SELECT * FROM Bar\",\n            json!([{\n                \"type\": \"SELECT\",\n                \"rows\": [\n                    { \"hello\": 1 },\n                    { \"world\": \"cookie\" }\n                ]\n            }]),\n        ),\n        (\n            \"SELECT * FROM Foo\",\n            json!([{\n                \"type\": \"SELECT\",\n                \"rows\": [\n                    { \"id\": 1 },\n                    { \"id\": 2 },\n                    { \"id\": 3 }\n                ]\n            }]),\n        ),\n        (\n            \"UPDATE Foo SET id = id + 2 WHERE id = 3\",\n            json!([{\n                \"type\": \"UPDATE\",\n                \"affected\": 1\n            }]),\n        ),\n        (\n            \"DELETE FROM Foo WHERE id \u003c 5\",\n            json!([{\n                \"type\": \"DELETE\",\n                \"affected\": 2\n            }]),\n        ),\n        (\n            \"SELECT * FROM Foo\",\n            json!([{\n                \"type\": \"SELECT\",\n                \"rows\": [{ \"id\": 5 }]\n            }]),\n        ),\n        (\n            \"SHOW COLUMNS FROM Foo\",\n            json!([{\n                \"type\": \"SHOW COLUMNS\",\n                \"columns\": [{\n                    \"name\": \"id\",\n                    \"type\": \"INT\"\n                }]\n            }]),\n        ),\n        (\n            \"SHOW TABLES\",\n            json!([{\n                \"type\": \"SHOW TABLES\",\n                \"tables\": [\"Bar\", \"Foo\"]\n            }]),\n        ),\n        (\n            \"SHOW VERSION\",\n            json!([{\n                \"type\": \"SHOW VERSION\",\n                \"version\": env!(\"CARGO_PKG_VERSION\"),\n            }]),\n        ),\n        (\n            \"DROP TABLE IF EXISTS Foo\",\n            json!([{ \"type\": \"DROP TABLE\", \"affected\": 1 }]),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        let actual: Json = JsFuture::from(glue.query(sql.to_owned()))\n            .await\n            .unwrap()\n            .into_serde()\n            .unwrap();\n\n        assert_eq!(actual, expected, \"{sql}\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","python","src","error.rs"],"content":"use {\n    gluesql_core::prelude::Error,\n    pyo3::{create_exception, exceptions::PyException, prelude::*, pyclass::CompareOp},\n};\n\n#[pyclass(name = \"GlueSQLError\")]\npub struct PyGlueSQLError(pub Error);\n\ncreate_exception!(gluesql, GlueSQLError, PyException);\n\n#[pymethods]\nimpl PyGlueSQLError {\n    pub fn __richcmp__(\u0026self, py: Python, rhs: \u0026PyGlueSQLError, op: CompareOp) -\u003e PyObject {\n        match op {\n            CompareOp::Eq =\u003e (self.0 == rhs.0).into_py(py),\n            CompareOp::Ne =\u003e (self.0 != rhs.0).into_py(py),\n            _ =\u003e py.NotImplemented(),\n        }\n    }\n\n    pub fn __repr__(\u0026self) -\u003e String {\n        format!(\"{}\", self.0)\n    }\n}\n\nimpl From\u003cPyGlueSQLError\u003e for PyErr {\n    fn from(e: PyGlueSQLError) -\u003e PyErr {\n        GlueSQLError::new_err(e.0.to_string())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","python","src","lib.rs"],"content":"#![cfg(feature = \"include-python-workspace\")]\n\nuse {\n    error::GlueSQLError,\n    gluesql_core::{\n        ast::Statement,\n        prelude::{Payload, execute, parse, plan},\n        translate::translate,\n    },\n    payload::{PyPayload, convert},\n    pyo3::{prelude::*, types::PyString},\n    storages::{\n        PyJsonStorage, PyMemoryStorage, PySharedMemoryStorage, PySledStorage, PySledStorageConfig,\n        PySledStorageModeConfig, PyStorageEngine,\n    },\n};\n\nmod error;\nmod payload;\nmod storages;\n\n#[pyclass(name = \"Glue\")]\npub struct PyGlue {\n    pub storage: PyStorageEngine,\n}\n\nmacro_rules! plan {\n    ($storage:expr, $statement:expr) =\u003e {{\n        plan(\u0026$storage.0, $statement)\n            .await\n            .map_err(|e| GlueSQLError::new_err(e.to_string()))\n    }};\n}\n\nmacro_rules! execute {\n    ($storage:expr, $statement:expr) =\u003e {{\n        execute(\u0026mut $storage.0, $statement)\n            .await\n            .map_err(|e| GlueSQLError::new_err(e.to_string()))\n    }};\n}\n\nimpl PyGlue {\n    #[tokio::main]\n    pub async fn plan(\u0026self, statement: Statement) -\u003e PyResult\u003cStatement\u003e {\n        let storage = \u0026self.storage;\n\n        match storage {\n            PyStorageEngine::Memory(storage) =\u003e plan!(storage, statement),\n            PyStorageEngine::Json(storage) =\u003e plan!(storage, statement),\n            PyStorageEngine::SharedMemory(storage) =\u003e plan!(storage, statement),\n            PyStorageEngine::Sled(storage) =\u003e plan!(storage, statement),\n        }\n    }\n\n    #[tokio::main]\n    pub async fn execute(\u0026mut self, statement: Statement) -\u003e PyResult\u003cPayload\u003e {\n        let storage = \u0026mut self.storage;\n\n        match storage {\n            PyStorageEngine::Memory(storage) =\u003e execute!(storage, \u0026statement),\n            PyStorageEngine::Json(storage) =\u003e execute!(storage, \u0026statement),\n            PyStorageEngine::SharedMemory(storage) =\u003e execute!(storage, \u0026statement),\n            PyStorageEngine::Sled(storage) =\u003e execute!(storage, \u0026statement),\n        }\n    }\n}\n\n#[pymethods]\nimpl PyGlue {\n    #[new]\n    pub fn new(storage: PyStorageEngine) -\u003e Self {\n        PyGlue { storage }\n    }\n\n    pub fn query(\u0026mut self, py: Python, sql: \u0026PyString) -\u003e PyResult\u003cPyObject\u003e {\n        let sql = sql.to_string();\n        let queries = parse(sql).map_err(|e| GlueSQLError::new_err(e.to_string()))?;\n\n        let mut payloads: Vec\u003cPyPayload\u003e = vec![];\n        for query in queries.iter() {\n            let statement = translate(query).map_err(|e| GlueSQLError::new_err(e.to_string()))?;\n            let statement = self.plan(statement)?;\n\n            let payload = self.execute(statement)?;\n\n            payloads.push(PyPayload { payload });\n        }\n\n        Ok(convert(py, payloads))\n    }\n}\n\n#[pymodule]\nfn gluesql(py: Python, m: \u0026PyModule) -\u003e PyResult\u003c()\u003e {\n    m.add_class::\u003cPyGlue\u003e()?;\n    m.add_class::\u003cPyMemoryStorage\u003e()?;\n    m.add_class::\u003cPyJsonStorage\u003e()?;\n    m.add_class::\u003cPySharedMemoryStorage\u003e()?;\n    m.add_class::\u003cPySledStorage\u003e()?;\n    m.add_class::\u003cPySledStorageConfig\u003e()?;\n    m.add_class::\u003cPySledStorageModeConfig\u003e()?;\n\n    m.add(\"GlueSQLError\", py.get_type::\u003cGlueSQLError\u003e())?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","python","src","payload.rs"],"content":"use {\n    gluesql_core::prelude::{Payload, PayloadVariable},\n    pyo3::{PyObject, Python, pyclass},\n    pythonize::pythonize,\n    serde_json::{Value as Json, json},\n};\n\n#[pyclass]\npub struct PyPayload {\n    pub payload: Payload,\n}\n\npub fn convert(py: Python, payloads: Vec\u003cPyPayload\u003e) -\u003e PyObject {\n    let payloads = payloads\n        .into_iter()\n        .map(|var| convert_payload(var.payload))\n        .collect();\n    let payloads = Json::Array(payloads);\n\n    pythonize(py, \u0026payloads).unwrap()\n}\n\nfn convert_payload(payload: Payload) -\u003e Json {\n    // TODO: Improve below logic.\n    match payload {\n        Payload::Create =\u003e json!({ \"type\": \"CREATE TABLE\" }),\n        Payload::DropTable(num) =\u003e json!({ \"type\": \"DROP TABLE\", \"affected\": num }),\n        Payload::Select { labels, rows } =\u003e {\n            let rows = rows\n                .into_iter()\n                .map(|values| {\n                    let row = labels\n                        .iter()\n                        .zip(values)\n                        .map(|(label, value)| {\n                            let key = label.to_owned();\n                            let value = Json::try_from(value).unwrap();\n\n                            (key, value)\n                        })\n                        .collect();\n\n                    Json::Object(row)\n                })\n                .collect();\n\n            json!({\n                \"type\": \"SELECT\",\n                \"rows\": Json::Array(rows),\n            })\n        }\n        Payload::SelectMap(rows) =\u003e {\n            let rows = rows\n                .into_iter()\n                .map(|row| {\n                    let row = row\n                        .into_iter()\n                        .map(|(key, value)| {\n                            let value = Json::try_from(value).unwrap();\n\n                            (key, value)\n                        })\n                        .collect();\n\n                    Json::Object(row)\n                })\n                .collect();\n\n            json!({\n                \"type\": \"SELECT\",\n                \"rows\": Json::Array(rows),\n            })\n        }\n        Payload::ShowColumns(columns) =\u003e {\n            let columns = columns\n                .into_iter()\n                .map(|(name, data_type)| {\n                    json!({\n                        \"name\": name,\n                        \"type\": data_type.to_string(),\n                    })\n                })\n                .collect();\n\n            json!({\n                \"type\": \"SHOW COLUMNS\",\n                \"columns\": Json::Array(columns),\n            })\n        }\n        Payload::Insert(num) =\u003e json!({\n            \"type\": \"INSERT\",\n            \"affected\": num\n        }),\n        Payload::Update(num) =\u003e json!({\n            \"type\": \"UPDATE\",\n            \"affected\": num\n        }),\n        Payload::Delete(num) =\u003e json!({\n            \"type\": \"DELETE\",\n            \"affected\": num\n        }),\n        Payload::AlterTable =\u003e json!({ \"type\": \"ALTER TABLE\" }),\n        Payload::CreateIndex =\u003e json!({ \"type\": \"CREATE INDEX\" }),\n        Payload::DropIndex =\u003e json!({ \"type\": \"DROP INDEX\" }),\n        Payload::StartTransaction =\u003e json!({ \"type\": \"BEGIN\" }),\n        Payload::Commit =\u003e json!({ \"type\": \"COMMIT\" }),\n        Payload::Rollback =\u003e json!({ \"type\": \"ROLLBACK\" }),\n        Payload::ShowVariable(PayloadVariable::Version(version)) =\u003e {\n            json!({\n                \"type\": \"SHOW VERSION\",\n                \"version\": version\n            })\n        }\n        Payload::ShowVariable(PayloadVariable::Tables(table_names)) =\u003e {\n            json!({\n                \"type\": \"SHOW TABLES\",\n                \"tables\": table_names\n            })\n        }\n        Payload::DropFunction =\u003e json!({ \"type\": \"DROP FUNCTION\" }),\n        Payload::ShowVariable(PayloadVariable::Functions(function_names)) =\u003e {\n            json!({\n                \"type\": \"SHOW FUNCTIONS\",\n                \"functions\": function_names\n            })\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","python","src","storages.rs"],"content":"use {\n    gluesql_json_storage::JsonStorage,\n    gluesql_memory_storage::MemoryStorage,\n    gluesql_shared_memory_storage::SharedMemoryStorage,\n    gluesql_sled_storage::{SledStorage, sled},\n    pyo3::{prelude::*, types::PyString},\n    std::path::PathBuf,\n};\n\n#[derive(FromPyObject)]\npub enum PyStorageEngine {\n    Memory(PyMemoryStorage),\n    Json(PyJsonStorage),\n    SharedMemory(PySharedMemoryStorage),\n    Sled(PySledStorage),\n}\n\n#[pyclass(name = \"MemoryStorage\")]\n#[derive(Clone, Default)]\npub struct PyMemoryStorage(pub MemoryStorage);\n\n#[pymethods]\nimpl PyMemoryStorage {\n    #[new]\n    pub fn new() -\u003e Self {\n        Default::default()\n    }\n\n    pub fn __repr__(\u0026self) -\u003e PyResult\u003cString\u003e {\n        Ok(format!(\"{:?}\", self.0))\n    }\n}\n\n#[pyclass(name = \"JsonStorage\")]\n#[derive(Clone)]\npub struct PyJsonStorage(pub JsonStorage);\n\n#[pymethods]\nimpl PyJsonStorage {\n    #[new]\n    pub fn new(path_arg: \u0026PyString) -\u003e Self {\n        let mut path = PathBuf::new();\n        path.push(path_arg.to_string());\n        PyJsonStorage(JsonStorage { path })\n    }\n\n    pub fn __repr__(\u0026self) -\u003e PyResult\u003cString\u003e {\n        Ok(format!(\"{:?}\", self.0))\n    }\n}\n\n#[pyclass(name = \"SharedMemoryStorage\")]\n#[derive(Clone, Default)]\npub struct PySharedMemoryStorage(pub SharedMemoryStorage);\n\n#[pymethods]\nimpl PySharedMemoryStorage {\n    #[new]\n    pub fn new() -\u003e Self {\n        Default::default()\n    }\n\n    pub fn __repr__(\u0026self) -\u003e PyResult\u003cString\u003e {\n        Ok(format!(\"{:?}\", self.0))\n    }\n}\n\n#[pyclass(name = \"SledStorageConfigMode\")]\n#[derive(Clone, Debug)]\npub struct PySledStorageModeConfig(pub sled::Mode);\n\n#[pymethods]\nimpl PySledStorageModeConfig {\n    pub fn __repr__(\u0026self) -\u003e PyResult\u003cString\u003e {\n        match self.0 {\n            sled::Mode::LowSpace =\u003e Ok(\"LowSpace\".to_owned()),\n            sled::Mode::HighThroughput =\u003e Ok(\"HighThroughput\".to_owned()),\n        }\n    }\n}\n\nimpl Default for PySledStorageModeConfig {\n    fn default() -\u003e Self {\n        PySledStorageModeConfig(sled::Mode::LowSpace)\n    }\n}\n\n#[pyclass(name = \"SledStorageConfig\")]\n#[derive(Clone, Default, Debug)]\npub struct PySledStorageConfig {\n    #[pyo3(get, set)]\n    pub cache_capacity: u64,\n\n    #[pyo3(get, set)]\n    pub path: String,\n\n    #[pyo3(get, set)]\n    pub create_new: bool,\n\n    #[pyo3(get, set)]\n    pub mode: PySledStorageModeConfig,\n\n    #[pyo3(get, set)]\n    pub temporary: bool,\n\n    #[pyo3(get, set)]\n    pub use_compression: bool,\n\n    #[pyo3(get, set)]\n    pub compression_factor: i32,\n\n    #[pyo3(get, set)]\n    pub print_profile_on_drop: bool,\n}\n\n#[pymethods]\nimpl PySledStorageConfig {\n    #[new]\n    pub fn new() -\u003e Self {\n        PySledStorageConfig::default()\n    }\n\n    pub fn __repr__(\u0026self) -\u003e PyResult\u003cString\u003e {\n        Ok(format!(\"{:?}\", self))\n    }\n}\n\n#[pyclass(name = \"SledStorage\")]\n#[derive(Clone)]\npub struct PySledStorage(pub SledStorage);\n\n#[pymethods]\nimpl PySledStorage {\n    #[new]\n    pub fn new(path_arg: \u0026PyString) -\u003e PyResult\u003cSelf\u003e {\n        let path_str = path_arg.to_str()?;\n        let storage = SledStorage::new(path_str).unwrap();\n        Ok(PySledStorage(storage))\n    }\n\n    #[staticmethod]\n    pub fn try_from(cfg: \u0026PySledStorageConfig) -\u003e PyResult\u003cSelf\u003e {\n        let sled_cfg = sled::Config::default()\n            .cache_capacity(cfg.cache_capacity)\n            .compression_factor(cfg.compression_factor)\n            .create_new(cfg.create_new)\n            .mode(cfg.mode.0)\n            .path(\u0026cfg.path)\n            .print_profile_on_drop(cfg.print_profile_on_drop)\n            .temporary(cfg.temporary)\n            .use_compression(cfg.use_compression);\n\n        let storage = SledStorage::try_from(sled_cfg).unwrap();\n        Ok(PySledStorage(storage))\n    }\n\n    pub fn __repr__(\u0026self) -\u003e PyResult\u003cString\u003e {\n        Ok(format!(\"{:?}\", self.0))\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","rust","examples","api_usage.rs"],"content":"#[cfg(feature = \"gluesql_sled_storage\")]\nmod api_usage {\n    use gluesql::prelude::{Glue, SledStorage};\n\n    pub async fn run() {\n        let storage = SledStorage::new(\"data/mutable-api\").unwrap();\n        let mut glue = Glue::new(storage);\n\n        let sqls = [\n            \"CREATE TABLE Glue (id INTEGER);\",\n            \"INSERT INTO Glue VALUES (100);\",\n            \"INSERT INTO Glue VALUES (200);\",\n            \"DROP TABLE Glue;\",\n        ];\n\n        for sql in sqls {\n            glue.execute(sql).await.unwrap();\n        }\n    }\n}\n\nfn main() {\n    #[cfg(feature = \"gluesql_sled_storage\")]\n    futures::executor::block_on(api_usage::run());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","rust","examples","hello_ast_builder.rs"],"content":"#[cfg(feature = \"gluesql_sled_storage\")]\nmod hello_ast_builder {\n    use {\n        gluesql::{\n            core::ast_builder::{self, Execute},\n            gluesql_sled_storage::SledStorage,\n            prelude::{Glue, Payload, Value},\n        },\n        std::fs,\n    };\n\n    pub async fn run() {\n        /*\n            Initiate a connection\n        */\n        /*\n            Open a Sled database, this will create one if one does not yet exist\n        */\n        let sled_dir = \"/tmp/gluesql/hello_ast_builder\";\n        fs::remove_dir_all(sled_dir).unwrap_or(());\n        let storage = SledStorage::new(sled_dir).expect(\"Something went wrong!\");\n        /*\n            Wrap the Sled database with Glue\n        */\n        let mut glue = Glue::new(storage);\n\n        /*\n            Create table\n        */\n        ast_builder::table(\"greet\")\n            .create_table()\n            .add_column(\"name TEXT\")\n            .execute(\u0026mut glue)\n            .await\n            .expect(\"Execution failed\");\n\n        /*\n            Insert a row\n        */\n        ast_builder::table(\"greet\")\n            .insert()\n            .values(vec![\"'AST Builder'\"])\n            .execute(\u0026mut glue)\n            .await\n            .expect(\"Execution failed\");\n\n        /*\n            Select inserted row\n        */\n        let result = ast_builder::table(\"greet\")\n            .select()\n            .project(\"name\")\n            .execute(\u0026mut glue)\n            .await\n            .expect(\"Failed to execute\");\n\n        /*\n            Query results are wrapped into a payload enum, on the basis of the query type\n        */\n        let rows = match result {\n            Payload::Select { labels: _, rows } =\u003e rows,\n            _ =\u003e panic!(\"Unexpected result: {:?}\", result),\n        };\n\n        let first_row = \u0026rows[0];\n        let first_value = first_row.iter().next().unwrap();\n\n        /*\n            Row values are wrapped into a value enum, on the basis of the result type\n        */\n        let to_greet = match first_value {\n            Value::Str(to_greet) =\u003e to_greet,\n            value =\u003e panic!(\"Unexpected type: {:?}\", value),\n        };\n\n        println!(\"Hello {}!\", to_greet); // Will always output \"Hello AST Builder!\"\n    }\n}\n\nfn main() {\n    #[cfg(feature = \"gluesql_sled_storage\")]\n    futures::executor::block_on(hello_ast_builder::run());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","rust","examples","hello_world.rs"],"content":"#[cfg(feature = \"gluesql_sled_storage\")]\nmod hello_world {\n    use {\n        gluesql::{gluesql_sled_storage::SledStorage, prelude::Glue},\n        std::fs,\n    };\n\n    struct GreetRow {\n        name: String,\n    }\n\n    pub async fn run() {\n        /*\n            Initiate a connection\n        */\n        /*\n            Open a Sled database, this will create one if one does not yet exist\n        */\n        let sled_dir = \"/tmp/gluesql/hello_world\";\n        fs::remove_dir_all(sled_dir).unwrap_or(());\n        let storage = SledStorage::new(sled_dir).expect(\"Something went wrong!\");\n        /*\n            Wrap the Sled database with Glue\n        */\n        let mut glue = Glue::new(storage);\n\n        /*\n            Create table then insert a row\n\n            Write queries as a string\n        */\n        let queries = \"\n            CREATE TABLE greet (name TEXT);\n            INSERT INTO greet VALUES ('World');\n        \";\n\n        glue.execute(queries).await.expect(\"Execution failed\");\n\n        /*\n            Select inserted row\n        */\n        let queries = \"\n            SELECT name FROM greet\n        \";\n\n        let mut result = glue.execute(queries).await.expect(\"Failed to execute\");\n\n        /*\n            Query results are wrapped into a payload enum, on the basis of the query type\n        */\n        assert_eq!(result.len(), 1);\n\n        let payload = result.remove(0);\n\n        let rows = payload\n            .select()\n            .unwrap()\n            .map(|map| {\n                let name = *map.get(\"name\").unwrap();\n                let name = name.into();\n\n                GreetRow { name }\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        assert_eq!(rows.len(), 1);\n        assert_eq!(\u0026rows[0].name, \"World\");\n\n        println!(\"Hello {}!\", rows[0].name); // Will always output \"Hello World!\"\n    }\n}\n\nfn main() {\n    #[cfg(feature = \"gluesql_sled_storage\")]\n    futures::executor::block_on(hello_world::run());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","rust","examples","memory_storage_usage.rs"],"content":"#[cfg(feature = \"gluesql_memory_storage\")]\nmod api_usage {\n    use gluesql::{gluesql_memory_storage::MemoryStorage, prelude::Glue};\n\n    pub async fn run() {\n        let storage = MemoryStorage::default();\n        let mut glue = Glue::new(storage);\n\n        glue.execute(\"DROP TABLE IF EXISTS api_test\").await.unwrap();\n\n        glue.execute(\n            \"CREATE TABLE api_test (\n                id INTEGER,\n                name TEXT,\n                nullable TEXT NULL,\n                is BOOLEAN\n            )\",\n        )\n        .await\n        .unwrap();\n\n        glue.execute(\n            \"INSERT INTO api_test (\n                id,\n                name,\n                nullable,\n                is\n            ) VALUES\n                (1, 'test1', 'not null', TRUE),\n                (2, 'test2', NULL, FALSE)\",\n        )\n        .await\n        .unwrap();\n    }\n}\n\nfn main() {\n    #[cfg(feature = \"gluesql_memory_storage\")]\n    futures::executor::block_on(api_usage::run());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","rust","examples","sled_multi_threaded.rs"],"content":"#[cfg(feature = \"gluesql_sled_storage\")]\nmod sled_multi_threaded {\n    use {\n        futures::executor::block_on,\n        gluesql::{\n            gluesql_sled_storage::SledStorage,\n            prelude::{Glue, Payload, Value},\n        },\n        std::thread,\n    };\n\n    pub async fn run() {\n        let storage = SledStorage::new(\"/tmp/gluesql/hello_world\").expect(\"Something went wrong!\");\n        let mut glue = Glue::new(storage.clone());\n        let queries = \"\n            CREATE TABLE IF NOT EXISTS greet (name TEXT);\n            DELETE FROM greet;\n        \";\n\n        glue.execute(queries).await.unwrap();\n\n        /*\n            SledStorage supports cloning, using this we can create copies of the storage for new threads;\n            all we need to do is wrap it in glue again.\n        */\n        let insert_storage = storage.clone();\n        let insert_thread = thread::spawn(move || {\n            let mut glue = Glue::new(insert_storage);\n            let query = \"INSERT INTO greet (name) VALUES ('Foo')\";\n\n            block_on(glue.execute(query)).unwrap();\n        });\n\n        let select_storage = storage;\n        let select_thread = thread::spawn(move || {\n            let mut glue = Glue::new(select_storage);\n            let query = \"SELECT * FROM greet;\";\n\n            let payloads = block_on(glue.execute(query)).unwrap();\n            println!(\"{payloads:?}\");\n        });\n\n        select_thread\n            .join()\n            .expect(\"Something went wrong in the world thread\");\n\n        insert_thread\n            .join()\n            .expect(\"Something went wrong in the foo thread\");\n\n        let query = \"SELECT name FROM greet\";\n        let payloads = glue.execute(query).await.unwrap();\n        assert_eq!(payloads.len(), 1);\n\n        let rows = match \u0026payloads[0] {\n            Payload::Select { rows, .. } =\u003e rows,\n            _ =\u003e panic!(\"Unexpected result: {:?}\", payloads),\n        };\n\n        let first_row = \u0026rows[0];\n        let first_value = first_row.iter().next().unwrap();\n        let to_greet = match first_value {\n            Value::Str(to_greet) =\u003e to_greet,\n            value =\u003e panic!(\"Unexpected type: {:?}\", value),\n        };\n\n        // Will typically output \"Hello Foo!\" but will sometimes output \"Hello World!\"; depends on which thread finished first.\n        println!(\"Hello {}!\", to_greet);\n    }\n}\n\nfn main() {\n    #[cfg(feature = \"gluesql_sled_storage\")]\n    futures::executor::block_on(sled_multi_threaded::run());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","rust","examples","using_config.rs"],"content":"#[cfg(feature = \"gluesql_sled_storage\")]\nuse {\n    futures::executor::block_on,\n    gluesql::{gluesql_sled_storage::SledStorage, prelude::Glue},\n    gluesql_sled_storage::sled,\n    std::convert::TryFrom,\n};\n\nfn main() {\n    #[cfg(feature = \"gluesql_sled_storage\")]\n    {\n        let config = sled::Config::default()\n            .path(\"data/using_config\")\n            .temporary(true)\n            .mode(sled::Mode::HighThroughput);\n\n        let storage = SledStorage::try_from(config).unwrap();\n\n        let mut glue = Glue::new(storage);\n\n        let sqls = \"\n            CREATE TABLE Glue (id INTEGER);\n            INSERT INTO Glue VALUES (100);\n            INSERT INTO Glue VALUES (200);\n            DROP TABLE Glue;\n        \";\n\n        block_on(glue.execute(sqls)).unwrap();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","rust","src","lib.rs"],"content":"//! # GlueSQL\n//!\n//! ## Multi-Model Database Engine as a Library\n//! GlueSQL is a Rust library for SQL databases that includes a parser ([sqlparser-rs](https://github.com/sqlparser-rs/sqlparser-rs)), an execution layer, and a variety of storage options, both persistent and non-persistent, all in one package. It is a versatile tool for developers, supporting both SQL and its own query builder (AST Builder). GlueSQL can handle structured and unstructured data, making it suitable for a wide range of use cases. It is portable and can be used with various storage types, including log files and read-write capable storage. GlueSQL is designed to be extensible and supports custom planners, making it a powerful tool for developers who need SQL support for their databases or services. GlueSQL is also flexible, as it can be used in Rust and JavaScript environments, and its language support is constantly expanding to include more programming languages.\n//!\n//! For more information on how to use GlueSQL, please refer to the [**official documentation website**](https://gluesql.org/docs). The documentation provides detailed information on how to install and use GlueSQL, as well as examples and tutorials on how to create custom storage systems and perform SQL operations.\n\npub mod core {\n    pub use gluesql_core::*;\n}\n\n#[cfg(feature = \"gluesql_memory_storage\")]\npub use gluesql_memory_storage;\n\n#[cfg(feature = \"gluesql-shared-memory-storage\")]\npub use gluesql_shared_memory_storage;\n\n#[cfg(feature = \"gluesql_sled_storage\")]\npub use gluesql_sled_storage;\n\n#[cfg(feature = \"gluesql-redb-storage\")]\npub use gluesql_redb_storage;\n\n#[cfg(feature = \"gluesql-json-storage\")]\npub use gluesql_json_storage;\n\n#[cfg(feature = \"gluesql-csv-storage\")]\npub use gluesql_csv_storage;\n\n#[cfg(feature = \"gluesql-parquet-storage\")]\npub use gluesql_parquet_storage;\n\n#[cfg(feature = \"gluesql-file-storage\")]\npub use gluesql_file_storage;\n\n#[cfg(feature = \"gluesql-git-storage\")]\npub use gluesql_git_storage;\n\n#[cfg(feature = \"gluesql-mongo-storage\")]\npub use gluesql_mongo_storage;\n\n#[cfg(feature = \"gluesql-composite-storage\")]\npub use gluesql_composite_storage;\n\n#[cfg(all(feature = \"gluesql-web-storage\", target_arch = \"wasm32\"))]\npub use gluesql_web_storage;\n\n#[cfg(all(feature = \"gluesql-idb-storage\", target_arch = \"wasm32\"))]\npub use gluesql_idb_storage;\n\n#[cfg(feature = \"test-suite\")]\npub use test_suite;\n\npub mod prelude {\n    pub use gluesql_core::prelude::*;\n\n    #[cfg(feature = \"gluesql_memory_storage\")]\n    pub use gluesql_memory_storage::MemoryStorage;\n\n    #[cfg(feature = \"gluesql-shared-memory-storage\")]\n    pub use gluesql_shared_memory_storage::SharedMemoryStorage;\n\n    #[cfg(feature = \"gluesql_sled_storage\")]\n    pub use gluesql_sled_storage::SledStorage;\n\n    #[cfg(feature = \"gluesql-redb-storage\")]\n    pub use gluesql_redb_storage::RedbStorage;\n\n    #[cfg(feature = \"gluesql-json-storage\")]\n    pub use gluesql_json_storage::JsonStorage;\n\n    #[cfg(feature = \"gluesql-csv-storage\")]\n    pub use gluesql_csv_storage::CsvStorage;\n\n    #[cfg(feature = \"gluesql-parquet-storage\")]\n    pub use gluesql_parquet_storage::ParquetStorage;\n\n    #[cfg(feature = \"gluesql-file-storage\")]\n    pub use gluesql_file_storage::FileStorage;\n\n    #[cfg(feature = \"gluesql-git-storage\")]\n    pub use gluesql_git_storage::GitStorage;\n\n    #[cfg(feature = \"gluesql-mongo-storage\")]\n    pub use gluesql_mongo_storage;\n\n    #[cfg(feature = \"gluesql-composite-storage\")]\n    pub use gluesql_composite_storage::CompositeStorage;\n\n    #[cfg(all(feature = \"gluesql-web-storage\", target_arch = \"wasm32\"))]\n    pub use gluesql_web_storage::WebStorage;\n\n    #[cfg(all(feature = \"gluesql-idb-storage\", target_arch = \"wasm32\"))]\n    pub use gluesql_idb_storage::IdbStorage;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","rust","src","main.rs"],"content":"fn main() {\n    #[cfg(feature = \"cli\")]\n    cli::run().unwrap();\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":0}},{"line":3,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","pkg","rust","tests","glue.rs"],"content":"#![cfg(any(feature = \"gluesql_memory_storage\", feature = \"gluesql_sled_storage\"))]\nuse {\n    futures::executor::block_on,\n    gluesql_core::{\n        executor::Payload,\n        prelude::{Glue, Value},\n        store::{GStore, GStoreMut},\n    },\n};\n\nasync fn basic\u003cT: GStore + GStoreMut\u003e(mut glue: Glue\u003cT\u003e) {\n    assert_eq!(\n        glue.execute(\"DROP TABLE IF EXISTS api_test\").await,\n        Ok(vec![Payload::DropTable(0)])\n    );\n\n    assert_eq!(\n        glue.execute(\n            \"CREATE TABLE api_test (id INTEGER, name TEXT, nullable TEXT NULL, is BOOLEAN)\"\n        )\n        .await,\n        Ok(vec![Payload::Create])\n    );\n\n    assert_eq!(\n        glue.execute(\n            \"\n                INSERT INTO\n                    api_test (id, name, nullable, is)\n                VALUES\n                    (1, 'test1', 'not null', TRUE),\n                    (2, 'test2', NULL, FALSE)\"\n        )\n        .await,\n        Ok(vec![Payload::Insert(2)])\n    );\n\n    assert_eq!(\n        glue.execute(\"SELECT id, name, is FROM api_test\").await,\n        Ok(vec![Payload::Select {\n            labels: vec![String::from(\"id\"), String::from(\"name\"), String::from(\"is\")],\n            rows: vec![\n                vec![\n                    Value::I64(1),\n                    Value::Str(String::from(\"test1\")),\n                    Value::Bool(true)\n                ],\n                vec![\n                    Value::I64(2),\n                    Value::Str(String::from(\"test2\")),\n                    Value::Bool(false)\n                ],\n            ]\n        }])\n    );\n}\n\n#[cfg(feature = \"gluesql_sled_storage\")]\n#[test]\nfn sled_basic() {\n    use gluesql_sled_storage::{SledStorage, sled};\n\n    let config = sled::Config::default()\n        .path(\"data/using_config\")\n        .temporary(true);\n\n    let storage = SledStorage::try_from(config).unwrap();\n    let glue = Glue::new(storage);\n\n    block_on(basic(glue));\n}\n\n#[cfg(feature = \"gluesql_memory_storage\")]\n#[test]\nfn memory_basic() {\n    use gluesql_memory_storage::MemoryStorage;\n\n    let storage = MemoryStorage::default();\n    let glue = Glue::new(storage);\n\n    block_on(basic(glue));\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","composite-storage","src","lib.rs"],"content":"#![deny(clippy::str_to_string)]\n\nmod store;\nmod store_mut;\nmod transaction;\n\nuse {\n    gluesql_core::{\n        data::Schema,\n        error::{Error, Result},\n        store::{GStore, GStoreMut, Metadata, Store},\n    },\n    std::collections::HashMap,\n};\n\npub trait IStorage: GStore + GStoreMut {}\n\nimpl\u003cT: GStore + GStoreMut\u003e IStorage for T {}\n\n#[derive(Default)]\npub struct CompositeStorage {\n    pub storages: HashMap\u003cString, Box\u003cdyn IStorage\u003e\u003e,\n    pub default_engine: Option\u003cString\u003e,\n}\n\nimpl CompositeStorage {\n    pub fn new() -\u003e Self {\n        CompositeStorage::default()\n    }\n\n    pub fn set_default\u003cT: Into\u003cString\u003e\u003e(\u0026mut self, default_engine: T) {\n        self.default_engine = Some(default_engine.into());\n    }\n\n    pub fn remove_default(\u0026mut self) {\n        self.default_engine = None;\n    }\n\n    pub fn push\u003cT: Into\u003cString\u003e, U: IStorage + 'static\u003e(\u0026mut self, engine: T, storage: U) {\n        self.storages.insert(engine.into(), Box::new(storage));\n    }\n\n    pub fn remove\u003cT: AsRef\u003cstr\u003e\u003e(\u0026mut self, engine: T) -\u003e Option\u003cBox\u003cdyn IStorage\u003e\u003e {\n        let engine = engine.as_ref();\n\n        if self.default_engine.as_deref() == Some(engine) {\n            self.default_engine = None;\n        }\n\n        self.storages.remove(engine)\n    }\n\n    pub fn clear(\u0026mut self) {\n        self.storages.clear();\n        self.default_engine = None;\n    }\n\n    async fn fetch_engine(\u0026self, table_name: \u0026str) -\u003e Result\u003cString\u003e {\n        self.fetch_schema(table_name)\n            .await?\n            .and_then(|Schema { engine, .. }| engine)\n            .or_else(|| self.default_engine.clone())\n            .ok_or_else(|| Error::StorageMsg(format!(\"engine not found for table: {table_name}\")))\n    }\n\n    async fn fetch_storage(\u0026self, table_name: \u0026str) -\u003e Result\u003c\u0026Box\u003cdyn IStorage\u003e\u003e {\n        self.fetch_engine(table_name)\n            .await\n            .map(|engine| self.storages.get(\u0026engine))?\n            .ok_or_else(|| {\n                Error::StorageMsg(format!(\n                    \"[fetch_storage] storage not found for table: {table_name}\"\n                ))\n            })\n    }\n\n    async fn fetch_storage_mut(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c\u0026mut Box\u003cdyn IStorage\u003e\u003e {\n        self.fetch_engine(table_name)\n            .await\n            .map(|engine| self.storages.get_mut(\u0026engine))?\n            .ok_or_else(|| {\n                Error::StorageMsg(format!(\n                    \"[fetch_storage_mut] storage not found for table: {table_name}\"\n                ))\n            })\n    }\n}\n\nimpl gluesql_core::store::AlterTable for CompositeStorage {}\nimpl gluesql_core::store::Index for CompositeStorage {}\nimpl gluesql_core::store::IndexMut for CompositeStorage {}\nimpl Metadata for CompositeStorage {}\nimpl gluesql_core::store::CustomFunction for CompositeStorage {}\nimpl gluesql_core::store::CustomFunctionMut for CompositeStorage {}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":36},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","composite-storage","src","store.rs"],"content":"use {\n    super::{CompositeStorage, IStorage},\n    async_trait::async_trait,\n    futures::stream::{self, StreamExt, TryStreamExt},\n    gluesql_core::{\n        data::{Key, Schema},\n        error::Result,\n        store::{DataRow, RowIter, Store},\n    },\n};\n\n#[async_trait(?Send)]\nimpl Store for CompositeStorage {\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let schemas = stream::iter(self.storages.values())\n            .map(AsRef::as_ref)\n            .then(\u003cdyn IStorage\u003e::fetch_all_schemas)\n            .try_collect::\u003cVec\u003c_\u003e\u003e()\n            .await?\n            .into_iter()\n            .flatten()\n            .collect();\n\n        Ok(schemas)\n    }\n\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        for storage in self.storages.values() {\n            let schema = storage.fetch_schema(table_name).await?;\n\n            if schema.is_some() {\n                return Ok(schema);\n            }\n        }\n\n        Ok(None)\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, key: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        self.fetch_storage(table_name)\n            .await?\n            .fetch_data(table_name, key)\n            .await\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        self.fetch_storage(table_name)\n            .await?\n            .scan_data(table_name)\n            .await\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","composite-storage","src","store_mut.rs"],"content":"use {\n    super::CompositeStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::{Error, Result},\n        store::{DataRow, StoreMut},\n    },\n};\n\n#[async_trait(?Send)]\nimpl StoreMut for CompositeStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let storage = schema\n            .engine\n            .as_ref()\n            .or(self.default_engine.as_ref())\n            .and_then(|engine| self.storages.get_mut(engine));\n\n        match (storage, schema.engine.is_some()) {\n            (Some(storage), true) =\u003e storage.insert_schema(schema).await,\n            (Some(storage), false) =\u003e {\n                let schema = Schema {\n                    engine: self.default_engine.clone(),\n                    ..schema.clone()\n                };\n\n                storage.insert_schema(\u0026schema).await\n            }\n            (None, _) =\u003e Err(Error::StorageMsg(format!(\n                \"storage not found for table: {}\",\n                schema.table_name\n            ))),\n        }\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        self.fetch_storage_mut(table_name)\n            .await?\n            .delete_schema(table_name)\n            .await\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        self.fetch_storage_mut(table_name)\n            .await?\n            .append_data(table_name, rows)\n            .await\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        self.fetch_storage_mut(table_name)\n            .await?\n            .insert_data(table_name, rows)\n            .await\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        self.fetch_storage_mut(table_name)\n            .await?\n            .delete_data(table_name, keys)\n            .await\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","composite-storage","src","transaction.rs"],"content":"use {\n    super::CompositeStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        error::{Error, Result},\n        store::Transaction,\n    },\n};\n\n#[async_trait(?Send)]\nimpl Transaction for CompositeStorage {\n    async fn begin(\u0026mut self, autocommit: bool) -\u003e Result\u003cbool\u003e {\n        if autocommit {\n            for storage in self.storages.values_mut() {\n                storage.begin(autocommit).await?;\n            }\n\n            return Ok(true);\n        }\n\n        Err(Error::StorageMsg(\n            \"[CompositeStorage] Transaction::begin is not supported\".to_owned(),\n        ))\n    }\n\n    async fn rollback(\u0026mut self) -\u003e Result\u003c()\u003e {\n        for storage in self.storages.values_mut() {\n            storage.commit().await?;\n        }\n\n        Ok(())\n    }\n\n    async fn commit(\u0026mut self) -\u003e Result\u003c()\u003e {\n        for storage in self.storages.values_mut() {\n            storage.commit().await?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","composite-storage","tests","basic.rs"],"content":"use {\n    gluesql_composite_storage::CompositeStorage,\n    gluesql_core::{\n        error::FetchError,\n        prelude::{Error, Glue, Value::I64},\n    },\n    gluesql_memory_storage::MemoryStorage,\n    test_suite::*,\n};\n\n#[tokio::test]\nasync fn basic() {\n    let m1 = MemoryStorage::default();\n    let m2 = MemoryStorage::default();\n\n    let mut storage = CompositeStorage::new();\n    storage.push(\"M1\", m1);\n    storage.push(\"M2\", m2);\n\n    let mut glue = Glue::new(storage);\n\n    glue.storage.set_default(\"M1\");\n    glue.execute(\"CREATE TABLE Foo (id INTEGER);\")\n        .await\n        .unwrap();\n\n    glue.storage.set_default(\"M2\");\n    glue.execute(\"CREATE TABLE Bar (id INTEGER);\")\n        .await\n        .unwrap();\n\n    glue.execute(\"INSERT INTO Foo VALUES (1), (2);\")\n        .await\n        .unwrap();\n    glue.execute(\"INSERT INTO Bar VALUES (5), (7);\")\n        .await\n        .unwrap();\n\n    assert_eq!(\n        glue.execute(\n            \"SELECT\n                Foo.id AS fid,\n                Bar.id AS bid\n            FROM Foo\n            JOIN Bar;\n        \"\n        )\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap(),\n        select!(\n            fid | bid;\n            I64 | I64;\n            1     5;\n            1     7;\n            2     5;\n            2     7\n        )\n    );\n\n    glue.storage.remove(\"M2\");\n    assert_eq!(\n        glue.execute(\"SELECT * FROM Bar;\").await,\n        Err(FetchError::TableNotFound(\"Bar\".to_owned()).into())\n    );\n\n    glue.storage.set_default(\"M1\");\n    glue.storage.remove_default();\n    assert_eq!(\n        glue.execute(\"CREATE TABLE Tae (id INTEGER);\").await,\n        Err(Error::StorageMsg(\n            \"storage not found for table: Tae\".to_owned()\n        ))\n    );\n\n    glue.storage.clear();\n    assert_eq!(\n        glue.execute(\"SELECT * FROM Foo;\").await,\n        Err(FetchError::TableNotFound(\"Foo\".to_owned()).into())\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","composite-storage","tests","composite_storage.rs"],"content":"use {\n    async_trait::async_trait, gluesql_composite_storage::CompositeStorage,\n    gluesql_core::prelude::Glue, gluesql_memory_storage::MemoryStorage, test_suite::*,\n};\n\nstruct CompositeTester {\n    glue: Glue\u003cCompositeStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cCompositeStorage\u003e for CompositeTester {\n    async fn new(_: \u0026str) -\u003e Self {\n        let mut storage = CompositeStorage::default();\n        storage.push(\"MEMORY\", MemoryStorage::default());\n        storage.set_default(\"MEMORY\");\n\n        let glue = Glue::new(storage);\n\n        Self { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cCompositeStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, CompositeTester);\ngenerate_alter_table_tests!(tokio::test, CompositeTester);\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","composite-storage","tests","error.rs"],"content":"use {\n    futures::stream::TryStreamExt,\n    gluesql_composite_storage::CompositeStorage,\n    gluesql_core::{\n        prelude::{Error, Glue},\n        store::{Store, StoreMut},\n    },\n    gluesql_memory_storage::MemoryStorage,\n};\n\n#[tokio::test]\nasync fn error() {\n    let storage = CompositeStorage::new();\n\n    assert_eq!(\n        storage.scan_data(\"Foo\").await.map(|_| ()),\n        Err(Error::StorageMsg(\n            \"engine not found for table: Foo\".to_owned()\n        ))\n    );\n\n    let mut glue = Glue::new(storage);\n    assert_eq!(\n        glue.execute(\"CREATE TABLE Foo ENGINE = NONAME;\").await,\n        Err(Error::StorageMsg(\n            \"storage not found for table: Foo\".to_owned()\n        ))\n    );\n\n    let storage = {\n        let storage = MemoryStorage::default();\n        let mut glue = Glue::new(storage);\n        glue.execute(\"CREATE TABLE WrongEngine (id INTEGER) ENGINE = SomethingElse\")\n            .await\n            .unwrap();\n\n        glue.storage\n    };\n\n    glue.storage.push(\"Test\", storage);\n    glue.storage.set_default(\"Test\");\n\n    glue.execute(\"CREATE TABLE Foo (id INTEGER);\")\n        .await\n        .unwrap();\n\n    assert_eq!(\n        glue.storage.scan_data(\"WrongEngine\").await.map(|_| ()),\n        Err(Error::StorageMsg(\n            \"[fetch_storage] storage not found for table: WrongEngine\".to_owned()\n        ))\n    );\n\n    assert_eq!(\n        glue.storage.delete_schema(\"WrongEngine\").await.map(|_| ()),\n        Err(Error::StorageMsg(\n            \"[fetch_storage_mut] storage not found for table: WrongEngine\".to_owned()\n        ))\n    );\n}\n\nmacro_rules! exec {\n    ($glue: ident $sql: literal) =\u003e {\n        $glue.execute($sql).await.unwrap();\n    };\n}\n\nmacro_rules! test {\n    ($glue: ident $sql: literal, $result: expr) =\u003e {\n        assert_eq!($glue.execute($sql).await, $result);\n    };\n}\n\n#[tokio::test]\nasync fn composite_storage_index() {\n    use {gluesql_core::store::Index, gluesql_memory_storage::MemoryStorage};\n\n    let mut storage = CompositeStorage::default();\n    storage.push(\"mem\", MemoryStorage::default());\n    storage.set_default(\"mem\");\n\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"CREATE TABLE Idx (id INTEGER);\");\n\n    assert_eq!(\n        glue.storage\n            .scan_data(\"Idx\")\n            .await\n            .unwrap()\n            .try_collect::\u003cVec\u003c_\u003e\u003e()\n            .await\n            .as_ref()\n            .map(Vec::len),\n        Ok(0),\n    );\n\n    assert_eq!(\n        glue.storage\n            .scan_indexed_data(\"Idx\", \"hello\", None, None)\n            .await\n            .map(|_| ()),\n        Err(Error::StorageMsg(\n            \"[Storage] Index::scan_indexed_data is not supported\".to_owned()\n        ))\n    );\n\n    test!(\n        glue \"CREATE INDEX idx_id ON Idx (id);\",\n        Err(Error::StorageMsg(\"[Storage] Index::create_index is not supported\".to_owned()))\n    );\n    test!(\n        glue \"DROP INDEX Idx.idx_id;\",\n        Err(Error::StorageMsg(\"[Storage] Index::drop_index is not supported\".to_owned()))\n    );\n}\n\n#[tokio::test]\nasync fn composite_storage_function() {\n    let storage = CompositeStorage::default();\n    let mut glue = Glue::new(storage);\n\n    test!(\n        glue \"CREATE FUNCTION abc() RETURN 1;\",\n        Err(Error::StorageMsg(\"[Storage] CustomFunction is not supported\".to_owned()))\n    );\n    test!(\n        glue \"SELECT abc();\",\n        Err(Error::StorageMsg(\"[Storage] CustomFunction is not supported\".to_owned()))\n    );\n    test!(\n        glue \"DROP FUNCTION abc;\",\n        Err(Error::StorageMsg(\"[Storage] CustomFunction is not supported\".to_owned()))\n    );\n    test!(\n        glue \"SHOW FUNCTIONS;\",\n        Err(Error::StorageMsg(\"[Storage] CustomFunction is not supported\".to_owned()))\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","composite-storage","tests","memory_and_sled.rs"],"content":"use {\n    gluesql_composite_storage::CompositeStorage,\n    gluesql_core::prelude::{Error, Glue, Value::I64},\n    gluesql_memory_storage::MemoryStorage,\n    gluesql_sled_storage::SledStorage,\n    std::fs,\n    test_suite::*,\n};\n\n#[tokio::test]\nasync fn memory_and_sled() {\n    let memory_storage = MemoryStorage::default();\n    let sled_storage = {\n        let path = \"data/memory_and_sled\";\n        fs::remove_dir_all(path).unwrap_or(());\n\n        SledStorage::new(path).unwrap()\n    };\n\n    let mut storage = CompositeStorage::new();\n    storage.push(\"MEMORY\", memory_storage);\n    storage.push(\"SLED\", sled_storage);\n    storage.set_default(\"MEMORY\");\n\n    let mut glue = Glue::new(storage);\n\n    glue.execute(\"CREATE TABLE Foo (foo_id INTEGER) ENGINE = MEMORY;\")\n        .await\n        .unwrap();\n    glue.execute(\"CREATE TABLE Bar (bar_id INTEGER, foo_id INTEGER) ENGINE = SLED;\")\n        .await\n        .unwrap();\n\n    glue.execute(\"INSERT INTO Foo VALUES (1), (2), (3), (4), (5);\")\n        .await\n        .unwrap();\n    glue.execute(\"INSERT INTO Bar VALUES (10, 1), (20, 3), (30, 3), (40, 3), (50, 5);\")\n        .await\n        .unwrap();\n\n    assert_eq!(\n        glue.execute(\"SELECT Bar.* FROM Bar LEFT JOIN Foo ON Bar.foo_id = Foo.foo_id;\")\n            .await\n            .unwrap()\n            .into_iter()\n            .next()\n            .unwrap(),\n        select!(\n            bar_id | foo_id\n            I64    | I64;\n            10       1;\n            20       3;\n            30       3;\n            40       3;\n            50       5\n        )\n    );\n\n    assert_eq!(\n        glue.execute(\"BEGIN;\").await.unwrap_err(),\n        Error::StorageMsg(\"[CompositeStorage] Transaction::begin is not supported\".to_owned()),\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","csv-storage","src","error.rs"],"content":"use {gluesql_core::error::Error, thiserror::Error};\n\npub trait ResultExt\u003cT, E: ToString\u003e {\n    fn map_storage_err(self) -\u003e Result\u003cT, Error\u003e;\n}\n\nimpl\u003cT, E: ToString\u003e ResultExt\u003cT, E\u003e for std::result::Result\u003cT, E\u003e {\n    fn map_storage_err(self) -\u003e Result\u003cT, Error\u003e {\n        self.map_err(|e| e.to_string()).map_err(Error::StorageMsg)\n    }\n}\n\npub trait OptionExt\u003cT, E: ToString\u003e {\n    fn map_storage_err(self, error: E) -\u003e Result\u003cT, Error\u003e;\n}\n\nimpl\u003cT, E: ToString\u003e OptionExt\u003cT, E\u003e for std::option::Option\u003cT\u003e {\n    fn map_storage_err(self, error: E) -\u003e Result\u003cT, Error\u003e {\n        self.ok_or_else(|| error.to_string())\n            .map_err(Error::StorageMsg)\n    }\n}\n\nimpl From\u003cCsvStorageError\u003e for Error {\n    fn from(error: CsvStorageError) -\u003e Self {\n        Error::StorageMsg(error.to_string())\n    }\n}\n\n#[derive(Error, Debug)]\npub enum CsvStorageError {\n    #[error(\"file not found\")]\n    FileNotFound,\n\n    #[error(\"table does not exist\")]\n    TableDoesNotExist,\n\n    #[error(\"table name does not match with file\")]\n    TableNameDoesNotMatchWithFile,\n\n    #[error(\"unreachable map type data row found\")]\n    UnreachableMapTypeDataRowFound,\n\n    #[error(\"unreachable vector data row type found\")]\n    UnreachableVecTypeDataRowTypeFound,\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","csv-storage","src","lib.rs"],"content":"pub mod error;\nmod store;\nmod store_mut;\n\nuse {\n    error::{CsvStorageError, ResultExt},\n    gluesql_core::{\n        ast::{ColumnDef, ColumnUniqueOption, DataType},\n        data::{Key, Schema, Value},\n        error::Result,\n        parse_sql::parse_data_type,\n        store::{\n            AlterTable, CustomFunction, CustomFunctionMut, DataRow, Index, IndexMut, Metadata,\n            Transaction,\n        },\n        translate::translate_data_type,\n    },\n    std::{\n        collections::HashMap,\n        fs::{self, File},\n        io::Read,\n        path::{Path, PathBuf},\n    },\n};\n\ntype RowIter = Box\u003cdyn Iterator\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e\u003e;\n\npub struct CsvStorage {\n    pub path: PathBuf,\n}\n\nimpl CsvStorage {\n    pub fn new\u003cT: AsRef\u003cPath\u003e\u003e(path: T) -\u003e Result\u003cSelf\u003e {\n        let path = path.as_ref();\n        fs::create_dir_all(path).map_storage_err()?;\n        let path = PathBuf::from(path);\n\n        Ok(Self { path })\n    }\n\n    fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003c(Schema, bool)\u003e\u003e {\n        let schema_path = self.schema_path(table_name);\n        if !schema_path.exists() {\n            let data_path = self.data_path(table_name);\n            let types_path = self.types_path(table_name);\n\n            let column_defs = match (types_path.exists(), data_path.exists()) {\n                (false, false) =\u003e return Ok(None),\n                (false, true) =\u003e Some(\n                    csv::Reader::from_path(data_path)\n                        .map_storage_err()?\n                        .headers()\n                        .map_storage_err()?\n                        .into_iter()\n                        .map(|header| ColumnDef {\n                            name: header.to_string(),\n                            data_type: DataType::Text,\n                            unique: None,\n                            default: None,\n                            nullable: true,\n                            comment: None,\n                        })\n                        .collect::\u003cVec\u003c_\u003e\u003e(),\n                ),\n                (true, _) =\u003e None,\n            };\n\n            let schema = Schema {\n                table_name: table_name.to_owned(),\n                column_defs,\n                indexes: Vec::new(),\n                engine: None,\n                foreign_keys: Vec::new(),\n                comment: None,\n            };\n\n            return Ok(Some((schema, true)));\n        }\n\n        let mut file = File::open(\u0026schema_path).map_storage_err()?;\n        let mut ddl = String::new();\n        file.read_to_string(\u0026mut ddl).map_storage_err()?;\n\n        let schema = Schema::from_ddl(\u0026ddl)?;\n        if schema.table_name != table_name {\n            return Err(CsvStorageError::TableNameDoesNotMatchWithFile.into());\n        }\n\n        Ok(Some((schema, false)))\n    }\n\n    fn path_by(\u0026self, table_name: \u0026str, extension: \u0026str) -\u003e PathBuf {\n        let path = self.path.as_path();\n        let mut path = path.join(table_name);\n        path.set_extension(extension);\n\n        path\n    }\n\n    fn schema_path(\u0026self, table_name: \u0026str) -\u003e PathBuf {\n        self.path_by(table_name, \"sql\")\n    }\n\n    fn data_path(\u0026self, table_name: \u0026str) -\u003e PathBuf {\n        self.path_by(table_name, \"csv\")\n    }\n\n    fn tmp_data_path(\u0026self, table_name: \u0026str) -\u003e PathBuf {\n        self.path_by(table_name, \"tmp.csv\")\n    }\n\n    fn types_path(\u0026self, table_name: \u0026str) -\u003e PathBuf {\n        self.path_by(table_name, \"types.csv\")\n    }\n\n    fn tmp_types_path(\u0026self, table_name: \u0026str) -\u003e PathBuf {\n        self.path_by(table_name, \"types.tmp.csv\")\n    }\n\n    fn scan_data(\u0026self, table_name: \u0026str) -\u003e Result\u003c(Option\u003cVec\u003cString\u003e\u003e, RowIter)\u003e {\n        let data_path = self.data_path(table_name);\n        let (schema, generated) = match (self.fetch_schema(table_name)?, data_path.exists()) {\n            (None, _) | (_, false) =\u003e return Ok((None, Box::new(std::iter::empty()))),\n            (Some(v), true) =\u003e v,\n        };\n\n        let mut data_rdr = csv::Reader::from_path(data_path).map_storage_err()?;\n        let mut fetch_data_header_columns = || -\u003e Result\u003cVec\u003cString\u003e\u003e {\n            Ok(data_rdr\n                .headers()\n                .map_storage_err()?\n                .into_iter()\n                .map(|header| header.to_string())\n                .collect::\u003cVec\u003c_\u003e\u003e())\n        };\n\n        if let Schema {\n            column_defs: Some(column_defs),\n            ..\n        } = schema\n        {\n            let columns = column_defs\n                .iter()\n                .map(|column_def| column_def.name.to_owned())\n                .collect::\u003cVec\u003c_\u003e\u003e();\n\n            let rows = data_rdr\n                .into_records()\n                .enumerate()\n                .map(move |(index, record)| {\n                    let mut key: Option\u003cKey\u003e = None;\n\n                    let values = record\n                        .map_storage_err()?\n                        .into_iter()\n                        .zip(column_defs.iter())\n                        .map(|(value, column_def)| {\n                            let value = match value {\n                                \"NULL\" =\u003e Value::Null,\n                                _ =\u003e Value::Str(value.to_owned()),\n                            };\n\n                            let value = match \u0026column_def.data_type {\n                                DataType::Text =\u003e value,\n                                data_type =\u003e value.cast(data_type)?,\n                            };\n\n                            if column_def.unique == Some(ColumnUniqueOption { is_primary: true }) {\n                                key = Key::try_from(\u0026value).map(Some)?;\n                            }\n\n                            Ok(value)\n                        })\n                        .collect::\u003cResult\u003cVec\u003cValue\u003e\u003e\u003e()?;\n\n                    let key = key.unwrap_or(Key::U64(index as u64));\n                    let row = DataRow::Vec(values);\n\n                    Ok((key, row))\n                });\n\n            Ok((Some(columns), Box::new(rows)))\n        } else if self.types_path(table_name).exists() {\n            let types_path = self.types_path(table_name);\n            let types_rdr = csv::Reader::from_path(types_path)\n                .map_storage_err()?\n                .into_records();\n\n            let columns = fetch_data_header_columns()?;\n            let rows = data_rdr.into_records().zip(types_rdr).enumerate().map(\n                move |(index, (record, types))| {\n                    let key = Key::U64(index as u64);\n                    let record = record.map_storage_err()?;\n                    let types = types.map_storage_err()?;\n\n                    record\n                        .into_iter()\n                        .zip(columns.iter())\n                        .zip(\u0026types)\n                        .filter_map(|((value, column), data_type)| {\n                            if data_type.is_empty() {\n                                return None;\n                            }\n\n                            let value = if data_type == \"NULL\" {\n                                Ok(Value::Null)\n                            } else {\n                                parse_data_type(data_type).and_then(|data_type| {\n                                    let data_type = translate_data_type(\u0026data_type)?;\n                                    let value = Value::Str(value.to_owned());\n\n                                    match data_type {\n                                        DataType::Text =\u003e Ok(value),\n                                        data_type =\u003e value.cast(\u0026data_type),\n                                    }\n                                })\n                            };\n\n                            Some(value.map(|value| (column.clone(), value)))\n                        })\n                        .collect::\u003cResult\u003cHashMap\u003cString, Value\u003e\u003e\u003e()\n                        .map(DataRow::Map)\n                        .map(|row| (key, row))\n                },\n            );\n\n            Ok((None, Box::new(rows)))\n        } else {\n            let columns = fetch_data_header_columns()?;\n            let rows = {\n                let columns = columns.clone();\n\n                data_rdr\n                    .into_records()\n                    .enumerate()\n                    .map(move |(index, record)| {\n                        let key = Key::U64(index as u64);\n                        let row = record\n                            .map_storage_err()?\n                            .into_iter()\n                            .zip(columns.iter())\n                            .map(|(value, column)| (column.clone(), Value::Str(value.to_owned())))\n                            .collect::\u003cHashMap\u003cString, Value\u003e\u003e();\n\n                        Ok((key, DataRow::Map(row)))\n                    })\n            };\n\n            Ok((generated.then_some(columns), Box::new(rows)))\n        }\n    }\n}\n\nimpl AlterTable for CsvStorage {}\nimpl CustomFunction for CsvStorage {}\nimpl CustomFunctionMut for CsvStorage {}\nimpl Index for CsvStorage {}\nimpl IndexMut for CsvStorage {}\nimpl Transaction for CsvStorage {}\nimpl Metadata for CsvStorage {}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":134},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","csv-storage","src","store.rs"],"content":"use {\n    crate::{\n        CsvStorage,\n        error::{CsvStorageError, OptionExt, ResultExt},\n    },\n    async_trait::async_trait,\n    futures::stream::iter,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::Result,\n        store::{DataRow, RowIter, Store},\n    },\n    std::{ffi::OsStr, fs},\n};\n\n#[async_trait(?Send)]\nimpl Store for CsvStorage {\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        self.fetch_schema(table_name)\n            .map(|schema| schema.map(|(schema, _)| schema))\n    }\n\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let paths = fs::read_dir(\u0026self.path).map_storage_err()?;\n        let mut schemas = paths\n            .map(|result| {\n                let path = result.map_storage_err()?.path();\n                let extension = path.extension().and_then(OsStr::to_str);\n                if extension != Some(\"csv\") || path.to_string_lossy().ends_with(\".types.csv\") {\n                    return Ok(None);\n                }\n\n                let table_name = path\n                    .file_stem()\n                    .and_then(OsStr::to_str)\n                    .map_storage_err(CsvStorageError::FileNotFound)?;\n\n                self.fetch_schema(table_name)?\n                    .map(|(schema, _)| schema)\n                    .map_storage_err(CsvStorageError::TableDoesNotExist)\n                    .map(Some)\n            })\n            .filter_map(Result::transpose)\n            .collect::\u003cResult\u003cVec\u003cSchema\u003e\u003e\u003e()?;\n\n        schemas.sort_by(|a, b| a.table_name.cmp(\u0026b.table_name));\n\n        Ok(schemas)\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, target: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        let (_, rows) = self.scan_data(table_name)?;\n\n        for item in rows {\n            let (key, row) = item?;\n\n            if \u0026key == target {\n                return Ok(Some(row));\n            }\n        }\n\n        Ok(None)\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        let rows = self.scan_data(table_name).map(|(_, rows)| rows)?;\n\n        Ok(Box::pin(iter(rows)))\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","csv-storage","src","store_mut.rs"],"content":"use {\n    crate::{\n        CsvStorage,\n        error::{CsvStorageError, ResultExt},\n    },\n    async_trait::async_trait,\n    csv::Writer,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::Result,\n        store::{DataRow, StoreMut},\n    },\n    std::{\n        cmp::Ordering,\n        collections::BTreeSet,\n        fs::{File, OpenOptions, remove_file, rename},\n        io::Write,\n        iter::Peekable,\n        vec::IntoIter,\n    },\n};\n\n#[async_trait(?Send)]\nimpl StoreMut for CsvStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let schema_path = self.schema_path(schema.table_name.as_str());\n        let ddl = schema.to_ddl();\n        let mut file = File::create(schema_path).map_storage_err()?;\n        file.write_all(ddl.as_bytes()).map_storage_err()?;\n\n        let column_defs = match \u0026schema.column_defs {\n            Some(column_defs) =\u003e column_defs,\n            None =\u003e {\n                return Ok(());\n            }\n        };\n\n        let columns = column_defs\n            .iter()\n            .map(|column_def| column_def.name.as_str())\n            .collect::\u003cVec\u003c\u0026str\u003e\u003e();\n        let data_path = self.data_path(schema.table_name.as_str());\n\n        File::create(data_path)\n            .map_storage_err()\n            .map(Writer::from_writer)?\n            .write_record(\u0026columns)\n            .map_storage_err()\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let data_path = self.data_path(table_name);\n        if data_path.exists() {\n            remove_file(data_path).map_storage_err()?;\n        }\n\n        let types_path = self.types_path(table_name);\n        if types_path.exists() {\n            remove_file(types_path).map_storage_err()?;\n        }\n\n        let schema_path = self.schema_path(table_name);\n        if schema_path.exists() {\n            remove_file(schema_path).map_storage_err()?;\n        }\n\n        Ok(())\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let (columns, prev_rows) = self.scan_data(table_name)?;\n\n        if columns.is_some() {\n            let data_path = self.data_path(table_name);\n            let mut wtr = OpenOptions::new()\n                .append(true)\n                .open(data_path)\n                .map_storage_err()\n                .map(Writer::from_writer)?;\n\n            for row in rows {\n                let row = convert(row)?;\n\n                wtr.write_record(\u0026row).map_storage_err()?;\n            }\n\n            Ok(())\n        } else {\n            let rows = prev_rows\n                .map(|item| item.map(|(_, row)| row))\n                .chain(rows.into_iter().map(Ok));\n\n            self.write(table_name, columns, rows)\n        }\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, mut rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        let (columns, prev_rows) = self.scan_data(table_name)?;\n\n        rows.sort_by(|(key_a, _), (key_b, _)| key_a.cmp(key_b));\n\n        let merged = SortMerge::new(prev_rows, rows.into_iter());\n\n        self.write(table_name, columns, merged)\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        let (columns, prev_rows) = self.scan_data(table_name)?;\n        let rows = prev_rows.filter_map(|item| {\n            let (key, data_row) = match item {\n                Ok(item) =\u003e item,\n                Err(e) =\u003e return Some(Err(e)),\n            };\n\n            keys.iter()\n                .all(|target_key| target_key != \u0026key)\n                .then_some(Ok(data_row))\n        });\n\n        self.write(table_name, columns, rows)\n    }\n}\n\nimpl CsvStorage {\n    fn write\u003cT: Iterator\u003cItem = Result\u003cDataRow\u003e\u003e\u003e(\n        \u0026self,\n        table_name: \u0026str,\n        columns: Option\u003cVec\u003cString\u003e\u003e,\n        rows: T,\n    ) -\u003e Result\u003c()\u003e {\n        let tmp_data_path = self.tmp_data_path(table_name);\n        let mut data_wtr = File::create(\u0026tmp_data_path)\n            .map_storage_err()\n            .map(Writer::from_writer)?;\n\n        if let Some(columns) = columns {\n            data_wtr.write_record(\u0026columns).map_storage_err()?;\n\n            for row in rows {\n                let row = convert(row?)?;\n\n                data_wtr.write_record(\u0026row).map_storage_err()?;\n            }\n        } else {\n            let tmp_types_path = self.tmp_types_path(table_name);\n            let mut types_wtr = File::create(\u0026tmp_types_path)\n                .map(Writer::from_writer)\n                .map_storage_err()?;\n\n            let mut columns = BTreeSet::new();\n            let rows = rows\n                .map(|row| match row? {\n                    DataRow::Vec(_) =\u003e {\n                        Err(CsvStorageError::UnreachableVecTypeDataRowTypeFound.into())\n                    }\n                    DataRow::Map(values) =\u003e Ok(values),\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n            for row in \u0026rows {\n                columns.extend(row.keys());\n            }\n\n            data_wtr.write_record(\u0026columns).map_storage_err()?;\n            types_wtr.write_record(\u0026columns).map_storage_err()?;\n\n            for row in \u0026rows {\n                let (row, data_types): (Vec\u003c_\u003e, Vec\u003c_\u003e) = columns\n                    .iter()\n                    .map(|key| {\n                        row.get(key.as_str())\n                            .map(|value| {\n                                let data_type = value\n                                    .get_type()\n                                    .map(|t| t.to_string())\n                                    .unwrap_or(\"NULL\".to_owned());\n\n                                (String::from(value), data_type)\n                            })\n                            .unwrap_or((\"NULL\".to_owned(), \"\".to_owned()))\n                    })\n                    .unzip();\n\n                data_wtr.write_record(\u0026row).map_storage_err()?;\n                types_wtr.write_record(\u0026data_types).map_storage_err()?;\n            }\n\n            rename(tmp_types_path, self.types_path(table_name)).map_storage_err()?\n        }\n\n        rename(tmp_data_path, self.data_path(table_name)).map_storage_err()\n    }\n}\n\nfn convert(data_row: DataRow) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    match data_row {\n        DataRow::Vec(values) =\u003e Ok(values.into_iter().map(String::from).collect()),\n        DataRow::Map(_) =\u003e Err(CsvStorageError::UnreachableMapTypeDataRowFound.into()),\n    }\n}\n\nstruct SortMerge\u003cT: Iterator\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e\u003e {\n    left_rows: Peekable\u003cT\u003e,\n    right_rows: Peekable\u003cIntoIter\u003c(Key, DataRow)\u003e\u003e,\n}\n\nimpl\u003cT\u003e SortMerge\u003cT\u003e\nwhere\n    T: Iterator\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e,\n{\n    fn new(left_rows: T, right_rows: IntoIter\u003c(Key, DataRow)\u003e) -\u003e Self {\n        let left_rows = left_rows.peekable();\n        let right_rows = right_rows.peekable();\n\n        Self {\n            left_rows,\n            right_rows,\n        }\n    }\n}\nimpl\u003cT\u003e Iterator for SortMerge\u003cT\u003e\nwhere\n    T: Iterator\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e,\n{\n    type Item = Result\u003cDataRow\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let left = self.left_rows.peek();\n        let right = self.right_rows.peek();\n\n        match (left, right) {\n            (Some(Ok((left_key, _))), Some((right_key, _))) =\u003e match left_key.cmp(right_key) {\n                Ordering::Less =\u003e self.left_rows.next(),\n                Ordering::Greater =\u003e self.right_rows.next().map(Ok),\n                Ordering::Equal =\u003e {\n                    self.left_rows.next();\n                    self.right_rows.next().map(Ok)\n                }\n            }\n            .map(|item| Ok(item?.1)),\n            (Some(_), _) =\u003e self.left_rows.next().map(|item| Ok(item?.1)),\n            (None, Some(_)) =\u003e self.right_rows.next().map(|item| Ok(item.1)),\n            (None, None) =\u003e None,\n        }\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":113},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","csv-storage","tests","basic.rs"],"content":"use {\n    gluesql_core::prelude::{\n        Glue,\n        Value::{I64, Str},\n    },\n    gluesql_csv_storage::CsvStorage,\n    test_suite::*,\n};\n\n#[tokio::test]\nasync fn basic() {\n    let path = \"./tests/samples/\";\n    let storage = CsvStorage::new(path).unwrap();\n    let mut glue = Glue::new(storage);\n\n    let actual = glue\n        .execute(\"SELECT * FROM Employee\")\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = select! {\n        Name                | Age            | Gender             | Occupation\n        Str                 | Str            | Str                | Str;\n        \"John\".to_owned()     \"25\".to_owned()  \"Male\".to_owned()    \"Engineer\".to_owned();\n        \"Sarah\".to_owned()    \"30\".to_owned()  \"Female\".to_owned()  \"Doctor\".to_owned();\n        \"Michael\".to_owned()  \"40\".to_owned()  \"Male\".to_owned()    \"Lawyer\".to_owned();\n        \"Emily\".to_owned()    \"28\".to_owned()  \"Female\".to_owned()  \"Teacher\".to_owned();\n        \"David\".to_owned()    \"35\".to_owned()  \"Male\".to_owned()    \"Programmer\".to_owned()\n    };\n    assert_eq!(actual, expected);\n\n    let actual = glue\n        .execute(\n            \"\n            SELECT\n                Name,\n                CAST(Age AS INTEGER) AS Age\n            FROM Employee\n         \",\n        )\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = select! {\n        Name                | Age\n        Str                 | I64;\n        \"John\".to_owned()     25;\n        \"Sarah\".to_owned()    30;\n        \"Michael\".to_owned()  40;\n        \"Emily\".to_owned()    28;\n        \"David\".to_owned()    35\n    };\n    assert_eq!(actual, expected);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","csv-storage","tests","csv_storage.rs"],"content":"use {\n    async_trait::async_trait, gluesql_core::prelude::Glue, gluesql_csv_storage::CsvStorage,\n    std::fs::remove_dir_all, test_suite::*,\n};\n\nstruct CsvTester {\n    glue: Glue\u003cCsvStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cCsvStorage\u003e for CsvTester {\n    async fn new(namespace: \u0026str) -\u003e Self {\n        let path = format!(\"tmp/{namespace}\");\n\n        if let Err(e) = remove_dir_all(\u0026path) {\n            println!(\"fs::remove_file {:?}\", e);\n        };\n\n        let storage = CsvStorage::new(\u0026path).expect(\"CsvStorage::new\");\n        let glue = Glue::new(storage);\n        CsvTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cCsvStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, CsvTester);\ngenerate_alter_table_tests!(tokio::test, CsvTester);\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","csv-storage","tests","error.rs"],"content":"use {\n    gluesql_core::prelude::Glue,\n    gluesql_csv_storage::{CsvStorage, error::CsvStorageError},\n};\n\n#[tokio::test]\nasync fn error() {\n    let path = \"./tests/samples/\";\n    let storage = CsvStorage::new(path).unwrap();\n    let mut glue = Glue::new(storage);\n\n    let actual = glue.execute(\"SELECT * FROM WrongSchemaName\").await;\n    let expected = Err(CsvStorageError::TableNameDoesNotMatchWithFile.into());\n    assert_eq!(actual, expected);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","csv-storage","tests","schema.rs"],"content":"use {\n    gluesql_core::prelude::{\n        Glue,\n        Value::{I64, Str},\n    },\n    gluesql_csv_storage::CsvStorage,\n    test_suite::*,\n};\n\n#[tokio::test]\nasync fn schema() {\n    let path = \"./tests/samples/\";\n    let storage = CsvStorage::new(path).unwrap();\n    let mut glue = Glue::new(storage);\n\n    let actual = glue\n        .execute(\"SELECT * FROM City\")\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = select! {\n        Country                    | City                       | Population\n        Str                        | Str                        | I64;\n        \"South Korea\".to_owned()     \"Seoul\".to_owned()           9736962;\n        \"Japan\".to_owned()           \"Tokyo\".to_owned()           13515271;\n        \"China\".to_owned()           \"Shanghai\".to_owned()        24281000;\n        \"United States\".to_owned()   \"New York City\".to_owned()   8336817;\n        \"Italy\".to_owned()           \"Milan\".to_owned()           2837332\n    };\n    assert_eq!(actual, expected);\n\n    let actual = glue\n        .execute(\"SELECT * FROM City WHERE Population \u003c 10000000\")\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = select! {\n        Country                    | City                       | Population\n        Str                        | Str                        | I64;\n        \"South Korea\".to_owned()     \"Seoul\".to_owned()           9736962;\n        \"United States\".to_owned()   \"New York City\".to_owned()   8336817;\n        \"Italy\".to_owned()           \"Milan\".to_owned()           2837332\n    };\n    assert_eq!(actual, expected);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","csv-storage","tests","schemaless.rs"],"content":"use {\n    gluesql_core::{\n        error::FetchError,\n        prelude::{\n            Glue,\n            Value::{self, I64, Null, Str},\n        },\n    },\n    gluesql_csv_storage::CsvStorage,\n    serde_json::json,\n    test_suite::*,\n};\n\n#[tokio::test]\nasync fn schemaless() {\n    let path = \"./tests/samples/\";\n    let storage = CsvStorage::new(path).unwrap();\n    let mut glue = Glue::new(storage);\n\n    let actual = glue\n        .execute(\"SELECT * FROM Student\")\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = select_map![\n        json!({\n            \"Name\": \"John\",\n            \"Gender\": \"Male\",\n            \"Age\": 18,\n            \"Grade\": \"A\"\n        }),\n        json!({\n            \"Name\": \"Jane\",\n            \"Gender\": \"Female\",\n            \"Age\": 17,\n            \"Grade\": \"B\"\n        }),\n        json!({\n            \"Name\": \"Bob\",\n            \"Grade\": \"C\"\n        }),\n        json!({\n            \"Name\": \"Alice\",\n            \"Gender\": \"Female\",\n            \"Age\": 18\n        }),\n        json!({\n            \"Name\": \"Mike\",\n            \"Gender\": \"Male\",\n            \"Grade\": \"B\"\n        }),\n        json!({\n            \"Name\": \"Lisa\",\n            \"Age\": 18,\n            \"Grade\": \"A\"\n        })\n    ];\n    assert_eq!(actual, expected);\n\n    let actual = glue\n        .execute(\"SELECT Name, Gender, Age, Grade FROM Student\")\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = select_with_null! {\n        Name                    | Gender                   | Age     | Grade;\n        Str(\"John\".to_owned())    Str(\"Male\".to_owned())     I64(18)   Str(\"A\".to_owned());\n        Str(\"Jane\".to_owned())    Str(\"Female\".to_owned())   I64(17)   Str(\"B\".to_owned());\n        Str(\"Bob\".to_owned())     Null                       Null      Str(\"C\".to_owned());\n        Str(\"Alice\".to_owned())   Str(\"Female\".to_owned())   I64(18)   Null;\n        Str(\"Mike\".to_owned())    Str(\"Male\".to_owned())     Null      Str(\"B\".to_owned());\n        Str(\"Lisa\".to_owned())    Null                       I64(18)   Str(\"A\".to_owned())\n    };\n    assert_eq!(actual, expected);\n\n    let actual = glue\n        .execute(\"SELECT Name FROM Student WHERE Age \u003c 18\")\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = select!(Name Str; \"Jane\".to_owned());\n    assert_eq!(actual, expected);\n}\n\n#[tokio::test]\nasync fn schemaless_create_and_drop_table() {\n    let path = \"./tests/samples/\";\n    let storage = CsvStorage::new(path).unwrap();\n    let mut glue = Glue::new(storage);\n\n    glue.execute(\"CREATE TABLE Foo\").await.unwrap();\n    glue.execute(r#\"INSERT INTO Foo VALUES ('{ \"a\": 1 }')\"#)\n        .await\n        .unwrap();\n\n    let actual = glue\n        .execute(\"SELECT * FROM Foo\")\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = select_map![json!({ \"a\": 1 })];\n    assert_eq!(actual, expected);\n\n    glue.execute(\"DROP TABLE Foo\").await.unwrap();\n\n    let actual = glue.execute(\"SELECT * FROM Foo\").await;\n    let expected = Err(FetchError::TableNotFound(\"Foo\".to_owned()).into());\n    assert_eq!(actual, expected);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","csv-storage","tests","schemaless_without_types.rs"],"content":"use {\n    gluesql_core::prelude::{\n        Glue,\n        Value::{self, Str},\n    },\n    gluesql_csv_storage::CsvStorage,\n    serde_json::json,\n    std::fs,\n    test_suite::*,\n};\n\n#[tokio::test]\nasync fn schemaless_without_types() {\n    let path = \"./tests/samples/\";\n    let storage = CsvStorage::new(path).unwrap();\n    let mut glue = Glue::new(storage);\n\n    let actual = glue\n        .execute(\"SELECT * FROM Book\")\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = select_map![\n        json!({\n            \"Title\": \"To Kill a Mockingbird\",\n            \"Author\": \"Harper Lee\",\n            \"Genre\": \"\",\n            \"Year\": \"1960\",\n            \"Publisher\": \"J. B. Lippincott \u0026 Co.\",\n            \"Price\": \"\"\n        }),\n        json!({\n            \"Title\": \"The Great Gatsby\",\n            \"Author\": \"F. Scott Fitzgerald\",\n            \"Genre\": \"Classic\",\n            \"Year\": \"1925\",\n            \"Publisher\": \"\",\n            \"Price\": \"9.99\"\n        }),\n        json!({\n            \"Title\": \"1984\",\n            \"Author\": \"George Orwell\",\n            \"Genre\": \"Dystopian\",\n            \"Year\": \"\",\n            \"Publisher\": \"Secker \u0026 Warburg\",\n            \"Price\": \"7.99\"\n        }),\n        json!({\n            \"Title\": \"The Catcher in the Rye\",\n            \"Author\": \"J. D. Salinger\",\n            \"Genre\": \"Coming-of-age\",\n            \"Year\": \"1951\",\n            \"Publisher\": \"Little, Brown and Company\",\n            \"Price\": \"6.99\"\n        }),\n        json!({\n            \"Title\": \"Pride and Prejudice\",\n            \"Author\": \"Jane Austen\",\n            \"Genre\": \"Romance\",\n            \"Year\": \"1813\",\n            \"Publisher\": \"\",\n            \"Price\": \"\"\n        })\n    ];\n    assert_eq!(actual, expected);\n\n    let actual = glue\n        .execute(\n            \"\n            SELECT Title\n            FROM Book\n            WHERE\n                CASE LENGTH(Price) \n                    WHEN 0 THEN FALSE\n                    ELSE CAST(Price AS DECIMAL) \u003e 6.99\n                END\n            \",\n        )\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = select!(\n        Title\n        Str;\n        \"The Great Gatsby\".to_owned();\n        \"1984\".to_owned()\n    );\n    assert_eq!(actual, expected);\n\n    glue.execute(\n        r#\"\n        INSERT INTO Book\n        VALUES (\n            '{ \"Title\": \"New Book Temporary\", \"Price\": \"100\" }'\n        )\n        \"#,\n    )\n    .await\n    .unwrap();\n\n    let actual = glue\n        .execute(\"SELECT * FROM Book WHERE Price = '100'\")\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = select_map![json!({\n        \"Title\": \"New Book Temporary\",\n        \"Price\": \"100\"\n    })];\n    assert_eq!(actual, expected);\n\n    glue.execute(\n        r#\"\n        UPDATE Book SET Year = '1925' WHERE Title = 'New Book Temporary'\n        \"#,\n    )\n    .await\n    .unwrap();\n\n    let actual = glue\n        .execute(\"SELECT * FROM Book WHERE Year = '1925'\")\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = select_map![\n        json!({\n            \"Title\": \"The Great Gatsby\",\n            \"Author\": \"F. Scott Fitzgerald\",\n            \"Genre\": \"Classic\",\n            \"Year\": \"1925\",\n            \"Publisher\": \"\",\n            \"Price\": \"9.99\"\n        }),\n        json!({\n            \"Title\": \"New Book Temporary\",\n            \"Year\": \"1925\",\n            \"Price\": \"100\"\n        })\n    ];\n    assert_eq!(actual, expected);\n\n    glue.execute(\"DELETE FROM Book WHERE Title = 'New Book Temporary'\")\n        .await\n        .unwrap();\n\n    fs::remove_file(format!(\"{path}Book.types.csv\")).unwrap_or(());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","csv-storage","tests","types_only.rs"],"content":"use {\n    gluesql_core::prelude::{\n        Glue, Payload,\n        Value::{Date, Decimal, I64, Null, Str},\n    },\n    gluesql_csv_storage::CsvStorage,\n    rust_decimal_macros::dec,\n    std::collections::HashMap,\n};\n\nmacro_rules! date {\n    ($date: expr) =\u003e {\n        Date($date.parse().unwrap())\n    };\n}\n\n#[tokio::test]\nasync fn types_only() {\n    let path = \"./tests/samples/\";\n    let storage = CsvStorage::new(path).unwrap();\n    let mut glue = Glue::new(storage);\n\n    let actual = glue\n        .execute(\"SELECT * FROM Grocery\")\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = [\n        vec![\n            (\"Product Name\", Str(\"Apple\".to_owned())),\n            (\"Price\", Decimal(dec!(1.99))),\n            (\"Quantity\", I64(100)),\n            (\"Manufacturer\", Str(\"Apple Inc.\".to_owned())),\n            (\"Expiration Date\", date!(\"2022-08-31\")),\n        ],\n        vec![\n            (\"Product Name\", Str(\"Banana\".to_owned())),\n            (\"Price\", Decimal(dec!(0.99))),\n            (\"Quantity\", I64(50)),\n            (\"Manufacturer\", Str(\"Chiquita Brands LLC\".to_owned())),\n            (\"Expiration Date\", date!(\"2022-09-01\")),\n        ],\n        vec![\n            (\"Product Name\", Str(\"Milk\".to_owned())),\n            (\"Price\", Decimal(dec!(2.49))),\n            (\"Manufacturer\", Str(\"Dean Foods Company\".to_owned())),\n            (\"Expiration Date\", date!(\"2022-08-30\")),\n        ],\n        vec![\n            (\"Product Name\", Str(\"Bread\".to_owned())),\n            (\"Price\", Decimal(dec!(1.99))),\n            (\"Quantity\", I64(30)),\n            (\"Manufacturer\", Str(\"Sara Lee Corporation\".to_owned())),\n            (\"Expiration Date\", Null),\n        ],\n        vec![\n            (\"Product Name\", Str(\"Eggs\".to_owned())),\n            (\"Price\", Decimal(dec!(2.99))),\n            (\"Quantity\", I64(40)),\n            (\"Expiration Date\", date!(\"2022-09-02\")),\n        ],\n    ]\n    .into_iter()\n    .map(|row| {\n        row.into_iter()\n            .map(|(k, v)| (k.to_owned(), v))\n            .collect::\u003cHashMap\u003c_, _\u003e\u003e()\n    })\n    .collect::\u003cVec\u003c_\u003e\u003e();\n    let expected = Payload::SelectMap(expected);\n    assert_eq!(actual, expected);\n\n    let actual = glue\n        .execute(\n            r#\"\n            SELECT \"Product Name\" AS name\n            FROM Grocery\n            WHERE \"Expiration Date\" IS NULL\n            \"#,\n        )\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = Payload::Select {\n        labels: vec![\"name\".to_owned()],\n        rows: vec![vec![Str(\"Bread\".to_owned())]],\n    };\n    assert_eq!(actual, expected);\n\n    let actual = glue\n        .execute(\n            r#\"\n            SELECT \"Product Name\" AS name\n            FROM Grocery\n            WHERE\n                Price \u003e= 2 AND\n                \"Expiration Date\" \u003c DATE '2022-09-02'\n            \"#,\n        )\n        .await\n        .unwrap()\n        .into_iter()\n        .next()\n        .unwrap();\n    let expected = Payload::Select {\n        labels: vec![\"name\".to_owned()],\n        rows: vec![vec![Str(\"Milk\".to_owned())]],\n    };\n    assert_eq!(actual, expected);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","file-storage","src","lib.rs"],"content":"#![deny(clippy::str_to_string)]\n\nmod store;\nmod store_mut;\n\nuse {\n    gluesql_core::{\n        data::{Key, Schema},\n        error::{Error, Result},\n        store::{\n            AlterTable, CustomFunction, CustomFunctionMut, DataRow, Index, IndexMut, Metadata,\n            Transaction,\n        },\n    },\n    hex::ToHex,\n    serde::{Deserialize, Serialize},\n    std::{\n        convert::AsRef,\n        fs,\n        path::{Path, PathBuf},\n    },\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FileStorage {\n    pub path: PathBuf,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct FileRow {\n    pub key: Key,\n    pub row: DataRow,\n}\n\nimpl FileStorage {\n    pub fn new\u003cT: AsRef\u003cPath\u003e\u003e(path: T) -\u003e Result\u003cSelf\u003e {\n        let path = path.as_ref();\n        fs::create_dir_all(path).map_storage_err()?;\n\n        Ok(Self { path: path.into() })\n    }\n\n    pub fn path\u003cT: AsRef\u003cPath\u003e\u003e(\u0026self, table_name: T) -\u003e PathBuf {\n        let mut path = self.path.clone();\n        path.push(table_name);\n        path\n    }\n\n    pub fn data_path\u003cT: AsRef\u003cPath\u003e\u003e(\u0026self, table_name: T, key: \u0026Key) -\u003e Result\u003cPathBuf\u003e {\n        let mut path = self.path(table_name);\n        let key = key.to_cmp_be_bytes()?.encode_hex::\u003cString\u003e();\n\n        path.push(key);\n        let path = path.with_extension(\"ron\");\n\n        Ok(path)\n    }\n\n    fn fetch_schema(\u0026self, path: PathBuf) -\u003e Result\u003cSchema\u003e {\n        fs::read_to_string(path)\n            .map_storage_err()\n            .and_then(|data| Schema::from_ddl(\u0026data))\n    }\n}\n\npub trait ResultExt\u003cT, E: ToString\u003e {\n    fn map_storage_err(self) -\u003e Result\u003cT, Error\u003e;\n}\n\nimpl\u003cT, E: ToString\u003e ResultExt\u003cT, E\u003e for std::result::Result\u003cT, E\u003e {\n    fn map_storage_err(self) -\u003e Result\u003cT, Error\u003e {\n        self.map_err(|e| e.to_string()).map_err(Error::StorageMsg)\n    }\n}\n\nimpl AlterTable for FileStorage {}\nimpl Index for FileStorage {}\nimpl IndexMut for FileStorage {}\nimpl Transaction for FileStorage {}\nimpl Metadata for FileStorage {}\nimpl CustomFunction for FileStorage {}\nimpl CustomFunctionMut for FileStorage {}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","file-storage","src","store.rs"],"content":"use {\n    crate::{FileRow, FileStorage, ResultExt},\n    async_trait::async_trait,\n    futures::stream::iter,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::Result,\n        store::{DataRow, RowIter, Store},\n    },\n    std::{ffi::OsStr, fs},\n};\n\n#[async_trait(?Send)]\nimpl Store for FileStorage {\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let mut schemas = fs::read_dir(\u0026self.path)\n            .map_storage_err()?\n            .map(|dir_entry| {\n                let dir_entry = dir_entry.map_storage_err()?;\n                let file_type = dir_entry.file_type().map_storage_err()?;\n                let path = dir_entry.path();\n                let extension = path.extension().and_then(OsStr::to_str);\n                if file_type.is_dir() || extension != Some(\"sql\") {\n                    return Ok(None);\n                }\n\n                self.fetch_schema(path).map(Some)\n            })\n            .filter_map(Result::transpose)\n            .collect::\u003cResult\u003cVec\u003cSchema\u003e\u003e\u003e()?;\n\n        schemas.sort_by(|a, b| a.table_name.cmp(\u0026b.table_name));\n\n        Ok(schemas)\n    }\n\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        let path = self.path(table_name).with_extension(\"sql\");\n        if !path.exists() {\n            return Ok(None);\n        }\n\n        self.fetch_schema(path).map(Some)\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, key: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        let path = self.data_path(table_name, key)?;\n        if !path.exists() {\n            return Ok(None);\n        }\n\n        fs::read_to_string(path)\n            .map_storage_err()\n            .and_then(|data| {\n                ron::from_str(\u0026data)\n                    .map_storage_err()\n                    .map(|FileRow { row, .. }| row)\n            })\n            .map(Some)\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        let path = self.path(table_name);\n        let mut entries = fs::read_dir(path)\n            .map_storage_err()?\n            .map(|dir_entry| {\n                let dir_entry = dir_entry.map_storage_err()?;\n                let file_type = dir_entry.file_type().map_storage_err()?;\n                let path = dir_entry.path();\n                let extension = path.extension().and_then(OsStr::to_str);\n                if file_type.is_dir() || extension != Some(\"ron\") {\n                    return Ok(None);\n                }\n\n                Ok(Some(path))\n            })\n            .filter_map(Result::transpose)\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        entries.sort();\n\n        let rows = entries.into_iter().map(|path| {\n            let data = fs::read_to_string(path).map_storage_err()?;\n\n            ron::from_str(\u0026data)\n                .map_storage_err()\n                .map(|FileRow { key, row }| (key, row))\n        });\n\n        Ok(Box::pin(iter(rows)))\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","file-storage","src","store_mut.rs"],"content":"use {\n    crate::{FileRow, FileStorage, ResultExt},\n    async_trait::async_trait,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::Result,\n        store::{DataRow, StoreMut},\n    },\n    ron::ser::{PrettyConfig, to_string_pretty},\n    std::{\n        fs::{self, File},\n        io::Write,\n    },\n    uuid::Uuid,\n};\n\n#[async_trait(?Send)]\nimpl StoreMut for FileStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let table_name = schema.table_name.clone();\n        let schema = schema.to_ddl();\n        let path = self.path(table_name);\n        if !path.exists() {\n            fs::create_dir(\u0026path).map_storage_err()?;\n        }\n\n        let path = path.with_extension(\"sql\");\n        if path.exists() {\n            fs::remove_file(\u0026path).map_storage_err()?;\n        }\n\n        let mut file = File::create(path).map_storage_err()?;\n        file.write_all(schema.as_bytes()).map_storage_err()?;\n\n        Ok(())\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let path = self.path(table_name);\n        if !path.exists() {\n            return Ok(());\n        }\n\n        fs::remove_dir_all(\u0026path).map_storage_err()?;\n\n        let path = path.with_extension(\"sql\");\n        fs::remove_file(path).map_storage_err()?;\n\n        Ok(())\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        for row in rows {\n            let key = Key::Uuid(Uuid::now_v7().as_u128());\n            let path = self.data_path(table_name, \u0026key)?;\n            let row = FileRow { key, row };\n            let row = to_string_pretty(\u0026row, PrettyConfig::default()).map_storage_err()?;\n\n            let mut file = File::create(path).map_storage_err()?;\n            file.write_all(row.as_bytes()).map_storage_err()?;\n        }\n\n        Ok(())\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        for (key, row) in rows {\n            let path = self.data_path(table_name, \u0026key)?;\n            let row = FileRow { key, row };\n            let row = to_string_pretty(\u0026row, PrettyConfig::default()).map_storage_err()?;\n\n            let mut file = File::create(path).map_storage_err()?;\n            file.write_all(row.as_bytes()).map_storage_err()?;\n        }\n\n        Ok(())\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        for key in keys {\n            let path = self.data_path(table_name, \u0026key)?;\n\n            fs::remove_file(path).map_storage_err()?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":42},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","file-storage","tests","file_storage.rs"],"content":"use {\n    async_trait::async_trait,\n    gluesql_core::{data::Value::I64, prelude::Glue},\n    gluesql_file_storage::FileStorage,\n    std::fs::{create_dir, remove_dir_all},\n    test_suite::*,\n};\n\nstruct FileStorageTester {\n    glue: Glue\u003cFileStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cFileStorage\u003e for FileStorageTester {\n    async fn new(namespace: \u0026str) -\u003e Self {\n        let path = format!(\"tmp/{namespace}\");\n\n        if let Err(e) = remove_dir_all(\u0026path) {\n            println!(\"fs::remove_file {:?}\", e);\n        };\n\n        let storage = FileStorage::new(\u0026path).expect(\"FileStorage::new\");\n        let glue = Glue::new(storage);\n        FileStorageTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cFileStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, FileStorageTester);\ngenerate_alter_table_tests!(tokio::test, FileStorageTester);\n\n#[tokio::test]\nasync fn scan_data_to_ignore_directory_items() {\n    let path = \"./tests/ignore_directory_items/\";\n    let storage = FileStorage::new(path).unwrap();\n    let mut glue = Glue::new(storage);\n\n    glue.execute(\"CREATE TABLE Foo (id INTEGER);\")\n        .await\n        .unwrap();\n    glue.execute(\"INSERT TABLE Foo VALUES (1), (2), (3);\")\n        .await\n        .unwrap();\n\n    let dir_path = format!(\"{path}Foo/something_in_data_directory\");\n    create_dir(dir_path).unwrap();\n\n    assert_eq!(\n        glue.execute(\"SELECT * FROM Foo\").await.unwrap().remove(0),\n        select!(id I64; 1; 2; 3)\n    );\n\n    remove_dir_all(path).unwrap();\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","git-storage","src","command_ext.rs"],"content":"use {\n    crate::ResultExt,\n    gluesql_core::error::{Error, Result},\n    std::process::Command,\n};\n\npub trait CommandExt {\n    fn execute(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n}\n\nimpl CommandExt for Command {\n    fn execute(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        let output = self.output().map_storage_err()?;\n\n        if !output.status.success() {\n            let stdout = String::from_utf8_lossy(\u0026output.stdout);\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n\n            let out_and_err = [\n                (!stdout.is_empty()).then(|| format!(\"[stdout] {}\", stdout)),\n                (!stderr.is_empty()).then(|| format!(\"[stderr] {}\", stderr)),\n            ]\n            .into_iter()\n            .flatten()\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\");\n\n            return Err(Error::StorageMsg(out_and_err));\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {crate::CommandExt, std::process::Command};\n\n    #[test]\n    fn test_command_ext() {\n        let path = \"tmp/command_ext_test\";\n\n        Command::new(\"mkdir\").arg(\"-p\").arg(path).execute().unwrap();\n        Command::new(\"git\")\n            .current_dir(path)\n            .arg(\"init\")\n            .execute()\n            .unwrap();\n        Command::new(\"git\")\n            .current_dir(path)\n            .arg(\"checkout\")\n            .arg(\"-b\")\n            .arg(\"main\")\n            .execute()\n            .unwrap();\n\n        let executed = Command::new(\"git\")\n            .current_dir(path)\n            .arg(\"commit\")\n            .arg(\"-m\")\n            .arg(\"test\")\n            .execute();\n        assert!(executed.is_err());\n        assert_eq!(\n            executed.unwrap_err().to_string(),\n            \"storage: [stdout] On branch main\\n\\nInitial commit\\n\\nnothing to commit (create/copy files and use \\\"git add\\\" to track)\\n\"\n        );\n\n        let executed = Command::new(\"git\")\n            .current_dir(path)\n            .arg(\"commit\")\n            .arg(\"-m\")\n            .arg(\"test\")\n            .arg(\"--amend\")\n            .execute();\n        assert!(executed.is_err());\n        assert_eq!(\n            executed.unwrap_err().to_string(),\n            \"storage: [stderr] fatal: You have nothing to amend.\\n\"\n        );\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","git-storage","src","lib.rs"],"content":"#![deny(clippy::str_to_string)]\n\nmod command_ext;\nmod store;\nmod store_mut;\n\npub use command_ext::CommandExt;\nuse {\n    gluesql_core::{\n        error::{Error, Result},\n        store::{\n            AlterTable, CustomFunction, CustomFunctionMut, Index, IndexMut, Metadata, Store,\n            StoreMut, Transaction,\n        },\n    },\n    gluesql_csv_storage::CsvStorage,\n    gluesql_file_storage::FileStorage,\n    gluesql_json_storage::JsonStorage,\n    std::{\n        path::{Path, PathBuf},\n        process::Command,\n    },\n    strum_macros::Display,\n};\n\npub struct GitStorage {\n    pub storage_base: StorageBase,\n    pub path: PathBuf,\n    pub remote: String,\n    pub branch: String,\n}\n\npub enum StorageBase {\n    File(FileStorage),\n    Csv(CsvStorage),\n    Json(JsonStorage),\n}\n\n#[derive(Clone, Copy, Display)]\n#[strum(serialize_all = \"lowercase\")]\npub enum StorageType {\n    File,\n    Csv,\n    Json,\n}\n\nconst DEFAULT_REMOTE: \u0026str = \"origin\";\nconst DEFAULT_BRANCH: \u0026str = \"main\";\n\nimpl GitStorage {\n    pub fn init\u003cT: AsRef\u003cPath\u003e\u003e(path: T, storage_type: StorageType) -\u003e Result\u003cSelf\u003e {\n        let path = path.as_ref();\n        let storage_base = Self::storage_base(path, storage_type)?;\n        Command::new(\"git\")\n            .current_dir(path)\n            .arg(\"init\")\n            .execute()?;\n\n        Ok(Self {\n            storage_base,\n            path: path.to_owned(),\n            remote: DEFAULT_REMOTE.to_owned(),\n            branch: DEFAULT_BRANCH.to_owned(),\n        })\n    }\n\n    pub fn open\u003cT: AsRef\u003cPath\u003e\u003e(path: T, storage_type: StorageType) -\u003e Result\u003cSelf\u003e {\n        let path = path.as_ref();\n        let storage_base = Self::storage_base(path, storage_type)?;\n\n        Ok(Self {\n            storage_base,\n            path: path.to_owned(),\n            remote: DEFAULT_REMOTE.to_owned(),\n            branch: DEFAULT_BRANCH.to_owned(),\n        })\n    }\n\n    fn storage_base(path: \u0026Path, storage_type: StorageType) -\u003e Result\u003cStorageBase\u003e {\n        use StorageType::*;\n\n        match storage_type {\n            File =\u003e FileStorage::new(path).map(StorageBase::File),\n            Csv =\u003e CsvStorage::new(path).map(StorageBase::Csv),\n            Json =\u003e JsonStorage::new(path).map(StorageBase::Json),\n        }\n    }\n\n    pub fn set_remote(\u0026mut self, remote: String) {\n        self.remote = remote;\n    }\n\n    pub fn set_branch(\u0026mut self, branch: String) {\n        self.branch = branch;\n    }\n\n    pub fn add_and_commit(\u0026self, message: \u0026str) -\u003e Result\u003c()\u003e {\n        Command::new(\"git\")\n            .current_dir(\u0026self.path)\n            .arg(\"add\")\n            .arg(\".\")\n            .execute()?;\n\n        Command::new(\"git\")\n            .current_dir(\u0026self.path)\n            .arg(\"commit\")\n            .arg(\"--allow-empty\")\n            .arg(\"-m\")\n            .arg(message)\n            .execute()\n    }\n\n    pub fn pull(\u0026self) -\u003e Result\u003c()\u003e {\n        Command::new(\"git\")\n            .current_dir(\u0026self.path)\n            .arg(\"pull\")\n            .arg(\u0026self.remote)\n            .arg(\u0026self.branch)\n            .execute()\n    }\n\n    pub fn push(\u0026self) -\u003e Result\u003c()\u003e {\n        Command::new(\"git\")\n            .current_dir(\u0026self.path)\n            .arg(\"push\")\n            .arg(\u0026self.remote)\n            .arg(\u0026self.branch)\n            .execute()\n    }\n\n    fn get_store(\u0026self) -\u003e \u0026dyn Store {\n        match \u0026self.storage_base {\n            StorageBase::File(storage) =\u003e storage,\n            StorageBase::Csv(storage) =\u003e storage,\n            StorageBase::Json(storage) =\u003e storage,\n        }\n    }\n\n    fn get_store_mut(\u0026mut self) -\u003e \u0026mut dyn StoreMut {\n        match \u0026mut self.storage_base {\n            StorageBase::File(storage) =\u003e storage,\n            StorageBase::Csv(storage) =\u003e storage,\n            StorageBase::Json(storage) =\u003e storage,\n        }\n    }\n}\n\npub trait ResultExt\u003cT, E: ToString\u003e {\n    fn map_storage_err(self) -\u003e Result\u003cT, Error\u003e;\n}\n\nimpl\u003cT, E: ToString\u003e ResultExt\u003cT, E\u003e for std::result::Result\u003cT, E\u003e {\n    fn map_storage_err(self) -\u003e Result\u003cT, Error\u003e {\n        self.map_err(|e| e.to_string()).map_err(Error::StorageMsg)\n    }\n}\n\nimpl AlterTable for GitStorage {}\nimpl Index for GitStorage {}\nimpl IndexMut for GitStorage {}\nimpl Transaction for GitStorage {}\nimpl Metadata for GitStorage {}\nimpl CustomFunction for GitStorage {}\nimpl CustomFunctionMut for GitStorage {}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":55},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","git-storage","src","store.rs"],"content":"use {\n    crate::GitStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::Result,\n        store::{DataRow, RowIter, Store},\n    },\n};\n\n#[async_trait(?Send)]\nimpl Store for GitStorage {\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        self.get_store().fetch_all_schemas().await\n    }\n\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        self.get_store().fetch_schema(table_name).await\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, key: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        self.get_store().fetch_data(table_name, key).await\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        self.get_store().scan_data(table_name).await\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","git-storage","src","store_mut.rs"],"content":"use {\n    crate::GitStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::Result,\n        store::{DataRow, StoreMut},\n    },\n};\n\n#[async_trait(?Send)]\nimpl StoreMut for GitStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        self.get_store_mut().insert_schema(schema).await?;\n\n        self.add_and_commit(\u0026format!(\n            \"[GitStorage::insert_schema] {}\",\n            schema.table_name\n        ))\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        self.get_store_mut().delete_schema(table_name).await?;\n\n        self.add_and_commit(\"[GitStorage::delete_schema] {table_name}\")\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let n = rows.len();\n        if n == 0 {\n            return Ok(());\n        }\n\n        self.get_store_mut().append_data(table_name, rows).await?;\n\n        self.add_and_commit(\u0026format!(\n            \"[GitStorage::append_data] {table_name} - {n} rows\"\n        ))\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        let n = rows.len();\n        if n == 0 {\n            return Ok(());\n        }\n\n        self.get_store_mut().insert_data(table_name, rows).await?;\n\n        self.add_and_commit(\u0026format!(\n            \"[GitStorage::insert_data] {table_name} - {n} rows\"\n        ))\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        let n = keys.len();\n        if n == 0 {\n            return Ok(());\n        }\n\n        self.get_store_mut().delete_data(table_name, keys).await?;\n\n        self.add_and_commit(\u0026format!(\n            \"[GitStorage::delete_data] {table_name} - {n} rows\"\n        ))\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","git-storage","tests","git_storage_csv.rs"],"content":"use {\n    async_trait::async_trait,\n    gluesql_core::prelude::Glue,\n    gluesql_git_storage::{GitStorage, StorageType},\n    std::fs::remove_dir_all,\n    test_suite::*,\n};\n\nstruct GitStorageTester {\n    glue: Glue\u003cGitStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cGitStorage\u003e for GitStorageTester {\n    async fn new(namespace: \u0026str) -\u003e Self {\n        let path = format!(\"tmp/git_storage_csv/{namespace}\");\n\n        if let Err(e) = remove_dir_all(\u0026path) {\n            println!(\"fs::remove_file {:?}\", e);\n        };\n\n        let storage = GitStorage::init(\u0026path, StorageType::Csv).expect(\"GitStorage::init - CSV\");\n        let glue = Glue::new(storage);\n        GitStorageTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cGitStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, GitStorageTester);\ngenerate_alter_table_tests!(tokio::test, GitStorageTester);\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","git-storage","tests","git_storage_file.rs"],"content":"use {\n    async_trait::async_trait,\n    gluesql_core::prelude::Glue,\n    gluesql_git_storage::{GitStorage, StorageType},\n    std::fs::remove_dir_all,\n    test_suite::*,\n};\n\nstruct GitStorageTester {\n    glue: Glue\u003cGitStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cGitStorage\u003e for GitStorageTester {\n    async fn new(namespace: \u0026str) -\u003e Self {\n        let path = format!(\"tmp/git_storage_file/{namespace}\");\n\n        if let Err(e) = remove_dir_all(\u0026path) {\n            println!(\"fs::remove_file {:?}\", e);\n        };\n\n        let storage = GitStorage::init(\u0026path, StorageType::File).expect(\"GitStorage::init - File\");\n        let glue = Glue::new(storage);\n        GitStorageTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cGitStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, GitStorageTester);\ngenerate_alter_table_tests!(tokio::test, GitStorageTester);\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","git-storage","tests","git_storage_json.rs"],"content":"use {\n    async_trait::async_trait,\n    gluesql_core::prelude::Glue,\n    gluesql_git_storage::{GitStorage, StorageType},\n    std::fs::remove_dir_all,\n    test_suite::*,\n};\n\nstruct GitStorageTester {\n    glue: Glue\u003cGitStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cGitStorage\u003e for GitStorageTester {\n    async fn new(namespace: \u0026str) -\u003e Self {\n        let path = format!(\"tmp/git_storage_json/{namespace}\");\n\n        if let Err(e) = remove_dir_all(\u0026path) {\n            println!(\"fs::remove_file {:?}\", e);\n        };\n\n        let storage = GitStorage::init(\u0026path, StorageType::Json).expect(\"GitStorage::init - JSON\");\n        let glue = Glue::new(storage);\n        GitStorageTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cGitStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, GitStorageTester);\ngenerate_alter_table_tests!(tokio::test, GitStorageTester);\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","git-storage","tests","pull_and_push.rs"],"content":"#![cfg(feature = \"test-git-remote\")]\n\nuse {\n    gluesql_core::prelude::Glue,\n    gluesql_git_storage::{CommandExt, GitStorage, StorageType},\n    std::{\n        env,\n        fs::{create_dir, remove_dir_all},\n        process::Command,\n    },\n    uuid::Uuid,\n};\n\n#[tokio::test]\nasync fn pull_and_push() {\n    let remote = env::var(\"GIT_REMOTE\").unwrap_or(\"git@github.com:gluesql/gluesql.git\".to_owned());\n    let path = \".tmp/gluesql/\";\n    let _ = remove_dir_all(path);\n    let _ = create_dir(\".tmp\");\n\n    Command::new(\"git\")\n        .current_dir(\".tmp\")\n        .arg(\"clone\")\n        .arg(\u0026remote)\n        .execute()\n        .unwrap();\n\n    let branch = format!(\"test-{}\", Uuid::now_v7());\n    Command::new(\"git\")\n        .current_dir(path)\n        .arg(\"checkout\")\n        .arg(\"-b\")\n        .arg(\u0026branch)\n        .execute()\n        .unwrap();\n\n    let mut storage = GitStorage::open(path, StorageType::Json).unwrap();\n    storage.set_remote(remote.clone());\n    storage.set_branch(branch.clone());\n\n    let mut glue = Glue::new(storage);\n    glue.execute(\"CREATE TABLE Foo (id INTEGER);\")\n        .await\n        .unwrap();\n    glue.execute(\"INSERT INTO Foo VALUES (1), (2), (3);\")\n        .await\n        .unwrap();\n\n    let _ = glue.storage.push();\n    let _ = glue.storage.pull();\n\n    let _ = Command::new(\"git\")\n        .current_dir(path)\n        .arg(\"push\")\n        .arg(remote)\n        .arg(\"-d\")\n        .arg(branch)\n        .execute();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","idb-storage","src","convert.rs"],"content":"use {\n    super::ErrInto,\n    gloo_utils::format::JsValueSerdeExt,\n    gluesql_core::{\n        ast::ColumnDef,\n        data::Value,\n        error::{Error, Result},\n        store::DataRow,\n    },\n    serde_json::Value as JsonValue,\n    std::collections::HashMap,\n    wasm_bindgen::JsValue,\n};\n\npub fn convert(value: JsValue, column_defs: Option\u003c\u0026[ColumnDef]\u003e) -\u003e Result\u003cDataRow\u003e {\n    let value: JsonValue = value.into_serde().err_into()?;\n\n    match (value, column_defs) {\n        (JsonValue::Array(json_array), Some(column_defs))\n            if json_array.len() == column_defs.len() =\u003e\n        {\n            json_array\n                .into_iter()\n                .map(Value::try_from)\n                .zip(column_defs.iter())\n                .map(|(value, ColumnDef { data_type, .. })| {\n                    let value = value?;\n\n                    match value.get_type() {\n                        Some(curr_type) if \u0026curr_type != data_type =\u003e value.cast(data_type),\n                        _ =\u003e Ok(value),\n                    }\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n                .map(DataRow::Vec)\n        }\n        (JsonValue::Object(json_map), None) =\u003e json_map\n            .into_iter()\n            .map(|(key, value)| value.try_into().map(|value| (key, value)))\n            .collect::\u003cResult\u003cHashMap\u003cString, Value\u003e\u003e\u003e()\n            .map(DataRow::Map),\n        (value, _) =\u003e Err(Error::StorageMsg(format!(\n            \"conflict - unsupported value stored: {value:?}\"\n        ))),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","idb-storage","src","error.rs"],"content":"use {\n    async_trait::async_trait,\n    core::fmt::Display,\n    gluesql_core::error::{Error, Result},\n    std::{future::IntoFuture, result::Result as StdResult},\n};\n\npub trait ErrInto\u003cT\u003e {\n    fn err_into(self) -\u003e Result\u003cT\u003e;\n}\n\nimpl\u003cT, E: Display\u003e ErrInto\u003cT\u003e for Result\u003cT, E\u003e {\n    fn err_into(self) -\u003e Result\u003cT\u003e {\n        self.map_err(|e| Error::StorageMsg(e.to_string()))\n    }\n}\n\n#[async_trait(?Send)]\npub trait StoreReqIntoFuture\u003cT\u003e {\n    async fn into_future(self) -\u003e Result\u003cT\u003e;\n}\n\n#[async_trait(?Send)]\nimpl\u003cF, T, E: Display\u003e StoreReqIntoFuture\u003cT\u003e for Result\u003cF, E\u003e\nwhere\n    F: IntoFuture\u003cOutput = StdResult\u003cT, E\u003e\u003e,\n{\n    async fn into_future(self) -\u003e Result\u003cT\u003e {\n        self.err_into()?.await.err_into()\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","idb-storage","src","lib.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n#![deny(clippy::str_to_string)]\n\npub mod convert;\nmod error;\n\nuse {\n    async_trait::async_trait,\n    convert::convert,\n    error::{ErrInto, StoreReqIntoFuture},\n    futures::stream::{empty, iter},\n    gloo_utils::format::JsValueSerdeExt,\n    gluesql_core::{\n        data::{Key, Schema, Value},\n        error::{Error, Result},\n        store::{DataRow, Metadata, RowIter, Store, StoreMut},\n    },\n    idb::{\n        CursorDirection, Database, DatabaseEvent, Factory, ObjectStoreParams, Query,\n        TransactionMode,\n    },\n    serde_json::Value as JsonValue,\n    std::sync::{Arc, Mutex},\n    wasm_bindgen::JsValue,\n    web_sys::console,\n};\n\nconst SCHEMA_STORE: \u0026str = \"gluesql-schema\";\nconst DEFAULT_NAMESPACE: \u0026str = \"gluesql\";\n\nenum AlterType {\n    InsertSchema,\n    DeleteSchema,\n}\n\npub struct IdbStorage {\n    namespace: String,\n    factory: Factory,\n    database: Database,\n}\n\nimpl IdbStorage {\n    pub async fn new(namespace: Option\u003cString\u003e) -\u003e Result\u003cSelf\u003e {\n        let factory = Factory::new().err_into()?;\n        let namespace = namespace.as_deref().unwrap_or(DEFAULT_NAMESPACE).to_owned();\n\n        let error = Arc::new(Mutex::new(None));\n        let open_request = {\n            let error = Arc::clone(\u0026error);\n            let mut open_request = factory.open(namespace.as_str(), None).err_into()?;\n            open_request.on_upgrade_needed(move |event| {\n                let database = match event.database().err_into() {\n                    Ok(database) =\u003e database,\n                    Err(e) =\u003e {\n                        let mut error = match error.lock() {\n                            Ok(error) =\u003e error,\n                            Err(_) =\u003e {\n                                let msg = JsValue::from_str(\"infallible - lock acquire failed\");\n                                console::error_1(\u0026msg);\n                                return;\n                            }\n                        };\n\n                        *error = Some(e);\n                        return;\n                    }\n                };\n\n                if let Err(e) = database\n                    .create_object_store(SCHEMA_STORE, ObjectStoreParams::new())\n                    .err_into()\n                {\n                    let mut error = match error.lock() {\n                        Ok(error) =\u003e error,\n                        Err(_) =\u003e {\n                            let msg = JsValue::from_str(\"infallible - lock acquire failed\");\n                            console::error_1(\u0026msg);\n                            return;\n                        }\n                    };\n\n                    *error = Some(e);\n                }\n            });\n\n            open_request\n        };\n\n        let database = open_request.await.err_into()?;\n        let mut error = error\n            .lock()\n            .map_err(|_| Error::StorageMsg(\"infallible - lock acquire failed\".to_owned()))?;\n        if let Some(e) = error.take() {\n            return Err(e);\n        }\n\n        Ok(Self {\n            namespace,\n            factory,\n            database,\n        })\n    }\n\n    pub async fn delete(\u0026self) -\u003e Result\u003c()\u003e {\n        self.factory.delete(\u0026self.namespace).into_future().await\n    }\n\n    async fn alter_object_store(\n        \u0026mut self,\n        table_name: String,\n        alter_type: AlterType,\n    ) -\u003e Result\u003c()\u003e {\n        let version = self.database.version().err_into()? + 1;\n        self.database.close();\n\n        let error = Arc::new(Mutex::new(None));\n        let open_request = {\n            let error = Arc::clone(\u0026error);\n            let mut open_request = self\n                .factory\n                .open(self.namespace.as_str(), Some(version))\n                .err_into()?;\n\n            open_request.on_upgrade_needed(move |event| {\n                let database = match event.database().err_into() {\n                    Ok(database) =\u003e database,\n                    Err(e) =\u003e {\n                        let mut error = match error.lock() {\n                            Ok(error) =\u003e error,\n                            Err(_) =\u003e {\n                                let msg = JsValue::from_str(\"infallible - lock acquire failed\");\n                                console::error_1(\u0026msg);\n                                return;\n                            }\n                        };\n\n                        *error = Some(e);\n                        return;\n                    }\n                };\n\n                let err = match alter_type {\n                    AlterType::InsertSchema =\u003e {\n                        let mut params = ObjectStoreParams::new();\n                        params.auto_increment(true);\n\n                        database\n                            .create_object_store(\u0026table_name, params)\n                            .err_into()\n                            .map(|_| ())\n                    }\n                    AlterType::DeleteSchema =\u003e {\n                        if !database\n                            .store_names()\n                            .iter()\n                            .any(|name| name == \u0026table_name)\n                        {\n                            return;\n                        }\n                        database\n                            .delete_object_store(table_name.as_str())\n                            .err_into()\n                            .map(|_| ())\n                    }\n                };\n\n                if let Err(e) = err {\n                    let mut error = match error.lock() {\n                        Ok(error) =\u003e error,\n                        Err(_) =\u003e {\n                            let msg = JsValue::from_str(\"infallible - lock acquire failed\");\n                            console::error_1(\u0026msg);\n                            return;\n                        }\n                    };\n\n                    *error = Some(e);\n                }\n            });\n\n            open_request\n        };\n\n        self.database = open_request.await.err_into()?;\n        let mut error = error\n            .lock()\n            .map_err(|_| Error::StorageMsg(\"infallible - lock acquire failed\".to_owned()))?;\n        if let Some(e) = error.take() {\n            return Err(e);\n        }\n\n        Ok(())\n    }\n}\n\n#[async_trait(?Send)]\nimpl Store for IdbStorage {\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let transaction = self\n            .database\n            .transaction(\u0026[SCHEMA_STORE], TransactionMode::ReadOnly)\n            .err_into()?;\n\n        let store = transaction.object_store(SCHEMA_STORE).err_into()?;\n        let schemas = store.get_all(None, None).into_future().await?;\n\n        transaction.commit().into_future().await?;\n        schemas\n            .into_iter()\n            .map(|schema| {\n                schema\n                    .as_string()\n                    .as_deref()\n                    .ok_or_else(|| {\n                        Error::StorageMsg(\"conflict - invalid schema value: {schema:?}\".to_owned())\n                    })\n                    .and_then(Schema::from_ddl)\n            })\n            .collect::\u003cResult\u003cVec\u003cSchema\u003e\u003e\u003e()\n    }\n\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        let transaction = self\n            .database\n            .transaction(\u0026[SCHEMA_STORE], TransactionMode::ReadOnly)\n            .err_into()?;\n\n        let store = transaction.object_store(SCHEMA_STORE).err_into()?;\n        let schema = store\n            .get(JsValue::from_str(table_name))\n            .into_future()\n            .await?\n            .and_then(|schema| JsValue::as_string(\u0026schema))\n            .map(|schema| Schema::from_ddl(schema.as_str()))\n            .transpose()?;\n\n        transaction.commit().into_future().await?;\n        Ok(schema)\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, target: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        let column_defs = self\n            .fetch_schema(table_name)\n            .await?\n            .and_then(|schema| schema.column_defs);\n        let transaction = self\n            .database\n            .transaction(\u0026[table_name], TransactionMode::ReadOnly)\n            .err_into()?;\n\n        let store = transaction.object_store(table_name).err_into()?;\n\n        let key: Value = target.clone().into();\n        let key: JsonValue = key.try_into()?;\n        let key = JsValue::from_serde(\u0026key).err_into()?;\n        let row = store.get(key).into_future().await?;\n\n        transaction.commit().into_future().await?;\n\n        match row {\n            Some(row) =\u003e convert(row, column_defs.as_deref()).map(Some),\n            None =\u003e Ok(None),\n        }\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        let column_defs = self\n            .fetch_schema(table_name)\n            .await?\n            .and_then(|schema| schema.column_defs);\n        let transaction = self\n            .database\n            .transaction(\u0026[table_name], TransactionMode::ReadOnly)\n            .err_into()?;\n\n        let store = transaction.object_store(table_name).err_into()?;\n        let cursor = store\n            .open_cursor(None, Some(CursorDirection::Next))\n            .into_future()\n            .await?;\n\n        let mut cursor = match cursor {\n            Some(cursor) =\u003e cursor.into_managed(),\n            None =\u003e {\n                return Ok(Box::pin(empty()));\n            }\n        };\n\n        let mut rows = Vec::new();\n        let mut current_key = cursor.key().err_into()?.unwrap_or(JsValue::NULL);\n        let mut current_row = cursor.value().err_into()?.unwrap_or(JsValue::NULL);\n\n        while !current_key.is_null() {\n            let key: JsonValue = current_key.into_serde().err_into()?;\n            let key: Key = Value::try_from(key)?.try_into()?;\n\n            let row = convert(current_row, column_defs.as_deref())?;\n\n            rows.push((key, row));\n\n            cursor.advance(1).await.err_into()?;\n            current_key = cursor.key().err_into()?.unwrap_or(JsValue::NULL);\n            current_row = cursor.value().err_into()?.unwrap_or(JsValue::NULL);\n        }\n\n        transaction.commit().into_future().await?;\n\n        let rows = rows.into_iter().map(Ok);\n        Ok(Box::pin(iter(rows)))\n    }\n}\n\n#[async_trait(?Send)]\nimpl StoreMut for IdbStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let schema_exists = self\n            .fetch_schema(\u0026schema.table_name)\n            .await\n            .map_err(|e| e.to_string())\n            .map_err(Error::StorageMsg)?\n            .is_some();\n\n        if !schema_exists {\n            self.alter_object_store(schema.table_name.to_owned(), AlterType::InsertSchema)\n                .await?;\n        }\n\n        let transaction = self\n            .database\n            .transaction(\u0026[SCHEMA_STORE], TransactionMode::ReadWrite)\n            .err_into()?;\n        let store = transaction.object_store(SCHEMA_STORE).err_into()?;\n\n        let key = JsValue::from_str(\u0026schema.table_name);\n        let schema = JsValue::from(schema.to_ddl());\n\n        if schema_exists {\n            store.put(\u0026schema, Some(\u0026key)).into_future().await?;\n        } else {\n            store.add(\u0026schema, Some(\u0026key)).into_future().await?;\n        };\n\n        transaction.commit().into_future().await.map(|_| ())\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        self.alter_object_store(table_name.to_owned(), AlterType::DeleteSchema)\n            .await?;\n\n        let transaction = self\n            .database\n            .transaction(\u0026[SCHEMA_STORE], TransactionMode::ReadWrite)\n            .err_into()?;\n        let store = transaction.object_store(SCHEMA_STORE).err_into()?;\n\n        let key = JsValue::from_str(table_name);\n        store.delete(Query::from(key)).into_future().await?;\n\n        transaction.commit().into_future().await.map(|_| ())\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, new_rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let transaction = self\n            .database\n            .transaction(\u0026[table_name], TransactionMode::ReadWrite)\n            .err_into()?;\n        let store = transaction.object_store(table_name).err_into()?;\n\n        for data_row in new_rows {\n            let row = match data_row {\n                DataRow::Vec(values) =\u003e Value::List(values),\n                DataRow::Map(values) =\u003e Value::Map(values),\n            };\n\n            let row = JsonValue::try_from(row)?;\n            let row = JsValue::from_serde(\u0026row).err_into()?;\n\n            store.add(\u0026row, None).into_future().await?;\n        }\n\n        transaction.commit().into_future().await.map(|_| ())\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, new_rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        let transaction = self\n            .database\n            .transaction(\u0026[table_name], TransactionMode::ReadWrite)\n            .err_into()?;\n        let store = transaction.object_store(table_name).err_into()?;\n\n        for (key, data_row) in new_rows {\n            let row = match data_row {\n                DataRow::Vec(values) =\u003e Value::List(values),\n                DataRow::Map(values) =\u003e Value::Map(values),\n            };\n\n            let row = JsonValue::try_from(row)?;\n            let row = JsValue::from_serde(\u0026row).err_into()?;\n\n            let key: JsonValue = Value::from(key).try_into()?;\n            let key = JsValue::from_serde(\u0026key).err_into()?;\n\n            store.put(\u0026row, Some(\u0026key)).into_future().await?;\n        }\n\n        transaction.commit().into_future().await.map(|_| ())\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        let transaction = self\n            .database\n            .transaction(\u0026[table_name], TransactionMode::ReadWrite)\n            .err_into()?;\n        let store = transaction.object_store(table_name).err_into()?;\n\n        for key in keys {\n            let key: JsonValue = Value::from(key).try_into()?;\n            let key = JsValue::from_serde(\u0026key).err_into()?;\n            let key = Query::from(key);\n\n            store.delete(key).into_future().await?;\n        }\n\n        transaction.commit().into_future().await.map(|_| ())\n    }\n}\n\nimpl gluesql_core::store::AlterTable for IdbStorage {}\nimpl gluesql_core::store::Index for IdbStorage {}\nimpl gluesql_core::store::IndexMut for IdbStorage {}\nimpl gluesql_core::store::Transaction for IdbStorage {}\nimpl Metadata for IdbStorage {}\nimpl gluesql_core::store::CustomFunction for IdbStorage {}\nimpl gluesql_core::store::CustomFunctionMut for IdbStorage {}\n","traces":[{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":30},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","idb-storage","tests","convert.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n\nuse {\n    gloo_utils::format::JsValueSerdeExt,\n    gluesql_core::{\n        ast::{ColumnDef, DataType},\n        data::Value,\n        store::DataRow,\n    },\n    gluesql_idb_storage::convert::convert,\n    serde_json::json,\n    wasm_bindgen::JsValue,\n    wasm_bindgen_test::{wasm_bindgen_test, wasm_bindgen_test_configure},\n};\n\nwasm_bindgen_test_configure!(run_in_browser);\n\n#[wasm_bindgen_test]\nasync fn convert_schema() {\n    let actual_data = json!([100, \"hello\", true]);\n    let actual_data = JsValue::from_serde(\u0026actual_data).unwrap();\n    let actual_defs = vec![\n        ColumnDef {\n            name: \"id\".to_owned(),\n            data_type: DataType::Int8,\n            nullable: false,\n            default: None,\n            unique: None,\n            comment: None,\n        },\n        ColumnDef {\n            name: \"name\".to_owned(),\n            data_type: DataType::Text,\n            nullable: false,\n            default: None,\n            unique: None,\n            comment: None,\n        },\n        ColumnDef {\n            name: \"flag\".to_owned(),\n            data_type: DataType::Boolean,\n            nullable: true,\n            default: None,\n            unique: None,\n            comment: None,\n        },\n    ];\n    let expected = DataRow::Vec(vec![\n        Value::I8(100),\n        Value::Str(\"hello\".to_owned()),\n        Value::Bool(true),\n    ]);\n    assert_eq!(\n        convert(actual_data, Some(actual_defs.as_slice())),\n        Ok(expected)\n    );\n}\n\n#[wasm_bindgen_test]\nasync fn convert_schemaless() {\n    let actual = json!({\n        \"id\": 100,\n        \"name\": \"hello\",\n        \"flag\": true\n    });\n    let actual = JsValue::from_serde(\u0026actual).unwrap();\n    let expected = DataRow::Map(\n        [\n            (\"id\".to_owned(), Value::I64(100)),\n            (\"name\".to_owned(), Value::Str(\"hello\".to_owned())),\n            (\"flag\".to_owned(), Value::Bool(true)),\n        ]\n        .into_iter()\n        .collect(),\n    );\n    assert_eq!(convert(actual, None), Ok(expected));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","idb-storage","tests","idb_storage.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n\nuse {\n    async_trait::async_trait,\n    gluesql_core::prelude::Glue,\n    gluesql_idb_storage::IdbStorage,\n    test_suite::*,\n    wasm_bindgen_test::{wasm_bindgen_test, wasm_bindgen_test_configure},\n};\n\nwasm_bindgen_test_configure!(run_in_browser);\n\nstruct IdbStorageTester {\n    glue: Glue\u003cIdbStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cIdbStorage\u003e for IdbStorageTester {\n    async fn new(namespace: \u0026str) -\u003e Self {\n        let storage = IdbStorage::new(Some(namespace.to_owned())).await.unwrap();\n        let glue = Glue::new(storage);\n\n        Self { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cIdbStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(wasm_bindgen_test, IdbStorageTester);\ngenerate_alter_table_tests!(wasm_bindgen_test, IdbStorageTester);\n\n#[wasm_bindgen_test]\nasync fn multiple_instances() {\n    {\n        let _ = IdbStorage::new(Some(\"multiple_instances\".to_owned()))\n            .await\n            .unwrap();\n    }\n    {\n        let _ = IdbStorage::new(Some(\"multiple_instances\".to_owned()))\n            .await\n            .unwrap();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","src","alter_table.rs"],"content":"use {super::JsonStorage, gluesql_core::store::AlterTable};\n\nimpl AlterTable for JsonStorage {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","src","error.rs"],"content":"use {gluesql_core::error::Error, thiserror::Error};\n\npub trait ResultExt\u003cT, E: ToString\u003e {\n    fn map_storage_err(self) -\u003e Result\u003cT, Error\u003e;\n}\n\nimpl\u003cT, E: ToString\u003e ResultExt\u003cT, E\u003e for std::result::Result\u003cT, E\u003e {\n    fn map_storage_err(self) -\u003e Result\u003cT, Error\u003e {\n        self.map_err(|e| e.to_string()).map_err(Error::StorageMsg)\n    }\n}\n\npub trait OptionExt\u003cT, E: ToString\u003e {\n    fn map_storage_err(self, error: E) -\u003e Result\u003cT, Error\u003e;\n}\n\nimpl\u003cT, E: ToString\u003e OptionExt\u003cT, E\u003e for std::option::Option\u003cT\u003e {\n    fn map_storage_err(self, error: E) -\u003e Result\u003cT, Error\u003e {\n        self.ok_or_else(|| error.to_string())\n            .map_err(Error::StorageMsg)\n    }\n}\n\n#[derive(Error, Debug)]\npub enum JsonStorageError {\n    #[error(\"file not found\")]\n    FileNotFound,\n\n    #[error(\"table does not exist\")]\n    TableDoesNotExist,\n\n    #[error(\"column does not exist: {0}\")]\n    ColumnDoesNotExist(String),\n\n    #[error(\"table name does not match with file\")]\n    TableNameDoesNotMatchWithFile,\n\n    #[error(\"both {0}.jsonl and {0}.json files exist. remove or rename one\")]\n    BothJsonlAndJsonExist(String),\n\n    #[error(\"invalid log file content: {0}\")]\n    InvalidJsonContent(String),\n\n    #[error(\"json object type is required\")]\n    JsonObjectTypeRequired,\n\n    #[error(\"json array type is required\")]\n    JsonArrayTypeRequired,\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","src","function.rs"],"content":"use {\n    super::JsonStorage,\n    gluesql_core::store::{CustomFunction, CustomFunctionMut},\n};\n\nimpl CustomFunction for JsonStorage {}\nimpl CustomFunctionMut for JsonStorage {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","src","index.rs"],"content":"use {\n    super::JsonStorage,\n    gluesql_core::store::{Index, IndexMut},\n};\n\nimpl Index for JsonStorage {}\nimpl IndexMut for JsonStorage {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","src","lib.rs"],"content":"mod alter_table;\npub mod error;\nmod function;\nmod index;\nmod store;\nmod store_mut;\nmod transaction;\n\nuse {\n    error::{JsonStorageError, OptionExt, ResultExt},\n    gluesql_core::{\n        ast::ColumnUniqueOption,\n        data::{Key, Schema, value::HashMapJsonExt},\n        error::{Error, Result},\n        store::{DataRow, Metadata},\n    },\n    iter_enum::Iterator,\n    serde_json::Value as JsonValue,\n    std::{\n        collections::HashMap,\n        fs::{self, File},\n        io::{self, BufRead, Read},\n        path::{Path, PathBuf},\n    },\n};\n\ntype RowIter = Box\u003cdyn Iterator\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e\u003e;\n\n#[derive(Clone, Debug)]\npub struct JsonStorage {\n    pub path: PathBuf,\n}\n\nimpl JsonStorage {\n    pub fn new\u003cT: AsRef\u003cPath\u003e\u003e(path: T) -\u003e Result\u003cSelf\u003e {\n        let path = path.as_ref();\n        fs::create_dir_all(path).map_storage_err()?;\n\n        Ok(Self { path: path.into() })\n    }\n\n    fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        match (\n            self.jsonl_path(table_name).exists(),\n            self.json_path(table_name).exists(),\n        ) {\n            (true, true) =\u003e {\n                return Err(Error::StorageMsg(\n                    JsonStorageError::BothJsonlAndJsonExist(table_name.to_owned()).to_string(),\n                ));\n            }\n            (false, false) =\u003e return Ok(None),\n            _ =\u003e {}\n        }\n\n        let schema_path = self.schema_path(table_name);\n        let (column_defs, foreign_keys, comment) = match schema_path.exists() {\n            true =\u003e {\n                let mut file = File::open(\u0026schema_path).map_storage_err()?;\n                let mut ddl = String::new();\n                file.read_to_string(\u0026mut ddl).map_storage_err()?;\n\n                let schema = Schema::from_ddl(\u0026ddl)?;\n                if schema.table_name != table_name {\n                    return Err(Error::StorageMsg(\n                        JsonStorageError::TableNameDoesNotMatchWithFile.to_string(),\n                    ));\n                }\n\n                (schema.column_defs, schema.foreign_keys, schema.comment)\n            }\n            false =\u003e (None, Vec::new(), None),\n        };\n\n        Ok(Some(Schema {\n            table_name: table_name.to_owned(),\n            column_defs,\n            indexes: vec![],\n            engine: None,\n            foreign_keys,\n            comment,\n        }))\n    }\n\n    fn jsonl_path(\u0026self, table_name: \u0026str) -\u003e PathBuf {\n        self.path_by(table_name, \"jsonl\")\n    }\n\n    fn json_path(\u0026self, table_name: \u0026str) -\u003e PathBuf {\n        self.path_by(table_name, \"json\")\n    }\n\n    fn schema_path(\u0026self, table_name: \u0026str) -\u003e PathBuf {\n        self.path_by(table_name, \"sql\")\n    }\n\n    fn path_by(\u0026self, table_name: \u0026str, extension: \u0026str) -\u003e PathBuf {\n        let path = self.path.as_path();\n        let mut path = path.join(table_name);\n        path.set_extension(extension);\n\n        path\n    }\n\n    fn scan_data(\u0026self, table_name: \u0026str) -\u003e Result\u003c(RowIter, Schema)\u003e {\n        let schema = self\n            .fetch_schema(table_name)?\n            .map_storage_err(JsonStorageError::TableDoesNotExist)?;\n\n        #[derive(Iterator)]\n        enum Extension\u003cI1, I2\u003e {\n            Json(I1),\n            Jsonl(I2),\n        }\n        let json_path = self.json_path(table_name);\n        let jsons = match fs::read_to_string(json_path) {\n            Ok(json_file_str) =\u003e {\n                let value = serde_json::from_str(\u0026json_file_str).map_err(|_| {\n                    Error::StorageMsg(\n                        JsonStorageError::InvalidJsonContent(format!(\"{table_name}.json\"))\n                            .to_string(),\n                    )\n                })?;\n\n                let jsons = match value {\n                    JsonValue::Array(values) =\u003e values\n                        .into_iter()\n                        .map(|value| match value {\n                            JsonValue::Object(json_map) =\u003e HashMap::try_from_json_map(json_map),\n                            _ =\u003e Err(Error::StorageMsg(\n                                JsonStorageError::JsonObjectTypeRequired.to_string(),\n                            )),\n                        })\n                        .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e(),\n                    JsonValue::Object(json_map) =\u003e Ok(vec![HashMap::try_from_json_map(json_map)?]),\n                    _ =\u003e Err(Error::StorageMsg(\n                        JsonStorageError::JsonArrayTypeRequired.to_string(),\n                    )),\n                }?;\n\n                Extension::Json(jsons.into_iter().map(Ok))\n            }\n            Err(_) =\u003e {\n                let jsonl_path = self.jsonl_path(table_name);\n                let lines = read_lines(jsonl_path).map_storage_err()?;\n                let jsons = lines.map(|line| HashMap::parse_json_object(\u0026line.map_storage_err()?));\n\n                Extension::Jsonl(jsons)\n            }\n        };\n\n        let schema2 = schema.clone();\n        let rows = jsons.enumerate().map(move |(index, json)| -\u003e Result\u003c_\u003e {\n            let json = json?;\n            let get_index_key = || index.try_into().map(Key::I64).map_storage_err();\n\n            let column_defs = match \u0026schema2.column_defs {\n                Some(column_defs) =\u003e column_defs,\n                None =\u003e {\n                    let key = get_index_key()?;\n                    let row = DataRow::Map(json);\n\n                    return Ok((key, row));\n                }\n            };\n\n            let mut key: Option\u003cKey\u003e = None;\n            let mut values = Vec::with_capacity(column_defs.len());\n            for column_def in column_defs {\n                let value = json.get(\u0026column_def.name).map_storage_err(\n                    JsonStorageError::ColumnDoesNotExist(column_def.name.clone()),\n                )?;\n\n                if column_def.unique == Some(ColumnUniqueOption { is_primary: true }) {\n                    let value = value.cast(\u0026column_def.data_type)?;\n                    key = Some(value.try_into().map_storage_err()?);\n                }\n\n                let value = match value.get_type() {\n                    Some(data_type) if data_type != column_def.data_type =\u003e {\n                        value.cast(\u0026column_def.data_type)?\n                    }\n                    Some(_) | None =\u003e value.clone(),\n                };\n\n                values.push(value);\n            }\n\n            let key = match key {\n                Some(key) =\u003e key,\n                None =\u003e get_index_key()?,\n            };\n            let row = DataRow::Vec(values);\n\n            Ok((key, row))\n        });\n\n        Ok((Box::new(rows), schema))\n    }\n}\n\nfn read_lines\u003cP\u003e(filename: P) -\u003e io::Result\u003cio::Lines\u003cio::BufReader\u003cFile\u003e\u003e\u003e\nwhere\n    P: AsRef\u003cPath\u003e,\n{\n    let file = File::open(filename)?;\n    Ok(io::BufReader::new(file).lines())\n}\n\nimpl Metadata for JsonStorage {}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":97},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","src","store.rs"],"content":"use {\n    crate::{\n        JsonStorage,\n        error::{JsonStorageError, OptionExt, ResultExt},\n    },\n    async_trait::async_trait,\n    futures::stream::iter,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::Result,\n        store::{DataRow, RowIter, Store},\n    },\n    std::{ffi::OsStr, fs},\n};\n\n#[async_trait(?Send)]\nimpl Store for JsonStorage {\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        self.fetch_schema(table_name)\n    }\n\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let paths = fs::read_dir(\u0026self.path).map_storage_err()?;\n        let mut schemas = paths\n            .map(|result| {\n                let path = result.map_storage_err()?.path();\n                let extension = path.extension().and_then(OsStr::to_str);\n                if extension != Some(\"jsonl\") \u0026\u0026 extension != Some(\"json\") {\n                    return Ok(None);\n                }\n\n                let table_name = path\n                    .file_stem()\n                    .and_then(OsStr::to_str)\n                    .map_storage_err(JsonStorageError::FileNotFound)?;\n\n                self.fetch_schema(table_name)?\n                    .map_storage_err(JsonStorageError::TableDoesNotExist)\n                    .map(Some)\n            })\n            .filter_map(Result::transpose)\n            .collect::\u003cResult\u003cVec\u003cSchema\u003e\u003e\u003e()?;\n\n        schemas.sort_by(|a, b| a.table_name.cmp(\u0026b.table_name));\n\n        Ok(schemas)\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, target: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        for item in self.scan_data(table_name)?.0 {\n            let (key, row) = item?;\n\n            if \u0026key == target {\n                return Ok(Some(row));\n            }\n        }\n\n        Ok(None)\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        let rows = self.scan_data(table_name)?.0;\n\n        Ok(Box::pin(iter(rows)))\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","src","store_mut.rs"],"content":"use {\n    crate::{\n        JsonStorage,\n        error::{JsonStorageError, OptionExt, ResultExt},\n    },\n    async_trait::async_trait,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::Result,\n        store::{DataRow, StoreMut},\n    },\n    serde_json::{Map, Value as JsonValue, to_string_pretty},\n    std::{\n        cmp::Ordering,\n        fs::{File, OpenOptions, remove_file},\n        io::Write,\n        iter::Peekable,\n        vec::IntoIter,\n    },\n};\n\n#[async_trait(?Send)]\nimpl StoreMut for JsonStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let data_path = self.jsonl_path(schema.table_name.as_str());\n        File::create(data_path).map_storage_err()?;\n\n        let schema_path = self.schema_path(schema.table_name.as_str());\n        let ddl = schema.to_ddl();\n        let mut file = File::create(schema_path).map_storage_err()?;\n\n        file.write_all(ddl.as_bytes()).map_storage_err()?;\n\n        Ok(())\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let json_path = self.json_path(table_name);\n        let jsonl_path = self.jsonl_path(table_name);\n\n        match (json_path.exists(), jsonl_path.exists()) {\n            (true, false) =\u003e remove_file(json_path).map_storage_err()?,\n            (false, true) =\u003e remove_file(jsonl_path).map_storage_err()?,\n            _ =\u003e {}\n        }\n\n        let schema_path = self.schema_path(table_name);\n        if schema_path.exists() {\n            remove_file(schema_path).map_storage_err()?;\n        }\n\n        Ok(())\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let json_path = self.json_path(table_name);\n        if json_path.exists() {\n            let (prev_rows, schema) = self.scan_data(table_name)?;\n\n            let rows = prev_rows\n                .map(|item| Ok(item?.1))\n                .chain(rows.into_iter().map(Ok))\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n            let file = File::create(\u0026json_path).map_storage_err()?;\n\n            self.write(schema, rows, file, true)\n        } else {\n            let schema = self\n                .fetch_schema(table_name)?\n                .map_storage_err(JsonStorageError::TableDoesNotExist)?;\n\n            let file = OpenOptions::new()\n                .append(true)\n                .open(self.jsonl_path(\u0026schema.table_name))\n                .map_storage_err()?;\n\n            self.write(schema, rows, file, false)\n        }\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, mut rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        let (prev_rows, schema) = self.scan_data(table_name)?;\n        rows.sort_by(|(key_a, _), (key_b, _)| key_a.cmp(key_b));\n\n        let sort_merge = SortMerge::new(prev_rows, rows.into_iter());\n        let merged = sort_merge.collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        self.rewrite(schema, merged)\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        let (prev_rows, schema) = self.scan_data(table_name)?;\n        let rows = prev_rows\n            .filter_map(|result| {\n                result\n                    .map(|(key, data_row)| {\n                        let preservable = !keys.iter().any(|target_key| target_key == \u0026key);\n\n                        preservable.then_some(data_row)\n                    })\n                    .transpose()\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        self.rewrite(schema, rows)\n    }\n}\n\nstruct SortMerge\u003cT: Iterator\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e\u003e {\n    left_rows: Peekable\u003cT\u003e,\n    right_rows: Peekable\u003cIntoIter\u003c(Key, DataRow)\u003e\u003e,\n}\n\nimpl\u003cT\u003e SortMerge\u003cT\u003e\nwhere\n    T: Iterator\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e,\n{\n    fn new(left_rows: T, right_rows: IntoIter\u003c(Key, DataRow)\u003e) -\u003e Self {\n        let left_rows = left_rows.peekable();\n        let right_rows = right_rows.peekable();\n\n        Self {\n            left_rows,\n            right_rows,\n        }\n    }\n}\nimpl\u003cT\u003e Iterator for SortMerge\u003cT\u003e\nwhere\n    T: Iterator\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e,\n{\n    type Item = Result\u003cDataRow\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let left = self.left_rows.peek();\n        let right = self.right_rows.peek();\n\n        match (left, right) {\n            (Some(Ok((left_key, _))), Some((right_key, _))) =\u003e match left_key.cmp(right_key) {\n                Ordering::Less =\u003e self.left_rows.next(),\n                Ordering::Greater =\u003e self.right_rows.next().map(Ok),\n                Ordering::Equal =\u003e {\n                    self.left_rows.next();\n                    self.right_rows.next().map(Ok)\n                }\n            }\n            .map(|item| Ok(item?.1)),\n            (Some(_), _) =\u003e self.left_rows.next().map(|item| Ok(item?.1)),\n            (None, Some(_)) =\u003e self.right_rows.next().map(|item| Ok(item.1)),\n            (None, None) =\u003e None,\n        }\n    }\n}\n\nimpl JsonStorage {\n    fn rewrite(\u0026mut self, schema: Schema, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let json_path = self.json_path(\u0026schema.table_name);\n        let (path, is_json) = match json_path.exists() {\n            true =\u003e (json_path, true),\n            false =\u003e {\n                let jsonl_path = self.jsonl_path(\u0026schema.table_name);\n\n                (jsonl_path, false)\n            }\n        };\n        let file = File::create(path).map_storage_err()?;\n\n        self.write(schema, rows, file, is_json)\n    }\n\n    fn write(\n        \u0026mut self,\n        schema: Schema,\n        rows: Vec\u003cDataRow\u003e,\n        mut file: File,\n        is_json: bool,\n    ) -\u003e Result\u003c()\u003e {\n        let column_defs = schema.column_defs.unwrap_or_default();\n        let labels = column_defs\n            .iter()\n            .map(|column_def| column_def.name.as_str())\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let rows = rows\n            .into_iter()\n            .map(|row| match row {\n                DataRow::Vec(values) =\u003e labels\n                    .iter()\n                    .zip(values)\n                    .map(|(key, value)| Ok((key.to_string(), value.try_into()?)))\n                    .collect::\u003cResult\u003cMap\u003cString, JsonValue\u003e\u003e\u003e(),\n                DataRow::Map(hash_map) =\u003e hash_map\n                    .into_iter()\n                    .map(|(key, value)| Ok((key, value.try_into()?)))\n                    .collect(),\n            })\n            .map(|result| result.map(JsonValue::Object));\n\n        if is_json {\n            let rows = rows.collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e().and_then(|rows| {\n                let rows = JsonValue::Array(rows);\n\n                to_string_pretty(\u0026rows).map_storage_err()\n            })?;\n\n            file.write_all(rows.as_bytes()).map_storage_err()?;\n        } else {\n            for row in rows {\n                let row = row?;\n\n                writeln!(file, \"{row}\").map_storage_err()?;\n            }\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":100},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","src","transaction.rs"],"content":"use {super::JsonStorage, gluesql_core::store::Transaction};\n\nimpl Transaction for JsonStorage {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","tests","error.rs"],"content":"use {\n    gluesql_core::{\n        error::{SchemaParseError, ValueError},\n        prelude::{Error, Glue},\n    },\n    gluesql_json_storage::{JsonStorage, error::JsonStorageError},\n};\n\n#[tokio::test]\nasync fn json_error() {\n    let path = \"./tests/samples/\";\n    let json_storage = JsonStorage::new(path).unwrap();\n    let mut glue = Glue::new(json_storage);\n\n    let cases = vec![\n        (\n            glue.execute(\"SELECT * FROM WrongFormatJsonl\").await,\n            Err(ValueError::InvalidJsonString(\"[\".to_owned()).into()),\n        ),\n        (\n            glue.execute(\"SELECT * FROM WrongFormatJson\").await,\n            Err(Error::StorageMsg(\n                JsonStorageError::InvalidJsonContent(\"WrongFormatJson.json\".to_owned()).to_string(),\n            )),\n        ),\n        (\n            glue.execute(\"SELECT * FROM WrongSchema\").await,\n            Err(Error::Schema(SchemaParseError::CannotParseDDL)),\n        ),\n        (\n            glue.execute(\"SELECT * FROM WrongTableName\").await,\n            Err(Error::StorageMsg(\n                JsonStorageError::TableNameDoesNotMatchWithFile.to_string(),\n            )),\n        ),\n        (\n            glue.execute(\"SELECT * FROM Duplicated\").await,\n            Err(Error::StorageMsg(\n                JsonStorageError::BothJsonlAndJsonExist(\"Duplicated\".to_owned()).to_string(),\n            )),\n        ),\n        (\n            glue.execute(\"DROP TABLE Duplicated\").await,\n            Err(Error::StorageMsg(\n                JsonStorageError::BothJsonlAndJsonExist(\"Duplicated\".to_owned()).to_string(),\n            )),\n        ),\n        (\n            glue.execute(\"SELECT * FROM JsonObjectTypeRequired\").await,\n            Err(Error::StorageMsg(\n                JsonStorageError::JsonObjectTypeRequired.to_string(),\n            )),\n        ),\n        (\n            glue.execute(\"SELECT * FROM JsonArrayTypeRequired\").await,\n            Err(Error::StorageMsg(\n                JsonStorageError::JsonArrayTypeRequired.to_string(),\n            )),\n        ),\n    ];\n\n    for (actual, expected) in cases {\n        assert_eq!(actual.map(|mut payloads| payloads.remove(0)), expected);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","tests","json_dml.rs"],"content":"use {\n    gluesql_core::prelude::{Glue, Payload, Value},\n    gluesql_json_storage::JsonStorage,\n    serde_json::json,\n    std::{\n        fs::{File, remove_dir_all},\n        io::Write,\n    },\n    test_suite::select_map,\n};\n\n#[tokio::test]\nasync fn json_dml() {\n    let path = \"tmp/json_dml\";\n    if let Err(e) = remove_dir_all(path) {\n        println!(\"fs::remove_file {:?}\", e);\n    };\n    let json_storage = JsonStorage::new(path).unwrap();\n    let mut glue = Glue::new(json_storage);\n\n    let dir = format!(\"{path}/JsonDML.json\");\n    let mut file = File::create(dir).unwrap();\n    let data = r#\"[\n  {\n    \"id\": 1,\n    \"notice\": \"should keep this array of jsons format\"\n  }\n]\n\"#;\n    write!(file, \"{data}\").unwrap();\n\n    let cases = vec![\n        (\n            glue.execute(r#\"INSERT INTO JsonDML VALUES ('{\"id\": 2, \"notice\": \"appended json\"}')\"#)\n                .await,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            glue.execute(\"SELECT * FROM JsonDML\").await,\n            Ok(select_map![\n                json!({\n                  \"id\": 1,\n                  \"notice\": \"should keep this array of jsons format\"\n                }),\n                json!({\n                  \"id\": 2,\n                  \"notice\": \"appended json\"\n                })\n            ]),\n        ),\n        (\n            glue.execute(\"UPDATE JsonDML SET notice = 'updated' WHERE id = 2\")\n                .await,\n            Ok(Payload::Update(1)),\n        ),\n        (\n            glue.execute(\"SELECT * FROM JsonDML WHERE id = 2\").await,\n            Ok(select_map![json!({\n              \"id\": 2,\n              \"notice\": \"updated\"\n            })]),\n        ),\n        (\n            glue.execute(\"DELETE FROM JsonDML WHERE id = 2\").await,\n            Ok(Payload::Delete(1)),\n        ),\n        (\n            glue.execute(\"SELECT * FROM JsonDML\").await,\n            Ok(select_map![json!({\n              \"id\": 1,\n              \"notice\": \"should keep this array of jsons format\"\n            })]),\n        ),\n        (\n            glue.execute(\"SELECT COUNT(*) FROM GLUE_TABLES WHERE TABLE_NAME = 'JsonDML'\")\n                .await,\n            Ok(Payload::Select {\n                labels: vec![\"COUNT(*)\".to_owned()],\n                rows: vec![vec![Value::I64(1)]],\n            }),\n        ),\n        (\n            glue.execute(\"DROP TABLE JsonDML\").await,\n            Ok(Payload::DropTable(1)),\n        ),\n        (\n            glue.execute(\"SELECT COUNT(*) FROM GLUE_TABLES WHERE TABLE_NAME = 'JsonDML'\")\n                .await,\n            Ok(Payload::Select {\n                labels: vec![\"COUNT(*)\".to_owned()],\n                rows: Vec::new(),\n            }),\n        ),\n    ];\n\n    for (actual, expected) in cases {\n        assert_eq!(actual.map(|mut payloads| payloads.remove(0)), expected);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","tests","json_storage.rs"],"content":"use {\n    async_trait::async_trait, gluesql_core::prelude::Glue, gluesql_json_storage::JsonStorage,\n    std::fs::remove_dir_all, test_suite::*,\n};\n\nstruct JsonTester {\n    glue: Glue\u003cJsonStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cJsonStorage\u003e for JsonTester {\n    async fn new(namespace: \u0026str) -\u003e Self {\n        let path = format!(\"tmp/{namespace}\");\n\n        if let Err(e) = remove_dir_all(\u0026path) {\n            println!(\"fs::remove_file {:?}\", e);\n        };\n\n        let storage = JsonStorage::new(\u0026path).expect(\"JsonStorage::new\");\n        let glue = Glue::new(storage);\n        JsonTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cJsonStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, JsonTester);\ngenerate_alter_table_tests!(tokio::test, JsonTester);\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","tests","primary_key.rs"],"content":"use {\n    gluesql_core::prelude::{\n        Glue,\n        {Payload, Value::*},\n    },\n    gluesql_json_storage::JsonStorage,\n    std::fs::remove_dir_all,\n    test_suite::{concat_with, row, select, stringify_label},\n};\n\n#[tokio::test]\nasync fn json_primary_key() {\n    let path = \"tmp/json_primary_key/\";\n    if let Err(e) = remove_dir_all(path) {\n        println!(\"fs::remove_file {:?}\", e);\n    };\n    let json_storage = JsonStorage::new(path).unwrap();\n    let mut glue = Glue::new(json_storage);\n\n    let cases = vec![\n        (\n            glue.execute(\n                \"CREATE TABLE SchemaWithPK (\n                   id INT NOT NULL PRIMARY KEY,\n                   name TEXT NULL\n                 );\",\n            )\n            .await,\n            Ok(Payload::Create),\n        ),\n        (\n            glue.execute(\"INSERT INTO SchemaWithPK VALUES(2, 'second')\")\n                .await,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            glue.execute(\"INSERT INTO SchemaWithPK VALUES(1, 'first')\")\n                .await,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            glue.execute(\"SELECT * FROM SchemaWithPK\").await,\n            Ok(select!(\n                id  | name\n                I64 | Str;\n                1     \"first\".to_owned();\n                2     \"second\".to_owned()\n            )),\n        ),\n    ];\n\n    for (actual, expected) in cases {\n        assert_eq!(actual.map(|mut payloads| payloads.remove(0)), expected);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","tests","schema.rs"],"content":"use {\n    gluesql_core::{\n        data::{Interval, value::HashMapJsonExt},\n        prelude::{\n            Glue,\n            Value::{self, *},\n        },\n    },\n    gluesql_json_storage::JsonStorage,\n    std::{\n        collections::HashMap,\n        net::{IpAddr, Ipv4Addr},\n    },\n    test_suite::{concat_with, concat_with_null, row, select, select_with_null, stringify_label},\n    uuid::Uuid as UUID,\n};\n\n#[tokio::test]\nasync fn json_schema() {\n    let path = \"./tests/samples/\";\n    let json_storage = JsonStorage::new(path).unwrap();\n    let mut glue = Glue::new(json_storage);\n\n    macro_rules! date {\n        ($date: expr) =\u003e {\n            $date.parse().unwrap()\n        };\n    }\n    let parse_uuid = |v| UUID::parse_str(v).unwrap().as_u128();\n    let bytea = |v| hex::decode(v).unwrap();\n    let ip = |a, b, c, d| IpAddr::V4(Ipv4Addr::new(a, b, c, d));\n    let m = |s: \u0026str| HashMap::parse_json_object(s).unwrap();\n    let l = |s: \u0026str| Value::parse_json_list(s).unwrap();\n\n    let cases = vec![\n        (\n            glue.execute(\"SELECT boolean, int8, int16, int32, int64, uint8 FROM Schema\")\n                .await,\n            Ok(select!(\n              boolean | int8 | int16 | int32      | int64               | uint8\n              Bool    | I8   | I16   | I32        | I64                 | U8;\n              false     44     12500   1398486491   6843542416722343000   179;\n              false     120    25269   40556486     2332015357713582000   92;\n              true      49     4821    2007327410   487898043248887500    92;\n              false     80     7235    1604644769   2854360423787302000   147;\n              false     26     32740   766408542    5159015894945299000   174;\n              true      94     32547   1645422225   4690433930230266000   21;\n              false     19     32632   1636850638   3150782249474742300   183;\n              false     24     26963   642584730    205655629028309660    241;\n              false     19     13123   1225214579   7027423886567483000   53;\n              false     21     17753   526033318    4966342914812151000   88\n            )),\n        ),\n        (\n            glue.execute(\"SELECT text, bytea, inet FROM Schema\").await,\n            Ok(select!(\n              text                                | bytea               | inet\n              Str                                 | Bytea               | Inet;\n              \"Dr. Delia Christiansen\".to_owned()   bytea(\"57E6aC3aAa\")   ip(16, 199, 176, 40);\n              \"Jody Stracke\".to_owned()             bytea(\"f43249Da4d\")   ip(120, 137, 6, 4);\n              \"Arnold Mraz\".to_owned()              bytea(\"996ed6bC9f\")   ip(104, 17, 25, 44);\n              \"Dr. Lila Pagac Jr.\".to_owned()       bytea(\"D271DeD0B7\")   ip(43, 18, 41, 224);\n              \"Gina Green\".to_owned()               bytea(\"4C5f01dA5E\")   ip(210, 26, 180, 136);\n              \"Wesley Trantow\".to_owned()           bytea(\"2a22a81c3D\")   ip(131, 50, 245, 4);\n              \"Andrew Bogan\".to_owned()             bytea(\"44e285db9e\")   ip(35, 223, 208, 13);\n              \"Whitney Lueilwitz\".to_owned()        bytea(\"3e704141C9\")   ip(34, 213, 220, 130);\n              \"Colin Bergstrom\".to_owned()          bytea(\"19dc6FD2bA\")   ip(242, 202, 162, 243);\n              \"Sylvia Nienow PhD\".to_owned()        bytea(\"b70dC8703A\")   ip(153, 83, 159, 41)\n            )),\n        ),\n        (\n            glue.execute(\"SELECT date, timestamp, time FROM Schema\")\n                .await,\n            Ok(select!(\n              date                | timestamp                    | time\n              Date                | Timestamp                    | Time;\n              date!(\"2022-12-09\")   date!(\"2022-03-25T00:51:20\")   date!(\"04:35:35\");\n              date!(\"2022-12-17\")   date!(\"2022-03-31T19:15:31\")   date!(\"12:07:22\");\n              date!(\"2022-04-26\")   date!(\"2022-09-12T07:57:02\")   date!(\"00:19:49\");\n              date!(\"2022-08-18\")   date!(\"2023-02-18T19:38:19\")   date!(\"13:27:34\");\n              date!(\"2023-02-20\")   date!(\"2022-10-16T09:41:12\")   date!(\"14:49:10\");\n              date!(\"2022-03-15\")   date!(\"2023-02-12T17:32:52\")   date!(\"01:54:59\");\n              date!(\"2022-12-09\")   date!(\"2022-05-05T12:20:55\")   date!(\"13:57:30\");\n              date!(\"2022-07-04\")   date!(\"2022-08-08T02:46:25\")   date!(\"16:22:34\");\n              date!(\"2022-04-29\")   date!(\"2022-06-01T03:33:01\")   date!(\"23:02:03\");\n              date!(\"2022-06-21\")   date!(\"2022-04-11T06:34:02\")   date!(\"22:59:49\")\n            )),\n        ),\n        (\n            glue.execute(\"SELECT \\\"interval\\\" FROM Schema\").await,\n            Ok(select!(\n              \"\\\"interval\\\"\"\n              Interval;\n              Interval::hours(-86);\n              Interval::microseconds((((84 * 60) + 30) * 60 + 12) * 1_000_000 + 132_400);\n              Interval::microseconds((((84 * 60) + 30) * 60 + 12) * 1_000_000 + 132_400);\n              Interval::hours(35);\n              Interval::seconds(-(12 * 3600 + 30 * 60 + 12));\n              Interval::minutes(84 * 60 + 30);\n              Interval::months(14);\n              Interval::minutes(84 * 60 + 30);\n              Interval::seconds(-(30 * 60 + 11));\n              Interval::minutes(84 * 60 + 30)\n            )),\n        ),\n        (\n            glue.execute(\"SELECT uuid FROM Schema\").await,\n            Ok(select!(\n              uuid\n              Uuid;\n              parse_uuid(\"7e11a009-4392-4bb8-92a9-884252542bdc\");\n              parse_uuid(\"a3b66bfb-bf15-42f5-baf1-15910992e099\");\n              parse_uuid(\"84147534-82fd-46c3-bdc2-a70a1c6beaa0\");\n              parse_uuid(\"e5350af3-a575-44bb-a78a-8ea8a94a767b\");\n              parse_uuid(\"b604018e-7287-4bdc-96cb-4f4b5a2e675d\");\n              parse_uuid(\"725b9cfc-6d10-4fcf-b063-948be71e4b40\");\n              parse_uuid(\"59e69126-0a57-46b7-8c54-a106b836d436\");\n              parse_uuid(\"d99e7f87-7f64-4992-b2dd-25241b03cd30\");\n              parse_uuid(\"8070582a-7906-4201-971d-3323b3ef79c6\");\n              parse_uuid(\"d4223eea-9514-4366-833d-933a1221d8e3\")\n            )),\n        ),\n        (\n            glue.execute(\"SELECT map FROM Schema\").await,\n            Ok(select!(\n              map\n              Map;\n              m(r#\"{\"age\": 84, \"city\": \"Armstrongfurt\"}\"#);\n              m(r#\"{\"age\": 34, \"city\": \"Fort Randiview\"}\"#);\n              m(r#\"{\"age\": 58, \"city\": \"Cambridge\"}\"#);\n              m(r#\"{\"age\": 77, \"city\": \"Gloverburgh\"}\"#);\n              m(r#\"{\"age\": 45, \"city\": \"Taunton\"}\"#);\n              m(r#\"{\"age\": 41, \"city\": \"West Rhiannaview\"}\"#);\n              m(r#\"{\"age\": 47, \"city\": \"North Chaddtown\"}\"#);\n              m(r#\"{\"age\": 11, \"city\": \"Joeyborough\"}\"#);\n              m(r#\"{\"age\": 86, \"city\": \"Lake Quintenberg\"}\"#);\n              m(r#\"{\"age\": 53, \"city\": \"Jazmyneville\"}\"#)\n            )),\n        ),\n        (\n            glue.execute(\"SELECT list FROM Schema\").await,\n            Ok(select_with_null!(\n              list;\n              l(r#\"[\"olive\", \"turquoise\", \"plum\"]\"#);\n              l(r#\"[\"red\", \"sky blue\", \"grey\"]\"#);\n              l(r#\"[\"indigo\", \"turquoise\", \"indigo\"]\"#);\n              l(r#\"[\"black\", \"turquoise\", \"purple\"]\"#);\n              l(r#\"[\"turquoise\", \"lavender\", \"red\"]\"#);\n              l(r#\"[\"turquoise\", \"magenta\", \"salmon\"]\"#);\n              l(r#\"[\"maroon\", \"violet\", \"lavender\"]\"#);\n              l(r#\"[\"pink\", \"teal\", \"indigo\"]\"#);\n              l(r#\"[\"black\", \"red\", \"purple\"]\"#);\n              l(r#\"[\"pink\", \"indigo\", \"plum\"]\"#)\n            )),\n        ),\n        (\n            glue.execute(\"SELECT * FROM ArrayOfJsonsSchema\").await,\n            Ok(select!(\n              id   | name\n              I64  | Str;\n              1      \"Glue\".to_owned();\n              2      \"SQL\".to_owned()\n            )),\n        ),\n        (\n            glue.execute(\"SELECT * FROM SingleJsonSchema\").await,\n            Ok(select_with_null!(\n              data;\n              l(r#\"[\n                     {\"id\": 1, \"name\": \"Glue\"},\n                     {\"id\": 2, \"name\": \"SQL\"}\n                   ]\"#\n              )\n            )),\n        ),\n    ];\n\n    for (actual, expected) in cases {\n        assert_eq!(actual.map(|mut payloads| payloads.remove(0)), expected);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","json-storage","tests","schemaless.rs"],"content":"use {\n    gluesql_core::prelude::{Glue, Value},\n    gluesql_json_storage::JsonStorage,\n    serde_json::json,\n    test_suite::select_map,\n};\n\n#[tokio::test]\nasync fn json_schemaless() {\n    let path = \"./tests/samples/\";\n    let json_storage = JsonStorage::new(path).unwrap();\n    let mut glue = Glue::new(json_storage);\n\n    let cases = vec![\n        (\n            glue.execute(\"SELECT * FROM Schemaless\").await,\n            Ok(select_map![\n                json!({\"id\": 1}),\n                json!({\"name\": \"Glue\"}),\n                json!({\"id\": 3, \"name\": \"SQL\"})\n            ]),\n        ),\n        (\n            glue.execute(\"SELECT * FROM ArrayOfJsonsSchemaless\").await,\n            Ok(select_map![\n                json!({ \"id\": 1, \"name\": \"Glue\" }),\n                json!({ \"id\": 2, \"name\": \"SQL\" })\n            ]),\n        ),\n        (\n            glue.execute(\"SELECT * FROM SingleJsonSchemaless\").await,\n            Ok(select_map![json!(\n                {\n                  \"data\": [\n                    {\n                      \"id\": 1,\n                      \"name\": \"Glue\"\n                    },\n                    {\n                      \"id\": 2,\n                      \"name\": \"SQL\"\n                    },\n                  ]\n                }\n            )]),\n        ),\n    ];\n\n    for (actual, expected) in cases {\n        assert_eq!(actual.map(|mut payloads| payloads.remove(0)), expected);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","memory-storage","src","alter_table.rs"],"content":"use {\n    super::MemoryStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        ast::ColumnDef,\n        data::Value,\n        error::{AlterTableError, Error, Result},\n        store::{AlterTable, DataRow},\n    },\n};\n\n#[async_trait(?Send)]\nimpl AlterTable for MemoryStorage {\n    async fn rename_schema(\u0026mut self, table_name: \u0026str, new_table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let mut item = self\n            .items\n            .remove(table_name)\n            .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()))?;\n\n        new_table_name.clone_into(\u0026mut item.schema.table_name);\n        self.items.insert(new_table_name.to_owned(), item);\n\n        Ok(())\n    }\n\n    async fn rename_column(\n        \u0026mut self,\n        table_name: \u0026str,\n        old_column_name: \u0026str,\n        new_column_name: \u0026str,\n    ) -\u003e Result\u003c()\u003e {\n        let item = self\n            .items\n            .get_mut(table_name)\n            .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()))?;\n\n        let column_defs = item\n            .schema\n            .column_defs\n            .as_mut()\n            .ok_or_else(|| AlterTableError::SchemalessTableFound(table_name.to_owned()))?;\n\n        if column_defs\n            .iter()\n            .any(|ColumnDef { name, .. }| name == new_column_name)\n        {\n            return Err(AlterTableError::AlreadyExistingColumn(new_column_name.to_owned()).into());\n        }\n\n        let column_def = column_defs\n            .iter_mut()\n            .find(|column_def| column_def.name == old_column_name)\n            .ok_or(AlterTableError::RenamingColumnNotFound)?;\n\n        new_column_name.clone_into(\u0026mut column_def.name);\n\n        Ok(())\n    }\n\n    async fn add_column(\u0026mut self, table_name: \u0026str, column_def: \u0026ColumnDef) -\u003e Result\u003c()\u003e {\n        let item = self\n            .items\n            .get_mut(table_name)\n            .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()))?;\n\n        let column_defs = item\n            .schema\n            .column_defs\n            .as_mut()\n            .ok_or_else(|| AlterTableError::SchemalessTableFound(table_name.to_owned()))?;\n\n        if column_defs\n            .iter()\n            .any(|ColumnDef { name, .. }| name == \u0026column_def.name)\n        {\n            let adding_column = column_def.name.to_owned();\n\n            return Err(AlterTableError::AlreadyExistingColumn(adding_column).into());\n        }\n\n        let ColumnDef {\n            data_type,\n            nullable,\n            default,\n            ..\n        } = column_def;\n\n        let value = match (default, nullable) {\n            (Some(expr), _) =\u003e {\n                let evaluated = gluesql_core::executor::evaluate_stateless(None, expr).await?;\n\n                evaluated.try_into_value(data_type, *nullable)?\n            }\n            (None, true) =\u003e Value::Null,\n            (None, false) =\u003e {\n                return Err(AlterTableError::DefaultValueRequired(column_def.clone()).into());\n            }\n        };\n\n        for (_, row) in item.rows.iter_mut() {\n            match row {\n                DataRow::Vec(values) =\u003e {\n                    values.push(value.clone());\n                }\n                DataRow::Map(_) =\u003e {\n                    return Err(Error::StorageMsg(\n                        \"conflict - add_column failed: schemaless row found\".to_owned(),\n                    ));\n                }\n            }\n        }\n\n        column_defs.push(column_def.clone());\n\n        Ok(())\n    }\n\n    async fn drop_column(\n        \u0026mut self,\n        table_name: \u0026str,\n        column_name: \u0026str,\n        if_exists: bool,\n    ) -\u003e Result\u003c()\u003e {\n        let item = self\n            .items\n            .get_mut(table_name)\n            .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()))?;\n\n        let column_defs = item\n            .schema\n            .column_defs\n            .as_mut()\n            .ok_or_else(|| AlterTableError::SchemalessTableFound(table_name.to_owned()))?;\n\n        let column_index = column_defs\n            .iter()\n            .position(|column_def| column_def.name == column_name);\n\n        match column_index {\n            Some(column_index) =\u003e {\n                column_defs.remove(column_index);\n\n                for (_, row) in item.rows.iter_mut() {\n                    if row.len() \u003c= column_index {\n                        continue;\n                    }\n\n                    match row {\n                        DataRow::Vec(values) =\u003e {\n                            values.remove(column_index);\n                        }\n                        DataRow::Map(_) =\u003e {\n                            return Err(Error::StorageMsg(\n                                \"conflict - drop_column failed: schemaless row found\".to_owned(),\n                            ));\n                        }\n                    }\n                }\n            }\n            None if if_exists =\u003e {}\n            None =\u003e {\n                return Err(AlterTableError::DroppingColumnNotFound(column_name.to_owned()).into());\n            }\n        };\n\n        Ok(())\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":81},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","memory-storage","src","index.rs"],"content":"use {\n    super::MemoryStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        ast::{IndexOperator, OrderByExpr},\n        data::Value,\n        error::{Error, Result},\n        store::{Index, IndexMut, RowIter},\n    },\n};\n\n#[async_trait(?Send)]\nimpl Index for MemoryStorage {\n    async fn scan_indexed_data\u003c'a\u003e(\n        \u0026'a self,\n        _table_name: \u0026str,\n        _index_name: \u0026str,\n        _asc: Option\u003cbool\u003e,\n        _cmp_value: Option\u003c(\u0026IndexOperator, Value)\u003e,\n    ) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        Err(Error::StorageMsg(\n            \"[MemoryStorage] index is not supported\".to_owned(),\n        ))\n    }\n}\n\n#[async_trait(?Send)]\nimpl IndexMut for MemoryStorage {\n    async fn create_index(\n        \u0026mut self,\n        _table_name: \u0026str,\n        _index_name: \u0026str,\n        _column: \u0026OrderByExpr,\n    ) -\u003e Result\u003c()\u003e {\n        Err(Error::StorageMsg(\n            \"[MemoryStorage] index is not supported\".to_owned(),\n        ))\n    }\n\n    async fn drop_index(\u0026mut self, _table_name: \u0026str, _index_name: \u0026str) -\u003e Result\u003c()\u003e {\n        Err(Error::StorageMsg(\n            \"[MemoryStorage] index is not supported\".to_owned(),\n        ))\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","memory-storage","src","lib.rs"],"content":"#![deny(clippy::str_to_string)]\n\nmod alter_table;\nmod index;\nmod metadata;\nmod transaction;\n\nuse {\n    async_trait::async_trait,\n    futures::stream::iter,\n    gluesql_core::{\n        chrono::Utc,\n        data::{CustomFunction as StructCustomFunction, Key, Schema, Value},\n        error::Result,\n        store::{CustomFunction, CustomFunctionMut, DataRow, RowIter, Store, StoreMut},\n    },\n    serde::{Deserialize, Serialize},\n    std::collections::{BTreeMap, HashMap},\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Item {\n    pub schema: Schema,\n    pub rows: BTreeMap\u003cKey, DataRow\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct MemoryStorage {\n    pub id_counter: i64,\n    pub items: HashMap\u003cString, Item\u003e,\n    pub metadata: HashMap\u003cString, HashMap\u003cString, Value\u003e\u003e,\n    pub functions: HashMap\u003cString, StructCustomFunction\u003e,\n}\n\nimpl MemoryStorage {\n    pub fn scan_data(\u0026self, table_name: \u0026str) -\u003e Vec\u003c(Key, DataRow)\u003e {\n        match self.items.get(table_name) {\n            Some(item) =\u003e item.rows.clone().into_iter().collect(),\n            None =\u003e vec![],\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl CustomFunction for MemoryStorage {\n    async fn fetch_function\u003c'a\u003e(\n        \u0026'a self,\n        func_name: \u0026str,\n    ) -\u003e Result\u003cOption\u003c\u0026'a StructCustomFunction\u003e\u003e {\n        Ok(self.functions.get(\u0026func_name.to_uppercase()))\n    }\n    async fn fetch_all_functions\u003c'a\u003e(\u0026'a self) -\u003e Result\u003cVec\u003c\u0026'a StructCustomFunction\u003e\u003e {\n        Ok(self.functions.values().collect())\n    }\n}\n\n#[async_trait(?Send)]\nimpl CustomFunctionMut for MemoryStorage {\n    async fn insert_function(\u0026mut self, func: StructCustomFunction) -\u003e Result\u003c()\u003e {\n        self.functions.insert(func.func_name.to_uppercase(), func);\n        Ok(())\n    }\n\n    async fn delete_function(\u0026mut self, func_name: \u0026str) -\u003e Result\u003c()\u003e {\n        self.functions.remove(\u0026func_name.to_uppercase());\n        Ok(())\n    }\n}\n\n#[async_trait(?Send)]\nimpl Store for MemoryStorage {\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let mut schemas = self\n            .items\n            .values()\n            .map(|item| item.schema.clone())\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        schemas.sort_by(|a, b| a.table_name.cmp(\u0026b.table_name));\n\n        Ok(schemas)\n    }\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        self.items\n            .get(table_name)\n            .map(|item| Ok(item.schema.clone()))\n            .transpose()\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, key: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        let row = self\n            .items\n            .get(table_name)\n            .and_then(|item| item.rows.get(key).cloned());\n\n        Ok(row)\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        let rows = MemoryStorage::scan_data(self, table_name)\n            .into_iter()\n            .map(Ok);\n\n        Ok(Box::pin(iter(rows)))\n    }\n}\n\n#[async_trait(?Send)]\nimpl StoreMut for MemoryStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let created = HashMap::from([(\n            \"CREATED\".to_owned(),\n            Value::Timestamp(Utc::now().naive_utc()),\n        )]);\n        let meta = HashMap::from([(schema.table_name.clone(), created)]);\n        self.metadata.extend(meta);\n\n        let table_name = schema.table_name.clone();\n        let item = Item {\n            schema: schema.clone(),\n            rows: BTreeMap::new(),\n        };\n        self.items.insert(table_name, item);\n\n        Ok(())\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        self.items.remove(table_name);\n        self.metadata.remove(table_name);\n\n        Ok(())\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        if let Some(item) = self.items.get_mut(table_name) {\n            for row in rows {\n                self.id_counter += 1;\n\n                item.rows.insert(Key::I64(self.id_counter), row);\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        if let Some(item) = self.items.get_mut(table_name) {\n            for (key, row) in rows {\n                item.rows.insert(key, row);\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        if let Some(item) = self.items.get_mut(table_name) {\n            for key in keys {\n                item.rows.remove(\u0026key);\n            }\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":64},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","memory-storage","src","metadata.rs"],"content":"use {\n    crate::MemoryStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        error::Result,\n        store::{MetaIter, Metadata},\n    },\n};\n\n#[async_trait(?Send)]\nimpl Metadata for MemoryStorage {\n    async fn scan_table_meta(\u0026self) -\u003e Result\u003cMetaIter\u003e {\n        let meta = self.metadata.clone().into_iter().map(Ok);\n\n        Ok(Box::new(meta))\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","memory-storage","src","transaction.rs"],"content":"use {\n    super::MemoryStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        error::{Error, Result},\n        store::Transaction,\n    },\n};\n\n#[async_trait(?Send)]\nimpl Transaction for MemoryStorage {\n    async fn begin(\u0026mut self, autocommit: bool) -\u003e Result\u003cbool\u003e {\n        if autocommit {\n            return Ok(false);\n        }\n\n        Err(Error::StorageMsg(\n            \"[MemoryStorage] transaction is not supported\".to_owned(),\n        ))\n    }\n\n    async fn rollback(\u0026mut self) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n\n    async fn commit(\u0026mut self) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","memory-storage","tests","memory_storage.rs"],"content":"use {\n    async_trait::async_trait, futures::stream::TryStreamExt, gluesql_core::prelude::Glue,\n    gluesql_memory_storage::MemoryStorage, test_suite::*,\n};\n\nstruct MemoryTester {\n    glue: Glue\u003cMemoryStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cMemoryStorage\u003e for MemoryTester {\n    async fn new(_: \u0026str) -\u003e Self {\n        let storage = MemoryStorage::default();\n        let glue = Glue::new(storage);\n\n        MemoryTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cMemoryStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, MemoryTester);\n\ngenerate_alter_table_tests!(tokio::test, MemoryTester);\n\ngenerate_metadata_table_tests!(tokio::test, MemoryTester);\n\ngenerate_custom_function_tests!(tokio::test, MemoryTester);\n\nmacro_rules! exec {\n    ($glue: ident $sql: literal) =\u003e {\n        $glue.execute($sql).await.unwrap();\n    };\n}\n\nmacro_rules! test {\n    ($glue: ident $sql: expr, $result: expr) =\u003e {\n        assert_eq!($glue.execute($sql).await, $result);\n    };\n}\n\n#[tokio::test]\nasync fn memory_storage_index() {\n    use gluesql_core::{\n        prelude::{Error, Glue},\n        store::{Index, Store},\n    };\n\n    let storage = MemoryStorage::default();\n\n    assert_eq!(\n        Store::scan_data(\u0026storage, \"Idx\")\n            .await\n            .unwrap()\n            .try_collect::\u003cVec\u003c_\u003e\u003e()\n            .await\n            .as_ref()\n            .map(Vec::len),\n        Ok(0),\n    );\n\n    assert_eq!(\n        storage\n            .scan_indexed_data(\"Idx\", \"hello\", None, None)\n            .await\n            .map(|_| ()),\n        Err(Error::StorageMsg(\n            \"[MemoryStorage] index is not supported\".to_owned()\n        ))\n    );\n\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"CREATE TABLE Idx (id INTEGER);\");\n    test!(\n        glue \"CREATE INDEX idx_id ON Idx (id);\",\n        Err(Error::StorageMsg(\"[MemoryStorage] index is not supported\".to_owned()))\n    );\n    test!(\n        glue \"DROP INDEX Idx.idx_id;\",\n        Err(Error::StorageMsg(\"[MemoryStorage] index is not supported\".to_owned()))\n    );\n}\n\n#[tokio::test]\nasync fn memory_storage_transaction() {\n    use gluesql_core::prelude::{Error, Glue, Payload};\n\n    let storage = MemoryStorage::default();\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"CREATE TABLE TxTest (id INTEGER);\");\n    test!(glue \"BEGIN\", Err(Error::StorageMsg(\"[MemoryStorage] transaction is not supported\".to_owned())));\n    test!(glue \"COMMIT\", Ok(vec![Payload::Commit]));\n    test!(glue \"ROLLBACK\", Ok(vec![Payload::Rollback]));\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","src","description.rs"],"content":"use {\n    gluesql_core::ast::{Expr, ForeignKey},\n    serde::{Deserialize, Serialize},\n};\n\n#[derive(Serialize, Deserialize)]\npub struct TableDescription {\n    pub foreign_keys: Vec\u003cForeignKey\u003e,\n    pub comment: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct ColumnDescription {\n    pub default: Option\u003cExpr\u003e,\n    pub comment: Option\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","src","error.rs"],"content":"use {gluesql_core::error::Error, thiserror::Error};\n\npub trait ResultExt\u003cT, E: ToString\u003e {\n    fn map_storage_err(self) -\u003e Result\u003cT, Error\u003e;\n}\n\nimpl\u003cT, E: ToString\u003e ResultExt\u003cT, E\u003e for std::result::Result\u003cT, E\u003e {\n    fn map_storage_err(self) -\u003e Result\u003cT, Error\u003e {\n        self.map_err(|e| e.to_string()).map_err(Error::StorageMsg)\n    }\n}\n\npub trait OptionExt\u003cT, E: ToString\u003e {\n    fn map_storage_err(self, error: E) -\u003e Result\u003cT, Error\u003e;\n}\n\nimpl\u003cT, E: ToString\u003e OptionExt\u003cT, E\u003e for std::option::Option\u003cT\u003e {\n    fn map_storage_err(self, error: E) -\u003e Result\u003cT, Error\u003e {\n        self.ok_or_else(|| error.to_string())\n            .map_err(Error::StorageMsg)\n    }\n}\n\n#[derive(Error, Debug)]\npub enum MongoStorageError {\n    #[error(\"invalid document\")]\n    InvalidDocument,\n\n    #[error(\"unreachable\")]\n    Unreachable,\n\n    #[error(\"conflict when fetching data\")]\n    ConflictFetchData,\n\n    #[error(\"conflict when appending data\")]\n    ConflictAppendData,\n\n    #[error(\"unsupported bson type\")]\n    UnsupportedBsonType,\n\n    #[error(r#\"Invalid bsonType - it should be Array eg) [\"string\"] or [\"string\", \"null\"]\"#)]\n    InvalidBsonType,\n\n    #[error(\"Invalid glueType - it should be type of GlueSQL Value\")]\n    InvalidGlueType,\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","src","lib.rs"],"content":"mod description;\npub mod error;\npub mod row;\nmod store;\nmod store_mut;\npub mod utils;\n\nuse {\n    error::ResultExt,\n    gluesql_core::{\n        error::Result,\n        store::{\n            AlterTable, CustomFunction, CustomFunctionMut, Index, IndexMut, Metadata, Transaction,\n        },\n    },\n    mongodb::{Client, Database, options::ClientOptions},\n};\n\npub struct MongoStorage {\n    pub db: Database,\n}\n\nimpl MongoStorage {\n    pub async fn new(conn_str: \u0026str, db_name: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let client_options = ClientOptions::parse(conn_str).await.map_storage_err()?;\n        let client = Client::with_options(client_options).map_storage_err()?;\n        let db = client.database(db_name);\n\n        Ok(Self { db })\n    }\n\n    pub async fn drop_database(\u0026self) -\u003e Result\u003c()\u003e {\n        self.db.drop(None).await.map_storage_err()\n    }\n}\n\nimpl Metadata for MongoStorage {}\nimpl AlterTable for MongoStorage {}\nimpl CustomFunction for MongoStorage {}\nimpl CustomFunctionMut for MongoStorage {}\nimpl Index for MongoStorage {}\nimpl IndexMut for MongoStorage {}\nimpl Transaction for MongoStorage {}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","src","row","data_type.rs"],"content":"use {\n    gluesql_core::prelude::DataType,\n    strum_macros::{EnumString, IntoStaticStr},\n};\n\n#[derive(IntoStaticStr, EnumString)]\npub enum BsonType {\n    #[strum(to_string = \"double\")]\n    Double,\n    #[strum(to_string = \"string\")]\n    String,\n    #[strum(to_string = \"object\")]\n    Object,\n    #[strum(to_string = \"array\")]\n    Array,\n    #[strum(to_string = \"binData\")]\n    Binary,\n    #[strum(to_string = \"undefined\")]\n    Undefined,\n    #[strum(to_string = \"objectId\")]\n    ObjectId,\n    #[strum(to_string = \"bool\")]\n    Boolean,\n    #[strum(to_string = \"date\")]\n    Date,\n    #[strum(to_string = \"null\")]\n    Null,\n    #[strum(to_string = \"regex\")]\n    RegularExpression,\n    #[strum(to_string = \"dbPointer\")]\n    DbPointer,\n    #[strum(to_string = \"javascript\")]\n    JavaScript,\n    #[strum(to_string = \"symbol\")]\n    Symbol,\n    #[strum(to_string = \"javascriptWithScope\")]\n    JavaScriptCodeWithScope,\n    #[strum(to_string = \"int\")]\n    Int32,\n    #[strum(to_string = \"timestamp\")]\n    Timestamp,\n    #[strum(to_string = \"long\")]\n    Int64,\n    #[strum(to_string = \"decimal\")]\n    Decimal128,\n    #[strum(to_string = \"minKey\")]\n    MinKey,\n    #[strum(to_string = \"maxKey\")]\n    MaxKey,\n}\n\nimpl From\u003c\u0026DataType\u003e for BsonType {\n    fn from(data_type: \u0026DataType) -\u003e BsonType {\n        match data_type {\n            DataType::Boolean =\u003e BsonType::Boolean,\n            DataType::Int8 =\u003e BsonType::Int32,\n            DataType::Int16 =\u003e BsonType::Int32,\n            DataType::Int32 =\u003e BsonType::Int32,\n            DataType::Int =\u003e BsonType::Int64,\n            DataType::Int128 =\u003e BsonType::Decimal128,\n            DataType::Uint8 =\u003e BsonType::Int32,\n            DataType::Uint16 =\u003e BsonType::Int32,\n            DataType::Uint32 =\u003e BsonType::Int64,\n            DataType::Uint64 =\u003e BsonType::Decimal128,\n            DataType::Uint128 =\u003e BsonType::Decimal128,\n            DataType::Float32 =\u003e BsonType::Double,\n            DataType::Float =\u003e BsonType::Double,\n            DataType::Text =\u003e BsonType::String,\n            DataType::Bytea =\u003e BsonType::Binary,\n            DataType::Date =\u003e BsonType::Date,\n            DataType::Timestamp =\u003e BsonType::String,\n            DataType::Time =\u003e BsonType::Date,\n            DataType::Uuid =\u003e BsonType::Binary,\n            DataType::Map =\u003e BsonType::Object,\n            DataType::List =\u003e BsonType::Array,\n            DataType::Decimal =\u003e BsonType::Decimal128,\n            DataType::Point =\u003e BsonType::Object,\n            DataType::Inet =\u003e BsonType::String,\n            DataType::Interval =\u003e BsonType::String,\n        }\n    }\n}\n\npub const B15: i64 = 2_i64.pow(15);\npub const B7: i64 = 2_i64.pow(7);\npub const B31: i64 = 2_i64.pow(31);\npub const TIME: i64 = 86400000 - 1;\n\npub trait IntoRange {\n    fn get_max(\u0026self) -\u003e Option\u003ci64\u003e;\n    fn get_min(\u0026self) -\u003e Option\u003ci64\u003e;\n}\n\nimpl IntoRange for DataType {\n    fn get_max(\u0026self) -\u003e Option\u003ci64\u003e {\n        match self {\n            DataType::Int8 =\u003e Some(B7),\n            DataType::Int16 =\u003e Some(B15),\n            DataType::Int32 =\u003e Some(B31),\n            DataType::Float32 =\u003e Some(B31),\n            DataType::Time =\u003e Some(TIME),\n            _ =\u003e None,\n        }\n    }\n\n    fn get_min(\u0026self) -\u003e Option\u003ci64\u003e {\n        match self {\n            DataType::Time =\u003e Some(0),\n            v =\u003e v.get_max().map(|max| -max),\n        }\n    }\n}\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":39},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","src","row","key.rs"],"content":"use {\n    crate::error::MongoStorageError,\n    bson::{Binary, Bson},\n    gluesql_core::prelude::Key,\n};\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, MongoStorageError\u003e;\n\npub trait KeyIntoBson {\n    fn into_bson(self, has_primary: bool) -\u003e Result\u003cBson\u003e;\n}\n\nimpl KeyIntoBson for Key {\n    fn into_bson(self, has_primary: bool) -\u003e Result\u003cBson\u003e {\n        match has_primary {\n            true =\u003e Ok(Bson::Binary(Binary {\n                subtype: bson::spec::BinarySubtype::Generic,\n                bytes: self\n                    .to_cmp_be_bytes()\n                    .map_err(|_| MongoStorageError::UnsupportedBsonType)?,\n            })),\n            false =\u003e into_object_id(self),\n        }\n    }\n}\n\npub fn into_object_id(key: Key) -\u003e Result\u003cBson\u003e {\n    match key {\n        Key::Bytea(bytes) =\u003e {\n            let mut byte_array: [u8; 12] = [0; 12];\n            byte_array[..].copy_from_slice(\u0026bytes[..]);\n\n            Ok(Bson::ObjectId(bson::oid::ObjectId::from_bytes(byte_array)))\n        }\n        _ =\u003e Err(MongoStorageError::UnsupportedBsonType),\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","src","row","value.rs"],"content":"use {\n    crate::error::MongoStorageError,\n    gluesql_core::{\n        ast::{Expr, ToSql},\n        chrono::{NaiveDate, NaiveDateTime, TimeZone, Utc},\n        data::{Interval, Point, Value},\n        parse_sql::parse_interval,\n        prelude::DataType,\n        translate::translate_expr,\n    },\n    mongodb::bson::{self, Binary, Bson, DateTime, Decimal128, Document, doc},\n    rust_decimal::Decimal,\n    std::collections::HashMap,\n};\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, MongoStorageError\u003e;\n\npub trait IntoValue {\n    fn into_value_schemaless(self) -\u003e Result\u003cValue\u003e;\n    fn into_value(self, data_type: \u0026DataType) -\u003e Result\u003cValue\u003e;\n}\n\nimpl IntoValue for Bson {\n    fn into_value_schemaless(self) -\u003e Result\u003cValue\u003e {\n        Ok(match self {\n            Bson::String(string) =\u003e Value::Str(string),\n            Bson::Document(d) =\u003e Value::Map(\n                d.into_iter()\n                    .map(|(k, v)| Ok((k, v.into_value_schemaless()?)))\n                    .collect::\u003cResult\u003cHashMap\u003c_, _\u003e\u003e\u003e()?,\n            ),\n            Bson::Boolean(b) =\u003e Value::Bool(b),\n            Bson::Int32(i) =\u003e Value::I32(i),\n            Bson::Int64(i) =\u003e Value::I64(i),\n            Bson::Double(f) =\u003e Value::F64(f),\n            Bson::Array(arr) =\u003e Value::List(\n                arr.into_iter()\n                    .map(|v| v.into_value_schemaless())\n                    .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n            ),\n            Bson::Null =\u003e Value::Null,\n            _ =\u003e {\n                return Err(MongoStorageError::UnsupportedBsonType);\n            }\n        })\n    }\n\n    fn into_value(self, data_type: \u0026DataType) -\u003e Result\u003cValue\u003e {\n        Ok(match (self, data_type) {\n            (Bson::Null, _) =\u003e Value::Null,\n            (Bson::Double(num), DataType::Float32) =\u003e Value::F32(num as f32),\n            (Bson::Double(num), _) =\u003e Value::F64(num),\n            (Bson::String(string), DataType::Inet) =\u003e Value::Inet(\n                string\n                    .parse()\n                    .map_err(|_| MongoStorageError::UnsupportedBsonType)?,\n            ),\n            (Bson::String(string), DataType::Timestamp) =\u003e Value::Timestamp(\n                NaiveDateTime::parse_from_str(\u0026string, \"%Y-%m-%d %H:%M:%S%.f\")\n                    .map_err(|_| MongoStorageError::UnsupportedBsonType)?,\n            ),\n            (Bson::String(string), DataType::Interval) =\u003e {\n                let interval =\n                    parse_interval(string).map_err(|_| MongoStorageError::UnsupportedBsonType)?;\n                let interval = translate_expr(\u0026interval)\n                    .map_err(|_| MongoStorageError::UnsupportedBsonType)?;\n                match interval {\n                    Expr::Interval {\n                        expr,\n                        leading_field,\n                        last_field,\n                    } =\u003e Value::Interval(\n                        Interval::try_from_str(\u0026expr.to_sql(), leading_field, last_field)\n                            .map_err(|_| MongoStorageError::UnsupportedBsonType)?,\n                    ),\n                    _ =\u003e {\n                        return Err(MongoStorageError::UnsupportedBsonType);\n                    }\n                }\n            }\n            (Bson::String(string), _) =\u003e Value::Str(string),\n            (Bson::Array(array), _) =\u003e {\n                let values = array\n                    .into_iter()\n                    .map(|bson| bson.into_value(data_type))\n                    .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n                Value::List(values)\n            }\n            (Bson::Document(d), DataType::Point) =\u003e {\n                let x = d\n                    .get(\"x\")\n                    .and_then(Bson::as_f64)\n                    .ok_or(MongoStorageError::UnsupportedBsonType)?;\n                let y = d\n                    .get(\"y\")\n                    .and_then(Bson::as_f64)\n                    .ok_or(MongoStorageError::UnsupportedBsonType)?;\n\n                Value::Point(Point::new(x, y))\n            }\n            (Bson::Document(d), _) =\u003e Value::Map(\n                d.into_iter()\n                    .map(|(k, v)| Ok((k, v.into_value(data_type)?)))\n                    .collect::\u003cResult\u003cHashMap\u003c_, _\u003e\u003e\u003e()?,\n            ),\n            (Bson::Boolean(b), _) =\u003e Value::Bool(b),\n            (Bson::RegularExpression(regex), _) =\u003e {\n                let pattern = regex.pattern;\n                let options = regex.options;\n                Value::Str(format!(\"/{}/{}\", pattern, options))\n            }\n            (Bson::Int32(i), DataType::Uint8) =\u003e Value::U8(\n                i.try_into()\n                    .map_err(|_| MongoStorageError::UnsupportedBsonType)?,\n            ),\n            (Bson::Int32(i), DataType::Int8) =\u003e Value::I8(i as i8),\n            (Bson::Int32(i), DataType::Int16) =\u003e Value::I16(i as i16),\n            (Bson::Int32(i), DataType::Uint16) =\u003e Value::U16(\n                i.try_into()\n                    .map_err(|_| MongoStorageError::UnsupportedBsonType)?,\n            ),\n            (Bson::Int32(i), _) =\u003e Value::I32(i),\n            (Bson::Int64(i), DataType::Uint32) =\u003e Value::U32(\n                i.try_into()\n                    .map_err(|_| MongoStorageError::UnsupportedBsonType)?,\n            ),\n            (Bson::Int64(i), _) =\u003e Value::I64(i),\n            (Bson::Binary(Binary { bytes, .. }), DataType::Uuid) =\u003e {\n                let u128 = u128::from_be_bytes(\n                    bytes\n                        .try_into()\n                        .map_err(|_| MongoStorageError::UnsupportedBsonType)?,\n                );\n\n                Value::Uuid(u128)\n            }\n            (Bson::Binary(Binary { bytes, .. }), _) =\u003e Value::Bytea(bytes),\n            (Bson::Decimal128(decimal128), DataType::Uint64) =\u003e {\n                let bytes = decimal128.bytes();\n                let u64 = u64::from_be_bytes(\n                    bytes[..8]\n                        .try_into()\n                        .map_err(|_| MongoStorageError::UnsupportedBsonType)?,\n                );\n\n                Value::U64(u64)\n            }\n            (Bson::Decimal128(decimal128), DataType::Uint128) =\u003e {\n                let bytes = decimal128.bytes();\n                let u128 = u128::from_be_bytes(bytes);\n\n                Value::U128(u128)\n            }\n            (Bson::Decimal128(decimal128), DataType::Int128) =\u003e {\n                let bytes = decimal128.bytes();\n                let i128 = i128::from_be_bytes(bytes);\n\n                Value::I128(i128)\n            }\n            (Bson::Decimal128(decimal128), _) =\u003e {\n                let decimal = Decimal::deserialize(decimal128.bytes());\n\n                Value::Decimal(decimal)\n            }\n            (Bson::DateTime(dt), DataType::Time) =\u003e Value::Time(dt.to_chrono().time()),\n            (Bson::DateTime(dt), _) =\u003e Value::Date(dt.to_chrono().date_naive()),\n            (Bson::JavaScriptCode(code), _) =\u003e Value::Str(code),\n            (Bson::JavaScriptCodeWithScope(bson::JavaScriptCodeWithScope { code, scope }), _) =\u003e {\n                Value::Map(HashMap::from([\n                    (\"code\".to_owned(), Value::Str(code)),\n                    (\n                        \"scope\".to_owned(),\n                        bson::to_bson(\u0026scope)\n                            .map_err(|_| MongoStorageError::UnsupportedBsonType)?\n                            .into_value_schemaless()?,\n                    ),\n                ]))\n            }\n            (Bson::MinKey, _) =\u003e Value::Str(\"MinKey()\".to_owned()),\n            (Bson::MaxKey, _) =\u003e Value::Str(\"MaxKey()\".to_owned()),\n            _ =\u003e {\n                return Err(MongoStorageError::UnsupportedBsonType);\n            }\n        })\n    }\n}\n\npub trait IntoBson {\n    fn into_bson(self) -\u003e Result\u003cBson\u003e;\n}\n\nimpl IntoBson for Value {\n    fn into_bson(self) -\u003e Result\u003cBson\u003e {\n        match self {\n            Value::Null =\u003e Ok(Bson::Null),\n            Value::I32(val) =\u003e Ok(Bson::Int32(val)),\n            Value::I64(val) =\u003e Ok(Bson::Int64(val)),\n            Value::F64(val) =\u003e Ok(Bson::Double(val)),\n            Value::Bool(val) =\u003e Ok(Bson::Boolean(val)),\n            Value::Str(val) =\u003e Ok(Bson::String(val)),\n            Value::List(val) =\u003e {\n                let bson = val\n                    .into_iter()\n                    .map(|val| val.into_bson())\n                    .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n                Ok(Bson::Array(bson))\n            }\n            Value::Bytea(bytes) =\u003e Ok(Bson::Binary(bson::Binary {\n                subtype: bson::spec::BinarySubtype::Generic,\n                bytes,\n            })),\n            Value::Decimal(decimal) =\u003e Ok(Bson::Decimal128(Decimal128::from_bytes(\n                decimal.serialize(),\n            ))),\n            Value::I8(val) =\u003e Ok(Bson::Int32(val.into())),\n            Value::F32(val) =\u003e Ok(Bson::Double(val.into())),\n            Value::Uuid(val) =\u003e Ok(Bson::Binary(Binary {\n                subtype: bson::spec::BinarySubtype::Uuid,\n\n                bytes: val.to_be_bytes().to_vec(),\n            })),\n            Value::Date(val) =\u003e {\n                let utc = Utc.from_utc_datetime(\n                    \u0026val.and_hms_opt(0, 0, 0)\n                        .ok_or(MongoStorageError::UnsupportedBsonType)?,\n                );\n                let datetime = DateTime::from_chrono(utc);\n\n                Ok(Bson::DateTime(datetime))\n            }\n            Value::Timestamp(val) =\u003e Ok(Bson::String(val.to_string())),\n            Value::Time(val) =\u003e {\n                let date = NaiveDate::from_ymd_opt(1970, 1, 1)\n                    .ok_or(MongoStorageError::UnsupportedBsonType)?;\n                let utc = Utc.from_utc_datetime(\u0026NaiveDateTime::new(date, val));\n                let datetime = DateTime::from_chrono(utc);\n\n                Ok(Bson::DateTime(datetime))\n            }\n            Value::Point(Point { x, y }) =\u003e Ok(Bson::Document(doc! {  \"x\": x, \"y\": y })),\n            Value::Inet(val) =\u003e Ok(Bson::String(val.to_string())),\n            Value::I16(val) =\u003e Ok(Bson::Int32(val.into())),\n            Value::I128(val) =\u003e Ok(Bson::Decimal128(Decimal128::from_bytes(val.to_be_bytes()))),\n            Value::Map(hash_map) =\u003e {\n                let doc =\n                    hash_map\n                        .into_iter()\n                        .try_fold(Document::new(), |mut acc, (key, value)| {\n                            acc.extend(doc! {key: value.into_bson()?});\n\n                            Ok::\u003c_, MongoStorageError\u003e(acc)\n                        })?;\n\n                Ok(Bson::Document(doc))\n            }\n            Value::U32(val) =\u003e Ok(Bson::Int64(val.into())),\n            Value::U16(val) =\u003e Ok(Bson::Int32(val.into())),\n            Value::U128(val) =\u003e Ok(Bson::Decimal128(Decimal128::from_bytes(val.to_be_bytes()))),\n            Value::U8(val) =\u003e Ok(Bson::Int32(val.into())),\n            Value::U64(val) =\u003e {\n                let mut bytes_128: [u8; 16] = [0; 16];\n                bytes_128[..8].copy_from_slice(\u0026val.to_be_bytes());\n\n                Ok(Bson::Decimal128(Decimal128::from_bytes(bytes_128)))\n            }\n\n            Value::Interval(val) =\u003e Ok(Bson::String(val.to_sql_str())),\n        }\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":174},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","src","row.rs"],"content":"pub mod data_type;\npub mod key;\npub mod value;\n\nuse {\n    self::value::IntoValue,\n    crate::error::ResultExt,\n    gluesql_core::{\n        prelude::{DataType, Key, Result},\n        store::DataRow,\n    },\n    mongodb::bson::Document,\n};\n\npub trait IntoRow {\n    fn into_row\u003c'a\u003e(\n        self,\n        data_types: impl Iterator\u003cItem = \u0026'a DataType\u003e,\n        is_primary: bool,\n    ) -\u003e Result\u003c(Key, DataRow)\u003e;\n}\n\nimpl IntoRow for Document {\n    fn into_row\u003c'a\u003e(\n        self,\n        data_types: impl Iterator\u003cItem = \u0026'a DataType\u003e,\n        has_primary: bool,\n    ) -\u003e Result\u003c(Key, DataRow)\u003e {\n        let key = match has_primary {\n            true =\u003e self.get_binary_generic(\"_id\").map_storage_err()?.to_owned(),\n            false =\u003e self\n                .get_object_id(\"_id\")\n                .map_storage_err()?\n                .bytes()\n                .to_vec(),\n        };\n        let key = Key::Bytea(key);\n\n        let row = self\n            .into_iter()\n            .skip(1)\n            .zip(data_types)\n            .map(|((_, bson), data_type)| bson.into_value(data_type).map_storage_err())\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        Ok((key, DataRow::Vec(row)))\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","src","store.rs"],"content":"use {\n    crate::{\n        MongoStorage,\n        description::{ColumnDescription, TableDescription},\n        error::{MongoStorageError, OptionExt, ResultExt},\n        row::{IntoRow, key::KeyIntoBson, value::IntoValue},\n        utils::get_primary_key,\n    },\n    async_trait::async_trait,\n    futures::{Stream, StreamExt, TryStreamExt, stream},\n    gluesql_core::{\n        ast::{ColumnDef, ColumnUniqueOption},\n        data::{Key, Schema},\n        error::Result,\n        parse_sql::parse_data_type,\n        prelude::{Error, Value},\n        store::{DataRow, RowIter, Store},\n        translate::translate_data_type,\n    },\n    mongodb::{\n        IndexModel,\n        bson::{Document, doc, document::ValueAccessError},\n        options::{FindOptions, ListIndexesOptions},\n    },\n    serde_json::from_str,\n    std::{collections::HashMap, future},\n};\n\n#[async_trait(?Send)]\nimpl Store for MongoStorage {\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        self.fetch_schemas_iter(Some(table_name))\n            .await?\n            .next()\n            .await\n            .transpose()\n    }\n\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let mut schemas = self\n            .fetch_schemas_iter(None)\n            .await?\n            .try_collect::\u003cVec\u003c_\u003e\u003e()\n            .await?;\n\n        schemas.sort_by(|a, b| a.table_name.cmp(\u0026b.table_name));\n\n        Ok(schemas)\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, target: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        let column_defs = self\n            .get_column_defs(table_name)\n            .await?\n            .map_storage_err(MongoStorageError::ConflictFetchData)?;\n\n        let primary_key = get_primary_key(\u0026column_defs)\n            .ok_or(MongoStorageError::Unreachable)\n            .map_storage_err()?;\n\n        let filter = doc! { \"_id\": target.to_owned().into_bson(true).map_storage_err()?};\n        let projection = doc! {\"_id\": 0};\n        let options = FindOptions::builder()\n            .projection(projection)\n            .sort(doc! { primary_key.name.clone(): 1 })\n            .build();\n\n        let mut cursor = self\n            .db\n            .collection::\u003cDocument\u003e(table_name)\n            .find(filter, options)\n            .await\n            .map_storage_err()?;\n\n        cursor\n            .next()\n            .await\n            .transpose()\n            .map_storage_err()?\n            .map(|doc| {\n                doc.into_iter()\n                    .zip(column_defs.iter())\n                    .map(|((_, bson), column_def)| {\n                        bson.into_value(\u0026column_def.data_type).map_storage_err()\n                    })\n                    .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n                    .map(DataRow::Vec)\n            })\n            .transpose()\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        let column_defs = self.get_column_defs(table_name).await?;\n\n        let primary_key = column_defs\n            .as_ref()\n            .and_then(|column_defs| get_primary_key(column_defs));\n\n        let has_primary = primary_key.is_some();\n\n        let options = FindOptions::builder();\n        let options = match primary_key {\n            Some(primary_key) =\u003e options.sort(doc! { primary_key.name.to_owned(): 1}).build(),\n            None =\u003e options.build(),\n        };\n\n        let cursor = self\n            .db\n            .collection::\u003cDocument\u003e(table_name)\n            .find(Document::new(), options)\n            .await\n            .map_storage_err()?;\n\n        let column_types = column_defs.as_ref().map(|column_defs| {\n            column_defs\n                .iter()\n                .map(|column_def| column_def.data_type.clone())\n                .collect::\u003cVec\u003c_\u003e\u003e()\n        });\n\n        let row_iter = cursor.map(move |doc| {\n            let doc = doc.map_storage_err()?;\n\n            match \u0026column_types {\n                Some(column_types) =\u003e doc.into_row(column_types.iter(), has_primary),\n                None =\u003e {\n                    let mut iter = doc.into_iter();\n                    let (_, first_value) = iter\n                        .next()\n                        .map_storage_err(MongoStorageError::InvalidDocument)?;\n                    let key_bytes = first_value\n                        .as_object_id()\n                        .map_storage_err(MongoStorageError::InvalidDocument)?\n                        .bytes()\n                        .to_vec();\n                    let key = Key::Bytea(key_bytes);\n                    let row = iter\n                        .map(|(key, bson)| {\n                            Ok((key, bson.into_value_schemaless().map_storage_err()?))\n                        })\n                        .collect::\u003cResult\u003cHashMap\u003cString, Value\u003e\u003e\u003e()?;\n\n                    Ok((key, DataRow::Map(row)))\n                }\n            }\n        });\n\n        Ok(Box::pin(row_iter))\n    }\n}\n\nimpl MongoStorage {\n    async fn fetch_schemas_iter\u003c'a\u003e(\n        \u0026'a self,\n        table_name: Option\u003c\u0026'a str\u003e,\n    ) -\u003e Result\u003cimpl Stream\u003cItem = Result\u003cSchema\u003e\u003e + 'a\u003e {\n        let command = match table_name {\n            Some(table_name) =\u003e doc! { \"listCollections\": 1, \"filter\": { \"name\": table_name } },\n            None =\u003e doc! { \"listCollections\": 1 },\n        };\n\n        let validators_list = self\n            .db\n            .run_command(command, None)\n            .await\n            .map_storage_err()?\n            .get_document(\"cursor\")\n            .and_then(|doc| doc.get_array(\"firstBatch\"))\n            .map_storage_err()?\n            .to_owned();\n\n        let schemas = stream::iter(validators_list).then(move |validators| async move {\n            let doc = validators\n                .as_document()\n                .map_storage_err(MongoStorageError::InvalidDocument)?;\n\n            let collection_name = doc.get_str(\"name\").map_storage_err()?;\n            let validator = doc\n                .get_document(\"options\")\n                .and_then(|doc| doc.get_document(\"validator\"))\n                .and_then(|doc| doc.get_document(\"$jsonSchema\"))\n                .map_storage_err()?;\n\n            let collection = self.db.collection::\u003cDocument\u003e(collection_name);\n            let options = ListIndexesOptions::builder().build();\n            let cursor = collection.list_indexes(options).await.map_storage_err()?;\n            let indexes = cursor\n                .into_stream()\n                .map_err(|e| Error::StorageMsg(e.to_string()))\n                .try_filter_map(|index_model| {\n                    let IndexModel { keys, options, .. } = index_model;\n                    if keys.len() \u003e 1 {\n                        return future::ready(Ok::\u003c_, Error\u003e(None));\n                    }\n\n                    let index_keys = \u0026mut keys.into_iter().map(|(index_key, _)| index_key);\n                    let index_key = index_keys.next();\n                    let name = options.and_then(|options| options.name);\n\n                    future::ready(Ok::\u003c_, Error\u003e(index_key.zip(name)))\n                })\n                .try_collect::\u003cHashMap\u003cString, String\u003e\u003e()\n                .await?;\n\n            let column_defs = validator\n                .get_document(\"properties\")\n                .map_storage_err()?\n                .into_iter()\n                .skip(1)\n                .map(|(column_name, doc)| {\n                    let doc = doc\n                        .as_document()\n                        .map_storage_err(MongoStorageError::InvalidDocument)?;\n\n                    let nullable = doc\n                        .get_array(\"bsonType\")\n                        .map_err(|_| MongoStorageError::InvalidBsonType)\n                        .map_storage_err()?\n                        .get(1)\n                        .and_then(|x| x.as_str())\n                        .map(|x| x == \"null\")\n                        .unwrap_or(false);\n\n                    let data_type = doc\n                        .get_str(\"title\")\n                        .map_err(|_| MongoStorageError::InvalidGlueType)\n                        .map_storage_err()\n                        .and_then(parse_data_type)\n                        .and_then(|s| translate_data_type(\u0026s))?;\n\n                    let index_name = indexes.get(column_name).and_then(|i| i.split_once('_'));\n\n                    let unique = match index_name {\n                        Some((_, \"PK\")) =\u003e Some(true),\n                        Some((_, \"UNIQUE\")) =\u003e Some(false),\n                        _ =\u003e None,\n                    }\n                    .map(|is_primary| ColumnUniqueOption { is_primary });\n\n                    let column_description = doc.get_str(\"description\");\n                    let ColumnDescription { default, comment } = match column_description {\n                        Ok(desc) =\u003e {\n                            serde_json::from_str::\u003cColumnDescription\u003e(desc).map_storage_err()?\n                        }\n                        Err(ValueAccessError::NotPresent) =\u003e ColumnDescription {\n                            default: None,\n                            comment: None,\n                        },\n                        Err(_) =\u003e {\n                            return Err(Error::StorageMsg(\n                                MongoStorageError::InvalidGlueType.to_string(),\n                            ));\n                        }\n                    };\n\n                    let column_def = ColumnDef {\n                        name: column_name.to_owned(),\n                        data_type,\n                        nullable,\n                        default,\n                        unique,\n                        comment,\n                    };\n\n                    Ok(column_def)\n                })\n                .collect::\u003cResult\u003cVec\u003cColumnDef\u003e\u003e\u003e()?;\n\n            let column_defs = match column_defs.len() {\n                0 =\u003e None,\n                _ =\u003e Some(column_defs),\n            };\n\n            let table_description = validator.get_str(\"description\").map_storage_err()?;\n            let TableDescription {\n                foreign_keys,\n                comment,\n            } = from_str::\u003cTableDescription\u003e(table_description).map_storage_err()?;\n\n            let schema = Schema {\n                table_name: collection_name.to_owned(),\n                column_defs,\n                indexes: Vec::new(),\n                engine: None,\n                foreign_keys,\n                comment,\n            };\n\n            Ok::\u003c_, Error\u003e(schema)\n        });\n\n        Ok(Box::pin(schemas))\n    }\n\n    pub async fn get_column_defs(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cVec\u003cColumnDef\u003e\u003e\u003e {\n        Ok(self\n            .fetch_schema(table_name)\n            .await?\n            .and_then(|schema| schema.column_defs))\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":182},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","src","store_mut.rs"],"content":"use {\n    crate::{\n        MongoStorage,\n        description::ColumnDescription,\n        error::{MongoStorageError, OptionExt, ResultExt},\n        row::{\n            data_type::{BsonType, IntoRange},\n            key::{KeyIntoBson, into_object_id},\n            value::IntoBson,\n        },\n        utils::{Validator, get_primary_key},\n    },\n    async_trait::async_trait,\n    gluesql_core::{\n        ast::ColumnUniqueOption,\n        data::{Key, Schema},\n        error::{Error, Result},\n        store::{DataRow, Store, StoreMut},\n    },\n    mongodb::{\n        bson::{Bson, Document, doc},\n        options::{IndexOptions, ReplaceOptions},\n    },\n};\n\nstruct IndexInfo {\n    name: String,\n    key: String,\n    index_type: IndexType,\n}\n\nenum IndexType {\n    Primary,\n    Unique,\n}\n\n#[async_trait(?Send)]\nimpl StoreMut for MongoStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let (labels, column_types, indexes) = schema\n            .column_defs\n            .as_ref()\n            .map(|column_defs| {\n                column_defs.iter().try_fold(\n                    (Vec::new(), Document::new(), Vec::new()),\n                    |(mut labels, mut column_types, mut indexes), column_def| {\n                        let column_name = \u0026column_def.name;\n                        labels.push(column_name.clone());\n\n                        let data_type = BsonType::from(\u0026column_def.data_type).into();\n                        let maximum = column_def.data_type.get_max();\n                        let minimum = column_def.data_type.get_min();\n\n                        let mut bson_type = match column_def.nullable {\n                            true =\u003e vec![data_type, \"null\"],\n                            false =\u003e vec![data_type],\n                        };\n\n                        if let Some(ColumnUniqueOption { is_primary }) = \u0026column_def.unique {\n                            match *is_primary {\n                                true =\u003e {\n                                    indexes.push(IndexInfo {\n                                        name: format!(\"{column_name}_PK\"),\n                                        key: column_name.clone(),\n                                        index_type: IndexType::Primary,\n                                    });\n                                }\n                                false =\u003e {\n                                    bson_type = vec![data_type, \"null\"];\n                                    indexes.push(IndexInfo {\n                                        name: format!(\"{column_name}_UNIQUE\"),\n                                        key: column_name.clone(),\n                                        index_type: IndexType::Unique,\n                                    });\n                                }\n                            }\n                        }\n\n                        let mut property = doc! {\n                            \"bsonType\": bson_type,\n                        };\n\n                        if let Some(maximum) = maximum {\n                            property.extend(doc! {\n                                \"maximum\": maximum,\n                            });\n                        }\n\n                        if let Some(minimum) = minimum {\n                            property.extend(doc! {\n                                \"minimum\": minimum,\n                            });\n                        }\n\n                        let column_description = ColumnDescription {\n                            default: column_def.default.clone(),\n                            comment: column_def.comment.clone(),\n                        };\n                        let column_description =\n                            serde_json::to_string(\u0026column_description).map_storage_err()?;\n\n                        property.extend(doc! {\n                            \"description\": column_description,\n                        });\n\n                        let type_str = column_def.data_type.to_string();\n                        property.extend(doc! {\n                            \"title\": type_str\n                        });\n\n                        let column_type = doc! {\n                            column_name: property,\n                        };\n\n                        column_types.extend(column_type);\n\n                        Ok::\u003c_, Error\u003e((labels, column_types, indexes))\n                    },\n                )\n            })\n            .transpose()?\n            .unwrap_or_default();\n\n        let comment = schema.comment.as_ref().map(ToOwned::to_owned);\n        let validator = Validator::new(labels, column_types, schema.foreign_keys.clone(), comment)?;\n\n        let schema_exists = self\n            .fetch_schema(\u0026schema.table_name)\n            .await\n            .map_storage_err()?\n            .is_some();\n\n        if schema_exists {\n            let command = doc! {\n                \"collMod\": schema.table_name.clone(),\n                \"validator\": validator.document,\n                \"validationLevel\": \"strict\",\n                \"validationAction\": \"error\",\n            };\n            self.db.run_command(command, None).await.map_storage_err()?;\n\n            return Ok(());\n        }\n\n        let options = validator.to_options();\n\n        self.db\n            .create_collection(\u0026schema.table_name, options)\n            .await\n            .map_storage_err()?;\n\n        if indexes.is_empty() {\n            return Ok(());\n        }\n\n        let index_models = indexes\n            .into_iter()\n            .map(\n                |IndexInfo {\n                     name,\n                     key,\n                     index_type,\n                 }| {\n                    let index_options = IndexOptions::builder().unique(true);\n                    let index_options = match index_type {\n                        IndexType::Primary =\u003e index_options.name(name).build(),\n                        IndexType::Unique =\u003e index_options\n                            .partial_filter_expression(\n                                doc! { \"partialFilterExpression\": { key.clone(): { \"$ne\": null } } }, \n                            )\n                            .name(name)\n                            .build(),\n                    };\n\n                    mongodb::IndexModel::builder()\n                        .keys(doc! {key: 1})\n                        .options(index_options)\n                        .build()\n                },\n            )\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        self.db\n            .collection::\u003cDocument\u003e(\u0026schema.table_name)\n            .create_indexes(index_models, None)\n            .await\n            .map(|_| ())\n            .map_storage_err()\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        self.db\n            .collection::\u003cDocument\u003e(table_name)\n            .drop(None)\n            .await\n            .map_storage_err()\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let column_defs = self.get_column_defs(table_name).await?;\n\n        let data = rows\n            .into_iter()\n            .map(|row| match row {\n                DataRow::Vec(values) =\u003e column_defs\n                    .as_ref()\n                    .map_storage_err(MongoStorageError::ConflictAppendData)?\n                    .iter()\n                    .zip(values.into_iter())\n                    .try_fold(Document::new(), |mut acc, (column_def, value)| {\n                        acc.extend(\n                            doc! {column_def.name.clone(): value.into_bson().map_storage_err()?},\n                        );\n\n                        Ok(acc)\n                    }),\n                DataRow::Map(hash_map) =\u003e {\n                    hash_map\n                        .into_iter()\n                        .try_fold(Document::new(), |mut acc, (key, value)| {\n                            acc.extend(doc! {key: value.into_bson().map_storage_err()?});\n\n                            Ok(acc)\n                        })\n                }\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        if data.is_empty() {\n            return Ok(());\n        }\n\n        self.db\n            .collection::\u003cDocument\u003e(table_name)\n            .insert_many(data, None)\n            .await\n            .map(|_| ())\n            .map_storage_err()\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        let column_defs = self.get_column_defs(table_name).await?;\n\n        let primary_key = column_defs\n            .as_ref()\n            .and_then(|column_defs| get_primary_key(column_defs));\n\n        for (key, row) in rows {\n            let doc = match row {\n                DataRow::Vec(values) =\u003e column_defs\n                    .as_ref()\n                    .map_storage_err(MongoStorageError::Unreachable)?\n                    .iter()\n                    .zip(values.into_iter())\n                    .try_fold(\n                        doc! {\"_id\": key.clone().into_bson(primary_key.is_some()).map_storage_err()?},\n                        |mut acc, (column_def, value)| {\n                            acc.extend(doc! {column_def.name.clone(): value.into_bson().map_storage_err()?});\n\n                            Ok::\u003c_, Error\u003e(acc)\n                        },\n                    ),\n                DataRow::Map(hash_map) =\u003e hash_map.into_iter().try_fold(\n                    doc! {\"_id\": into_object_id(key.clone()).map_storage_err()?},\n                    |mut acc, (key, value)| {\n                        acc.extend(doc! {key: value.into_bson().map_storage_err()?});\n\n                        Ok(acc)\n                    },\n                ),\n            }?;\n\n            let query = doc! {\"_id\": key.into_bson(primary_key.is_some()).map_storage_err()?};\n            let options = ReplaceOptions::builder().upsert(Some(true)).build();\n\n            self.db\n                .collection::\u003cDocument\u003e(table_name)\n                .replace_one(query, doc, options)\n                .await\n                .map_storage_err()?;\n        }\n\n        Ok(())\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        let column_defs = self.get_column_defs(table_name).await?;\n        let primary_key = column_defs\n            .as_ref()\n            .and_then(|column_defs| get_primary_key(column_defs));\n\n        self.db\n            .collection::\u003cBson\u003e(table_name)\n            .delete_many(\n                doc! { \"_id\": {\n                    \"$in\": keys\n                        .into_iter()\n                        .map(|key| key.into_bson(primary_key.is_some()).map_storage_err())\n                        .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?\n                }},\n                None,\n            )\n            .await\n            .map(|_| ())\n            .map_storage_err()\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":157},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","src","utils.rs"],"content":"use {\n    crate::{description::TableDescription, error::ResultExt},\n    bson::{Document, doc},\n    gluesql_core::{\n        ast::{ColumnDef, ForeignKey},\n        error::Result,\n    },\n    mongodb::options::CreateCollectionOptions,\n    serde_json::to_string,\n};\n\npub fn get_primary_key(column_defs: \u0026[ColumnDef]) -\u003e Option\u003c\u0026ColumnDef\u003e {\n    column_defs\n        .iter()\n        .find(|column_def| column_def.unique.map(|x| x.is_primary).unwrap_or(false))\n}\n\npub struct Validator {\n    pub document: Document,\n}\n\nimpl Validator {\n    pub fn new(\n        labels: Vec\u003cString\u003e,\n        column_types: Document,\n        foreign_keys: Vec\u003cForeignKey\u003e,\n        comment: Option\u003cString\u003e,\n    ) -\u003e Result\u003cSelf\u003e {\n        let mut required = vec![\"_id\".to_owned()];\n        required.extend(labels);\n\n        let mut properties = doc! {\n            \"_id\": { \"bsonType\": [\"objectId\", \"binData\"] }\n        };\n        properties.extend(column_types);\n\n        let additional_properties = matches!(required.len(), 1);\n        let table_description = to_string(\n            \u0026(TableDescription {\n                foreign_keys,\n                comment,\n            }),\n        )\n        .map_storage_err()?;\n\n        let document = doc! {\n            \"$jsonSchema\": {\n                \"type\": \"object\",\n                \"required\": required,\n                \"properties\": properties,\n                \"description\": table_description,\n                \"additionalProperties\": additional_properties\n              }\n        };\n\n        Ok(Self { document })\n    }\n\n    pub fn to_options(self) -\u003e CreateCollectionOptions {\n        CreateCollectionOptions::builder()\n            .validator(Some(self.document))\n            .build()\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","tests","mongo_indexes.rs"],"content":"#![cfg(feature = \"test-mongo\")]\n\nuse {\n    bson::{Document, doc},\n    gluesql_core::prelude::{Glue, Payload},\n    gluesql_mongo_storage::{MongoStorage, utils::Validator},\n    mongodb::{IndexModel, options::IndexOptions},\n    std::vec,\n};\n\n#[tokio::test]\nasync fn mongo_indexes() {\n    let conn_str = \"mongodb://localhost:27017\";\n\n    let storage = MongoStorage::new(conn_str, \"mongo_indexes\")\n        .await\n        .expect(\"MongoStorage::new\");\n    storage.drop_database().await.expect(\"database dropped\");\n\n    let labels = vec![\"id\".to_owned(), \"name\".to_owned()];\n    let column_types = doc! {\n        \"id\": { \"bsonType\": [\"int\"], \"title\": \"INT\" },\n        \"name\": { \"bsonType\": [\"string\"], \"title\": \"TEXT\" },\n    };\n\n    let options = Validator::new(labels, column_types, Vec::new(), None)\n        .unwrap()\n        .to_options();\n\n    let table_name = \"collection_with_composite_index\";\n\n    storage\n        .db\n        .create_collection(table_name, options)\n        .await\n        .expect(\"create_collection\");\n\n    let index_options = IndexOptions::builder()\n        .name(\"ignored_composite_index\".to_owned())\n        .build();\n    let index_model = IndexModel::builder()\n        .keys(doc! {\"id\": 1, \"name\":1 })\n        .options(index_options)\n        .build();\n    let collection = storage.db.collection::\u003cDocument\u003e(table_name);\n    collection.create_index(index_model, None).await.unwrap();\n\n    let mut glue = Glue::new(storage);\n\n    let cases = vec![(\n        glue.execute(format! {\"SELECT * FROM {table_name}\"}).await,\n        Ok(Payload::Select {\n            labels: vec![\"id\".to_owned(), \"name\".to_owned()],\n            rows: vec![],\n        }),\n    )];\n\n    for (actual, expected) in cases {\n        assert_eq!(actual.map(|mut payloads| payloads.remove(0)), expected);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","tests","mongo_schemaless.rs"],"content":"#![cfg(feature = \"test-mongo\")]\n\nuse {\n    gluesql_core::prelude::{Glue, Payload, Value},\n    gluesql_mongo_storage::MongoStorage,\n    serde_json::json,\n    std::collections::HashMap,\n};\n\n#[tokio::test]\nasync fn mongo_schemaless() {\n    let conn_str = \"mongodb://localhost:27017\";\n\n    let storage = MongoStorage::new(conn_str, \"mongo_schemaless\")\n        .await\n        .expect(\"MongoStorage::new\");\n    storage.drop_database().await.expect(\"database dropped\");\n\n    let mut glue = Glue::new(storage);\n\n    glue.execute(\"CREATE TABLE Logs\").await.unwrap();\n    glue.execute(\n        format!(\n            \"INSERT INTO Logs VALUES ('{}'), ('{}'), ('{}');\",\n            json!({ \"id\": 1, \"value\": 30 }),\n            json!({ \"id\": 2, \"rate\": 3.5, \"list\": [1, 2, 3] }),\n            json!({ \"id\": 3, \"optional\": null })\n        )\n        .as_str(),\n    )\n    .await\n    .unwrap();\n\n    let actual = glue.execute(\"SELECT * FROM Logs\").await;\n    let expected = Ok(vec![Payload::SelectMap(vec![\n        HashMap::from([\n            (\"id\".to_owned(), Value::I64(1)),\n            (\"value\".to_owned(), Value::I64(30)),\n        ]),\n        HashMap::from([\n            (\"id\".to_owned(), Value::I64(2)),\n            (\"rate\".to_owned(), Value::F64(3.5)),\n            (\n                \"list\".to_owned(),\n                Value::List(vec![Value::I64(1), Value::I64(2), Value::I64(3)]),\n            ),\n        ]),\n        HashMap::from([\n            (\"id\".to_owned(), Value::I64(3)),\n            (\"optional\".to_owned(), Value::Null),\n        ]),\n    ])]);\n    assert_eq!(actual, expected);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","tests","mongo_storage.rs"],"content":"#![cfg(feature = \"test-mongo\")]\n\nuse {\n    async_trait::async_trait, gluesql_core::prelude::Glue, gluesql_mongo_storage::MongoStorage,\n    test_suite::*,\n};\n\nstruct MongoTester {\n    glue: Glue\u003cMongoStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cMongoStorage\u003e for MongoTester {\n    async fn new(namespace: \u0026str) -\u003e Self {\n        let conn_str = \"mongodb://localhost:27017\";\n        let storage = MongoStorage::new(conn_str, namespace)\n            .await\n            .expect(\"MongoStorage::new\");\n        storage.drop_database().await.expect(\"database dropped\");\n        let glue = Glue::new(storage);\n\n        MongoTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cMongoStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, MongoTester);\ngenerate_alter_table_tests!(tokio::test, MongoTester);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","tests","mongo_storage_conflict.rs"],"content":"#![cfg(feature = \"test-mongo\")]\n\nuse {\n    gluesql_core::{\n        data::Key,\n        error::Error,\n        prelude::{Glue, Value},\n        store::{DataRow, Store, StoreMut},\n    },\n    gluesql_mongo_storage::{MongoStorage, error::MongoStorageError},\n};\n\n#[tokio::test]\nasync fn mongo_storage_conflict_errors() {\n    let conn_str = \"mongodb://localhost:27017\";\n\n    let storage = MongoStorage::new(conn_str, \"mongo_storage_conflict\")\n        .await\n        .expect(\"MongoStorage::new\");\n    storage.drop_database().await.expect(\"database dropped\");\n\n    let mut glue = Glue::new(storage);\n\n    glue.execute(\"CREATE TABLE Logs\").await.unwrap();\n\n    let actual = glue.storage.fetch_data(\"Logs\", \u0026Key::I64(1)).await;\n    let expected = Err(Error::StorageMsg(\n        MongoStorageError::ConflictFetchData.to_string(),\n    ));\n    assert_eq!(\n        actual, expected,\n        \"fetch_data on schemaless table should return conflict error\"\n    );\n\n    let actual = glue\n        .storage\n        .append_data(\"Logs\", vec![DataRow::Vec(vec![Value::I64(1)])])\n        .await;\n    let expected = Err(Error::StorageMsg(\n        MongoStorageError::ConflictAppendData.to_string(),\n    ));\n    assert_eq!(\n        actual, expected,\n        \"append_data with DataRow::Vec should return conflict error\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","mongo-storage","tests","mongo_types.rs"],"content":"#![cfg(feature = \"test-mongo\")]\n\nuse {\n    bson::{Bson, doc},\n    gluesql_core::prelude::{Glue, Payload, Value},\n    gluesql_mongo_storage::{MongoStorage, utils::Validator},\n    std::{collections::HashMap, vec},\n};\n\n#[tokio::test]\nasync fn mongo_types() {\n    let conn_str = \"mongodb://localhost:27017\";\n\n    let storage = MongoStorage::new(conn_str, \"mongo_types\")\n        .await\n        .expect(\"MongoStorage::new\");\n    storage.drop_database().await.expect(\"database dropped\");\n\n    let labels = vec![\n        \"col_javascript\".to_owned(),\n        \"col_javascriptWithScope\".to_owned(),\n        \"col_regex\".to_owned(),\n        \"col_minKey\".to_owned(),\n        \"col_maxKey\".to_owned(),\n    ];\n    let column_types = doc! {\n        \"col_javascript\": { \"bsonType\": [\"javascript\"], \"title\": \"TEXT\" },\n        \"col_javascriptWithScope\": { \"bsonType\": [\"javascriptWithScope\"], \"title\": \"TEXT\" },\n        \"col_regex\": { \"bsonType\": [\"regex\"], \"title\": \"TEXT\" },\n        \"col_minKey\": { \"bsonType\": [\"minKey\"], \"title\": \"TEXT\" },\n        \"col_maxKey\": { \"bsonType\": [\"maxKey\"], \"title\": \"TEXT\" },\n    };\n\n    let options = Validator::new(labels, column_types, Vec::new(), None)\n        .unwrap()\n        .to_options();\n\n    let table_name = \"mongo_type_collection\";\n\n    storage\n        .db\n        .create_collection(table_name, options)\n        .await\n        .expect(\"create_collection\");\n\n    let data = doc! {\n        \"col_javascript\": Bson::JavaScriptCode(\"function add(a, b) { return a + b; }\".to_owned()),\n        \"col_javascriptWithScope\": Bson::JavaScriptCodeWithScope(bson::JavaScriptCodeWithScope {\n            code: \"function sub(a, b) { return a - b; }\".to_owned(),\n            scope: doc! { \"a\": 1, \"b\": 2 }\n        }),\n        \"col_regex\": Bson::RegularExpression(bson::Regex {\n            pattern: \"^[a-z]*$\".to_owned(),\n            options: \"i\".to_owned()\n        }),\n        \"col_minKey\": Bson::MinKey,\n        \"col_maxKey\": Bson::MaxKey,\n    };\n\n    storage\n        .db\n        .collection(table_name)\n        .insert_one(data, None)\n        .await\n        .expect(\"insert_data\");\n\n    let mut glue = Glue::new(storage);\n\n    let cases = vec![(\n        glue.execute(format! {\"SELECT * FROM {table_name}\"}).await,\n        Ok(Payload::Select {\n            labels: vec![\n                \"col_javascript\".to_owned(),\n                \"col_javascriptWithScope\".to_owned(),\n                \"col_regex\".to_owned(),\n                \"col_minKey\".to_owned(),\n                \"col_maxKey\".to_owned(),\n            ],\n            rows: vec![vec![\n                Value::Str(\"function add(a, b) { return a + b; }\".to_owned()),\n                Value::Map(HashMap::from([\n                    (\n                        \"code\".to_owned(),\n                        Value::Str(\"function sub(a, b) { return a - b; }\".to_owned()),\n                    ),\n                    (\n                        \"scope\".to_owned(),\n                        Value::Map(HashMap::from([\n                            (\"a\".to_owned(), Value::I32(1)),\n                            (\"b\".to_owned(), Value::I32(2)),\n                        ])),\n                    ),\n                ])),\n                Value::Str(\"/^[a-z]*$/i\".to_owned()),\n                Value::Str(\"MinKey()\".to_owned()),\n                Value::Str(\"MaxKey()\".to_owned()),\n            ]],\n        }),\n    )];\n\n    for (actual, expected) in cases {\n        assert_eq!(actual.map(|mut payloads| payloads.remove(0)), expected);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","src","alter_table.rs"],"content":"use {super::ParquetStorage, gluesql_core::store::AlterTable};\n\nimpl AlterTable for ParquetStorage {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","src","column_def.rs"],"content":"use {\n    gluesql_core::{\n        ast::{ColumnDef, ColumnUniqueOption},\n        parse_sql::parse_expr,\n        prelude::{DataType, Error},\n        translate::translate_expr,\n    },\n    lazy_static::lazy_static,\n    parquet::{basic::Type as PhysicalType, format::KeyValue, schema::types::Type as SchemaType},\n    std::{collections::HashMap, convert::TryFrom},\n};\n\nlazy_static! {\n    static ref PARQUET_TO_GLUESQL_DATA_TYPE_MAPPING: HashMap\u003c\u0026'static str, DataType\u003e = {\n        let mut m = HashMap::new();\n        m.insert(\"Boolean\", DataType::Boolean);\n        m.insert(\"Int8\", DataType::Int8);\n        m.insert(\"Int16\", DataType::Int16);\n        m.insert(\"Int32\", DataType::Int32);\n        m.insert(\"Int\", DataType::Int);\n        m.insert(\"Int128\", DataType::Int128);\n        m.insert(\"Uint8\", DataType::Uint8);\n        m.insert(\"Uint16\", DataType::Uint16);\n        m.insert(\"Uint32\", DataType::Uint32);\n        m.insert(\"Uint64\", DataType::Uint64);\n        m.insert(\"Uint128\", DataType::Uint128);\n        m.insert(\"Float32\", DataType::Float32);\n        m.insert(\"Float\", DataType::Float);\n        m.insert(\"Text\", DataType::Text);\n        m.insert(\"Bytea\", DataType::Bytea);\n        m.insert(\"Inet\", DataType::Inet);\n        m.insert(\"Date\", DataType::Date);\n        m.insert(\"Timestamp\", DataType::Timestamp);\n        m.insert(\"Time\", DataType::Time);\n        m.insert(\"Interval\", DataType::Interval);\n        m.insert(\"Uuid\", DataType::Uuid);\n        m.insert(\"Map\", DataType::Map);\n        m.insert(\"List\", DataType::List);\n        m.insert(\"Decimal\", DataType::Decimal);\n        m.insert(\"Point\", DataType::Point);\n        m\n    };\n}\n\npub fn map_parquet_to_gluesql(data_type: \u0026str) -\u003e Option\u003c\u0026'static DataType\u003e {\n    PARQUET_TO_GLUESQL_DATA_TYPE_MAPPING.get(data_type)\n}\n\n#[derive(Debug)]\npub struct ParquetSchemaType\u003c'a\u003e {\n    pub inner: \u0026'a SchemaType,\n    pub metadata: Option\u003c\u0026'a Vec\u003cKeyValue\u003e\u003e, // this will hold the metadata for unique \u0026 primary key concepts\n}\n\nimpl\u003c'a\u003e ParquetSchemaType\u003c'a\u003e {\n    pub fn inner(\u0026self) -\u003e \u0026'a SchemaType {\n        self.inner\n    }\n\n    pub fn get_metadata(\u0026self) -\u003e \u0026Option\u003c\u0026'a Vec\u003cKeyValue\u003e\u003e {\n        \u0026self.metadata\n    }\n}\n\nimpl\u003c'a\u003e TryFrom\u003cParquetSchemaType\u003c'a\u003e\u003e for ColumnDef {\n    type Error = Error;\n\n    fn try_from(parquet_col_def: ParquetSchemaType\u003c'a\u003e) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let inner = parquet_col_def.inner();\n\n        let name = inner.name().to_owned();\n        let mut data_type = match inner {\n            SchemaType::PrimitiveType { physical_type, .. } =\u003e convert_to_data_type(physical_type),\n            SchemaType::GroupType { .. } =\u003e DataType::Map,\n        };\n        let nullable = inner.is_optional();\n        let mut unique = None;\n        let mut default = None;\n        let mut comment = None;\n\n        if let Some(metadata) = parquet_col_def.get_metadata().as_deref() {\n            for kv in metadata.iter() {\n                match kv.key.as_str() {\n                    k if k == format!(\"unique_option{}\", name) =\u003e match kv.value.as_deref() {\n                        Some(\"primary_key\") =\u003e {\n                            unique = Some(ColumnUniqueOption { is_primary: true });\n                        }\n                        _ =\u003e unique = Some(ColumnUniqueOption { is_primary: false }),\n                    },\n                    k if k == format!(\"data_type{}\", name) =\u003e {\n                        if let Some(value) = kv.value.as_deref() {\n                            if let Some(mapped_data_type) = map_parquet_to_gluesql(value) {\n                                data_type = mapped_data_type.clone();\n                            }\n                        }\n                    }\n                    k if k == format!(\"default_{}\", name) =\u003e {\n                        if let Some(value) = \u0026kv.value {\n                            let parsed = parse_expr(value.clone())?;\n                            let tran = translate_expr(\u0026parsed)?;\n\n                            default = Some(tran);\n                        }\n                    }\n                    k if k == format!(\"comment_{}\", name) =\u003e {\n                        if let Some(value) = \u0026kv.value {\n                            comment = Some(value.clone());\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n        Ok(ColumnDef {\n            name,\n            data_type,\n            nullable,\n            default,\n            unique,\n            comment,\n        })\n    }\n}\n\nfn convert_to_data_type(pt: \u0026PhysicalType) -\u003e DataType {\n    match pt {\n        PhysicalType::BOOLEAN =\u003e DataType::Boolean,\n        PhysicalType::INT32 =\u003e DataType::Int32,\n        PhysicalType::INT64 =\u003e DataType::Int,\n        PhysicalType::FLOAT =\u003e DataType::Float32,\n        PhysicalType::DOUBLE =\u003e DataType::Float,\n        PhysicalType::INT96 =\u003e DataType::Int128,\n        PhysicalType::BYTE_ARRAY | PhysicalType::FIXED_LEN_BYTE_ARRAY =\u003e DataType::Bytea,\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":52},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","src","error.rs"],"content":"use {gluesql_core::prelude::Error, thiserror::Error};\n\npub trait ResultExt\u003cT, E: ToString\u003e {\n    fn map_storage_err(self) -\u003e Result\u003cT, Error\u003e;\n}\n\nimpl\u003cT, E: ToString\u003e ResultExt\u003cT, E\u003e for std::result::Result\u003cT, E\u003e {\n    fn map_storage_err(self) -\u003e Result\u003cT, Error\u003e {\n        self.map_err(|e| e.to_string()).map_err(Error::StorageMsg)\n    }\n}\n\npub trait OptionExt\u003cT, E: ToString\u003e {\n    fn map_storage_err(self, error: E) -\u003e Result\u003cT, Error\u003e;\n}\n\nimpl\u003cT, E: ToString\u003e OptionExt\u003cT, E\u003e for std::option::Option\u003cT\u003e {\n    fn map_storage_err(self, error: E) -\u003e Result\u003cT, Error\u003e {\n        self.ok_or_else(|| error.to_string())\n            .map_err(Error::StorageMsg)\n    }\n}\n\nimpl From\u003cParquetStorageError\u003e for Error {\n    fn from(error: ParquetStorageError) -\u003e Self {\n        Self::StorageMsg(error.to_string())\n    }\n}\n\n#[derive(Error, Debug)]\npub enum ParquetStorageError {\n    #[error(\"file not found\")]\n    FileNotFound,\n\n    #[error(\"table {0} does not exist\")]\n    TableDoesNotExist(String),\n\n    #[error(\"Unexpected key type for map: received {0}, expected String\")]\n    UnexpectedKeyTypeForMap(String),\n\n    #[error(\"Unreachable gluesql value type for parquet writer\")]\n    UnreachableGlueSqlValueTypeForParquetWriter,\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","src","function.rs"],"content":"use {\n    super::ParquetStorage,\n    gluesql_core::store::{CustomFunction, CustomFunctionMut},\n};\n\nimpl CustomFunctionMut for ParquetStorage {}\nimpl CustomFunction for ParquetStorage {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","src","index.rs"],"content":"use {\n    super::ParquetStorage,\n    gluesql_core::store::{Index, IndexMut},\n};\n\nimpl Index for ParquetStorage {}\nimpl IndexMut for ParquetStorage {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","src","lib.rs"],"content":"use {\n    column_def::ParquetSchemaType,\n    error::{OptionExt, ParquetStorageError, ResultExt},\n    gluesql_core::{\n        ast::{ColumnDef, ColumnUniqueOption, ForeignKey},\n        data::Schema,\n        error::{Error, Result},\n        prelude::{DataType, Key, Value},\n        store::{DataRow, Metadata},\n    },\n    parquet::{\n        file::{reader::FileReader, serialized_reader::SerializedFileReader},\n        record::Row,\n    },\n    serde_json::from_str,\n    std::{\n        collections::HashMap,\n        fs::{self, File},\n        path::{Path, PathBuf},\n    },\n    value::ParquetField,\n};\n\nmod alter_table;\nmod column_def;\npub mod error;\nmod function;\nmod index;\nmod store;\nmod store_mut;\nmod transaction;\nmod value;\n\ntype RowIter = Box\u003cdyn Iterator\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e\u003e;\n\n#[derive(Debug, Clone)]\npub struct ParquetStorage {\n    pub path: PathBuf,\n}\n\nimpl ParquetStorage {\n    pub fn new\u003cT: AsRef\u003cPath\u003e\u003e(path: T) -\u003e Result\u003cSelf\u003e {\n        let path = path.as_ref();\n        fs::create_dir_all(path).map_storage_err()?;\n\n        Ok(Self { path: path.into() })\n    }\n\n    fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        let schema_path = self.data_path(table_name);\n        let is_schema_path_exist = schema_path.exists();\n        if !is_schema_path_exist {\n            return Ok(None);\n        }\n        let file = File::open(\u0026schema_path).map_storage_err()?;\n        let reader = SerializedFileReader::new(file).map_storage_err()?;\n        let parquet_metadata = reader.metadata();\n        let file_metadata = parquet_metadata.file_metadata();\n        let schema = file_metadata.schema();\n        let key_value_file_metadata = file_metadata.key_value_metadata();\n\n        let mut is_schemaless = false;\n        let mut foreign_keys = Vec::new();\n        let mut comment = None;\n        if let Some(metadata) = key_value_file_metadata {\n            for kv in metadata.iter() {\n                if kv.key == \"schemaless\" {\n                    is_schemaless = matches!(kv.value.as_deref(), Some(\"true\"));\n                } else if kv.key == \"comment\" {\n                    comment.clone_from(\u0026kv.value)\n                } else if kv.key.starts_with(\"foreign_key\") {\n                    let fk = kv\n                        .value\n                        .as_ref()\n                        .map(|x| from_str::\u003cForeignKey\u003e(x))\n                        .map_storage_err(Error::StorageMsg(\n                            \"No value found on metadata\".to_owned(),\n                        ))?\n                        .map_storage_err()?;\n\n                    foreign_keys.push(fk);\n                }\n            }\n        }\n\n        let column_defs = if is_schemaless {\n            None\n        } else {\n            Some(\n                schema\n                    .get_fields()\n                    .iter()\n                    .map(|field| {\n                        ColumnDef::try_from(ParquetSchemaType {\n                            inner: field,\n                            metadata: key_value_file_metadata,\n                        })\n                    })\n                    .collect::\u003cResult\u003cVec\u003cColumnDef\u003e, _\u003e\u003e()?,\n            )\n        };\n\n        Ok(Some(Schema {\n            table_name: table_name.to_owned(),\n            column_defs,\n            indexes: vec![],\n            engine: None,\n            foreign_keys,\n            comment,\n        }))\n    }\n\n    fn data_path(\u0026self, table_name: \u0026str) -\u003e PathBuf {\n        self.path_by(table_name, \"parquet\")\n    }\n\n    fn path_by(\u0026self, table_name: \u0026str, extension: \u0026str) -\u003e PathBuf {\n        let path = self.path.as_path();\n        let mut path = path.join(table_name);\n        path.set_extension(extension);\n\n        path\n    }\n\n    fn scan_data(\u0026self, table_name: \u0026str) -\u003e Result\u003c(RowIter, Schema)\u003e {\n        let fetched_schema = self.fetch_schema(table_name)?.map_storage_err(\n            ParquetStorageError::TableDoesNotExist(table_name.to_owned()),\n        )?;\n        let file = File::open(self.data_path(table_name)).map_storage_err()?;\n\n        let parquet_reader = SerializedFileReader::new(file).map_storage_err()?;\n        let row_iter = parquet_reader.get_row_iter(None).map_storage_err()?;\n\n        let mut rows = Vec::new();\n        let mut key_counter: u64 = 0;\n\n        if let Some(column_defs) = \u0026fetched_schema.column_defs {\n            for record in row_iter {\n                let record: Row = record.map_storage_err()?;\n                let mut row = Vec::new();\n                let mut key = None;\n\n                for (idx, (_, field)) in record.get_column_iter().enumerate() {\n                    let value = ParquetField(field.clone()).to_value(\u0026fetched_schema, idx)?;\n                    row.push(value.clone());\n\n                    if column_defs[idx].unique == Some(ColumnUniqueOption { is_primary: true }) {\n                        key = Key::try_from(\u0026value).ok();\n                    }\n                }\n\n                let generated_key = key.unwrap_or_else(|| {\n                    let generated = Key::U64(key_counter);\n                    key_counter += 1;\n                    generated\n                });\n                rows.push(Ok((generated_key, DataRow::Vec(row))));\n            }\n        } else {\n            let tmp_schema = Self::generate_temp_schema();\n            for record in row_iter {\n                let record: Row = record.map_storage_err()?;\n                let mut data_map = HashMap::new();\n\n                for (_, field) in record.get_column_iter() {\n                    let value = ParquetField(field.clone()).to_value(\u0026tmp_schema, 0)?;\n                    let generated_key = Key::U64(key_counter);\n                    key_counter += 1;\n                    if let Value::Map(inner_map) = value {\n                        data_map = inner_map;\n                    }\n\n                    rows.push(Ok((generated_key, DataRow::Map(data_map.clone()))));\n                }\n            }\n        }\n\n        Ok((Box::new(rows.into_iter()), fetched_schema))\n    }\n\n    fn generate_temp_schema() -\u003e Schema {\n        Schema {\n            table_name: \"temporary\".to_owned(),\n            column_defs: Some(vec![ColumnDef {\n                name: \"schemaless\".to_owned(),\n                data_type: DataType::Map,\n                nullable: true,\n                default: None,\n                unique: None,\n                comment: None,\n            }]),\n            indexes: vec![],\n            engine: None,\n            foreign_keys: Vec::new(),\n            comment: None,\n        }\n    }\n}\n\nimpl Metadata for ParquetStorage {}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":95},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","src","store.rs"],"content":"use {\n    crate::{\n        ParquetStorage,\n        error::{OptionExt, ParquetStorageError, ResultExt},\n    },\n    async_trait::async_trait,\n    futures::stream::iter,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::Result,\n        store::{DataRow, RowIter, Store},\n    },\n    std::{ffi::OsStr, fs},\n};\n\n#[async_trait(?Send)]\nimpl Store for ParquetStorage {\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        self.fetch_schema(table_name)\n    }\n\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let paths = fs::read_dir(\u0026self.path).map_storage_err()?;\n        let mut schemas = paths\n            .map(|result| {\n                let path = result.map_storage_err()?.path();\n\n                let table_name = path\n                    .file_stem()\n                    .and_then(OsStr::to_str)\n                    .map_storage_err(ParquetStorageError::FileNotFound)?;\n\n                self.fetch_schema(table_name)?\n                    .map_storage_err(ParquetStorageError::TableDoesNotExist(\n                        table_name.to_owned(),\n                    ))\n                    .map(Some)\n            })\n            .filter_map(Result::transpose)\n            .collect::\u003cResult\u003cVec\u003cSchema\u003e\u003e\u003e()?;\n\n        schemas.sort_by(|a, b| a.table_name.cmp(\u0026b.table_name));\n        Ok(schemas)\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, target: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        for item in self.scan_data(table_name)?.0 {\n            let (key, row) = item?;\n\n            if \u0026key == target {\n                return Ok(Some(row));\n            }\n        }\n        return Ok(None);\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        let rows = self.scan_data(table_name)?.0;\n        Ok(Box::pin(iter(rows)))\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","src","store_mut.rs"],"content":"use {\n    crate::{ParquetStorage, ParquetStorageError, error::ResultExt},\n    async_trait::async_trait,\n    gluesql_core::{\n        ast::{ColumnDef, ToSql},\n        chrono::{NaiveDate, Timelike},\n        data::{Key, Schema},\n        error::Result,\n        prelude::{DataType, Error, Value},\n        store::{DataRow, StoreMut},\n    },\n    lazy_static::lazy_static,\n    parquet::{\n        basic::{ConvertedType, Type},\n        column::writer::ColumnWriter,\n        data_type::{ByteArray, FixedLenByteArray},\n        file::{properties::WriterProperties, writer::SerializedFileWriter},\n        format::KeyValue,\n        schema::types::Type as SchemaType,\n    },\n    std::{\n        cmp::Ordering,\n        collections::HashMap,\n        fs::{File, remove_file},\n        iter::Peekable,\n        sync::Arc,\n        vec::IntoIter,\n    },\n};\n\nlazy_static! {\n    static ref GLUESQL_TO_PARQUET_DATA_TYPE_MAPPING: HashMap\u003cDataType, \u0026'static str\u003e = {\n        let mut m = HashMap::new();\n        m.insert(DataType::Boolean, \"Boolean\");\n        m.insert(DataType::Int8, \"Int8\");\n        m.insert(DataType::Int16, \"Int16\");\n        m.insert(DataType::Int32, \"Int32\");\n        m.insert(DataType::Int, \"Int\");\n        m.insert(DataType::Int128, \"Int128\");\n        m.insert(DataType::Uint8, \"Uint8\");\n        m.insert(DataType::Uint16, \"Uint16\");\n        m.insert(DataType::Uint32, \"Uint32\");\n        m.insert(DataType::Uint64, \"Uint64\");\n        m.insert(DataType::Uint128, \"Uint128\");\n        m.insert(DataType::Float32, \"Float32\");\n        m.insert(DataType::Float, \"Float\");\n        m.insert(DataType::Text, \"Text\");\n        m.insert(DataType::Bytea, \"Bytea\");\n        m.insert(DataType::Inet, \"Inet\");\n        m.insert(DataType::Date, \"Date\");\n        m.insert(DataType::Timestamp, \"Timestamp\");\n        m.insert(DataType::Time, \"Time\");\n        m.insert(DataType::Interval, \"Interval\");\n        m.insert(DataType::Uuid, \"Uuid\");\n        m.insert(DataType::Map, \"Map\");\n        m.insert(DataType::List, \"List\");\n        m.insert(DataType::Decimal, \"Decimal\");\n        m.insert(DataType::Point, \"Point\");\n        m\n    };\n}\n\n#[async_trait(?Send)]\nimpl StoreMut for ParquetStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let data_path = self.data_path(schema.table_name.as_str());\n        let file = File::create(data_path).map_storage_err()?;\n        self.write(schema.clone(), Vec::new(), file)?;\n\n        Ok(())\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let schema_path = self.data_path(table_name);\n        if schema_path.exists() {\n            remove_file(schema_path).map_storage_err()?;\n        }\n        Ok(())\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let schema_path = self.data_path(table_name);\n        let (prev_rows, schema) = self.scan_data(table_name)?;\n\n        let rows = prev_rows\n            .map(|item| Ok(item?.1))\n            .chain(rows.into_iter().map(Ok))\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        let file = File::create(schema_path).map_storage_err()?;\n        self.write(schema, rows, file)\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, mut rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        let (prev_rows, schema) = self.scan_data(table_name)?;\n\n        rows.sort_by(|(key_a, _), (key_b, _)| key_a.cmp(key_b));\n\n        let sort_merge = SortMerge::new(prev_rows, rows.into_iter());\n        let merged = sort_merge.collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n        self.rewrite(schema, merged)\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        let (prev_rows, schema) = self.scan_data(table_name)?;\n        let rows = prev_rows\n            .filter_map(|result| {\n                result\n                    .map(|(key, data_row)| {\n                        let preservable = !keys.iter().any(|target_key| target_key == \u0026key);\n\n                        preservable.then_some(data_row)\n                    })\n                    .transpose()\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        self.rewrite(schema, rows)\n    }\n}\n\nstruct SortMerge\u003cT: Iterator\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e\u003e {\n    left_rows: Peekable\u003cT\u003e,\n    right_rows: Peekable\u003cIntoIter\u003c(Key, DataRow)\u003e\u003e,\n}\n\nimpl\u003cT\u003e SortMerge\u003cT\u003e\nwhere\n    T: Iterator\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e,\n{\n    fn new(left_rows: T, right_rows: IntoIter\u003c(Key, DataRow)\u003e) -\u003e Self {\n        let left_rows = left_rows.peekable();\n        let right_rows = right_rows.peekable();\n\n        Self {\n            left_rows,\n            right_rows,\n        }\n    }\n}\nimpl\u003cT\u003e Iterator for SortMerge\u003cT\u003e\nwhere\n    T: Iterator\u003cItem = Result\u003c(Key, DataRow)\u003e\u003e,\n{\n    type Item = Result\u003cDataRow\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let left = self.left_rows.peek();\n        let right = self.right_rows.peek();\n\n        match (left, right) {\n            (Some(Ok((left_key, _))), Some((right_key, _))) =\u003e match left_key.cmp(right_key) {\n                Ordering::Less =\u003e self.left_rows.next(),\n                Ordering::Greater =\u003e self.right_rows.next().map(Ok),\n                Ordering::Equal =\u003e {\n                    self.left_rows.next();\n                    self.right_rows.next().map(Ok)\n                }\n            }\n            .map(|item| Ok(item?.1)),\n            (Some(_), _) =\u003e self.left_rows.next().map(|item| Ok(item?.1)),\n            (None, Some(_)) =\u003e self.right_rows.next().map(|item| Ok(item.1)),\n            (None, None) =\u003e None,\n        }\n    }\n}\n\nimpl ParquetStorage {\n    fn rewrite(\u0026mut self, schema: Schema, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let parquet_path = self.data_path(\u0026schema.table_name);\n        let file = File::create(parquet_path).map_storage_err()?;\n        self.write(schema, rows, file)\n    }\n\n    fn write(\u0026mut self, schema: Schema, rows: Vec\u003cDataRow\u003e, file: File) -\u003e Result\u003c()\u003e {\n        let schema_type: Arc\u003cSchemaType\u003e =\n            self.convert_to_parquet_schema(\u0026schema).map_storage_err()?;\n\n        let metadata = Self::gather_metadata_from_glue_schema(\u0026schema)?;\n\n        let props = Arc::new(\n            WriterProperties::builder()\n                .set_key_value_metadata(metadata)\n                .build(),\n        );\n\n        let mut file_writer =\n            SerializedFileWriter::new(file, schema_type.clone(), props).map_storage_err()?;\n\n        let mut row_group_writer = file_writer.next_row_group().map_storage_err()?;\n\n        for (i, _) in schema_type.get_fields().iter().enumerate() {\n            let mut writer = row_group_writer\n                .next_column()\n                .map_storage_err()?\n                .ok_or(Error::StorageMsg(\"Expected a column but found None\".into()))?;\n            let mut col_writer = writer.untyped();\n            for row in \u0026rows {\n                match row {\n                    DataRow::Vec(values) =\u003e {\n                        let value = values[i].clone();\n                        let col_writer = \u0026mut col_writer;\n                        match (value, col_writer) {\n                            (Value::Null, ColumnWriter::BoolColumnWriter(typed)) =\u003e {\n                                typed.write_batch(\u0026[], Some(\u0026[0]), None).map_storage_err()?;\n                            }\n                            (Value::Null, ColumnWriter::Int32ColumnWriter(typed)) =\u003e {\n                                typed.write_batch(\u0026[], Some(\u0026[0]), None).map_storage_err()?;\n                            }\n                            (Value::Null, ColumnWriter::Int64ColumnWriter(typed)) =\u003e {\n                                typed.write_batch(\u0026[], Some(\u0026[0]), None).map_storage_err()?;\n                            }\n                            (Value::Null, ColumnWriter::Int96ColumnWriter(typed)) =\u003e {\n                                typed.write_batch(\u0026[], Some(\u0026[0]), None).map_storage_err()?;\n                            }\n                            (Value::Null, ColumnWriter::FloatColumnWriter(typed)) =\u003e {\n                                typed.write_batch(\u0026[], Some(\u0026[0]), None).map_storage_err()?;\n                            }\n                            (Value::Null, ColumnWriter::DoubleColumnWriter(typed)) =\u003e {\n                                typed.write_batch(\u0026[], Some(\u0026[0]), None).map_storage_err()?;\n                            }\n                            (Value::Null, ColumnWriter::ByteArrayColumnWriter(typed)) =\u003e {\n                                typed.write_batch(\u0026[], Some(\u0026[0]), None).map_storage_err()?;\n                            }\n                            (Value::Null, ColumnWriter::FixedLenByteArrayColumnWriter(typed)) =\u003e {\n                                typed.write_batch(\u0026[], Some(\u0026[0]), None).map_storage_err()?;\n                            }\n                            (Value::Bool(val), ColumnWriter::BoolColumnWriter(typed)) =\u003e {\n                                typed\n                                    .write_batch(\u0026[val], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::I8(val), ColumnWriter::Int32ColumnWriter(typed)) =\u003e {\n                                typed\n                                    .write_batch(\u0026[val as i32], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::I16(val), ColumnWriter::Int32ColumnWriter(typed)) =\u003e {\n                                typed\n                                    .write_batch(\u0026[val as i32], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::I32(val), ColumnWriter::Int32ColumnWriter(typed)) =\u003e {\n                                typed\n                                    .write_batch(\u0026[val], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::Date(d), ColumnWriter::Int32ColumnWriter(typed)) =\u003e {\n                                let epoch = NaiveDate::from_ymd_opt(1970, 1, 1)\n                                    .expect(\"Invalid epoch date\");\n                                let days_since_epoch = (d - epoch).num_days() as i32;\n                                typed\n                                    .write_batch(\u0026[days_since_epoch], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::U8(val), ColumnWriter::Int32ColumnWriter(typed)) =\u003e {\n                                typed\n                                    .write_batch(\u0026[val as i32], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::U16(val), ColumnWriter::Int32ColumnWriter(typed)) =\u003e {\n                                typed\n                                    .write_batch(\u0026[val as i32], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::U32(val), ColumnWriter::Int32ColumnWriter(typed)) =\u003e {\n                                typed\n                                    .write_batch(\u0026[val as i32], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::U64(val), ColumnWriter::Int64ColumnWriter(typed)) =\u003e {\n                                typed\n                                    .write_batch(\u0026[val as i64], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::I64(val), ColumnWriter::Int64ColumnWriter(typed)) =\u003e {\n                                typed\n                                    .write_batch(\u0026[val], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::Time(val), ColumnWriter::Int64ColumnWriter(typed)) =\u003e {\n                                let total_micros = (val.hour() as i64 * 60 * 60 * 1_000_000) // hours to micros\n                                + (val.minute() as i64 * 60 * 1_000_000)                          // minutes to micros\n                                + (val.second() as i64 * 1_000_000)                               // seconds to micros\n                                + (val.nanosecond() as i64 / 1_000); // nanos to micros\n                                typed\n                                    .write_batch(\u0026[total_micros], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::Timestamp(val), ColumnWriter::ByteArrayColumnWriter(typed)) =\u003e {\n                                let serialized = bincode::serialize(\u0026val).map_storage_err()?;\n                                typed\n                                    .write_batch(\u0026[serialized.into()], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::I128(val), ColumnWriter::ByteArrayColumnWriter(typed)) =\u003e {\n                                let serialized = bincode::serialize(\u0026val).map_storage_err()?;\n                                typed\n                                    .write_batch(\u0026[serialized.into()], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::U128(val), ColumnWriter::ByteArrayColumnWriter(typed)) =\u003e {\n                                let serialized = bincode::serialize(\u0026val).map_storage_err()?;\n                                typed\n                                    .write_batch(\u0026[serialized.into()], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (\n                                Value::Uuid(val),\n                                ColumnWriter::FixedLenByteArrayColumnWriter(typed),\n                            ) =\u003e {\n                                let serialized = bincode::serialize(\u0026val).map_storage_err()?;\n                                typed\n                                    .write_batch(\n                                        \u0026[FixedLenByteArray::from(serialized.to_vec())],\n                                        Some(\u0026[1]),\n                                        None,\n                                    )\n                                    .map_storage_err()?;\n                            }\n                            (Value::F32(val), ColumnWriter::FloatColumnWriter(typed)) =\u003e {\n                                typed\n                                    .write_batch(\u0026[val], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::F64(val), ColumnWriter::DoubleColumnWriter(typed)) =\u003e {\n                                typed\n                                    .write_batch(\u0026[val], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::Str(val), ColumnWriter::ByteArrayColumnWriter(typed)) =\u003e {\n                                typed\n                                    .write_batch(\n                                        \u0026[ByteArray::from(val.as_bytes())],\n                                        Some(\u0026[1]),\n                                        None,\n                                    )\n                                    .map_storage_err()?;\n                            }\n                            (Value::Decimal(val), ColumnWriter::ByteArrayColumnWriter(typed)) =\u003e {\n                                let serialized = bincode::serialize(\u0026val).map_storage_err()?;\n                                typed\n                                    .write_batch(\u0026[serialized.into()], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::Interval(val), ColumnWriter::ByteArrayColumnWriter(typed)) =\u003e {\n                                let serialized = bincode::serialize(\u0026val).map_storage_err()?;\n                                typed\n                                    .write_batch(\u0026[serialized.into()], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::Bytea(val), ColumnWriter::ByteArrayColumnWriter(typed)) =\u003e {\n                                let byte_array = ByteArray::from(val);\n                                typed\n                                    .write_batch(\u0026[byte_array], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::Map(m), ColumnWriter::ByteArrayColumnWriter(typed)) =\u003e {\n                                let serialized = bincode::serialize(\u0026m).map_storage_err()?;\n                                typed\n                                    .write_batch(\u0026[serialized.into()], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::List(l), ColumnWriter::ByteArrayColumnWriter(typed)) =\u003e {\n                                let serialized = bincode::serialize(\u0026l).map_storage_err()?;\n                                typed\n                                    .write_batch(\u0026[serialized.into()], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::Point(p), ColumnWriter::ByteArrayColumnWriter(typed)) =\u003e {\n                                let serialized = bincode::serialize(\u0026p).map_storage_err()?;\n                                typed\n                                    .write_batch(\u0026[serialized.into()], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            (Value::Inet(inet), ColumnWriter::ByteArrayColumnWriter(typed)) =\u003e {\n                                let serialized = bincode::serialize(\u0026inet).map_storage_err()?;\n                                typed\n                                    .write_batch(\u0026[serialized.into()], Some(\u0026[1]), None)\n                                    .map_storage_err()?;\n                            }\n                            _ =\u003e return Err(\n                                ParquetStorageError::UnreachableGlueSqlValueTypeForParquetWriter\n                                    .into(),\n                            ),\n                        };\n                    }\n                    DataRow::Map(map) =\u003e {\n                        let serialized = bincode::serialize(\u0026map).map_storage_err()?;\n                        if let ColumnWriter::ByteArrayColumnWriter(typed) = col_writer {\n                            typed\n                                .write_batch(\u0026[serialized.into()], Some(\u0026[1]), None)\n                                .map_storage_err()?;\n                        }\n                    }\n                }\n            }\n            writer.close().map_storage_err()?;\n        }\n\n        row_group_writer.close().map_storage_err()?;\n        file_writer.close().map_storage_err()?;\n\n        Ok(())\n    }\n\n    fn convert_to_parquet_schema(\n        \u0026self,\n        schema: \u0026Schema,\n    ) -\u003e Result\u003cArc\u003cparquet::schema::types::Type\u003e\u003e {\n        let mut fields = Vec::new();\n        let column_defs = match schema.column_defs {\n            Some(ref defs) =\u003e defs.clone(),\n            None =\u003e {\n                vec![ColumnDef {\n                    name: \"schemaless\".to_owned(),\n                    data_type: DataType::Map,\n                    nullable: true,\n                    default: None,\n                    unique: None,\n                    comment: None,\n                }]\n            }\n        };\n\n        for column_def in column_defs {\n            let (physical_type, converted_type_option) =\n                Self::get_parquet_type_mappings(\u0026column_def.data_type)?;\n            let repetition = if column_def.nullable {\n                parquet::basic::Repetition::OPTIONAL\n            } else {\n                parquet::basic::Repetition::REQUIRED\n            };\n\n            let mut field_builder = parquet::schema::types::Type::primitive_type_builder(\n                column_def.name.as_str(),\n                physical_type,\n            )\n            .with_repetition(repetition)\n            .with_length(16); // for FIXED_LEN_BYTE_ARRAY length\n\n            if let Some(converted_type) = converted_type_option {\n                field_builder = field_builder.with_converted_type(converted_type);\n            }\n\n            let field = field_builder.build().map_storage_err()?;\n\n            fields.push(Arc::new(field));\n        }\n\n        let parquet_schema = parquet::schema::types::Type::group_type_builder(\"schema\")\n            .with_fields(\u0026mut fields)\n            .build()\n            .map_storage_err()?;\n        Ok(Arc::new(parquet_schema))\n    }\n\n    fn gather_metadata_from_glue_schema(schema: \u0026Schema) -\u003e Result\u003cOption\u003cVec\u003cKeyValue\u003e\u003e\u003e {\n        let mut metadata = Vec::new();\n\n        for foreign_key in \u0026schema.foreign_keys {\n            metadata.push(KeyValue {\n                key: format!(\"foreign_key_{}\", foreign_key.name),\n                value: Some(serde_json::to_string(\u0026foreign_key).map_storage_err()?),\n            });\n        }\n\n        if let Some(column_defs) = \u0026schema.column_defs {\n            for column_def in column_defs {\n                if let Some(unique_option) = \u0026column_def.unique {\n                    let key = format!(\"unique_option{}\", column_def.name);\n                    let value = if unique_option.is_primary {\n                        Some(\"primary_key\".to_owned())\n                    } else {\n                        Some(\"unique\".to_owned())\n                    };\n\n                    metadata.push(KeyValue { key, value });\n                }\n\n                if let Some(default_value) = \u0026column_def.default {\n                    metadata.push(KeyValue {\n                        key: format!(\"default_{}\", column_def.name),\n                        value: Some(ToSql::to_sql(default_value)),\n                    });\n                }\n\n                if let Some(comment) = \u0026column_def.comment {\n                    metadata.push(KeyValue {\n                        key: format!(\"comment_{}\", column_def.name),\n                        value: Some(comment.to_string()),\n                    });\n                }\n\n                if let Some(data_type_str) =\n                    GLUESQL_TO_PARQUET_DATA_TYPE_MAPPING.get(\u0026column_def.data_type)\n                {\n                    metadata.push(KeyValue {\n                        key: format!(\"data_type{}\", column_def.name),\n                        value: Some(data_type_str.to_string()),\n                    });\n                }\n            }\n            metadata.push(KeyValue {\n                key: \"schemaless\".to_owned(),\n                value: Some(\"false\".to_owned()),\n            });\n        } else {\n            metadata.push(KeyValue {\n                key: \"schemaless\".to_owned(),\n                value: Some(\"true\".to_owned()),\n            });\n        }\n\n        if schema.comment.is_some() {\n            metadata.push(KeyValue {\n                key: \"comment\".to_owned(),\n                value: schema.comment.as_ref().map(ToOwned::to_owned),\n            });\n        }\n\n        Ok(Some(metadata))\n    }\n\n    fn get_parquet_type_mappings(data_type: \u0026DataType) -\u003e Result\u003c(Type, Option\u003cConvertedType\u003e)\u003e {\n        match data_type {\n            DataType::Text =\u003e Ok((Type::BYTE_ARRAY, Some(ConvertedType::UTF8))),\n            DataType::Date =\u003e Ok((Type::INT32, Some(ConvertedType::DATE))),\n            DataType::Uint8 =\u003e Ok((Type::INT32, Some(ConvertedType::UINT_8))),\n            DataType::Int =\u003e Ok((Type::INT64, Some(ConvertedType::INT_64))),\n            DataType::Int8 =\u003e Ok((Type::INT32, Some(ConvertedType::INT_8))),\n            DataType::Int16 =\u003e Ok((Type::INT32, Some(ConvertedType::INT_16))),\n            DataType::Int32 =\u003e Ok((Type::INT32, Some(ConvertedType::INT_32))),\n            DataType::Uint16 =\u003e Ok((Type::INT32, Some(ConvertedType::UINT_16))),\n            DataType::Uint32 =\u003e Ok((Type::INT32, Some(ConvertedType::UINT_32))),\n            DataType::Uint64 =\u003e Ok((Type::INT64, Some(ConvertedType::UINT_64))),\n            DataType::Boolean =\u003e Ok((Type::BOOLEAN, None)),\n            DataType::Float32 =\u003e Ok((Type::FLOAT, None)),\n            DataType::Float =\u003e Ok((Type::DOUBLE, None)),\n            DataType::Uuid =\u003e Ok((Type::FIXED_LEN_BYTE_ARRAY, None)),\n            DataType::Point =\u003e Ok((Type::BYTE_ARRAY, None)),\n            DataType::Inet =\u003e Ok((Type::BYTE_ARRAY, None)),\n            DataType::Uint128 =\u003e Ok((Type::BYTE_ARRAY, None)),\n            DataType::Int128 =\u003e Ok((Type::BYTE_ARRAY, None)),\n            DataType::Time =\u003e Ok((Type::INT64, None)),\n            DataType::Map =\u003e Ok((Type::BYTE_ARRAY, None)),\n            DataType::List =\u003e Ok((Type::BYTE_ARRAY, None)),\n            DataType::Interval =\u003e Ok((Type::BYTE_ARRAY, None)),\n            DataType::Decimal =\u003e Ok((Type::BYTE_ARRAY, None)),\n            DataType::Timestamp =\u003e Ok((Type::BYTE_ARRAY, None)),\n            DataType::Bytea =\u003e Ok((Type::BYTE_ARRAY, None)),\n        }\n    }\n}\n","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":292},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","src","transaction.rs"],"content":"use {super::ParquetStorage, gluesql_core::store::Transaction};\n\nimpl Transaction for ParquetStorage {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","src","value.rs"],"content":"use {\n    crate::error::{OptionExt, ParquetStorageError, ResultExt},\n    byteorder::{BigEndian, ByteOrder},\n    gluesql_core::{\n        chrono::{DateTime, Duration, NaiveDate, NaiveTime},\n        data::{Schema, Value},\n        prelude::{DataType, Error, Result},\n    },\n    parquet::record::Field,\n    std::collections::HashMap,\n};\n\n#[derive(Debug)]\npub struct ParquetField(pub Field);\n\nimpl ParquetField {\n    pub fn as_field(\u0026self) -\u003e \u0026Field {\n        \u0026self.0\n    }\n\n    pub fn to_value(\u0026self, schema: \u0026Schema, idx: usize) -\u003e Result\u003cValue\u003e {\n        match self.as_field() {\n            Field::Bool(v) =\u003e Ok(Value::Bool(*v)),\n            Field::Byte(v) =\u003e Ok(Value::I8(*v)),\n            Field::Short(v) =\u003e Ok(Value::I16(*v)),\n            Field::Int(v) =\u003e Ok(Value::I32(*v)),\n            Field::Long(v) =\u003e {\n                if let Some(columns) = \u0026schema.column_defs {\n                    if let Some(column) = columns.get(idx) {\n                        if column.data_type == DataType::Time {\n                            // Convert from microseconds since midnight to NaiveTime\n                            let total_seconds = v / 1_000_000;\n                            let hours = (total_seconds / 3600) % 24;\n                            let minutes = (total_seconds / 60) % 60;\n                            let seconds = total_seconds % 60;\n                            let micros = v % 1_000_000;\n\n                            return NaiveTime::from_hms_micro_opt(\n                                hours as u32,\n                                minutes as u32,\n                                seconds as u32,\n                                micros as u32,\n                            )\n                            .map_storage_err(Error::StorageMsg(\n                                \"Failed to convert to NaiveTime\".to_owned(),\n                            ))\n                            .map(Value::Time);\n                        }\n                    }\n                }\n                Ok(Value::I64(*v))\n            }\n            Field::UByte(v) =\u003e Ok(Value::U8(*v)),\n            Field::UShort(v) =\u003e Ok(Value::U16(*v)),\n            Field::UInt(v) =\u003e Ok(Value::U32(*v)),\n            Field::ULong(v) =\u003e Ok(Value::U64(*v)),\n            Field::Float(v) =\u003e Ok(Value::F32(*v)),\n            Field::Double(v) =\u003e Ok(Value::F64(*v)),\n            Field::Str(v) =\u003e Ok(Value::Str(v.clone())),\n            Field::Bytes(v) =\u003e {\n                if let Some(columns) = \u0026schema.column_defs {\n                    if let Some(column) = columns.get(idx) {\n                        match column.data_type {\n                            DataType::Timestamp =\u003e {\n                                let timestamp = bincode::deserialize(v.data()).map_storage_err()?;\n                                return Ok(Value::Timestamp(timestamp));\n                            }\n                            DataType::Uuid =\u003e {\n                                let uuid = bincode::deserialize(v.data()).map_storage_err()?;\n                                return Ok(Value::Uuid(uuid));\n                            }\n                            DataType::Uint128 =\u003e {\n                                let uint128 = bincode::deserialize(v.data()).map_storage_err()?;\n                                return Ok(Value::U128(uint128));\n                            }\n                            DataType::Int128 =\u003e {\n                                let int128 = bincode::deserialize(v.data()).map_storage_err()?;\n                                return Ok(Value::I128(int128));\n                            }\n                            DataType::Interval =\u003e {\n                                let interval = bincode::deserialize(v.data()).map_storage_err()?;\n                                return Ok(Value::Interval(interval));\n                            }\n                            DataType::Decimal =\u003e {\n                                let decimal = bincode::deserialize(v.data()).map_storage_err()?;\n                                return Ok(Value::Decimal(decimal));\n                            }\n                            DataType::Map =\u003e {\n                                let map: HashMap\u003cString, Value\u003e =\n                                    bincode::deserialize(v.data()).map_storage_err()?;\n                                return Ok(Value::Map(map));\n                            }\n                            DataType::List =\u003e {\n                                let list: Vec\u003cValue\u003e =\n                                    bincode::deserialize(v.data()).map_storage_err()?;\n                                return Ok(Value::List(list));\n                            }\n                            DataType::Inet =\u003e {\n                                let inet = bincode::deserialize(v.data()).map_storage_err()?;\n                                return Ok(Value::Inet(inet));\n                            }\n                            DataType::Point =\u003e {\n                                let point = bincode::deserialize(v.data()).map_storage_err()?;\n                                return Ok(Value::Point(point));\n                            }\n                            _ =\u003e {}\n                        }\n                    }\n                }\n                Ok(Value::Bytea(v.data().to_vec()))\n            }\n            Field::Date(v) =\u003e {\n                let epoch = NaiveDate::from_ymd_opt(1970, 1, 1).expect(\"Invalid epoch date\");\n                let result_date = epoch + Duration::days(*v as i64);\n                Ok(Value::Date(result_date))\n            }\n            Field::Group(v) =\u003e {\n                let mut map = HashMap::new();\n                for (name, field) in v.get_column_iter() {\n                    let value: Value = ParquetField(field.clone()).to_value(schema, idx)?;\n                    map.insert(name.clone(), value);\n                }\n                Ok(Value::Map(map))\n            }\n            Field::ListInternal(v) =\u003e {\n                let mut list = Vec::new();\n                for field in v.elements() {\n                    let value: Value = ParquetField(field.clone()).to_value(schema, idx)?;\n                    list.push(value);\n                }\n                Ok(Value::List(list))\n            }\n            Field::TimestampMillis(v) =\u003e Ok(Value::Timestamp(\n                DateTime::from_timestamp_millis(*v)\n                    .map_storage_err(\"Field::TimestampMillis to Value::Timestamp fail\")?\n                    .naive_utc(),\n            )),\n\n            Field::TimestampMicros(v) =\u003e Ok(Value::Timestamp(\n                DateTime::from_timestamp_micros(*v)\n                    .map_storage_err(\"Field::TimestampMicros to Value::Timestamp fail\")?\n                    .naive_utc(),\n            )),\n            Field::Decimal(v) =\u003e {\n                let decimal = match v {\n                    parquet::data_type::Decimal::Int32 { value, .. } =\u003e {\n                        let val = i32::from_be_bytes(*value);\n                        Some(Value::Decimal(val.into()))\n                    }\n                    parquet::data_type::Decimal::Int64 { value, .. } =\u003e {\n                        let val = i64::from_be_bytes(*value);\n                        Some(Value::Decimal(val.into()))\n                    }\n                    parquet::data_type::Decimal::Bytes { value, .. } =\u003e {\n                        // The byte array might represent a decimal larger than i64::MAX, so\n                        let mut bytes = value.data().to_vec();\n                        bytes.resize(16, 0);\n                        let val = BigEndian::read_i128(\u0026bytes);\n                        Some(Value::Decimal(val.into()))\n                    }\n                };\n                match decimal {\n                    Some(v) =\u003e Ok(v),\n                    None =\u003e Err(Error::StorageMsg(\"Invalid decimal\".to_owned())),\n                }\n            }\n            Field::MapInternal(m) =\u003e {\n                let mut result_map = HashMap::new();\n                for (key_field, value_field) in m.entries() {\n                    match key_field {\n                        Field::Str(key_str) =\u003e {\n                            let glue_value =\n                                ParquetField(value_field.clone()).to_value(schema, idx)?;\n                            result_map.insert(key_str.clone(), glue_value);\n                        }\n                        _ =\u003e {\n                            return Err(ParquetStorageError::UnexpectedKeyTypeForMap(format!(\n                                \"{:?}\",\n                                key_field\n                            ))\n                            .into());\n                        }\n                    }\n                }\n                Ok(Value::Map(result_map))\n            }\n            Field::Null =\u003e Ok(Value::Null),\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":115},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","tests","error.rs"],"content":"use {\n    gluesql_core::prelude::Glue,\n    gluesql_parquet_storage::{ParquetStorage, error::ParquetStorageError},\n};\n\n#[tokio::test]\nasync fn test_from_parquet_storage_error_to_error() {\n    let path_str = \"./tests/samples/\";\n    let parquet_storage = ParquetStorage::new(path_str).unwrap();\n    let mut glue = Glue::new(parquet_storage);\n\n    let cases = vec![(\n        glue.execute(\"SELECT * FROM nested_maps_snappy\").await,\n        Err(ParquetStorageError::UnexpectedKeyTypeForMap(\"Int(1)\".to_owned()).into()),\n    )];\n\n    for (actual, expected) in cases {\n        assert_eq!(actual.map(|mut payloads| payloads.remove(0)), expected);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","tests","parquet_storage.rs"],"content":"use {\n    async_trait::async_trait, gluesql_core::prelude::Glue, gluesql_parquet_storage::ParquetStorage,\n    std::fs::remove_dir_all, test_suite::*,\n};\n\nstruct ParquetTester {\n    glue: Glue\u003cParquetStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cParquetStorage\u003e for ParquetTester {\n    async fn new(namespace: \u0026str) -\u003e Self {\n        let path: String = format!(\"tmp/{namespace}\");\n\n        if let Err(e) = remove_dir_all(\u0026path) {\n            println!(\"fs::remove_file {:?}\", e);\n        }\n        let storage = ParquetStorage::new(\u0026path).expect(\"ParquetStorage::new\");\n        let glue = Glue::new(storage);\n\n        ParquetTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cParquetStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, ParquetTester);\ngenerate_alter_table_tests!(tokio::test, ParquetTester);\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","parquet-storage","tests","schema.rs"],"content":"use {\n    gluesql_core::{\n        chrono::NaiveDateTime,\n        prelude::{\n            Glue, Payload,\n            Value::{self, *},\n        },\n    },\n    gluesql_parquet_storage::ParquetStorage,\n    parquet::data_type::ByteArray,\n    std::fs,\n    test_suite::{concat_with, concat_with_null, row, select, select_with_null, stringify_label},\n};\n\nstruct FileGuard {\n    path: String,\n}\n\nimpl Drop for FileGuard {\n    fn drop(\u0026mut self) {\n        if let Err(err) = fs::remove_file(\u0026self.path) {\n            eprintln!(\"Failed to remove file: {:?}\", err);\n        }\n    }\n}\n\n#[tokio::test]\nasync fn test_alltypes_select() {\n    let path = \"./tests/samples/\";\n    let parquet_storage = ParquetStorage::new(path).unwrap();\n    let mut glue = Glue::new(parquet_storage);\n\n    let bytea = |input: \u0026str| ByteArray::from(input).data().to_vec();\n    let ts = |datetime_str| {\n        NaiveDateTime::parse_from_str(datetime_str, \"%Y-%m-%dT%H:%M:%S\")\n            .expect(\"Failed to parse date time\")\n    };\n\n    let cases = vec![\n        (\n            glue.execute(\"SELECT * FROM alltypes_dictionary\").await,\n            Ok(select!(\n                id  | bool_col | tinyint_col | smallint_col | int_col | bigint_col | float_col | double_col | date_string_col  | string_col   | timestamp_col;\n                I32 | Bool     | I32         | I32          | I32     | I64        | F32       | F64        | Value::Bytea     | Value::Bytea | Value::Timestamp;\n                0    true        0             0              0         0            0.0         0.0          bytea(\"01/01/09\")  bytea(\"0\")     ts(\"2009-01-01T00:00:00\");\n                1    false       1             1              1         10           1.1         10.1         bytea(\"01/01/09\")  bytea(\"1\")     ts(\"2009-01-01T00:01:00\")\n            )),\n        ),\n        (\n            glue.execute(\"SELECT * FROM alltypes_plain_snappy\").await,\n            Ok(select!(\n                id  | bool_col | tinyint_col | smallint_col | int_col | bigint_col | float_col | double_col | date_string_col  | string_col   | timestamp_col;\n                I32 | Bool     | I32         | I32          | I32     | I64        | F32       | F64        | Value::Bytea     | Value::Bytea | Value::Timestamp;\n                6     true       0             0              0         0            0.0         0.0          bytea(\"04/01/09\")  bytea(\"0\")     ts(\"2009-04-01T00:00:00\");\n                7     false      1             1              1         10           1.1         10.1         bytea(\"04/01/09\")  bytea(\"1\")     ts(\"2009-04-01T00:01:00\")\n            )),\n        ),\n        (\n            glue.execute(\"SELECT * FROM alltypes_plain\").await,\n            Ok(select!(\n                id  | bool_col | tinyint_col | smallint_col | int_col | bigint_col | float_col | double_col | date_string_col  | string_col   | timestamp_col;\n                I32 | Bool     | I32         | I32          | I32     | I64        | F32       | F64        | Value::Bytea     | Value::Bytea | Value::Timestamp;\n                4     true       0             0              0         0            0.0         0.0          bytea(\"03/01/09\")  bytea(\"0\")     ts(\"2009-03-01T00:00:00\");\n                5     false      1             1              1         10           1.1         10.1         bytea(\"03/01/09\")  bytea(\"1\")     ts(\"2009-03-01T00:01:00\");\n                6     true       0             0              0         0            0.0         0.0          bytea(\"04/01/09\")  bytea(\"0\")     ts(\"2009-04-01T00:00:00\");\n                7     false      1             1              1         10           1.1         10.1         bytea(\"04/01/09\")  bytea(\"1\")     ts(\"2009-04-01T00:01:00\");\n                2     true       0             0              0         0            0.0         0.0          bytea(\"02/01/09\")  bytea(\"0\")     ts(\"2009-02-01T00:00:00\");\n                3     false      1             1              1         10           1.1         10.1         bytea(\"02/01/09\")  bytea(\"1\")     ts(\"2009-02-01T00:01:00\");\n                0     true       0             0              0         0            0.0         0.0          bytea(\"01/01/09\")  bytea(\"0\")     ts(\"2009-01-01T00:00:00\");\n                1     false      1             1              1         10           1.1         10.1         bytea(\"01/01/09\")  bytea(\"1\")     ts(\"2009-01-01T00:01:00\")\n            )),\n        ),\n        (\n            glue.execute(\"SELECT * FROM nested_lists_snappy\").await,\n            Ok(select!(\n                a | b;\n                List | I32;\n                vec![\n                    List(vec![\n                        List(vec![Str(\"a\".to_owned()), Str(\"b\".to_owned())]),\n                        List(vec![Str(\"c\".to_owned())])\n                    ]),\n                    List(vec![Null, List(vec![Str(\"d\".to_owned())])])\n                ] 1;\n                vec![\n                    List(vec![\n                        List(vec![Str(\"a\".to_owned()), Str(\"b\".to_owned())]),\n                        List(vec![Str(\"c\".to_owned()), Str(\"d\".to_owned())])\n                    ]),\n                    List(vec![Null, List(vec![Str(\"e\".to_owned())])])\n                ] 1;\n                vec![\n                    List(vec![\n                        List(vec![Str(\"a\".to_owned()), Str(\"b\".to_owned())]),\n                        List(vec![Str(\"c\".to_owned()), Str(\"d\".to_owned())]),\n                        List(vec![Str(\"e\".to_owned())])\n                    ]),\n                    List(vec![Null, List(vec![Str(\"f\".to_owned())])])\n                ] 1\n            )),\n        ),\n    ];\n\n    for (actual, expected) in cases {\n        assert_eq!(actual.map(|mut payloads| payloads.remove(0)), expected);\n    }\n}\n\n#[tokio::test]\nasync fn test_data_modify() {\n    let path = \"./tests/samples/\";\n    let parquet_storage = ParquetStorage::new(path).unwrap();\n    let mut glue = Glue::new(parquet_storage);\n\n    let original_file = \"./tests/samples/all_types_with_nulls.parquet\"; // adjust the extension if needed\n    let copied_file = \"./tests/samples/all_types_with_nulls_copy.parquet\"; // adjust the extension if needed\n    fs::copy(original_file, copied_file).expect(\"Failed to copy file\");\n\n    //invoke delete copy file\n    let _file_guard = FileGuard {\n        path: copied_file.to_string(),\n    };\n\n    let cases = vec![\n        (\n            glue.execute(\"SELECT * FROM all_types_with_nulls_copy\").await,\n            Ok(select_with_null!(\n                bool_field | int32_field | int64_field | int96_field | float_field | double_field | binary_field | flba_field;\n                Null         Null          Null          Null          Null          Null           Null           Null\n            )),\n        ),\n        (\n            glue.execute(\"INSERT INTO all_types_with_nulls_copy VALUES(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)\").await,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            glue.execute(\"SELECT * FROM all_types_with_nulls_copy\").await,\n            Ok(select_with_null!(\n                bool_field | int32_field | int64_field | int96_field | float_field | double_field | binary_field | flba_field;\n                Null         Null          Null          Null          Null          Null           Null           Null;\n                Null         Null          Null          Null          Null          Null           Null           Null\n            )),\n        ),\n        (\n            glue.execute(\"DELETE FROM all_types_with_nulls_copy\").await,\n            Ok(Payload::Delete(2)),\n        ),\n        (\n            glue.execute(\"SELECT * FROM all_types_with_nulls_copy\").await,\n            Ok(select!(\n                bool_field | int32_field | int64_field | int96_field | float_field | double_field | binary_field | flba_field;\n            )),\n        ),\n        (\n            glue.execute(\"SELECT TABLE_NAME FROM GLUE_TABLES\").await,\n            Ok(select!(\n                TABLE_NAME;\n                Str;\n                \"all_types_with_nulls\".to_owned();\n                \"all_types_with_nulls_copy\".to_owned();\n                \"alltypes_dictionary\".to_owned();\n                \"alltypes_plain\".to_owned();\n                \"alltypes_plain_snappy\".to_owned();\n                \"nested_lists_snappy\".to_owned();\n                \"nested_maps_snappy\".to_owned() \n            ))\n            ,\n        ),\n    ];\n\n    for (actual, expected) in cases {\n        assert_eq!(actual.map(|mut payloads| payloads.remove(0)), expected);\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redb-storage","src","core.rs"],"content":"use {\n    super::error::StorageError,\n    async_stream::try_stream,\n    bincode::{deserialize, serialize},\n    futures::stream::iter,\n    gluesql_core::{\n        data::{Key, Schema},\n        store::{DataRow, RowIter},\n    },\n    redb::{Database, ReadableTable, TableDefinition, WriteTransaction},\n    std::path::Path,\n    uuid::Uuid,\n};\n\nconst SCHEMA_TABLE_NAME: \u0026str = \"__SCHEMA__\";\nconst SCHEMA_TABLE: TableDefinition\u003c\u0026str, Vec\u003cu8\u003e\u003e = TableDefinition::new(SCHEMA_TABLE_NAME);\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, StorageError\u003e;\n\npub enum TransactionState {\n    None,\n    Active {\n        txn: Box\u003cWriteTransaction\u003e,\n        autocommit: bool,\n    },\n}\n\npub struct StorageCore {\n    db: Database,\n    state: TransactionState,\n}\n\nimpl StorageCore {\n    pub fn new\u003cP: AsRef\u003cPath\u003e\u003e(filename: P) -\u003e Result\u003cSelf\u003e {\n        let db = Database::create(filename)?;\n\n        Ok(Self {\n            db,\n            state: TransactionState::None,\n        })\n    }\n\n    pub fn from_database(db: Database) -\u003e Self {\n        Self {\n            db,\n            state: TransactionState::None,\n        }\n    }\n\n    fn data_table_def\u003c'a\u003e(\n        \u0026self,\n        table_name: \u0026'a str,\n    ) -\u003e Result\u003cTableDefinition\u003c'a, \u0026'static [u8], Vec\u003cu8\u003e\u003e\u003e {\n        if table_name == SCHEMA_TABLE_NAME {\n            return Err(StorageError::ReservedTableName(table_name.to_owned()));\n        }\n\n        Ok(TableDefinition::new(table_name))\n    }\n\n    fn txn(\u0026self) -\u003e Result\u003c\u0026WriteTransaction\u003e {\n        match \u0026self.state {\n            TransactionState::Active { txn, .. } =\u003e Ok(txn),\n            TransactionState::None =\u003e Err(StorageError::TransactionNotFound),\n        }\n    }\n\n    fn txn_mut(\u0026mut self) -\u003e Result\u003c\u0026mut WriteTransaction\u003e {\n        match \u0026mut self.state {\n            TransactionState::Active { txn, .. } =\u003e Ok(txn),\n            TransactionState::None =\u003e Err(StorageError::TransactionNotFound),\n        }\n    }\n\n    fn take_txn(\u0026mut self) -\u003e Option\u003cWriteTransaction\u003e {\n        match std::mem::replace(\u0026mut self.state, TransactionState::None) {\n            TransactionState::Active { txn, .. } =\u003e Some(*txn),\n            TransactionState::None =\u003e None,\n        }\n    }\n}\n\n// Store\nimpl StorageCore {\n    pub fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let txn = self.txn()?;\n        let table = txn.open_table(SCHEMA_TABLE)?;\n\n        table\n            .iter()?\n            .map(|entry| {\n                let value = entry?.1.value();\n                let schema = deserialize(\u0026value)?;\n                Ok(schema)\n            })\n            .collect()\n    }\n\n    pub fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        let schema = match \u0026self.state {\n            TransactionState::Active { txn, .. } =\u003e txn\n                .open_table(SCHEMA_TABLE)?\n                .get(table_name)?\n                .map(|v| deserialize(\u0026v.value())),\n            TransactionState::None =\u003e self\n                .db\n                .begin_write()?\n                .open_table(SCHEMA_TABLE)?\n                .get(table_name)?\n                .map(|v| deserialize(\u0026v.value())),\n        }\n        .transpose()?;\n\n        Ok(schema)\n    }\n\n    pub fn fetch_data(\u0026self, table_name: \u0026str, key: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        let txn = self.txn()?;\n        let table_def = self.data_table_def(table_name)?;\n        let table = txn.open_table(table_def)?;\n\n        let key = key.to_cmp_be_bytes()?;\n        let key = key.as_slice();\n        let row = table\n            .get(key)?\n            .map(|v| deserialize(\u0026v.value()))\n            .transpose()?\n            .map(|(_, row): (Key, DataRow)| row);\n\n        Ok(row)\n    }\n\n    pub fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        if let TransactionState::Active { autocommit, txn } = \u0026self.state {\n            if !autocommit {\n                let table_def = self.data_table_def(table_name)?;\n                let table = txn.open_table(table_def)?;\n\n                let rows: Vec\u003c_\u003e = table\n                    .iter()?\n                    .map(|entry| {\n                        let value = entry?.1.value();\n                        let (key, row): (Key, DataRow) = deserialize(\u0026value)?;\n\n                        Ok((key, row))\n                    })\n                    .collect::\u003cResult\u003c_\u003e\u003e()?;\n\n                return Ok(Box::pin(iter(rows.into_iter().map(Ok))));\n            }\n        }\n\n        let read_txn = self.db.begin_read()?;\n        let table_def = self.data_table_def(table_name)?;\n        let table = read_txn.open_table(table_def)?;\n\n        let rows = try_stream! {\n            for entry in table.iter().map_err(Into::\u003cStorageError\u003e::into)? {\n                let value = entry.map_err(Into::\u003cStorageError\u003e::into)?.1.value();\n                let (key, row): (Key, DataRow) = deserialize(\u0026value).map_err(Into::\u003cStorageError\u003e::into)?;\n\n                yield (key, row);\n            }\n        };\n\n        Ok(Box::pin(rows))\n    }\n}\n\n// StoreMut\nimpl StorageCore {\n    pub async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let data_def = self.data_table_def(\u0026schema.table_name)?;\n        let txn = self.txn_mut()?;\n        let mut table = txn.open_table(SCHEMA_TABLE)?;\n        let value = serialize(\u0026schema)?;\n        table.insert(schema.table_name.as_str(), value)?;\n        txn.open_table(data_def)?;\n\n        Ok(())\n    }\n\n    pub async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let table_def = self.data_table_def(table_name)?;\n        let txn = self.txn_mut()?;\n        let mut table = txn.open_table(SCHEMA_TABLE)?;\n        table.remove(table_name)?;\n        txn.delete_table(table_def)?;\n\n        Ok(())\n    }\n\n    pub async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let table_def = self.data_table_def(table_name)?;\n        let txn = self.txn_mut()?;\n        let mut table = txn.open_table(table_def)?;\n\n        for row in rows {\n            let key = Key::Uuid(Uuid::now_v7().as_u128());\n            let value = serialize(\u0026(\u0026key, row))?;\n            let table_key = key.to_cmp_be_bytes()?;\n            let table_key = table_key.as_slice();\n            table.insert(table_key, value)?;\n        }\n\n        Ok(())\n    }\n\n    pub async fn insert_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        let table_def = self.data_table_def(table_name)?;\n        let txn = self.txn_mut()?;\n        let mut table = txn.open_table(table_def)?;\n\n        for (key, row) in rows {\n            let value = serialize(\u0026(\u0026key, row))?;\n            let table_key = key.to_cmp_be_bytes()?;\n            let table_key = table_key.as_slice();\n            table.insert(table_key, value)?;\n        }\n\n        Ok(())\n    }\n\n    pub async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        let table_def = self.data_table_def(table_name)?;\n        let txn = self.txn_mut()?;\n        let mut table = txn.open_table(table_def)?;\n\n        for key in keys {\n            let table_key = key.to_cmp_be_bytes()?;\n            let table_key = table_key.as_slice();\n            table.remove(table_key)?;\n        }\n\n        Ok(())\n    }\n}\n\n// Transaction\nimpl StorageCore {\n    pub fn begin(\u0026mut self, autocommit: bool) -\u003e Result\u003cbool\u003e {\n        match (\u0026self.state, autocommit) {\n            (TransactionState::Active { .. }, true) =\u003e Ok(false),\n            (TransactionState::Active { .. }, false) =\u003e {\n                Err(StorageError::NestedTransactionNotSupported)\n            }\n            (TransactionState::None, _) =\u003e {\n                let write_txn = self.db.begin_write()?;\n                self.state = TransactionState::Active {\n                    txn: Box::new(write_txn),\n                    autocommit,\n                };\n\n                Ok(autocommit)\n            }\n        }\n    }\n\n    pub fn rollback(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if let Some(txn) = self.take_txn() {\n            txn.abort()?;\n        }\n\n        Ok(())\n    }\n\n    pub fn commit(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if let Some(txn) = self.take_txn() {\n            txn.commit()?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":135},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redb-storage","src","error.rs"],"content":"use {gluesql_core::error::Error, thiserror::Error as ThisError};\n\n#[derive(ThisError, Debug)]\npub enum StorageError {\n    #[error(\"nested transaction is not supported\")]\n    NestedTransactionNotSupported,\n    #[error(\"transaction not found\")]\n    TransactionNotFound,\n    #[error(\"cannot create table with reserved name: {0}\")]\n    ReservedTableName(String),\n\n    #[error(transparent)]\n    Glue(#[from] Error),\n\n    #[error(transparent)]\n    RedbDatabase(#[from] redb::DatabaseError),\n    #[error(transparent)]\n    RedbStorage(#[from] redb::StorageError),\n    #[error(transparent)]\n    RedbTable(#[from] redb::TableError),\n    #[error(transparent)]\n    RedbTransaction(Box\u003credb::TransactionError\u003e),\n    #[error(transparent)]\n    RedbCommit(#[from] redb::CommitError),\n\n    #[error(transparent)]\n    Bincode(#[from] bincode::Error),\n}\n\nimpl From\u003cStorageError\u003e for Error {\n    fn from(e: StorageError) -\u003e Error {\n        Error::StorageMsg(e.to_string())\n    }\n}\n\nimpl From\u003credb::TransactionError\u003e for StorageError {\n    fn from(e: redb::TransactionError) -\u003e StorageError {\n        StorageError::RedbTransaction(Box::new(e))\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redb-storage","src","lib.rs"],"content":"#![deny(clippy::str_to_string)]\n\nmod core;\nmod error;\n\nuse {\n    async_trait::async_trait,\n    core::StorageCore,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::Result,\n        store::{\n            AlterTable, CustomFunction, CustomFunctionMut, DataRow, Index, IndexMut, Metadata,\n            RowIter, Store, StoreMut, Transaction,\n        },\n    },\n    redb::Database,\n    std::path::Path,\n};\n\npub struct RedbStorage(StorageCore);\n\nimpl RedbStorage {\n    pub fn new\u003cP: AsRef\u003cPath\u003e\u003e(filename: P) -\u003e Result\u003cSelf\u003e {\n        StorageCore::new(filename).map(Self).map_err(Into::into)\n    }\n\n    pub fn from_database(db: Database) -\u003e Self {\n        Self(StorageCore::from_database(db))\n    }\n}\n\n#[async_trait(?Send)]\nimpl Store for RedbStorage {\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        self.0.fetch_all_schemas().map_err(Into::into)\n    }\n\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        self.0.fetch_schema(table_name).map_err(Into::into)\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, key: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        self.0.fetch_data(table_name, key).map_err(Into::into)\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        self.0.scan_data(table_name).map_err(Into::into)\n    }\n}\n\n#[async_trait(?Send)]\nimpl StoreMut for RedbStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        self.0.insert_schema(schema).await.map_err(Into::into)\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        self.0.delete_schema(table_name).await.map_err(Into::into)\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        self.0\n            .append_data(table_name, rows)\n            .await\n            .map_err(Into::into)\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        self.0\n            .insert_data(table_name, rows)\n            .await\n            .map_err(Into::into)\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        self.0\n            .delete_data(table_name, keys)\n            .await\n            .map_err(Into::into)\n    }\n}\n\n#[async_trait(?Send)]\nimpl Transaction for RedbStorage {\n    async fn begin(\u0026mut self, autocommit: bool) -\u003e Result\u003cbool\u003e {\n        self.0.begin(autocommit).map_err(Into::into)\n    }\n\n    async fn rollback(\u0026mut self) -\u003e Result\u003c()\u003e {\n        self.0.rollback().map_err(Into::into)\n    }\n\n    async fn commit(\u0026mut self) -\u003e Result\u003c()\u003e {\n        self.0.commit().map_err(Into::into)\n    }\n}\n\nimpl AlterTable for RedbStorage {}\nimpl Index for RedbStorage {}\nimpl IndexMut for RedbStorage {}\nimpl Metadata for RedbStorage {}\nimpl CustomFunction for RedbStorage {}\nimpl CustomFunctionMut for RedbStorage {}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redb-storage","tests","begin_write_error.rs"],"content":"use {\n    gluesql_core::store::Transaction,\n    gluesql_redb_storage::RedbStorage,\n    redb::{Database, StorageBackend, TableDefinition, backends::FileBackend},\n    std::{\n        fs::{OpenOptions, create_dir, remove_file},\n        io::ErrorKind,\n        sync::{\n            Arc,\n            atomic::{AtomicBool, Ordering},\n        },\n    },\n};\n\n#[derive(Debug)]\nstruct FailingBackend {\n    inner: FileBackend,\n    fail_flag: Arc\u003cAtomicBool\u003e,\n}\n\nimpl FailingBackend {\n    fn new(inner: FileBackend, fail_flag: Arc\u003cAtomicBool\u003e) -\u003e Self {\n        Self { inner, fail_flag }\n    }\n}\n\nimpl StorageBackend for FailingBackend {\n    fn len(\u0026self) -\u003e Result\u003cu64, std::io::Error\u003e {\n        self.inner.len()\n    }\n\n    fn read(\u0026self, offset: u64, len: usize) -\u003e Result\u003cVec\u003cu8\u003e, std::io::Error\u003e {\n        self.inner.read(offset, len)\n    }\n\n    fn set_len(\u0026self, len: u64) -\u003e Result\u003c(), std::io::Error\u003e {\n        self.inner.set_len(len)\n    }\n\n    fn sync_data(\u0026self, eventual: bool) -\u003e Result\u003c(), std::io::Error\u003e {\n        if self.fail_flag.load(Ordering::SeqCst) {\n            Err(std::io::Error::from(ErrorKind::Other))\n        } else {\n            self.inner.sync_data(eventual)\n        }\n    }\n\n    fn write(\u0026self, offset: u64, data: \u0026[u8]) -\u003e Result\u003c(), std::io::Error\u003e {\n        self.inner.write(offset, data)\n    }\n}\n\n#[tokio::test]\nasync fn begin_write_after_io_error() {\n    let _ = create_dir(\"tmp\");\n    let path = \"tmp/redb_prev_io\";\n    let _ = remove_file(path);\n\n    let file = OpenOptions::new()\n        .read(true)\n        .write(true)\n        .create(true)\n        .truncate(true)\n        .open(path)\n        .expect(\"create file\");\n    let fail_flag = Arc::new(AtomicBool::new(false));\n    let backend = FailingBackend::new(FileBackend::new(file).unwrap(), fail_flag.clone());\n    let db = Database::builder()\n        .create_with_backend(backend)\n        .expect(\"create database\");\n\n    const TABLE: TableDefinition\u003cu64, u64\u003e = TableDefinition::new(\"x\");\n\n    fail_flag.store(true, Ordering::SeqCst);\n    let tx = db.begin_write().expect(\"begin write\");\n    {\n        let mut table = tx.open_table(TABLE).expect(\"open table\");\n        table.insert(\u00260, \u00260).expect(\"insert\");\n    }\n    let _ = tx.commit().expect_err(\"commit should fail\");\n\n    let mut storage = RedbStorage::from_database(db);\n    let err = storage.begin(true).await.expect_err(\"begin should fail\");\n    assert!(err.to_string().contains(\"Previous I/O error\"));\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redb-storage","tests","nested_transaction.rs"],"content":"use {\n    gluesql_core::prelude::{Error, Glue},\n    gluesql_redb_storage::RedbStorage,\n};\n\n#[tokio::test]\nasync fn redb_nested_transaction() {\n    let _ = std::fs::create_dir(\"tmp\");\n    let path = \"tmp/redb_nested_transaction\";\n    let _ = std::fs::remove_file(path);\n\n    let storage = RedbStorage::new(path).unwrap();\n    let mut glue = Glue::new(storage);\n\n    glue.execute(\"BEGIN\").await.unwrap();\n    let result = glue.execute(\"BEGIN\").await;\n    assert_eq!(\n        result,\n        Err(Error::StorageMsg(\n            \"nested transaction is not supported\".to_owned()\n        ))\n        .map(|payload| vec![payload])\n    );\n    glue.execute(\"COMMIT;\").await.unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redb-storage","tests","redb_storage.rs"],"content":"use {\n    async_trait::async_trait,\n    gluesql_core::prelude::Glue,\n    gluesql_redb_storage::RedbStorage,\n    std::fs::{create_dir, remove_file},\n    test_suite::*,\n};\n\nstruct RedbTester {\n    glue: Glue\u003cRedbStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cRedbStorage\u003e for RedbTester {\n    async fn new(namespace: \u0026str) -\u003e Self {\n        let _ = create_dir(\"tmp\");\n        let path = format!(\"tmp/{}\", namespace);\n        let _ = remove_file(\u0026path);\n\n        let storage = RedbStorage::new(path).expect(\"[RedbTester] failed to create storage\");\n        let glue = Glue::new(storage);\n\n        Self { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cRedbStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, RedbTester);\ngenerate_transaction_tests!(tokio::test, RedbTester);\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redb-storage","tests","reserved_table_name.rs"],"content":"use {\n    gluesql_core::prelude::{Error, Glue},\n    gluesql_redb_storage::RedbStorage,\n    std::fs::{create_dir, remove_file},\n};\n\n#[tokio::test]\nasync fn reserved_table_name() {\n    let _ = create_dir(\"tmp\");\n    let path = \"tmp/redb_reserved_table_name\";\n    let _ = remove_file(path);\n\n    let storage = RedbStorage::new(path).unwrap();\n    let mut glue = Glue::new(storage);\n\n    let result = glue.execute(\"CREATE TABLE __SCHEMA__ (id INTEGER);\").await;\n\n    assert_eq!(\n        result,\n        Err(Error::StorageMsg(\n            \"cannot create table with reserved name: __SCHEMA__\".to_owned(),\n        ))\n        .map(|payload| vec![payload])\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redb-storage","tests","storage_interface_error.rs"],"content":"use {\n    gluesql_core::error::Error,\n    gluesql_redb_storage::RedbStorage,\n    std::fs::{create_dir, remove_file},\n};\n\n#[tokio::test]\nasync fn redb_storage_interface_error() {\n    let _ = create_dir(\"tmp\");\n    let path = \"tmp/redb_storage_interface_error\";\n    let _ = remove_file(path);\n\n    let storage1 = RedbStorage::new(path).expect(\"open first storage\");\n\n    // Attempt to open the same database again using the storage interface\n    let result = RedbStorage::new(path);\n    let err = result.err().expect(\"second open should fail\");\n\n    match err {\n        Error::StorageMsg(msg) =\u003e assert!(msg.contains(\"Database already open\")),\n        other =\u003e panic!(\"unexpected error: {other:?}\"),\n    }\n\n    drop(storage1);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redis-storage","src","alter_table.rs"],"content":"use {\n    super::RedisStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        ast::ColumnDef,\n        data::Value,\n        error::{AlterTableError, Error, Result},\n        store::{AlterTable, DataRow, Store},\n    },\n    redis::Commands,\n};\n\n#[async_trait(?Send)]\nimpl AlterTable for RedisStorage {\n    async fn rename_schema(\u0026mut self, table_name: \u0026str, new_table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        if let Some(mut schema) = self.fetch_schema(table_name).await? {\n            // Which should be done first? deleting or storing?\n            self.redis_delete_schema(table_name)?;\n\n            new_table_name.clone_into(\u0026mut schema.table_name);\n            self.redis_store_schema(\u0026schema)?;\n\n            let redis_key_iter: Vec\u003cString\u003e = self.redis_execute_scan(table_name)?;\n\n            for redis_key in redis_key_iter {\n                if let Some(value) = self.redis_execute_get(\u0026redis_key)? {\n                    let key = Self::redis_parse_key(\u0026redis_key)?;\n                    let new_key = Self::redis_generate_key(\u0026self.namespace, new_table_name, \u0026key)?;\n\n                    self.redis_execute_set(\u0026new_key, \u0026value)?;\n                    self.redis_execute_del(\u0026redis_key)?;\n                }\n            }\n        } else {\n            return Err(AlterTableError::TableNotFound(table_name.to_owned()).into());\n        }\n\n        Ok(())\n    }\n\n    async fn rename_column(\n        \u0026mut self,\n        table_name: \u0026str,\n        old_column_name: \u0026str,\n        new_column_name: \u0026str,\n    ) -\u003e Result\u003c()\u003e {\n        if let Some(mut schema) = self.fetch_schema(table_name).await? {\n            let column_defs = schema\n                .column_defs\n                .as_mut()\n                .ok_or_else(|| AlterTableError::SchemalessTableFound(table_name.to_owned()))?;\n\n            if column_defs\n                .iter()\n                .any(|ColumnDef { name, .. }| name == new_column_name)\n            {\n                return Err(\n                    AlterTableError::AlreadyExistingColumn(new_column_name.to_owned()).into(),\n                );\n            }\n\n            let column_def = column_defs\n                .iter_mut()\n                .find(|column_def| column_def.name == old_column_name)\n                .ok_or(AlterTableError::RenamingColumnNotFound)?;\n\n            new_column_name.clone_into(\u0026mut column_def.name);\n\n            self.redis_delete_schema(table_name)?;\n            self.redis_store_schema(\u0026schema)?;\n        } else {\n            return Err(AlterTableError::TableNotFound(table_name.to_owned()).into());\n        }\n\n        Ok(())\n    }\n\n    async fn add_column(\u0026mut self, table_name: \u0026str, column_def: \u0026ColumnDef) -\u003e Result\u003c()\u003e {\n        if let Some(mut schema) = self.fetch_schema(table_name).await? {\n            let column_defs = schema\n                .column_defs\n                .as_mut()\n                .ok_or_else(|| AlterTableError::SchemalessTableFound(table_name.to_owned()))?;\n\n            if column_defs\n                .iter()\n                .any(|ColumnDef { name, .. }| name == \u0026column_def.name)\n            {\n                let adding_column = column_def.name.to_owned();\n\n                return Err(AlterTableError::AlreadyExistingColumn(adding_column).into());\n            }\n\n            let ColumnDef {\n                data_type,\n                nullable,\n                default,\n                ..\n            } = column_def;\n\n            let new_value_of_new_column = match (default, nullable) {\n                (Some(expr), _) =\u003e {\n                    let evaluated = gluesql_core::executor::evaluate_stateless(None, expr).await?;\n\n                    evaluated.try_into_value(data_type, *nullable)?\n                }\n                (None, true) =\u003e Value::Null,\n                (None, false) =\u003e {\n                    return Err(AlterTableError::DefaultValueRequired(column_def.clone()).into());\n                }\n            };\n\n            // NOTE: It cannot call self.redis_execute_scan/get/set methods directly.\n            // column_defs has a reference to item and the item has a reference to self.\n            // Therefore it cannot call self.redis_execute_scan method because\n            // it needs to use the mutable reference of self.\n            // Otherwise, it will cause a mutable reference conflict.\n            let scan_key = Self::redis_generate_scankey(\u0026self.namespace, table_name);\n            let key_iter: Vec\u003cString\u003e = self\n                .conn\n                .borrow_mut()\n                .scan_match(\u0026scan_key)\n                .map(|iter| iter.collect::\u003cVec\u003cString\u003e\u003e())\n                .map_err(|_| {\n                    Error::StorageMsg(format!(\n                        \"[RedisStorage] failed to execute SCAN: key={}\",\n                        scan_key\n                    ))\n                })?;\n\n            for key in key_iter {\n                let value = redis::cmd(\"GET\")\n                    .arg(\u0026key)\n                    .query::\u003cString\u003e(\u0026mut self.conn.borrow_mut())\n                    .map_err(|_| {\n                        Error::StorageMsg(format!(\n                            \"[RedisStorage] failed to execute GET: key={}\",\n                            key\n                        ))\n                    })?;\n\n                let mut row: DataRow = serde_json::from_str(\u0026value).map_err(|e| {\n                    Error::StorageMsg(format!(\n                        \"[RedisStorage] failed to deserialize value={} error={}\",\n                        value, e\n                    ))\n                })?;\n                match \u0026mut row {\n                    DataRow::Vec(values) =\u003e {\n                        values.push(new_value_of_new_column.clone());\n                    }\n                    DataRow::Map(_) =\u003e {\n                        return Err(Error::StorageMsg(\n                            \"[RedisStorage] conflict - add_column failed: schemaless row found\"\n                                .to_owned(),\n                        ));\n                    }\n                }\n\n                let new_value = serde_json::to_string(\u0026row).map_err(|_e| {\n                    Error::StorageMsg(format!(\n                        \"[RedisStorage] failed to serialize row={:?} error={}\",\n                        row, _e\n                    ))\n                })?;\n                let _: () = redis::cmd(\"SET\")\n                    .arg(\u0026key)\n                    .arg(new_value)\n                    .query(\u0026mut self.conn.borrow_mut())\n                    .map_err(|_| {\n                        Error::StorageMsg(format!(\n                            \"[RedisStorage] add_column: failed to execute SET for row={:?}\",\n                            row\n                        ))\n                    })?;\n            }\n\n            column_defs.push(column_def.clone());\n            self.redis_delete_schema(table_name)?; // No problem yet, finally it's ok to delete the old schema\n            self.redis_store_schema(\u0026schema)?;\n        } else {\n            return Err(AlterTableError::TableNotFound(table_name.to_owned()).into());\n        }\n\n        Ok(())\n    }\n\n    async fn drop_column(\n        \u0026mut self,\n        table_name: \u0026str,\n        column_name: \u0026str,\n        if_exists: bool,\n    ) -\u003e Result\u003c()\u003e {\n        if let Some(mut schema) = self.fetch_schema(table_name).await? {\n            let column_defs = schema\n                .column_defs\n                .as_mut()\n                .ok_or_else(|| AlterTableError::SchemalessTableFound(table_name.to_owned()))?;\n\n            let column_index = column_defs\n                .iter()\n                .position(|column_def| column_def.name == column_name);\n\n            match column_index {\n                Some(column_index) =\u003e {\n                    column_defs.remove(column_index);\n\n                    let key_iter = self.redis_execute_scan(table_name)?;\n                    for key in key_iter {\n                        if let Some(value) = self.redis_execute_get(\u0026key)? {\n                            let mut row: DataRow = serde_json::from_str(\u0026value).map_err(|e| {\n                                Error::StorageMsg(format!(\n                                    \"[RedisStorage] failed to deserialize value={} error={}\",\n                                    value, e\n                                ))\n                            })?;\n                            match \u0026mut row {\n                                DataRow::Vec(values) =\u003e {\n                                    values.remove(column_index);\n                                }\n                                DataRow::Map(_) =\u003e {\n                                    return Err(Error::StorageMsg(\n                                    \"[RedisStorage] conflict - add_column failed: schemaless row found\".to_owned(),\n                                ));\n                                }\n                            }\n\n                            let new_value = serde_json::to_string(\u0026row).map_err(|e| {\n                                Error::StorageMsg(format!(\n                                    \"[RedisStorage] failed to serialize row={:?} error={}\",\n                                    row, e\n                                ))\n                            })?;\n                            self.redis_execute_set(\u0026key, \u0026new_value)?;\n                        }\n                    }\n                }\n                None if if_exists =\u003e {}\n                None =\u003e {\n                    return Err(\n                        AlterTableError::DroppingColumnNotFound(column_name.to_owned()).into(),\n                    );\n                }\n            };\n\n            self.redis_delete_schema(table_name)?; // No problem yet, finally it's ok to delete the old schema\n            self.redis_store_schema(\u0026schema)?;\n        } else {\n            return Err(AlterTableError::TableNotFound(table_name.to_owned()).into());\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":128},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redis-storage","src","index.rs"],"content":"use {\n    super::RedisStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        ast::{IndexOperator, OrderByExpr},\n        data::Value,\n        error::{Error, Result},\n        store::{Index, IndexMut, RowIter},\n    },\n};\n\n// Index is one of MUST-be-implemented traits.\n\n#[async_trait(?Send)]\nimpl Index for RedisStorage {\n    async fn scan_indexed_data\u003c'a\u003e(\n        \u0026'a self,\n        _table_name: \u0026str,\n        _index_name: \u0026str,\n        _asc: Option\u003cbool\u003e,\n        _cmp_value: Option\u003c(\u0026IndexOperator, Value)\u003e,\n    ) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        Err(Error::StorageMsg(\n            \"[RedisStorage] index is not supported\".to_owned(),\n        ))\n    }\n}\n\n#[async_trait(?Send)]\nimpl IndexMut for RedisStorage {\n    async fn create_index(\n        \u0026mut self,\n        _table_name: \u0026str,\n        _index_name: \u0026str,\n        _column: \u0026OrderByExpr,\n    ) -\u003e Result\u003c()\u003e {\n        Err(Error::StorageMsg(\n            \"[RedisStorage] index is not supported\".to_owned(),\n        ))\n    }\n\n    async fn drop_index(\u0026mut self, _table_name: \u0026str, _index_name: \u0026str) -\u003e Result\u003c()\u003e {\n        Err(Error::StorageMsg(\n            \"[RedisStorage] index is not supported\".to_owned(),\n        ))\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redis-storage","src","lib.rs"],"content":"#![deny(clippy::str_to_string)]\n\nmod alter_table;\nmod index;\nmod metadata;\nmod transaction;\n\nuse {\n    async_trait::async_trait,\n    futures::stream::iter,\n    gluesql_core::{\n        chrono::Utc,\n        data::{CustomFunction as StructCustomFunction, Key, Schema, Value},\n        error::{Error, Result},\n        store::{CustomFunction, CustomFunctionMut, DataRow, RowIter, Store, StoreMut},\n    },\n    redis::{Commands, Connection},\n    std::{cell::RefCell, collections::BTreeMap},\n};\n\npub struct RedisStorage {\n    pub namespace: String,\n    pub conn: RefCell\u003cConnection\u003e,\n}\n\nimpl RedisStorage {\n    pub fn new(namespace: \u0026str, url: \u0026str, port: u16) -\u003e Self {\n        let redis_url = format!(\"redis://{}:{}\", url, port);\n        let conn = redis::Client::open(redis_url)\n            .expect(\"Invalid connection URL\")\n            .get_connection()\n            .expect(\"failed to connect to Redis\");\n\n        RedisStorage {\n            namespace: namespace.to_owned(),\n            conn: RefCell::new(conn),\n        }\n    }\n\n    ///\n    /// Make a key to insert/delete a value with the namespace, table-name.\n    ///\n    /// Redis documentation recommends to use ':' as a separator for namespace and table-name.\n    /// But it is not a good idea when using serde_json to serialize/deserialize a key.\n    /// JSON uses ':' as a separator for key and value. So it conflicts with the JSON format.\n    /// Therefore I use '#' as a separator: \"namespace\"#\"table-name\"#\"key\"#\"value\".\n    ///\n    fn redis_generate_key(namespace: \u0026str, table_name: \u0026str, key: \u0026Key) -\u003e Result\u003cString\u003e {\n        let k = serde_json::to_string(key).map_err(|e| {\n            Error::StorageMsg(format!(\n                \"[RedisStorage] failed to serialize key key:{:?}, error={}\",\n                key, e\n            ))\n        })?;\n        Ok(format!(\"{}#{}#{}\", namespace, table_name, k))\n    }\n\n    ///\n    /// Parse a redis-key to get the original key of the table\n    ///\n    pub fn redis_parse_key(redis_key: \u0026str) -\u003e Result\u003cKey\u003e {\n        let split_key = redis_key.split('#').collect::\u003cVec\u003c\u0026str\u003e\u003e();\n        serde_json::from_str(split_key[2]).map_err(|e| {\n            Error::StorageMsg(format!(\n                \"[RedisStorage] failed to deserialize key: key={} error={}\",\n                redis_key, e\n            ))\n        })\n    }\n\n    ///\n    /// Make a key pattern to do scan and get all data in the namespace\n    ///\n    fn redis_generate_scankey(namespace: \u0026str, tablename: \u0026str) -\u003e String {\n        // First I used \"{}#{}*\" pattern. It had a problem when using\n        // similar table-names such like Test, TestA and TestB.\n        // When scanning Test, it gets all data from Test, TestA and TestB.\n        // Therefore it is very important to use the # twice.\n        format!(\"{}#{}#*\", namespace, tablename)\n    }\n\n    ///\n    /// Make a key pattern to do scan and get all schemas in the namespace\n    ///\n    fn redis_generate_schema_key(namespace: \u0026str, table_name: \u0026str) -\u003e String {\n        format!(\"#schema#{}#{}#\", namespace, table_name)\n    }\n\n    fn redis_generate_scan_schema_key(namespace: \u0026str) -\u003e String {\n        format!(\"#schema#{}#*\", namespace)\n    }\n\n    fn redis_generate_metadata_key(\n        namespace: \u0026str,\n        tablename: \u0026str,\n        metadata_name: \u0026str,\n    ) -\u003e String {\n        format!(\"#metadata#{}#{}#{}#\", namespace, tablename, metadata_name)\n    }\n\n    fn redis_generate_scan_metadata_key(namespace: \u0026str, tablename: \u0026str) -\u003e String {\n        format!(\"#metadata#{}#{}#*\", namespace, tablename)\n    }\n\n    fn redis_generate_scan_all_metadata_key(namespace: \u0026str) -\u003e String {\n        format!(\"#metadata#{}#*\", namespace)\n    }\n\n    fn redis_execute_get(\u0026mut self, key: \u0026str) -\u003e Result\u003cOption\u003cString\u003e\u003e {\n        let value = redis::cmd(\"GET\")\n            .arg(key)\n            .query::\u003cString\u003e(\u0026mut self.conn.get_mut())\n            .map_err(|e| {\n                Error::StorageMsg(format!(\n                    \"[RedisStorage] failed to execute GET: key={} error={}\",\n                    key, e\n                ))\n            })?;\n\n        Ok(Some(value))\n    }\n\n    fn redis_execute_set(\u0026mut self, key: \u0026str, value: \u0026str) -\u003e Result\u003c()\u003e {\n        redis::cmd(\"SET\")\n            .arg(key)\n            .arg(value)\n            .query::\u003c()\u003e(\u0026mut self.conn.get_mut())\n            .map_err(|e| {\n                Error::StorageMsg(format!(\n                    \"[RedisStorage] failed to execute SET: key={} value={} error={}\",\n                    key, value, e\n                ))\n            })?;\n\n        Ok(())\n    }\n\n    pub fn redis_execute_del(\u0026mut self, key: \u0026str) -\u003e Result\u003c()\u003e {\n        redis::cmd(\"DEL\")\n            .arg(key)\n            .query::\u003c()\u003e(\u0026mut self.conn.get_mut())\n            .map_err(|e| {\n                Error::StorageMsg(format!(\n                    \"[RedisStorage] failed to execute DEL: key={} error={}\",\n                    key, e\n                ))\n            })?;\n\n        Ok(())\n    }\n\n    pub fn redis_execute_scan(\u0026mut self, table_name: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let key = Self::redis_generate_scankey(\u0026self.namespace, table_name);\n        let redis_keys: Vec\u003cString\u003e = self\n            .conn\n            .get_mut()\n            .scan_match(\u0026key)\n            .map(|iter| iter.collect::\u003cVec\u003cString\u003e\u003e())\n            .map_err(|e| {\n                Error::StorageMsg(format!(\n                    \"[RedisStorage] failed to scan data: key={} error={}\",\n                    key, e\n                ))\n            })?;\n\n        Ok(redis_keys)\n    }\n\n    pub fn redis_store_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let schema_value = serde_json::to_string(schema).map_err(|e| {\n            Error::StorageMsg(format!(\n                \"[RedisStorage] failed to serialize schema={:?} error={}\",\n                schema, e\n            ))\n        })?;\n        let schema_key = Self::redis_generate_schema_key(\u0026self.namespace, \u0026schema.table_name);\n        self.redis_execute_set(\u0026schema_key, \u0026schema_value)?;\n\n        Ok(())\n    }\n\n    pub fn redis_delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let schema_key = Self::redis_generate_schema_key(\u0026self.namespace, table_name);\n        // It's already if the schema is already removed by another client.\n        if let Ok(Some(schema_value)) = self.redis_execute_get(\u0026schema_key) {\n            let schema = serde_json::from_str::\u003cSchema\u003e(\u0026schema_value).map_err(|e| {\n                Error::StorageMsg(format!(\n                    \"[RedisStorage] failed to deserialize schema={:?} error={}\",\n                    schema_value, e\n                ))\n            })?;\n            if schema.table_name == table_name {\n                self.redis_execute_del(\u0026schema_key)?;\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[async_trait(?Send)]\nimpl CustomFunction for RedisStorage {\n    async fn fetch_function\u003c'a\u003e(\n        \u0026'a self,\n        _func_name: \u0026str,\n    ) -\u003e Result\u003cOption\u003c\u0026'a StructCustomFunction\u003e\u003e {\n        Err(Error::StorageMsg(\n            \"[RedisStorage] fetch_function is not supported yet\".to_owned(),\n        ))\n    }\n\n    async fn fetch_all_functions\u003c'a\u003e(\u0026'a self) -\u003e Result\u003cVec\u003c\u0026'a StructCustomFunction\u003e\u003e {\n        Err(Error::StorageMsg(\n            \"[RedisStorage] fetch_all_functions is not supported yet\".to_owned(),\n        ))\n    }\n}\n\n#[async_trait(?Send)]\nimpl CustomFunctionMut for RedisStorage {\n    async fn insert_function(\u0026mut self, _func: StructCustomFunction) -\u003e Result\u003c()\u003e {\n        Err(Error::StorageMsg(\n            \"[RedisStorage] insert_function is not supported yet\".to_owned(),\n        ))\n    }\n\n    async fn delete_function(\u0026mut self, _func_name: \u0026str) -\u003e Result\u003c()\u003e {\n        Err(Error::StorageMsg(\n            \"[RedisStorage] delete_function is not supported yet\".to_owned(),\n        ))\n    }\n}\n\n#[async_trait(?Send)]\nimpl Store for RedisStorage {\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let mut schemas = Vec::\u003cSchema\u003e::new();\n        let scan_schema_key = Self::redis_generate_scan_schema_key(\u0026self.namespace);\n        let redis_keys: Vec\u003cString\u003e = self\n            .conn\n            .borrow_mut()\n            .scan_match(\u0026scan_schema_key)\n            .map(|iter| iter.collect::\u003cVec\u003cString\u003e\u003e())\n            .map_err(|e| {\n                Error::StorageMsg(format!(\n                    \"[RedisStorage] failed to scan schemas: namespace={} error={}\",\n                    self.namespace, e\n                ))\n            })?;\n\n        // Then read all schemas of the namespace\n        for redis_key in redis_keys.into_iter() {\n            // Another client just has removed the value with the key.\n            // It's not a problem. Just ignore it.\n            if let Ok(value) = redis::cmd(\"GET\")\n                .arg(\u0026redis_key)\n                .query::\u003cString\u003e(\u0026mut self.conn.borrow_mut())\n            {\n                serde_json::from_str::\u003cSchema\u003e(\u0026value)\n                    .map_err(|e| {\n                        Error::StorageMsg(format!(\n                            \"[RedisStorage] failed to deserialize schema={} error={}\",\n                            value, e\n                        ))\n                    })\n                    .map(|schema| schemas.push(schema))?;\n            }\n        }\n\n        schemas.sort_by(|a, b| a.table_name.cmp(\u0026b.table_name));\n\n        Ok(schemas)\n    }\n\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        let mut found = None;\n        let scan_schema_key = Self::redis_generate_scan_schema_key(\u0026self.namespace);\n        let redis_keys: Vec\u003cString\u003e = self\n            .conn\n            .borrow_mut()\n            .scan_match(\u0026scan_schema_key)\n            .map(|iter| iter.collect::\u003cVec\u003cString\u003e\u003e())\n            .map_err(|e| {\n                Error::StorageMsg(format!(\n                    \"[RedisStorage] failed to scan schemas: namespace={} error={}\",\n                    self.namespace, e\n                ))\n            })?;\n\n        // Then read all schemas of the namespace\n        for redis_key in redis_keys.into_iter() {\n            // Another client just has removed the value with the key.\n            // It's not a problem. Just ignore it.\n            if let Ok(value) = redis::cmd(\"GET\")\n                .arg(\u0026redis_key)\n                .query::\u003cString\u003e(\u0026mut self.conn.borrow_mut())\n            {\n                serde_json::from_str::\u003cSchema\u003e(\u0026value)\n                    .map_err(|e| {\n                        Error::StorageMsg(format!(\n                            \"[RedisStorage] failed to deserialize schema={} error={}\",\n                            value, e\n                        ))\n                    })\n                    .map(|schema| {\n                        if schema.table_name == table_name {\n                            found = Some(schema);\n                        }\n                    })?;\n            }\n\n            if found.is_some() {\n                break;\n            }\n        }\n\n        Ok(found)\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, key: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        let key = Self::redis_generate_key(\u0026self.namespace, table_name, key)?;\n        // It's not a problem if the value with the key is removed by another client.\n        if let Ok(value) = redis::cmd(\"GET\")\n            .arg(\u0026key)\n            .query::\u003cString\u003e(\u0026mut self.conn.borrow_mut())\n        {\n            return serde_json::from_str::\u003cDataRow\u003e(\u0026value)\n                .map_err(|e| {\n                    Error::StorageMsg(format!(\n                        \"[RedisStorage] failed to deserialize value={} error={:?}\",\n                        value, e\n                    ))\n                })\n                .map(Some);\n        }\n        Ok(None)\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        // First read all keys of the table\n        let redis_keys: Vec\u003cString\u003e = self\n            .conn\n            .borrow_mut()\n            .scan_match(Self::redis_generate_scankey(\u0026self.namespace, table_name))\n            .map(|iter| iter.collect::\u003cVec\u003cString\u003e\u003e())\n            .map_err(|e| {\n                Error::StorageMsg(format!(\n                    \"[RedisStorage] failed to scan data: namespace={} table_name={} error={}\",\n                    self.namespace, table_name, e\n                ))\n            })?;\n\n        let rows = redis_keys\n            .into_iter()\n            .filter_map(|redis_key| {\n                // Another client just has removed the value with the key.\n                // It's not a problem. Just ignore it.\n                redis::cmd(\"GET\")\n                    .arg(\u0026redis_key)\n                    .query::\u003cString\u003e(\u0026mut self.conn.borrow_mut())\n                    .ok()\n                    .map(|value| (redis_key, value))\n            })\n            .map(|(redis_key, value)| {\n                let key = Self::redis_parse_key(\u0026redis_key).map_err(|e| {\n                    Error::StorageMsg(format!(\n                        \"[RedisStorage] Wrong key format: key={} error={}\",\n                        redis_key, e\n                    ))\n                })?;\n\n                let row = serde_json::from_str::\u003cDataRow\u003e(\u0026value).map_err(|e| {\n                    Error::StorageMsg(format!(\n                        \"[RedisStorage] failed to deserialize value={} error={:?}\",\n                        value, e\n                    ))\n                })?;\n                Ok((key, row))\n            })\n            .collect::\u003cResult\u003cBTreeMap\u003cKey, DataRow\u003e\u003e\u003e()?;\n        Ok(Box::pin(iter(rows.into_iter().map(Ok))))\n    }\n}\n\n#[async_trait(?Send)]\nimpl StoreMut for RedisStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let current_time = Value::Timestamp(Utc::now().naive_utc());\n        let current_time_value = serde_json::to_string(\u0026current_time).map_err(|e| {\n            Error::StorageMsg(format!(\n                \"[RedisStorage] failed to serialize metadata={:?} error={}\",\n                current_time, e\n            ))\n        })?;\n        let metadata_key =\n            Self::redis_generate_metadata_key(\u0026self.namespace, \u0026schema.table_name, \"CREATED\");\n        self.redis_execute_set(\u0026metadata_key, \u0026current_time_value)?;\n\n        let table_name = schema.table_name.clone();\n        let metadata_key =\n            Self::redis_generate_metadata_key(\u0026self.namespace, \u0026table_name, \"CREATED\");\n        let metadata_value = serde_json::to_string(\u0026current_time).map_err(|e| {\n            Error::StorageMsg(format!(\n                \"[RedisStorage] failed to serialize metadata={:?} error={}\",\n                current_time, e\n            ))\n        })?;\n        self.redis_execute_set(\u0026metadata_key, \u0026metadata_value)?;\n\n        // Finally it's ok to store the new schema\n        self.redis_store_schema(schema)?;\n\n        Ok(())\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let redis_key_iter: Vec\u003cString\u003e = self.redis_execute_scan(table_name)?;\n        for key in redis_key_iter {\n            self.redis_execute_del(\u0026key)?;\n        }\n\n        // delete metadata\n        let metadata_scan_key = Self::redis_generate_scan_metadata_key(\u0026self.namespace, table_name);\n        let metadata_redis_keys: Vec\u003cString\u003e = self\n            .conn\n            .borrow_mut()\n            .scan_match(\u0026metadata_scan_key)\n            .map(|iter| iter.collect::\u003cVec\u003cString\u003e\u003e())\n            .map_err(|e| {\n                Error::StorageMsg(format!(\n                    \"[RedisStorage] failed to scan metadata: namespace={} table_name={} error={}\",\n                    self.namespace, table_name, e\n                ))\n            })?;\n        for key in metadata_redis_keys {\n            self.redis_execute_del(\u0026key)?;\n        }\n\n        self.redis_delete_schema(table_name)?;\n\n        Ok(())\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        for row in rows {\n            // Even multiple clients can get an unique value with INCR command.\n            // and a shared key \"globalkey\"\n            let k = redis::cmd(\"INCR\")\n                .arg(\"globalkey\")\n                .query::\u003ci64\u003e(\u0026mut self.conn.borrow_mut())\n                .map_err(|_| {\n                    Error::StorageMsg(\"[RedisStorage] failed to execute INCR\".to_owned())\n                })?;\n            let key = Key::I64(k);\n            let redis_key = Self::redis_generate_key(\u0026self.namespace, table_name, \u0026key)?;\n            let value = serde_json::to_string(\u0026row).map_err(|e| {\n                Error::StorageMsg(format!(\n                    \"[RedisStorage] failed to serialize row={:?} error={}\",\n                    row, e\n                ))\n            })?;\n\n            self.redis_execute_set(\u0026redis_key, \u0026value)?;\n        }\n\n        Ok(())\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        for (key, row) in rows {\n            let redis_key = Self::redis_generate_key(\u0026self.namespace, table_name, \u0026key)?;\n            let value = serde_json::to_string(\u0026row).map_err(|e| {\n                Error::StorageMsg(format!(\n                    \"[RedisStorage] failed to serialize row={:?} error={}\",\n                    row, e\n                ))\n            })?;\n            self.redis_execute_set(\u0026redis_key, \u0026value)?;\n        }\n\n        Ok(())\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        for key in keys {\n            let redis_key = Self::redis_generate_key(\u0026self.namespace, table_name, \u0026key)?;\n            self.redis_execute_del(\u0026redis_key)?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":249},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redis-storage","src","metadata.rs"],"content":"use {\n    crate::RedisStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        data::Value,\n        error::{Error, Result},\n        store::{MetaIter, Metadata},\n    },\n    redis::Commands,\n    std::collections::HashMap,\n};\n\n#[async_trait(?Send)]\nimpl Metadata for RedisStorage {\n    async fn scan_table_meta(\u0026self) -\u003e Result\u003cMetaIter\u003e {\n        let mut all_metadata: HashMap\u003cString, HashMap\u003cString, Value\u003e\u003e = HashMap::new();\n        let metadata_scan_key = Self::redis_generate_scan_all_metadata_key(\u0026self.namespace);\n        let redis_keys: Vec\u003cString\u003e = self\n            .conn\n            .borrow_mut()\n            .scan_match(\u0026metadata_scan_key)\n            .map(|iter| iter.collect::\u003cVec\u003cString\u003e\u003e())\n            .map_err(|_| {\n                Error::StorageMsg(format!(\n                    \"[RedisStorage] failed to scan metadata: namespace={}\",\n                    self.namespace\n                ))\n            })?;\n\n        // Then read all values of the table\n        for redis_key in redis_keys.into_iter() {\n            // Another client just has removed the value with the key.\n            // It's not a problem. Just ignore it.\n            if let Ok(value) = redis::cmd(\"GET\")\n                .arg(\u0026redis_key)\n                .query::\u003cString\u003e(\u0026mut self.conn.borrow_mut())\n            {\n                let value: Value = serde_json::from_str::\u003cValue\u003e(\u0026value).map_err(|e| {\n                    Error::StorageMsg(format!(\n                        \"[RedisStorage] failed to deserialize value: key={} error={}\",\n                        redis_key, e\n                    ))\n                })?;\n\n                // [0]: empty because key starts with '#'\n                // [1]: 'metadata'\n                // [2]: namespace\n                // [3]: tablename\n                // [4]: metadata_name\n                let tokens = redis_key.split('#').collect::\u003cVec\u003c\u0026str\u003e\u003e();\n                if let Some(meta_table) = all_metadata.get_mut(tokens[3]) {\n                    meta_table.insert(tokens[4].to_owned(), value);\n                } else {\n                    let meta_table = HashMap::from([(tokens[4].to_owned(), value)]);\n                    let meta = HashMap::from([(tokens[3].to_owned(), meta_table)]);\n                    all_metadata.extend(meta);\n                }\n            }\n        }\n\n        Ok(Box::new(all_metadata.into_iter().map(Ok)))\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redis-storage","src","transaction.rs"],"content":"use {\n    super::RedisStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        error::{Error, Result},\n        store::Transaction,\n    },\n};\n\n#[async_trait(?Send)]\nimpl Transaction for RedisStorage {\n    async fn begin(\u0026mut self, autocommit: bool) -\u003e Result\u003cbool\u003e {\n        if autocommit {\n            return Ok(false);\n        }\n\n        Err(Error::StorageMsg(\n            \"[RedisStorage] transaction is not supported\".to_owned(),\n        ))\n    }\n\n    async fn rollback(\u0026mut self) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n\n    async fn commit(\u0026mut self) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redis-storage","tests","redis_errors.rs"],"content":"#![cfg(feature = \"test-redis\")]\n\nuse {\n    gluesql_core::prelude::{Error, Payload},\n    gluesql_redis_storage::RedisStorage,\n    std::{env, fs},\n};\n\nmacro_rules! exec {\n    ($glue: ident $sql: literal) =\u003e {\n        $glue.execute($sql).await.unwrap();\n    };\n}\n\nmacro_rules! test {\n    ($glue: ident $sql: expr, $result: expr) =\u003e {\n        assert_eq!($glue.execute($sql).await, $result);\n    };\n}\n\n/// MUST run redis locally before test\n/// eg.) docker run --rm -p 6379:6379 redis\n#[tokio::test]\nasync fn redis_storage_errors() {\n    use gluesql_core::prelude::Glue;\n\n    let mut path = env::current_dir().unwrap();\n    path.push(\"tests/redis-storage.toml\");\n    let redis_config_str = fs::read_to_string(path).unwrap();\n    let redis_config: toml::Value = toml::from_str(\u0026redis_config_str).unwrap();\n    let url = redis_config[\"redis\"][\"url\"].as_str().unwrap();\n    let port: u16 = redis_config[\"redis\"][\"port\"].as_integer().unwrap() as u16;\n\n    let storage = RedisStorage::new(\"redis_storage_namespace_first\", url, port);\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"DROP TABLE IF EXISTS dummy;\");\n\n    exec!(glue \"CREATE TABLE dummy (id INTEGER PRIMARY KEY);\");\n    exec!(glue \"INSERT INTO dummy (id) values (1)\");\n    exec!(glue \"INSERT INTO dummy (id) values (11)\");\n\n    // index\n    test!(\n        glue \"CREATE INDEX idx_id ON dummy (id);\",\n        Err(Error::StorageMsg(\"[RedisStorage] index is not supported\".to_owned()))\n    );\n    test!(\n        glue \"DROP INDEX dummy.idx_id;\",\n        Err(Error::StorageMsg(\"[RedisStorage] index is not supported\".to_owned()))\n    );\n\n    // transaction\n    test!(\n        glue \"BEGIN\",\n        Err(Error::StorageMsg(\"[RedisStorage] transaction is not supported\".to_owned()))\n    );\n    assert_eq!(\n        glue.execute(\"COMMIT;\").await.unwrap(),\n        vec![Payload::Commit]\n    );\n    assert_eq!(\n        glue.execute(\"ROLLBACK;\").await.unwrap(),\n        vec![Payload::Rollback]\n    );\n\n    exec!(glue \"DROP TABLE dummy;\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redis-storage","tests","redis_reconnect.rs"],"content":"#![cfg(feature = \"test-redis\")]\n\nuse {\n    gluesql_core::prelude::{Payload, Value},\n    gluesql_redis_storage::RedisStorage,\n    std::{env, fs},\n};\n\nmacro_rules! exec {\n    ($glue: ident $sql: literal) =\u003e {\n        $glue.execute($sql).await.unwrap();\n    };\n}\n\n/// MUST run redis locally before test\n/// eg.) docker run --rm -p 6379:6379 redis\n#[tokio::test]\nasync fn redis_storage_reconnect() {\n    use gluesql_core::prelude::Glue;\n\n    let mut path = env::current_dir().unwrap();\n    path.push(\"tests/redis-storage.toml\");\n    let redis_config_str = fs::read_to_string(path).unwrap();\n    let redis_config: toml::Value = toml::from_str(\u0026redis_config_str).unwrap();\n    let url = redis_config[\"redis\"][\"url\"].as_str().unwrap();\n    let port: u16 = redis_config[\"redis\"][\"port\"].as_integer().unwrap() as u16;\n\n    {\n        let storage = RedisStorage::new(\"redis_storage_reconnect\", url, port);\n        let mut glue = Glue::new(storage);\n\n        exec!(glue \"DROP TABLE IF EXISTS dummy;\");\n\n        exec!(glue \"CREATE TABLE dummy (id INTEGER PRIMARY KEY);\");\n        exec!(glue \"INSERT INTO dummy (id) values (1)\");\n        exec!(glue \"INSERT INTO dummy (id) values (11)\");\n    }\n\n    {\n        let storage = RedisStorage::new(\"redis_storage_reconnect\", url, port);\n        let mut glue = Glue::new(storage);\n\n        let ret = glue.execute(\"SELECT * FROM dummy;\").await.unwrap();\n        match \u0026ret[0] {\n            Payload::Select { labels, rows } =\u003e {\n                assert_eq!(labels[0], \"id\");\n                assert_eq!(rows[0].len(), 1);\n                assert_eq!(rows[1].len(), 1);\n                assert_eq!(rows[0][0], Value::I64(1));\n                assert_eq!(rows[1][0], Value::I64(11));\n            }\n            _ =\u003e unreachable!(),\n        }\n        exec!(glue \"DROP TABLE dummy;\");\n    }\n}\n\n#[tokio::test]\nasync fn redis_storage_reconnect_drop() {\n    use gluesql_core::prelude::Glue;\n\n    let mut path = env::current_dir().unwrap();\n    path.push(\"tests/redis-storage.toml\");\n    let redis_config_str = fs::read_to_string(path).unwrap();\n    let redis_config: toml::Value = toml::from_str(\u0026redis_config_str).unwrap();\n    let url = redis_config[\"redis\"][\"url\"].as_str().unwrap();\n    let port: u16 = redis_config[\"redis\"][\"port\"].as_integer().unwrap() as u16;\n\n    {\n        let storage = RedisStorage::new(\"redis_storage_reconnect_drop\", url, port);\n        let mut glue = Glue::new(storage);\n\n        exec!(glue \"DROP TABLE IF EXISTS dummy;\");\n\n        exec!(glue \"CREATE TABLE dummy (id INTEGER PRIMARY KEY);\");\n        exec!(glue \"INSERT INTO dummy (id) values (1)\");\n        exec!(glue \"INSERT INTO dummy (id) values (11)\");\n        exec!(glue \"DROP TABLE dummy;\");\n    }\n\n    {\n        let storage = RedisStorage::new(\"redis_storage_reconnect_drop\", url, port);\n        let mut glue = Glue::new(storage);\n\n        if glue.execute(\"SELECT * FROM dummy;\").await.is_ok() {\n            exec!(glue \"DROP TABLE IF EXISTS dummy;\");\n            panic!(\"SELECT should fail\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redis-storage","tests","redis_store.rs"],"content":"#![cfg(feature = \"test-redis\")]\n\nuse {\n    async_trait::async_trait,\n    gluesql_core::prelude::Glue,\n    gluesql_redis_storage::RedisStorage,\n    redis::Commands,\n    std::{env, fs},\n    test_suite::*,\n};\n\nstruct RedisStorageTester {\n    glue: Glue\u003cRedisStorage\u003e,\n}\n\n/// MUST run redis locally before test\n/// eg.) docker run --rm -p 6379:6379 redis\n#[async_trait(?Send)]\nimpl Tester\u003cRedisStorage\u003e for RedisStorageTester {\n    async fn new(namespace: \u0026str) -\u003e Self {\n        let mut path = env::current_dir().unwrap();\n        path.push(\"tests/redis-storage.toml\");\n        let redis_config_str = fs::read_to_string(path).unwrap();\n        let redis_config: toml::Value = toml::from_str(\u0026redis_config_str).unwrap();\n        let url = redis_config[\"redis\"][\"url\"].as_str().unwrap();\n        let port: u16 = redis_config[\"redis\"][\"port\"].as_integer().unwrap() as u16;\n\n        let storage = RedisStorage::new(namespace, url, port);\n\n        // MUST clear namespace before test\n        // DO NOT USE FLUSHALL command because it also flushes all namespaces of other clients.\n        // It must clear only its own namespace.\n        let key_iter: Vec\u003cString\u003e = storage\n            .conn\n            .borrow_mut()\n            .scan_match(\u0026format!(\"{}#*\", namespace))\n            .unwrap()\n            .collect();\n        for key in key_iter {\n            let _: () = redis::cmd(\"DEL\")\n                .arg(\u0026key)\n                .query(\u0026mut storage.conn.borrow_mut())\n                .unwrap_or_else(|_| panic!(\"failed to execute DEL for key={}\", key));\n        }\n\n        let glue = Glue::new(storage);\n        RedisStorageTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cRedisStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, RedisStorageTester);\ngenerate_alter_table_tests!(tokio::test, RedisStorageTester);\ngenerate_metadata_table_tests!(tokio::test, RedisStorageTester);\n\nmacro_rules! exec {\n    ($glue: ident $sql: literal) =\u003e {\n        $glue.execute($sql).await.unwrap();\n    };\n}\n\n/// check if it's able to create tables with same name in different namespace\n#[tokio::test]\nasync fn redis_storage_namespace() {\n    use gluesql_core::prelude::Glue;\n\n    let mut path = env::current_dir().unwrap();\n    path.push(\"tests/redis-storage.toml\");\n    let redis_config_str = fs::read_to_string(path).unwrap();\n    let redis_config: toml::Value = toml::from_str(\u0026redis_config_str).unwrap();\n    let url = redis_config[\"redis\"][\"url\"].as_str().unwrap();\n    let port: u16 = redis_config[\"redis\"][\"port\"].as_integer().unwrap() as u16;\n\n    let storage_first = RedisStorage::new(\"redis_storage_namespace_first\", url, port);\n    let mut glue_first = Glue::new(storage_first);\n\n    let storage_second = RedisStorage::new(\"redis_storage_namespace_second\", url, port);\n    let mut glue_second = Glue::new(storage_second);\n\n    exec!(glue_first \"CREATE TABLE dummy (id INTEGER PRIMARY KEY);\");\n    exec!(glue_first \"INSERT INTO dummy (id) values (1)\");\n    exec!(glue_first \"INSERT INTO dummy (id) values (11)\");\n\n    exec!(glue_second \"CREATE TABLE dummy (id INTEGER PRIMARY KEY);\");\n    exec!(glue_second \"INSERT INTO dummy (id) values (2)\");\n    exec!(glue_second \"INSERT INTO dummy (id) values (22)\");\n\n    exec!(glue_first \"DROP TABLE dummy;\");\n    exec!(glue_second \"DROP TABLE dummy;\");\n}\n\n#[tokio::test]\nasync fn redis_storage_no_primarykey() {\n    use {\n        chrono::NaiveDate,\n        gluesql_core::prelude::{Glue, Payload, Value},\n    };\n\n    let mut path = env::current_dir().unwrap();\n    path.push(\"tests/redis-storage.toml\");\n    let redis_config_str = fs::read_to_string(path).unwrap();\n    let redis_config: toml::Value = toml::from_str(\u0026redis_config_str).unwrap();\n    let url = redis_config[\"redis\"][\"url\"].as_str().unwrap();\n    let port: u16 = redis_config[\"redis\"][\"port\"].as_integer().unwrap() as u16;\n\n    let storage = RedisStorage::new(\"redis_storage_no_primarykey\", url, port);\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"DROP TABLE IF EXISTS Heroes;\");\n    exec!(glue \"CREATE TABLE Heroes (id INTEGER, name TEXT, birth DATE);\");\n    exec!(glue r#\"INSERT INTO Heroes (id, name, birth) values (1, 'Superman', '2023-12-31');\"#);\n\n    let ret: Vec\u003cPayload\u003e = glue.execute(\"SELECT * FROM Heroes;\").await.unwrap();\n    match \u0026ret[0] {\n        Payload::Select { labels, rows } =\u003e {\n            assert_eq!(labels[0], \"id\");\n            assert_eq!(rows[0][0], Value::I64(1));\n            assert_eq!(labels[1], \"name\");\n            assert_eq!(rows[0][1], Value::Str(\"Superman\".to_owned()));\n            assert_eq!(labels[2], \"birth\");\n            assert_eq!(\n                rows[0][2],\n                Value::Date(NaiveDate::from_ymd_opt(2023, 12, 31).unwrap())\n            );\n        }\n        _ =\u003e unreachable!(),\n    }\n\n    exec!(glue r#\"INSERT INTO Heroes (id, name, birth) values (2, 'Batman', '2000-12-31');\"#);\n    exec!(glue r#\"INSERT INTO Heroes (id, name, birth) values (3, 'Flash', '2011-12-31');\"#);\n    exec!(glue r#\"UPDATE Heroes set birth = '1999-12-31' WHERE name = 'Batman';\"#);\n\n    let ret: Vec\u003cPayload\u003e = glue\n        .execute(\"SELECT id, name, birth FROM Heroes;\")\n        .await\n        .unwrap();\n    match \u0026ret[0] {\n        Payload::Select { labels, rows } =\u003e {\n            assert_eq!(labels[0], \"id\");\n            assert_eq!(labels[1], \"name\");\n            assert_eq!(labels[2], \"birth\");\n\n            for r in rows.iter() {\n                if r[1] == Value::Str(\"Batman\".to_owned()) {\n                    assert_eq!(\n                        r[2],\n                        Value::Date(NaiveDate::from_ymd_opt(1999, 12, 31).unwrap())\n                    );\n                }\n            }\n        }\n        _ =\u003e unreachable!(),\n    }\n\n    exec!(glue r#\"DELETE FROM Heroes WHERE name = 'Superman';\"#);\n\n    let ret: Vec\u003cPayload\u003e = glue\n        .execute(\"SELECT id, name, birth FROM Heroes;\")\n        .await\n        .unwrap();\n\n    match \u0026ret[0] {\n        Payload::Select { labels, rows } =\u003e {\n            assert_eq!(labels[0], \"id\");\n            assert_eq!(labels[1], \"name\");\n            assert_eq!(labels[2], \"birth\");\n\n            for r in rows.iter() {\n                assert_ne!(r[1], Value::Str(\"Super\".to_owned()));\n            }\n        }\n        _ =\u003e unreachable!(),\n    }\n\n    let _: Vec\u003cPayload\u003e = glue\n        .execute(\"SELECT id, name, birth FROM Heroes WHERE id = '2';\")\n        .await\n        .unwrap();\n\n    exec!(glue \"DROP TABLE Heroes;\");\n}\n\n#[tokio::test]\nasync fn redis_storage_primarykey() {\n    use {\n        chrono::NaiveDate,\n        gluesql_core::prelude::{Glue, Payload, Value},\n    };\n\n    let mut path = env::current_dir().unwrap();\n    path.push(\"tests/redis-storage.toml\");\n    let redis_config_str = fs::read_to_string(path).unwrap();\n    let redis_config: toml::Value = toml::from_str(\u0026redis_config_str).unwrap();\n    let url = redis_config[\"redis\"][\"url\"].as_str().unwrap();\n    let port: u16 = redis_config[\"redis\"][\"port\"].as_integer().unwrap() as u16;\n\n    let storage = RedisStorage::new(\"redis_storage_primarykey\", url, port);\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"DROP TABLE IF EXISTS Heroes;\");\n    exec!(glue \"CREATE TABLE Heroes (name TEXT PRIMARY KEY, birth DATE);\");\n\n    // INSERT with PRIMARY KEY will test the insert_data method\n    // Any type can be the PRIMARY KEY\n    exec!(glue r#\"INSERT INTO Heroes (name, birth) values ('Superman', '2023-12-31');\"#);\n    exec!(glue r#\"INSERT INTO Heroes (name, birth) values ('Batman', '2011-12-31');\"#);\n\n    // SELECT with PRIMARY KEY will test the fetch_data method\n    let ret: Vec\u003cPayload\u003e = glue\n        .execute(\"SELECT name, birth FROM Heroes;\")\n        .await\n        .unwrap();\n    match \u0026ret[0] {\n        Payload::Select { labels, rows } =\u003e {\n            assert_eq!(labels[0], \"name\");\n            assert_eq!(labels[1], \"birth\");\n\n            assert_eq!(rows.len(), 2);\n        }\n        _ =\u003e unreachable!(),\n    }\n\n    exec!(glue r#\"DELETE FROM Heroes WHERE name = 'Superman';\"#);\n\n    let ret: Vec\u003cPayload\u003e = glue\n        .execute(\"SELECT name, birth FROM Heroes;\")\n        .await\n        .unwrap();\n    match \u0026ret[0] {\n        Payload::Select { labels, rows } =\u003e {\n            assert_eq!(labels[0], \"name\");\n            assert_eq!(labels[1], \"birth\");\n\n            assert_eq!(rows.len(), 1);\n\n            assert_eq!(rows[0][0], Value::Str(\"Batman\".to_owned()));\n            assert_eq!(\n                rows[0][1],\n                Value::Date(NaiveDate::from_ymd_opt(2011, 12, 31).unwrap())\n            );\n        }\n        _ =\u003e unreachable!(),\n    }\n\n    exec!(glue \"DROP TABLE Heroes;\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","redis-storage","tests","redis_table.rs"],"content":"#![cfg(feature = \"test-redis\")]\n\nuse {\n    gluesql_core::prelude::{Glue, Payload, Value},\n    gluesql_redis_storage::RedisStorage,\n    std::{env, fs},\n};\n\nmacro_rules! exec {\n    ($glue: ident $sql: literal) =\u003e {\n        $glue.execute($sql).await.unwrap();\n    };\n}\n\n/// MUST run redis locally before test\n/// eg.) docker run --rm -p 6379:6379 redis\n#[tokio::test]\nasync fn redis_storage_tables() {\n    use chrono::NaiveDate;\n\n    let mut path = env::current_dir().unwrap();\n    path.push(\"tests/redis-storage.toml\");\n    let redis_config_str = fs::read_to_string(path).unwrap();\n    let redis_config: toml::Value = toml::from_str(\u0026redis_config_str).unwrap();\n    let url = redis_config[\"redis\"][\"url\"].as_str().unwrap();\n    let port: u16 = redis_config[\"redis\"][\"port\"].as_integer().unwrap() as u16;\n\n    let storage = RedisStorage::new(\"redis_storage_tables\", url, port);\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"DROP TABLE IF EXISTS DC;\");\n    exec!(glue \"DROP TABLE IF EXISTS Marvels;\");\n\n    exec!(glue \"CREATE TABLE DC (id INTEGER, name TEXT, birth DATE);\");\n    exec!(glue r#\"INSERT INTO DC (id, name, birth) values (1, 'Superman', '2023-12-31');\"#);\n    exec!(glue r#\"INSERT INTO DC (id, name, birth) values (2, 'Flash', '2011-12-31');\"#);\n\n    exec!(glue \"CREATE TABLE Marvels (id INTEGER, name TEXT);\");\n    exec!(glue r#\"INSERT INTO Marvels (id, name) values (1, 'Ironman');\"#);\n    exec!(glue r#\"INSERT INTO Marvels (id, name) values (2, 'Wanda');\"#);\n\n    let ret: Vec\u003cPayload\u003e = glue\n        .execute(\"SELECT id, name FROM Marvels WHERE name = 'Wanda';\")\n        .await\n        .unwrap();\n    match \u0026ret[0] {\n        Payload::Select { labels, rows } =\u003e {\n            assert_eq!(labels[0], \"id\");\n            assert_eq!(labels[1], \"name\");\n\n            assert_eq!(rows[0][0], Value::I64(2));\n            assert_eq!(rows[0][1], Value::Str(\"Wanda\".to_owned()));\n        }\n        _ =\u003e unreachable!(),\n    }\n\n    exec!(glue \"DROP TABLE Marvels;\");\n    assert!(glue.execute(\"SELECT id, name FROM Marvels;\").await.is_err());\n\n    let ret: Vec\u003cPayload\u003e = glue\n        .execute(\"SELECT id, name, birth FROM DC WHERE name = 'Superman';\")\n        .await\n        .unwrap();\n    match \u0026ret[0] {\n        Payload::Select { labels, rows } =\u003e {\n            assert_eq!(labels[0], \"id\");\n            assert_eq!(labels[1], \"name\");\n            assert_eq!(labels[2], \"birth\");\n\n            assert_eq!(rows[0][0], Value::I64(1));\n            assert_eq!(rows[0][1], Value::Str(\"Superman\".to_owned()));\n            assert_eq!(\n                rows[0][2],\n                Value::Date(NaiveDate::from_ymd_opt(2023, 12, 31).unwrap())\n            );\n        }\n        _ =\u003e unreachable!(),\n    }\n\n    exec!(glue \"DROP TABLE DC;\");\n}\n\n#[tokio::test]\nasync fn redis_storage_add_column() {\n    let mut path = env::current_dir().unwrap();\n    path.push(\"tests/redis-storage.toml\");\n    let redis_config_str = fs::read_to_string(path).unwrap();\n    let redis_config: toml::Value = toml::from_str(\u0026redis_config_str).unwrap();\n    let url = redis_config[\"redis\"][\"url\"].as_str().unwrap();\n    let port: u16 = redis_config[\"redis\"][\"port\"].as_integer().unwrap() as u16;\n\n    let storage = RedisStorage::new(\"redis_storage_add_column\", url, port);\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"CREATE TABLE dummy (id INTEGER PRIMARY KEY);\");\n    exec!(glue \"INSERT INTO dummy (id) values (1)\");\n    exec!(glue \"INSERT INTO dummy (id) values (11)\");\n    exec!(glue \"ALTER TABLE dummy ADD newcol TEXT\");\n\n    let ret: Vec\u003cPayload\u003e = glue.execute(\"SELECT id, newcol FROM dummy;\").await.unwrap();\n    match \u0026ret[0] {\n        Payload::Select { labels, rows } =\u003e {\n            assert_eq!(labels[0], \"id\");\n            assert_eq!(labels[1], \"newcol\");\n            assert_eq!(rows[0][0], Value::I64(1));\n            assert_eq!(rows[0][1], Value::Null);\n            assert_eq!(rows[1][0], Value::I64(11));\n            assert_eq!(rows[0][1], Value::Null);\n        }\n        _ =\u003e unreachable!(),\n    }\n\n    exec!(glue \"DROP TABLE dummy;\");\n\n    // TABLE dummy was dropped.\n    // It should be able to create the same namespace again.\n    let storage = RedisStorage::new(\"redis_Storage_add_column\", url, port);\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"CREATE TABLE dummy (id INTEGER);\");\n    exec!(glue \"INSERT INTO dummy (id) values (1)\");\n    exec!(glue \"INSERT INTO dummy (id) values (11)\");\n    exec!(glue \"ALTER TABLE dummy ADD newcol TEXT\");\n\n    let ret: Vec\u003cPayload\u003e = glue.execute(\"SELECT id, newcol FROM dummy;\").await.unwrap();\n    match \u0026ret[0] {\n        Payload::Select { labels, rows } =\u003e {\n            assert_eq!(labels[0], \"id\");\n            assert_eq!(labels[1], \"newcol\");\n            assert_eq!(rows[0][0], Value::I64(1));\n            assert_eq!(rows[0][1], Value::Null);\n            assert_eq!(rows[1][0], Value::I64(11));\n            assert_eq!(rows[0][1], Value::Null);\n        }\n        _ =\u003e unreachable!(),\n    }\n\n    exec!(glue \"DROP TABLE dummy;\");\n}\n\n#[tokio::test]\nasync fn redis_storage_drop_column() {\n    let mut path = env::current_dir().unwrap();\n    path.push(\"tests/redis-storage.toml\");\n    let redis_config_str = fs::read_to_string(path).unwrap();\n    let redis_config: toml::Value = toml::from_str(\u0026redis_config_str).unwrap();\n    let url = redis_config[\"redis\"][\"url\"].as_str().unwrap();\n    let port: u16 = redis_config[\"redis\"][\"port\"].as_integer().unwrap() as u16;\n\n    let storage = RedisStorage::new(\"redis_storage_drop_column\", url, port);\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"CREATE TABLE dummy (id INTEGER PRIMARY KEY, name TEXT);\");\n    exec!(glue r#\"INSERT INTO dummy (id, name) values (1, 'Superman');\"#);\n    exec!(glue r#\"INSERT INTO dummy (id, name) values (11, 'Batman');\"#);\n    exec!(glue \"ALTER TABLE dummy DROP COLUMN name\");\n\n    let ret: Vec\u003cPayload\u003e = glue.execute(\"SELECT * FROM dummy;\").await.unwrap();\n    match \u0026ret[0] {\n        Payload::Select { labels, rows } =\u003e {\n            assert_eq!(labels[0], \"id\");\n            assert_eq!(rows[0].len(), 1);\n            assert_eq!(rows[1].len(), 1);\n            assert_eq!(rows[0][0], Value::I64(1));\n            assert_eq!(rows[1][0], Value::I64(11));\n        }\n        _ =\u003e unreachable!(),\n    }\n\n    exec!(glue \"DROP TABLE dummy;\");\n\n    // TABLE dummy was dropped.\n    // It should be able to create the same namespace again.\n    let storage = RedisStorage::new(\"redis_storage_drop_column\", url, port);\n    let mut glue = Glue::new(storage);\n\n    // Second test without PRIMARY KEY\n    exec!(glue \"CREATE TABLE dummy (id INTEGER, name TEXT);\");\n    exec!(glue r#\"INSERT INTO dummy (id, name) values (1, 'Superman');\"#);\n    exec!(glue r#\"INSERT INTO dummy (id, name) values (11, 'Batman');\"#);\n    exec!(glue \"ALTER TABLE dummy DROP COLUMN name\");\n\n    let ret: Vec\u003cPayload\u003e = glue.execute(\"SELECT * FROM dummy;\").await.unwrap();\n    match \u0026ret[0] {\n        Payload::Select { labels, rows } =\u003e {\n            assert_eq!(labels[0], \"id\");\n            assert_eq!(rows[0].len(), 1);\n            assert_eq!(rows[1].len(), 1);\n            assert_eq!(rows[0][0], Value::I64(1));\n            assert_eq!(rows[1][0], Value::I64(11));\n        }\n        _ =\u003e unreachable!(),\n    }\n\n    exec!(glue \"DROP TABLE dummy;\");\n}\n\n#[tokio::test]\nasync fn redis_storage_alter_tablename() {\n    let mut path = env::current_dir().unwrap();\n    path.push(\"tests/redis-storage.toml\");\n    let redis_config_str = fs::read_to_string(path).unwrap();\n    let redis_config: toml::Value = toml::from_str(\u0026redis_config_str).unwrap();\n    let url = redis_config[\"redis\"][\"url\"].as_str().unwrap();\n    let port: u16 = redis_config[\"redis\"][\"port\"].as_integer().unwrap() as u16;\n\n    let storage = RedisStorage::new(\"redis_storage_alter_tablename\", url, port);\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"CREATE TABLE dummy (id INTEGER PRIMARY KEY);\");\n    exec!(glue \"INSERT INTO dummy (id) values (1)\");\n    exec!(glue \"INSERT INTO dummy (id) values (11)\");\n    exec!(glue \"ALTER TABLE dummy RENAME TO dumdum\");\n\n    let ret = glue.execute(\"SELECT * FROM dummy;\").await;\n    assert!(ret.is_err());\n\n    let ret: Vec\u003cPayload\u003e = glue.execute(\"SELECT * FROM dumdum;\").await.unwrap();\n    match \u0026ret[0] {\n        Payload::Select { labels, rows } =\u003e {\n            assert_eq!(labels[0], \"id\");\n            assert_eq!(rows[0].len(), 1);\n            assert_eq!(rows[1].len(), 1);\n            assert_eq!(rows[0][0], Value::I64(1));\n            assert_eq!(rows[1][0], Value::I64(11));\n        }\n        _ =\u003e unreachable!(),\n    }\n\n    exec!(glue \"DROP TABLE dumdum;\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","shared-memory-storage","src","alter_table.rs"],"content":"use {\n    super::SharedMemoryStorage,\n    async_trait::async_trait,\n    gluesql_core::{ast::ColumnDef, error::Result, store::AlterTable},\n    std::sync::Arc,\n};\n\n#[async_trait(?Send)]\nimpl AlterTable for SharedMemoryStorage {\n    async fn rename_schema(\u0026mut self, table_name: \u0026str, new_table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let database = Arc::clone(\u0026self.database);\n        let mut database = database.write().await;\n\n        database.rename_schema(table_name, new_table_name).await\n    }\n\n    async fn rename_column(\n        \u0026mut self,\n        table_name: \u0026str,\n        old_column_name: \u0026str,\n        new_column_name: \u0026str,\n    ) -\u003e Result\u003c()\u003e {\n        let database = Arc::clone(\u0026self.database);\n        let mut database = database.write().await;\n\n        database\n            .rename_column(table_name, old_column_name, new_column_name)\n            .await\n    }\n\n    async fn add_column(\u0026mut self, table_name: \u0026str, column_def: \u0026ColumnDef) -\u003e Result\u003c()\u003e {\n        let database = Arc::clone(\u0026self.database);\n        let mut database = database.write().await;\n\n        database.add_column(table_name, column_def).await\n    }\n\n    async fn drop_column(\n        \u0026mut self,\n        table_name: \u0026str,\n        column_name: \u0026str,\n        if_exists: bool,\n    ) -\u003e Result\u003c()\u003e {\n        let database = Arc::clone(\u0026self.database);\n        let mut database = database.write().await;\n\n        database\n            .drop_column(table_name, column_name, if_exists)\n            .await\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","shared-memory-storage","src","index.rs"],"content":"use {\n    super::SharedMemoryStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        ast::{IndexOperator, OrderByExpr},\n        data::Value,\n        error::{Error, Result},\n        store::{Index, IndexMut, RowIter},\n    },\n};\n\n#[async_trait(?Send)]\nimpl Index for SharedMemoryStorage {\n    async fn scan_indexed_data\u003c'a\u003e(\n        \u0026'a self,\n        _table_name: \u0026str,\n        _index_name: \u0026str,\n        _asc: Option\u003cbool\u003e,\n        _cmp_value: Option\u003c(\u0026IndexOperator, Value)\u003e,\n    ) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        Err(Error::StorageMsg(\n            \"[Shared MemoryStorage] index is not supported\".to_owned(),\n        ))\n    }\n}\n\n#[async_trait(?Send)]\nimpl IndexMut for SharedMemoryStorage {\n    async fn create_index(\n        \u0026mut self,\n        _table_name: \u0026str,\n        _index_name: \u0026str,\n        _column: \u0026OrderByExpr,\n    ) -\u003e Result\u003c()\u003e {\n        Err(Error::StorageMsg(\n            \"[Shared MemoryStorage] index is not supported\".to_owned(),\n        ))\n    }\n\n    async fn drop_index(\u0026mut self, _table_name: \u0026str, _index_name: \u0026str) -\u003e Result\u003c()\u003e {\n        Err(Error::StorageMsg(\n            \"[Shared MemoryStorage] index is not supported\".to_owned(),\n        ))\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","shared-memory-storage","src","lib.rs"],"content":"#![deny(clippy::str_to_string)]\n\nmod alter_table;\nmod index;\nmod transaction;\n\nuse {\n    async_trait::async_trait,\n    futures::stream,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::Result,\n        store::{DataRow, Metadata, RowIter, Store, StoreMut},\n    },\n    gluesql_memory_storage::MemoryStorage,\n    std::sync::Arc,\n    tokio::sync::RwLock,\n};\n\n#[derive(Clone, Debug)]\npub struct SharedMemoryStorage {\n    pub database: Arc\u003cRwLock\u003cMemoryStorage\u003e\u003e,\n}\n\nimpl SharedMemoryStorage {\n    pub fn new() -\u003e Self {\n        let database = MemoryStorage::default();\n        let database = Arc::new(RwLock::new(database));\n\n        Self { database }\n    }\n}\n\nimpl Default for SharedMemoryStorage {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl From\u003cMemoryStorage\u003e for SharedMemoryStorage {\n    fn from(storage: MemoryStorage) -\u003e Self {\n        let database = Arc::new(RwLock::new(storage));\n        Self { database }\n    }\n}\n\n#[async_trait(?Send)]\nimpl Store for SharedMemoryStorage {\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let database = Arc::clone(\u0026self.database);\n        let database = database.read().await;\n\n        database.fetch_all_schemas().await\n    }\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        let database = Arc::clone(\u0026self.database);\n        let database = database.read().await;\n\n        database.fetch_schema(table_name).await\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, key: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        let database = Arc::clone(\u0026self.database);\n        let database = database.read().await;\n\n        database.fetch_data(table_name, key).await\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        let rows = self\n            .database\n            .read()\n            .await\n            .scan_data(table_name)\n            .into_iter()\n            .map(Ok);\n\n        Ok(Box::pin(stream::iter(rows)))\n    }\n}\n\n#[async_trait(?Send)]\nimpl StoreMut for SharedMemoryStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let database = Arc::clone(\u0026self.database);\n        let mut database = database.write().await;\n\n        database.insert_schema(schema).await\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let database = Arc::clone(\u0026self.database);\n        let mut database = database.write().await;\n\n        database.delete_schema(table_name).await\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let database = Arc::clone(\u0026self.database);\n        let mut database = database.write().await;\n\n        database.append_data(table_name, rows).await\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        let database = Arc::clone(\u0026self.database);\n        let mut database = database.write().await;\n\n        database.insert_data(table_name, rows).await\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        let database = Arc::clone(\u0026self.database);\n        let mut database = database.write().await;\n\n        database.delete_data(table_name, keys).await\n    }\n}\n\nimpl Metadata for SharedMemoryStorage {}\nimpl gluesql_core::store::CustomFunction for SharedMemoryStorage {}\nimpl gluesql_core::store::CustomFunctionMut for SharedMemoryStorage {}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","shared-memory-storage","src","transaction.rs"],"content":"use {\n    super::SharedMemoryStorage,\n    async_trait::async_trait,\n    gluesql_core::{\n        error::{Error, Result},\n        store::Transaction,\n    },\n};\n\n#[async_trait(?Send)]\nimpl Transaction for SharedMemoryStorage {\n    async fn begin(\u0026mut self, autocommit: bool) -\u003e Result\u003cbool\u003e {\n        if autocommit {\n            return Ok(false);\n        }\n\n        Err(Error::StorageMsg(\n            \"[Shared MemoryStorage] transaction is not supported\".to_owned(),\n        ))\n    }\n\n    async fn rollback(\u0026mut self) -\u003e Result\u003c()\u003e {\n        Err(Error::StorageMsg(\n            \"[Shared MemoryStorage] transaction is not supported\".to_owned(),\n        ))\n    }\n\n    async fn commit(\u0026mut self) -\u003e Result\u003c()\u003e {\n        Err(Error::StorageMsg(\n            \"[Shared MemoryStorage] transaction is not supported\".to_owned(),\n        ))\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","shared-memory-storage","tests","concurrent_access.rs"],"content":"use {\n    futures::executor::block_on,\n    gluesql_core::prelude::{Glue, Payload, Value},\n    gluesql_shared_memory_storage::SharedMemoryStorage,\n};\n\n#[tokio::test]\nasync fn concurrent_access() {\n    let storage = SharedMemoryStorage::new();\n\n    let mut glue = Glue::new(storage.clone());\n    glue.execute(\"CREATE TABLE Thread (id INTEGER);\")\n        .await\n        .unwrap();\n\n    let thread_1 = tokio::spawn({\n        // Arc::clone\n        let storage = storage.clone();\n        async {\n            let mut glue = Glue::new(storage);\n            block_on(glue.execute(\"INSERT INTO Thread VALUES(1)\")).unwrap();\n        }\n    });\n\n    let thread_2 = tokio::spawn({\n        // Arc::clone\n        let storage = storage.clone();\n        async {\n            let mut glue = Glue::new(storage);\n            block_on(glue.execute(\"INSERT INTO Thread VALUES(2)\")).unwrap();\n        }\n    });\n\n    let _ = tokio::join!(thread_1, thread_2);\n\n    let actual = glue.execute(\"SELECT * FROM Thread\").await.unwrap();\n    let expected = vec![Payload::Select {\n        labels: vec![\"id\".to_owned()],\n        rows: vec![vec![Value::I64(1)], vec![Value::I64(2)]],\n    }];\n    assert_eq!(actual, expected);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","shared-memory-storage","tests","shared_memory_storage.rs"],"content":"use {\n    async_trait::async_trait, futures::stream::TryStreamExt, gluesql_core::prelude::Glue,\n    gluesql_shared_memory_storage::SharedMemoryStorage, test_suite::*,\n};\n\nstruct SharedMemoryTester {\n    glue: Glue\u003cSharedMemoryStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cSharedMemoryStorage\u003e for SharedMemoryTester {\n    async fn new(_: \u0026str) -\u003e Self {\n        let storage = SharedMemoryStorage::new();\n        let glue = Glue::new(storage);\n\n        SharedMemoryTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cSharedMemoryStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(tokio::test, SharedMemoryTester);\n\ngenerate_alter_table_tests!(tokio::test, SharedMemoryTester);\n\nmacro_rules! exec {\n    ($glue: ident $sql: literal) =\u003e {\n        $glue.execute($sql).await.unwrap();\n    };\n}\n\nmacro_rules! test {\n    ($glue: ident $sql: literal, $result: expr) =\u003e {\n        assert_eq!($glue.execute($sql).await, $result);\n    };\n}\n\n#[tokio::test]\nasync fn shared_memory_storage_index() {\n    use gluesql_core::{\n        error::Error,\n        prelude::Glue,\n        store::{Index, Store},\n    };\n\n    let storage = SharedMemoryStorage::new();\n\n    assert_eq!(\n        storage\n            .scan_data(\"Idx\")\n            .await\n            .unwrap()\n            .try_collect::\u003cVec\u003c_\u003e\u003e()\n            .await\n            .as_ref()\n            .map(Vec::len),\n        Ok(0),\n    );\n\n    assert_eq!(\n        storage\n            .scan_indexed_data(\"Idx\", \"hello\", None, None)\n            .await\n            .map(|_| ()),\n        Err(Error::StorageMsg(\n            \"[Shared MemoryStorage] index is not supported\".to_owned()\n        ))\n    );\n\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"CREATE TABLE Idx (id INTEGER);\");\n    test!(\n        glue \"CREATE INDEX idx_id ON Idx (id);\",\n        Err(Error::StorageMsg(\"[Shared MemoryStorage] index is not supported\".to_owned()))\n    );\n    test!(\n        glue \"DROP INDEX Idx.idx_id;\",\n        Err(Error::StorageMsg(\"[Shared MemoryStorage] index is not supported\".to_owned()))\n    );\n}\n\n#[tokio::test]\nasync fn shared_memory_storage_transaction() {\n    use gluesql_core::{error::Error, prelude::Glue};\n\n    let storage = SharedMemoryStorage::new();\n    let mut glue = Glue::new(storage);\n\n    exec!(glue \"CREATE TABLE TxTest (id INTEGER);\");\n    test!(glue \"BEGIN\", Err(Error::StorageMsg(\"[Shared MemoryStorage] transaction is not supported\".to_owned())));\n    test!(glue \"COMMIT\", Err(Error::StorageMsg(\"[Shared MemoryStorage] transaction is not supported\".to_owned())));\n    test!(glue \"ROLLBACK\", Err(Error::StorageMsg(\"[Shared MemoryStorage] transaction is not supported\".to_owned())));\n}\n\n#[tokio::test]\nasync fn shared_memory_storage_function() {\n    use gluesql_core::error::Error;\n\n    let storage = SharedMemoryStorage::new();\n    let mut glue = Glue::new(storage);\n\n    test!(\n        glue \"CREATE FUNCTION abc() RETURN 1;\",\n        Err(Error::StorageMsg(\"[Storage] CustomFunction is not supported\".to_owned()))\n    );\n    test!(\n        glue \"SELECT abc();\",\n        Err(Error::StorageMsg(\"[Storage] CustomFunction is not supported\".to_owned()))\n    );\n    test!(\n        glue \"DROP FUNCTION abc;\",\n        Err(Error::StorageMsg(\"[Storage] CustomFunction is not supported\".to_owned()))\n    );\n    test!(\n        glue \"SHOW FUNCTIONS;\",\n        Err(Error::StorageMsg(\"[Storage] CustomFunction is not supported\".to_owned()))\n    );\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","benches","sled_benchmark.rs"],"content":"use {\n    criterion::{Criterion, criterion_group, criterion_main},\n    futures::executor::block_on,\n    gluesql_core::prelude::Glue,\n    gluesql_sled_storage::SledStorage,\n};\n\nconst ITEM_SIZE: u32 = 5000;\n\n// Generate benchmark tests\npub fn bench_insert(c: \u0026mut Criterion) {\n    // Generate a new database\n    let path = \"data/bench_insert\";\n\n    // Silently ignore, 99% of the time this will already be removed\n    let _ = std::fs::remove_dir_all(path);\n\n    let config = sled::Config::default()\n        .path(path)\n        .temporary(true)\n        .mode(sled::Mode::HighThroughput);\n\n    let storage = SledStorage::try_from(config).unwrap();\n    let mut glue = Glue::new(storage);\n    // Create a dummy table\n    let sqls = \"\n        CREATE TABLE Testing (\n            id INTEGER,\n            field_one TEXT,\n            field_two TEXT,\n            field_three TEXT\n        );\n    \";\n\n    block_on(glue.execute(sqls)).unwrap();\n\n    // Prepare query out of scope, and copy it at the beginning\n    let mut id = 0;\n\n    c.bench_function(\"insert_one\", |b| {\n        b.iter(|| {\n            let query_str = format!(\n                \"INSERT INTO Testing \n                 VALUES ({:#}, 'Testing 1', 'Testing 2', 'Testing 3');\",\n                \u0026id\n            );\n            id += 1;\n\n            block_on(glue.execute(\u0026query_str)).unwrap();\n        })\n    });\n}\n\npub fn bench_select(c: \u0026mut Criterion) {\n    // Generate a new database\n    let path = \"data/bench_select\";\n\n    // Silently ignore, 99% of the time this will already be removed\n    let _ = std::fs::remove_dir_all(path);\n\n    let config = sled::Config::default()\n        .path(path)\n        .temporary(true)\n        .mode(sled::Mode::HighThroughput);\n\n    let storage = SledStorage::try_from(config).unwrap();\n    let mut glue = Glue::new(storage);\n    // Create a dummy table\n    {\n        let mut sqls: String = \"\n        CREATE TABLE Testing (\n            id INTEGER,\n            field_one TEXT,\n            field_two TEXT,\n            field_three TEXT\n        );\"\n        .to_owned();\n\n        for i in 0..ITEM_SIZE {\n            sqls += \u0026*format!(\n                \"INSERT INTO Testing\n                 VALUES ({:#}, 'Testing 1', 'Testing 2', 'Testing 3');\",\n                \u0026i\n            );\n        }\n\n        block_on(glue.execute(\u0026sqls)).unwrap();\n    }\n\n    // Prepare query out of scope, and copy it at the beginning\n    let mut id = 0;\n\n    c.bench_function(\"select_one\", |b| {\n        b.iter(|| {\n            let query_str = format!(\"SELECT * FROM Testing WHERE id = {}\", id);\n\n            id += 1;\n            if id \u003e= ITEM_SIZE {\n                id = 1;\n            }\n\n            block_on(glue.execute(\u0026query_str)).unwrap();\n        })\n    });\n\n    c.bench_function(\"select_many\", |b| {\n        b.iter(|| {\n            let query_str = format!(\n                \"SELECT * FROM Testing WHERE id \u003e {} AND id \u003c {}\",\n                id,\n                id + 50\n            );\n\n            id += 1;\n            if id \u003e= ITEM_SIZE {\n                id = 1;\n            }\n\n            block_on(glue.execute(\u0026query_str)).unwrap();\n        })\n    });\n}\n\npub fn bench_select_tainted(c: \u0026mut Criterion) {\n    // Generate a new database\n    let path = \"data/bench_select_tainted\";\n\n    // Silently ignore, 99% of the time this will already be removed\n    let _ = std::fs::remove_dir_all(path);\n\n    let config = sled::Config::default()\n        .path(path)\n        .temporary(true)\n        .mode(sled::Mode::HighThroughput);\n\n    let storage = SledStorage::try_from(config).unwrap();\n    let mut glue = Glue::new(storage);\n    // Create a dummy table\n    {\n        let mut sqls: String = \"\n        CREATE TABLE Testing (\n            id INTEGER,\n            field_one TEXT,\n            field_two TEXT,\n            field_three TEXT\n        );\n        CREATE TABLE TestingTainted (\n            id INTEGER,\n            field_one TEXT,\n            field_two TEXT,\n            field_three TEXT\n        );\n        \"\n        .to_owned();\n\n        for i in 0..ITEM_SIZE {\n            sqls += \u0026*format!(\n                \"INSERT INTO Testing\n                 VALUES ({0:#}, 'Testing 1', 'Testing 2', 'Testing 3');\n                 INSERT INTO TestingTainted\n                 VALUES ({0:#}, 'Testing_tainted 1', 'Testing_tainted 2', 'Testing_tainted 3');\",\n                \u0026i\n            );\n        }\n\n        block_on(glue.execute(\u0026sqls)).unwrap();\n    }\n\n    // Prepare query out of scope, and copy it at the beginning\n    let mut id = 0;\n\n    c.bench_function(\"select_one_tainted\", |b| {\n        b.iter(|| {\n            let query_str = format!(\"SELECT * FROM Testing WHERE id = {}\", id);\n\n            id += 1;\n            if id \u003e= ITEM_SIZE {\n                id = 1;\n            }\n\n            block_on(glue.execute(\u0026query_str)).unwrap();\n        })\n    });\n    c.bench_function(\"select_many_tainted\", |b| {\n        b.iter(|| {\n            let query_str = format!(\n                \"SELECT * FROM Testing WHERE id \u003e {} AND id \u003c {}\",\n                id,\n                id + 50\n            );\n\n            id += 1;\n            if id \u003e= ITEM_SIZE {\n                id = 1;\n            }\n\n            block_on(glue.execute(\u0026query_str)).unwrap();\n        })\n    });\n}\n\ncriterion_group!(benches, bench_insert, bench_select, bench_select_tainted);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","alter_table.rs"],"content":"use {\n    super::{\n        SledStorage, Snapshot,\n        error::err_into,\n        fetch_schema, key,\n        lock::{self, LockAcquired},\n        transaction::TxPayload,\n    },\n    async_io::block_on,\n    async_trait::async_trait,\n    gluesql_core::{\n        ast::ColumnDef,\n        data::{Value, schema::Schema},\n        error::{AlterTableError, Error, Result},\n        executor::evaluate_stateless,\n        store::{AlterTable, DataRow},\n    },\n    sled::transaction::ConflictableTransactionError,\n    std::{iter::once, str},\n    utils::Vector,\n};\n\n#[async_trait(?Send)]\nimpl AlterTable for SledStorage {\n    async fn rename_schema(\u0026mut self, table_name: \u0026str, new_table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let prefix = format!(\"data/{}/\", table_name);\n        let items = self\n            .tree\n            .scan_prefix(prefix.as_bytes())\n            .map(|item| item.map_err(err_into))\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        let state = \u0026self.state;\n        let tx_timeout = self.tx_timeout;\n        let tx_result = self.tree.transaction(move |tree| {\n            let (txid, autocommit) = match lock::acquire(tree, state, tx_timeout)? {\n                LockAcquired::Success { txid, autocommit } =\u003e (txid, autocommit),\n                LockAcquired::RollbackAndRetry { lock_txid } =\u003e {\n                    return Ok(TxPayload::RollbackAndRetry(lock_txid));\n                }\n            };\n\n            let (old_schema_key, schema_snapshot) = fetch_schema(tree, table_name)?;\n            let schema_snapshot = schema_snapshot\n                .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            // remove existing schema\n            let (old_snapshot, old_schema) = schema_snapshot.delete(txid);\n            let Schema {\n                column_defs,\n                indexes,\n                engine,\n                foreign_keys,\n                comment,\n                ..\n            } = old_schema\n                .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let new_schema = Schema {\n                table_name: new_table_name.to_owned(),\n                column_defs,\n                indexes,\n                engine,\n                foreign_keys,\n                comment,\n            };\n\n            bincode::serialize(\u0026old_snapshot)\n                .map_err(err_into)\n                .map_err(ConflictableTransactionError::Abort)\n                .map(|snapshot| tree.insert(old_schema_key.as_bytes(), snapshot))??;\n\n            // insert new schema\n            let new_snapshot = Snapshot::\u003cSchema\u003e::new(txid, new_schema);\n            let value = bincode::serialize(\u0026new_snapshot)\n                .map_err(err_into)\n                .map_err(ConflictableTransactionError::Abort)?;\n            let new_schema_key = format!(\"schema/{}\", new_table_name);\n            tree.insert(new_schema_key.as_bytes(), value)?;\n\n            // replace data\n            for (old_key, value) in items.iter() {\n                let new_key = str::from_utf8(old_key.as_ref())\n                    .map_err(err_into)\n                    .map_err(ConflictableTransactionError::Abort)?;\n                let new_key = new_key.replace(table_name, new_table_name);\n\n                let old_row_snapshot: Snapshot\u003cDataRow\u003e = bincode::deserialize(value)\n                    .map_err(err_into)\n                    .map_err(ConflictableTransactionError::Abort)?;\n\n                let (old_row_snapshot, row) = old_row_snapshot.delete(txid);\n                let row = match row {\n                    Some(row) =\u003e row,\n                    None =\u003e {\n                        continue;\n                    }\n                };\n\n                let old_row_snapshot = bincode::serialize(\u0026old_row_snapshot)\n                    .map_err(err_into)\n                    .map_err(ConflictableTransactionError::Abort)?;\n\n                let new_row_snapshot = Snapshot::\u003cDataRow\u003e::new(txid, row);\n                let new_row_snapshot = bincode::serialize(\u0026new_row_snapshot)\n                    .map_err(err_into)\n                    .map_err(ConflictableTransactionError::Abort)?;\n\n                tree.insert(old_key, old_row_snapshot)?;\n                tree.insert(new_key.as_bytes(), new_row_snapshot)?;\n\n                if !autocommit {\n                    let temp_old_key = key::temp_data(txid, old_key);\n                    let temp_new_key = key::temp_data_str(txid, \u0026new_key);\n\n                    tree.insert(temp_old_key, old_key)?;\n                    tree.insert(temp_new_key, new_key.as_bytes())?;\n                }\n            }\n\n            if !autocommit {\n                let temp_old_key = key::temp_schema(txid, table_name);\n                let temp_new_key = key::temp_schema(txid, new_table_name);\n\n                tree.insert(temp_old_key, old_schema_key.as_bytes())?;\n                tree.insert(temp_new_key, new_schema_key.as_bytes())?;\n            }\n\n            Ok(TxPayload::Success)\n        });\n\n        if self.check_retry(tx_result)? {\n            self.rename_schema(table_name, new_table_name).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn rename_column(\n        \u0026mut self,\n        table_name: \u0026str,\n        old_column_name: \u0026str,\n        new_column_name: \u0026str,\n    ) -\u003e Result\u003c()\u003e {\n        let state = \u0026self.state;\n        let tx_timeout = self.tx_timeout;\n        let tx_result = self.tree.transaction(move |tree| {\n            let (txid, autocommit) = match lock::acquire(tree, state, tx_timeout)? {\n                LockAcquired::Success { txid, autocommit } =\u003e (txid, autocommit),\n                LockAcquired::RollbackAndRetry { lock_txid } =\u003e {\n                    return Ok(TxPayload::RollbackAndRetry(lock_txid));\n                }\n            };\n\n            let (schema_key, snapshot) = fetch_schema(tree, table_name)?;\n            let snapshot = snapshot\n                .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let Schema {\n                column_defs,\n                indexes,\n                engine,\n                foreign_keys,\n                comment: schema_comment,\n                ..\n            } = snapshot\n                .get(txid, None)\n                .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let column_defs = column_defs\n                .ok_or_else(|| AlterTableError::SchemalessTableFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            if column_defs\n                .iter()\n                .any(|ColumnDef { name, .. }| name == new_column_name)\n            {\n                return Err(ConflictableTransactionError::Abort(\n                    AlterTableError::AlreadyExistingColumn(new_column_name.to_owned()).into(),\n                ));\n            }\n\n            let i = column_defs\n                .iter()\n                .position(|column_def| column_def.name == old_column_name)\n                .ok_or_else(|| AlterTableError::RenamingColumnNotFound.into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let ColumnDef {\n                data_type,\n                nullable,\n                default,\n                unique,\n                comment,\n                ..\n            } = column_defs[i].clone();\n\n            let column_def = ColumnDef {\n                name: new_column_name.to_owned(),\n                data_type,\n                nullable,\n                default,\n                unique,\n                comment,\n            };\n            let column_defs = Vector::from(column_defs).update(i, column_def).into();\n\n            let schema = Schema {\n                table_name: table_name.to_owned(),\n                column_defs: Some(column_defs),\n                indexes,\n                engine,\n                foreign_keys,\n                comment: schema_comment,\n            };\n            let (snapshot, _) = snapshot.update(txid, schema);\n            let value = bincode::serialize(\u0026snapshot)\n                .map_err(err_into)\n                .map_err(ConflictableTransactionError::Abort)?;\n            tree.insert(schema_key.as_bytes(), value)?;\n\n            if !autocommit {\n                let temp_key = key::temp_schema(txid, table_name);\n\n                tree.insert(temp_key, schema_key.as_bytes())?;\n            }\n\n            Ok(TxPayload::Success)\n        });\n\n        if self.check_retry(tx_result)? {\n            self.rename_column(table_name, old_column_name, new_column_name)\n                .await?;\n        }\n\n        Ok(())\n    }\n\n    async fn add_column(\u0026mut self, table_name: \u0026str, column_def: \u0026ColumnDef) -\u003e Result\u003c()\u003e {\n        let prefix = format!(\"data/{}/\", table_name);\n        let items = self\n            .tree\n            .scan_prefix(prefix.as_bytes())\n            .map(|item| item.map_err(err_into))\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        let state = \u0026self.state;\n        let tx_timeout = self.tx_timeout;\n        let tx_result = self.tree.transaction(move |tree| {\n            let (txid, autocommit) = match lock::acquire(tree, state, tx_timeout)? {\n                LockAcquired::Success { txid, autocommit } =\u003e (txid, autocommit),\n                LockAcquired::RollbackAndRetry { lock_txid } =\u003e {\n                    return Ok(TxPayload::RollbackAndRetry(lock_txid));\n                }\n            };\n\n            let (schema_key, schema_snapshot) = fetch_schema(tree, table_name)?;\n            let schema_snapshot = schema_snapshot\n                .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let Schema {\n                table_name,\n                column_defs,\n                indexes,\n                engine,\n                foreign_keys,\n                comment,\n            } = schema_snapshot\n                .get(txid, None)\n                .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let column_defs = column_defs\n                .ok_or_else(|| AlterTableError::SchemalessTableFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            if column_defs\n                .iter()\n                .any(|ColumnDef { name, .. }| name == \u0026column_def.name)\n            {\n                let adding_column = column_def.name.to_owned();\n\n                return Err(ConflictableTransactionError::Abort(\n                    AlterTableError::AlreadyExistingColumn(adding_column).into(),\n                ));\n            }\n\n            let ColumnDef {\n                data_type,\n                nullable,\n                default,\n                ..\n            } = column_def;\n\n            let value = match (default, nullable) {\n                (Some(expr), _) =\u003e {\n                    let evaluated = block_on(evaluate_stateless(None, expr))\n                        .map_err(ConflictableTransactionError::Abort)?;\n\n                    evaluated\n                        .try_into_value(data_type, *nullable)\n                        .map_err(ConflictableTransactionError::Abort)?\n                }\n                (None, true) =\u003e Value::Null,\n                (None, false) =\u003e {\n                    return Err(ConflictableTransactionError::Abort(\n                        AlterTableError::DefaultValueRequired(column_def.clone()).into(),\n                    ));\n                }\n            };\n\n            // migrate data\n            for (key, snapshot) in items.iter() {\n                let snapshot: Snapshot\u003cDataRow\u003e = bincode::deserialize(snapshot)\n                    .map_err(err_into)\n                    .map_err(ConflictableTransactionError::Abort)?;\n                let row = match snapshot.clone().extract(txid, None) {\n                    Some(row) =\u003e row,\n                    None =\u003e {\n                        continue;\n                    }\n                };\n\n                let values = match row {\n                    DataRow::Vec(values) =\u003e values,\n                    DataRow::Map(_) =\u003e {\n                        return Err(ConflictableTransactionError::Abort(Error::StorageMsg(\n                            \"conflict - add_column failed: schemaless row found\".to_owned(),\n                        )));\n                    }\n                };\n                let row = values\n                    .into_iter()\n                    .chain(once(value.clone()))\n                    .collect::\u003cVec\u003cValue\u003e\u003e()\n                    .into();\n\n                let (snapshot, _) = snapshot.update(txid, row);\n                let snapshot = bincode::serialize(\u0026snapshot)\n                    .map_err(err_into)\n                    .map_err(ConflictableTransactionError::Abort)?;\n\n                tree.insert(key, snapshot)?;\n\n                if !autocommit {\n                    let temp_key = key::temp_data(txid, key);\n\n                    tree.insert(temp_key, key)?;\n                }\n            }\n\n            // update schema\n            let column_defs = column_defs\n                .into_iter()\n                .chain(once(column_def.clone()))\n                .collect::\u003cVec\u003cColumnDef\u003e\u003e();\n\n            let temp_key = key::temp_schema(txid, \u0026table_name);\n\n            let schema = Schema {\n                table_name,\n                column_defs: Some(column_defs),\n                indexes,\n                engine,\n                foreign_keys,\n                comment,\n            };\n            let (schema_snapshot, _) = schema_snapshot.update(txid, schema);\n            let schema_value = bincode::serialize(\u0026schema_snapshot)\n                .map_err(err_into)\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            tree.insert(schema_key.as_bytes(), schema_value)?;\n\n            if !autocommit {\n                tree.insert(temp_key, schema_key.as_bytes())?;\n            }\n\n            Ok(TxPayload::Success)\n        });\n\n        if self.check_retry(tx_result)? {\n            self.add_column(table_name, column_def).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn drop_column(\n        \u0026mut self,\n        table_name: \u0026str,\n        column_name: \u0026str,\n        if_exists: bool,\n    ) -\u003e Result\u003c()\u003e {\n        let prefix = format!(\"data/{}/\", table_name);\n        let items = self\n            .tree\n            .scan_prefix(prefix.as_bytes())\n            .map(|item| item.map_err(err_into))\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        let state = \u0026self.state;\n        let tx_timeout = self.tx_timeout;\n        let tx_result = self.tree.transaction(move |tree| {\n            let (txid, autocommit) = match lock::acquire(tree, state, tx_timeout)? {\n                LockAcquired::Success { txid, autocommit } =\u003e (txid, autocommit),\n                LockAcquired::RollbackAndRetry { lock_txid } =\u003e {\n                    return Ok(TxPayload::RollbackAndRetry(lock_txid));\n                }\n            };\n\n            let (schema_key, schema_snapshot) = fetch_schema(tree, table_name)?;\n            let schema_snapshot = schema_snapshot\n                .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let Schema {\n                table_name,\n                column_defs,\n                indexes,\n                engine,\n                foreign_keys,\n                comment,\n            } = schema_snapshot\n                .get(txid, None)\n                .ok_or_else(|| AlterTableError::TableNotFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let column_defs = column_defs\n                .ok_or_else(|| AlterTableError::SchemalessTableFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let column_index = column_defs\n                .iter()\n                .position(|ColumnDef { name, .. }| name == column_name);\n            let column_index = match (column_index, if_exists) {\n                (Some(index), _) =\u003e index,\n                (None, true) =\u003e {\n                    return Ok(TxPayload::Success);\n                }\n                (None, false) =\u003e {\n                    return Err(ConflictableTransactionError::Abort(\n                        AlterTableError::DroppingColumnNotFound(column_name.to_owned()).into(),\n                    ));\n                }\n            };\n\n            // migrate data\n            for (key, snapshot) in items.iter() {\n                let snapshot: Snapshot\u003cDataRow\u003e = bincode::deserialize(snapshot)\n                    .map_err(err_into)\n                    .map_err(ConflictableTransactionError::Abort)?;\n                let row = match snapshot.clone().extract(txid, None) {\n                    Some(row) =\u003e row,\n                    None =\u003e {\n                        continue;\n                    }\n                };\n\n                let values = match row {\n                    DataRow::Vec(values) =\u003e values,\n                    DataRow::Map(_) =\u003e {\n                        return Err(ConflictableTransactionError::Abort(Error::StorageMsg(\n                            \"conflict - drop_column failed: schemaless row found\".to_owned(),\n                        )));\n                    }\n                };\n\n                let row = values\n                    .into_iter()\n                    .enumerate()\n                    .filter_map(|(i, v)| (i != column_index).then_some(v))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .into();\n\n                let (snapshot, _) = snapshot.update(txid, row);\n                let snapshot = bincode::serialize(\u0026snapshot)\n                    .map_err(err_into)\n                    .map_err(ConflictableTransactionError::Abort)?;\n\n                tree.insert(key, snapshot)?;\n\n                if !autocommit {\n                    let temp_key = key::temp_data(txid, key);\n\n                    tree.insert(temp_key, key)?;\n                }\n            }\n\n            // update schema\n            let column_defs = column_defs\n                .into_iter()\n                .enumerate()\n                .filter_map(|(i, v)| (i != column_index).then_some(v))\n                .collect::\u003cVec\u003cColumnDef\u003e\u003e();\n\n            let temp_key = key::temp_schema(txid, \u0026table_name);\n\n            let schema = Schema {\n                table_name,\n                column_defs: Some(column_defs),\n                indexes,\n                engine,\n                foreign_keys,\n                comment,\n            };\n            let (schema_snapshot, _) = schema_snapshot.update(txid, schema);\n            let schema_value = bincode::serialize(\u0026schema_snapshot)\n                .map_err(err_into)\n                .map_err(ConflictableTransactionError::Abort)?;\n            tree.insert(schema_key.as_bytes(), schema_value)?;\n\n            if !autocommit {\n                tree.insert(temp_key, schema_key.as_bytes())?;\n            }\n\n            Ok(TxPayload::Success)\n        });\n\n        if self.check_retry(tx_result)? {\n            self.drop_column(table_name, column_name, if_exists).await?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":331},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","error.rs"],"content":"use {\n    gluesql_core::error::{AlterTableError, Error, IndexError},\n    sled::transaction::TransactionError as SledTransactionError,\n    std::{str, time},\n    thiserror::Error as ThisError,\n};\n\n#[derive(ThisError, Debug)]\npub enum StorageError {\n    #[error(transparent)]\n    AlterTable(#[from] AlterTableError),\n    #[error(transparent)]\n    Index(#[from] IndexError),\n\n    #[error(transparent)]\n    Sled(#[from] sled::Error),\n    #[error(transparent)]\n    Bincode(#[from] bincode::Error),\n    #[error(transparent)]\n    Str(#[from] str::Utf8Error),\n    #[error(transparent)]\n    SystemTime(#[from] time::SystemTimeError),\n    #[error(transparent)]\n    TryFromSlice(#[from] std::array::TryFromSliceError),\n}\n\nimpl From\u003cStorageError\u003e for Error {\n    fn from(e: StorageError) -\u003e Error {\n        use StorageError::*;\n\n        match e {\n            Sled(e) =\u003e Error::StorageMsg(e.to_string()),\n            Bincode(e) =\u003e Error::StorageMsg(e.to_string()),\n            Str(e) =\u003e Error::StorageMsg(e.to_string()),\n            SystemTime(e) =\u003e Error::StorageMsg(e.to_string()),\n            TryFromSlice(e) =\u003e Error::StorageMsg(e.to_string()),\n            AlterTable(e) =\u003e e.into(),\n            Index(e) =\u003e e.into(),\n        }\n    }\n}\n\npub fn err_into\u003cE\u003e(e: E) -\u003e Error\nwhere\n    E: Into\u003cStorageError\u003e,\n{\n    let e: StorageError = e.into();\n    let e: Error = e.into();\n\n    e\n}\n\npub fn tx_err_into(e: SledTransactionError\u003cError\u003e) -\u003e Error {\n    match e {\n        SledTransactionError::Abort(e) =\u003e e,\n        SledTransactionError::Storage(e) =\u003e StorageError::Sled(e).into(),\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","gc.rs"],"content":"use {\n    super::{\n        SledStorage, Snapshot, err_into, key,\n        lock::{Lock, TxData, get_txdata_key},\n    },\n    gluesql_core::{data::Schema, error::Result, store::DataRow},\n    std::time::{SystemTime, UNIX_EPOCH},\n};\n\nimpl SledStorage {\n    pub fn gc(\u0026self) -\u003e Result\u003c()\u003e {\n        let mut lock: Lock = self\n            .tree\n            .get(\"lock/\")\n            .map_err(err_into)?\n            .map(|l| bincode::deserialize(\u0026l))\n            .transpose()\n            .map_err(err_into)?\n            .unwrap_or_default();\n\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map_err(err_into)?\n            .as_millis();\n\n        let txids = self\n            .tree\n            .scan_prefix(\"tx_data/\")\n            .map(|item| -\u003e Result\u003cTxData\u003e {\n                item.map(|(_, v)| bincode::deserialize(\u0026v))\n                    .map_err(err_into)?\n                    .map_err(err_into)\n            })\n            .take_while(|tx_data| match (tx_data, self.tx_timeout) {\n                (Ok(TxData { alive, .. }), None) =\u003e !alive,\n                (Ok(tx_data), Some(tx_timeout)) =\u003e {\n                    let TxData {\n                        txid,\n                        alive,\n                        created_at,\n                    } = tx_data;\n\n                    (!alive || now - created_at \u003e= tx_timeout)\n                        \u0026\u0026 Some(txid) != lock.lock_txid.as_ref()\n                }\n                (Err(_), _) =\u003e false,\n            })\n            .map(|tx_data| tx_data.map(|TxData { txid, .. }| txid))\n            .collect::\u003cResult\u003cVec\u003cu64\u003e\u003e\u003e()?;\n\n        let max_txid = match txids.iter().last() {\n            Some(txid) =\u003e txid,\n            None =\u003e {\n                return Ok(());\n            }\n        };\n\n        lock.gc_txid = Some(*max_txid);\n\n        bincode::serialize(\u0026lock)\n            .map(|lock| self.tree.insert(\"lock/\", lock))\n            .map_err(err_into)?\n            .map_err(err_into)?;\n\n        let fetch_keys = |prefix| {\n            self.tree\n                .scan_prefix(prefix)\n                .map(|item| item.map_err(err_into))\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n        };\n\n        macro_rules! gc_txid {\n            ($txid: expr, $prefix: expr, $T: ty) =\u003e {\n                for (temp_key, data_key) in fetch_keys($prefix)? {\n                    let snapshot: Option\u003cSnapshot\u003c$T\u003e\u003e = self\n                        .tree\n                        .get(\u0026data_key)\n                        .map_err(err_into)?\n                        .map(|v| bincode::deserialize(\u0026v))\n                        .transpose()\n                        .map_err(err_into)?;\n\n                    let snapshot = match snapshot {\n                        None =\u003e {\n                            continue;\n                        }\n                        Some(snapshot) =\u003e snapshot.gc($txid),\n                    };\n\n                    match snapshot {\n                        Some(snapshot) =\u003e {\n                            bincode::serialize(\u0026snapshot)\n                                .map_err(err_into)\n                                .map(|v| self.tree.insert(data_key, v))?\n                                .map_err(err_into)?;\n                        }\n                        None =\u003e {\n                            self.tree.remove(data_key).map_err(err_into)?;\n                        }\n                    }\n\n                    self.tree.remove(temp_key).map_err(err_into)?;\n                }\n            };\n        }\n\n        for txid in txids {\n            gc_txid!(txid, key::temp_data_prefix(txid), DataRow);\n            gc_txid!(txid, key::temp_schema_prefix(txid), Schema);\n\n            for (temp_key, data_key) in fetch_keys(key::temp_index_prefix(txid))? {\n                let snapshots: Option\u003cVec\u003cSnapshot\u003cVec\u003cu8\u003e\u003e\u003e\u003e = self\n                    .tree\n                    .get(\u0026data_key)\n                    .map_err(err_into)?\n                    .map(|v| bincode::deserialize(\u0026v))\n                    .transpose()\n                    .map_err(err_into)?;\n\n                let snapshots = match snapshots {\n                    Some(snapshots) =\u003e snapshots,\n                    None =\u003e {\n                        continue;\n                    }\n                };\n\n                let snapshots = snapshots\n                    .into_iter()\n                    .filter_map(|snapshot| snapshot.gc(txid))\n                    .collect::\u003cVec\u003c_\u003e\u003e();\n\n                if snapshots.is_empty() {\n                    self.tree.remove(data_key).map_err(err_into)?;\n                } else {\n                    bincode::serialize(\u0026snapshots)\n                        .map_err(err_into)\n                        .map(|v| self.tree.insert(data_key, v))?\n                        .map_err(err_into)?;\n                }\n\n                self.tree.remove(temp_key).map_err(err_into)?;\n            }\n\n            self.tree.remove(get_txdata_key(txid)).map_err(err_into)?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":65},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","index.rs"],"content":"use {\n    super::{\n        SledStorage, Snapshot, State, err_into,\n        index_sync::{build_index_key, build_index_key_prefix},\n        lock,\n    },\n    async_trait::async_trait,\n    futures::stream::iter,\n    gluesql_core::{\n        ast::IndexOperator,\n        data::{Key, Value},\n        error::{Error, IndexError, Result},\n        store::{DataRow, Index, RowIter},\n    },\n    iter_enum::{DoubleEndedIterator, Iterator},\n    sled::IVec,\n    std::iter::{empty, once},\n    utils::Vector,\n};\n\n#[async_trait(?Send)]\nimpl Index for SledStorage {\n    async fn scan_indexed_data\u003c'a\u003e(\n        \u0026'a self,\n        table_name: \u0026str,\n        index_name: \u0026str,\n        asc: Option\u003cbool\u003e,\n        cmp_value: Option\u003c(\u0026IndexOperator, Value)\u003e,\n    ) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        let data_keys = {\n            #[derive(Iterator, DoubleEndedIterator)]\n            enum DataIds\u003cI1, I2, I3, I4\u003e {\n                Empty(I1),\n                Once(I2),\n                Range(I3),\n                Full(I4),\n            }\n\n            let map = |item: std::result::Result\u003c_, _\u003e| item.map(|(_, v)| v);\n\n            match cmp_value {\n                None =\u003e {\n                    let prefix = build_index_key_prefix(table_name, index_name);\n\n                    DataIds::Full(self.tree.scan_prefix(prefix).map(map))\n                }\n                Some((op, value)) =\u003e {\n                    let incr = |key: Vec\u003cu8\u003e| {\n                        key.into_iter()\n                            .rev()\n                            .fold((false, Vector::new()), |(added, upper), v| {\n                                match (added, v) {\n                                    (true, _) =\u003e (added, upper.push(v)),\n                                    (false, u8::MAX) =\u003e (added, upper.push(v)),\n                                    (false, _) =\u003e (true, upper.push(v + 1)),\n                                }\n                            })\n                            .1\n                            .reverse()\n                            .into()\n                    };\n                    let lower = || build_index_key_prefix(table_name, index_name);\n                    let upper = || incr(build_index_key_prefix(table_name, index_name));\n                    let key = build_index_key(table_name, index_name, value)?;\n\n                    match op {\n                        IndexOperator::Eq =\u003e match self.tree.get(\u0026key).transpose() {\n                            Some(v) =\u003e DataIds::Once(once(v)),\n                            None =\u003e DataIds::Empty(empty()),\n                        },\n                        IndexOperator::Gt =\u003e {\n                            DataIds::Range(self.tree.range(incr(key)..upper()).map(map))\n                        }\n                        IndexOperator::GtEq =\u003e {\n                            DataIds::Range(self.tree.range(key..upper()).map(map))\n                        }\n                        IndexOperator::Lt =\u003e DataIds::Range(self.tree.range(lower()..key).map(map)),\n                        IndexOperator::LtEq =\u003e {\n                            DataIds::Range(self.tree.range(lower()..=key).map(map))\n                        }\n                    }\n                }\n            }\n        };\n\n        let (txid, created_at) = match self.state {\n            State::Transaction {\n                txid, created_at, ..\n            } =\u003e (txid, created_at),\n            State::Idle =\u003e {\n                return Err(Error::StorageMsg(\n                    \"conflict - scan_indexed_data failed, lock does not exist\".to_owned(),\n                ));\n            }\n        };\n        let lock_txid = lock::fetch(\u0026self.tree, txid, created_at, self.tx_timeout)?;\n\n        let prefix_len = build_index_key_prefix(table_name, index_name).len();\n        let tree = self.tree.clone();\n        let flat_map = move |keys: Result\u003cIVec\u003e| {\n            #[derive(Iterator)]\n            enum Rows\u003cI1, I2\u003e {\n                Ok(I1),\n                Err(I2),\n            }\n\n            macro_rules! try_into {\n                ($expr: expr) =\u003e {\n                    match $expr {\n                        Ok(v) =\u003e v,\n                        Err(e) =\u003e {\n                            return Rows::Err(once(Err(e)));\n                        }\n                    }\n                };\n            }\n\n            let keys = try_into!(keys);\n            let keys: Vec\u003cSnapshot\u003cVec\u003cu8\u003e\u003e\u003e =\n                try_into!(bincode::deserialize(\u0026keys).map_err(err_into));\n\n            let tree2 = tree.clone();\n            let rows = keys\n                .into_iter()\n                .map(move |key_snapshot| -\u003e Result\u003c_\u003e {\n                    let key = match key_snapshot.extract(txid, lock_txid) {\n                        Some(key) =\u003e key,\n                        None =\u003e {\n                            return Ok(None);\n                        }\n                    };\n\n                    let value = tree2\n                        .get(\u0026key)\n                        .map_err(err_into)?\n                        .ok_or(IndexError::ConflictOnEmptyIndexValueScan)?;\n                    let snapshot: Snapshot\u003cDataRow\u003e =\n                        bincode::deserialize(\u0026value).map_err(err_into)?;\n                    let row = snapshot.extract(txid, lock_txid);\n                    let key = key.into_iter().skip(prefix_len).collect();\n                    let item = row.map(|row| (Key::Bytea(key), row));\n\n                    Ok(item)\n                })\n                .filter_map(|item| item.transpose());\n\n            Rows::Ok(rows)\n        };\n\n        let data_keys = data_keys.map(|v| v.map_err(err_into));\n\n        Ok(match asc {\n            Some(true) | None =\u003e Box::pin(iter(data_keys.flat_map(flat_map))),\n            Some(false) =\u003e Box::pin(iter(data_keys.rev().flat_map(flat_map))),\n        })\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":73},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","index_mut.rs"],"content":"use {\n    super::{\n        SledStorage, Snapshot, err_into,\n        index_sync::IndexSync,\n        key,\n        lock::{self, LockAcquired},\n        transaction::TxPayload,\n    },\n    async_io::block_on,\n    async_trait::async_trait,\n    futures::stream::TryStreamExt,\n    gluesql_core::{\n        ast::OrderByExpr,\n        chrono::Utc,\n        data::{Schema, SchemaIndex, SchemaIndexOrd},\n        error::{Error, IndexError, Result},\n        store::{IndexMut, Store},\n    },\n    sled::transaction::{\n        ConflictableTransactionError, ConflictableTransactionResult, TransactionalTree,\n    },\n    std::iter::once,\n};\n\nfn fetch_schema(\n    tree: \u0026TransactionalTree,\n    table_name: \u0026str,\n) -\u003e ConflictableTransactionResult\u003c(String, Option\u003cSnapshot\u003cSchema\u003e\u003e), Error\u003e {\n    let key = format!(\"schema/{}\", table_name);\n    let value = tree.get(key.as_bytes())?;\n    let schema_snapshot = value\n        .map(|v| bincode::deserialize(\u0026v))\n        .transpose()\n        .map_err(err_into)\n        .map_err(ConflictableTransactionError::Abort)?;\n\n    Ok((key, schema_snapshot))\n}\n\n#[async_trait(?Send)]\nimpl IndexMut for SledStorage {\n    async fn create_index(\n        \u0026mut self,\n        table_name: \u0026str,\n        index_name: \u0026str,\n        column: \u0026OrderByExpr,\n    ) -\u003e Result\u003c()\u003e {\n        let rows = self\n            .scan_data(table_name)\n            .await?\n            .try_collect::\u003cVec\u003c_\u003e\u003e()\n            .await?;\n\n        let state = \u0026self.state;\n        let tx_timeout = self.tx_timeout;\n        let tx_result = self.tree.transaction(move |tree| {\n            let txid = match lock::acquire(tree, state, tx_timeout)? {\n                LockAcquired::Success { txid, .. } =\u003e txid,\n                LockAcquired::RollbackAndRetry { lock_txid } =\u003e {\n                    return Ok(TxPayload::RollbackAndRetry(lock_txid));\n                }\n            };\n\n            let index_expr = \u0026column.expr;\n\n            let (schema_key, schema_snapshot) = fetch_schema(tree, table_name)?;\n            let schema_snapshot = schema_snapshot\n                .ok_or_else(|| IndexError::TableNotFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let (schema_snapshot, schema) = schema_snapshot.delete(txid);\n            let Schema {\n                column_defs,\n                indexes,\n                engine,\n                foreign_keys,\n                comment,\n                ..\n            } = schema\n                .ok_or_else(|| IndexError::ConflictTableNotFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            if indexes.iter().any(|index| index.name == index_name) {\n                return Err(ConflictableTransactionError::Abort(\n                    IndexError::IndexNameAlreadyExists(index_name.to_owned()).into(),\n                ));\n            }\n\n            let index = SchemaIndex {\n                name: index_name.to_owned(),\n                expr: index_expr.clone(),\n                order: SchemaIndexOrd::Both,\n                created: Utc::now().naive_utc(),\n            };\n\n            let indexes = indexes\n                .into_iter()\n                .chain(once(index.clone()))\n                .collect::\u003cVec\u003c_\u003e\u003e();\n\n            let schema = Schema {\n                table_name: table_name.to_owned(),\n                column_defs,\n                indexes,\n                engine,\n                foreign_keys,\n                comment,\n            };\n\n            let index_sync = IndexSync::from_schema(tree, txid, \u0026schema);\n\n            let schema_snapshot = schema_snapshot.update(txid, schema.clone());\n            let schema_snapshot = bincode::serialize(\u0026schema_snapshot)\n                .map_err(err_into)\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            block_on(async {\n                for (data_key, row) in rows.iter() {\n                    let data_key = data_key\n                        .to_cmp_be_bytes()\n                        .map_err(ConflictableTransactionError::Abort)\n                        .map(|key| key::data(table_name, key))?;\n\n                    index_sync.insert_index(\u0026index, \u0026data_key, row).await?;\n                }\n\n                Ok(()) as ConflictableTransactionResult\u003c(), Error\u003e\n            })?;\n\n            tree.insert(schema_key.as_bytes(), schema_snapshot)?;\n\n            let temp_key = key::temp_schema(txid, table_name);\n            tree.insert(temp_key, schema_key.as_bytes())?;\n\n            Ok(TxPayload::Success)\n        });\n\n        if self.check_retry(tx_result)? {\n            self.create_index(table_name, index_name, column).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn drop_index(\u0026mut self, table_name: \u0026str, index_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let rows = self\n            .scan_data(table_name)\n            .await?\n            .try_collect::\u003cVec\u003c_\u003e\u003e()\n            .await?;\n\n        let state = \u0026self.state;\n        let tx_timeout = self.tx_timeout;\n        let tx_result = self.tree.transaction(move |tree| {\n            let txid = match lock::acquire(tree, state, tx_timeout)? {\n                LockAcquired::Success { txid, .. } =\u003e txid,\n                LockAcquired::RollbackAndRetry { lock_txid } =\u003e {\n                    return Ok(TxPayload::RollbackAndRetry(lock_txid));\n                }\n            };\n\n            let (schema_key, schema_snapshot) = fetch_schema(tree, table_name)?;\n            let schema_snapshot = schema_snapshot\n                .ok_or_else(|| IndexError::TableNotFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let (schema_snapshot, schema) = schema_snapshot.delete(txid);\n            let Schema {\n                column_defs,\n                indexes,\n                engine,\n                foreign_keys,\n                comment,\n                ..\n            } = schema\n                .ok_or_else(|| IndexError::ConflictTableNotFound(table_name.to_owned()).into())\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let (index, indexes): (Vec\u003c_\u003e, _) = indexes\n                .into_iter()\n                .partition(|index| index.name == index_name);\n\n            let index = match index.into_iter().next() {\n                Some(index) =\u003e index,\n                None =\u003e {\n                    return Err(ConflictableTransactionError::Abort(\n                        IndexError::IndexNameDoesNotExist(index_name.to_owned()).into(),\n                    ));\n                }\n            };\n\n            let schema = Schema {\n                table_name: table_name.to_owned(),\n                column_defs,\n                indexes,\n                engine,\n                foreign_keys,\n                comment,\n            };\n\n            let index_sync = IndexSync::from_schema(tree, txid, \u0026schema);\n\n            let schema_snapshot = schema_snapshot.update(txid, schema.clone());\n            let schema_snapshot = bincode::serialize(\u0026schema_snapshot)\n                .map_err(err_into)\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            block_on(async {\n                for (data_key, row) in rows.iter() {\n                    let data_key = data_key\n                        .to_cmp_be_bytes()\n                        .map_err(ConflictableTransactionError::Abort)\n                        .map(|key| key::data(table_name, key))?;\n\n                    index_sync.delete_index(\u0026index, \u0026data_key, row).await?;\n                }\n\n                Ok(()) as ConflictableTransactionResult\u003c(), Error\u003e\n            })?;\n\n            tree.insert(schema_key.as_bytes(), schema_snapshot)?;\n\n            let temp_key = key::temp_schema(txid, table_name);\n            tree.insert(temp_key, schema_key.as_bytes())?;\n\n            Ok(TxPayload::Success)\n        });\n\n        if self.check_retry(tx_result)? {\n            self.drop_index(table_name, index_name).await?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":131},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","index_sync.rs"],"content":"use {\n    super::{Snapshot, err_into, fetch_schema, key},\n    gluesql_core::{\n        ast::Expr,\n        data::schema::{Schema, SchemaIndex},\n        error::{Error, IndexError, Result},\n        executor::evaluate_stateless,\n        prelude::Value,\n        store::DataRow,\n    },\n    sled::{\n        IVec,\n        transaction::{\n            ConflictableTransactionError, ConflictableTransactionResult, TransactionalTree,\n        },\n    },\n    std::borrow::Cow,\n    utils::Vector,\n};\n\npub struct IndexSync\u003c'a\u003e {\n    tree: \u0026'a TransactionalTree,\n    txid: u64,\n    table_name: \u0026'a str,\n    columns: Option\u003cVec\u003cString\u003e\u003e,\n    indexes: Cow\u003c'a, [SchemaIndex]\u003e,\n}\n\nimpl\u003c'a\u003e IndexSync\u003c'a\u003e {\n    pub fn from_schema(tree: \u0026'a TransactionalTree, txid: u64, schema: \u0026'a Schema) -\u003e Self {\n        let Schema {\n            table_name,\n            column_defs,\n            indexes,\n            ..\n        } = schema;\n\n        let columns = column_defs.as_ref().map(|column_defs| {\n            column_defs\n                .iter()\n                .map(|column_def| column_def.name.to_owned())\n                .collect::\u003cVec\u003c_\u003e\u003e()\n        });\n\n        let indexes = Cow::Borrowed(indexes.as_slice());\n\n        Self {\n            tree,\n            txid,\n            table_name,\n            columns,\n            indexes,\n        }\n    }\n\n    pub fn new(\n        tree: \u0026'a TransactionalTree,\n        txid: u64,\n        table_name: \u0026'a str,\n    ) -\u003e sled::transaction::ConflictableTransactionResult\u003cSelf, Error\u003e {\n        let Schema {\n            column_defs,\n            indexes,\n            ..\n        } = fetch_schema(tree, table_name)\n            .map(|(_, snapshot)| snapshot)?\n            .and_then(|snapshot| snapshot.extract(txid, None))\n            .ok_or_else(|| IndexError::ConflictTableNotFound(table_name.to_owned()))\n            .map_err(err_into)\n            .map_err(ConflictableTransactionError::Abort)?;\n\n        let columns = column_defs.map(|column_defs| {\n            column_defs\n                .into_iter()\n                .map(|column_def| column_def.name)\n                .collect::\u003cVec\u003c_\u003e\u003e()\n        });\n\n        Ok(Self {\n            tree,\n            txid,\n            table_name,\n            columns,\n            indexes: Cow::Owned(indexes),\n        })\n    }\n\n    pub async fn insert(\n        \u0026self,\n        data_key: \u0026IVec,\n        row: \u0026DataRow,\n    ) -\u003e ConflictableTransactionResult\u003c(), Error\u003e {\n        for index in self.indexes.iter() {\n            self.insert_index(index, data_key, row).await?;\n        }\n\n        Ok(())\n    }\n\n    pub async fn insert_index(\n        \u0026self,\n        index: \u0026SchemaIndex,\n        data_key: \u0026IVec,\n        row: \u0026DataRow,\n    ) -\u003e ConflictableTransactionResult\u003c(), Error\u003e {\n        let SchemaIndex {\n            name: index_name,\n            expr: index_expr,\n            ..\n        } = index;\n\n        let index_key = \u0026evaluate_index_key(\n            self.table_name,\n            index_name,\n            index_expr,\n            self.columns.as_deref(),\n            row,\n        )\n        .await?;\n\n        self.insert_index_data(index_key, data_key)?;\n\n        Ok(())\n    }\n\n    pub async fn update(\n        \u0026self,\n        data_key: \u0026IVec,\n        old_row: \u0026DataRow,\n        new_row: \u0026DataRow,\n    ) -\u003e ConflictableTransactionResult\u003c(), Error\u003e {\n        for index in self.indexes.iter() {\n            let SchemaIndex {\n                name: index_name,\n                expr: index_expr,\n                ..\n            } = index;\n\n            let old_index_key = \u0026evaluate_index_key(\n                self.table_name,\n                index_name,\n                index_expr,\n                self.columns.as_deref(),\n                old_row,\n            )\n            .await?;\n\n            let new_index_key = \u0026evaluate_index_key(\n                self.table_name,\n                index_name,\n                index_expr,\n                self.columns.as_deref(),\n                new_row,\n            )\n            .await?;\n\n            self.delete_index_data(old_index_key, data_key)?;\n            self.insert_index_data(new_index_key, data_key)?;\n        }\n\n        Ok(())\n    }\n\n    pub async fn delete(\n        \u0026self,\n        data_key: \u0026IVec,\n        row: \u0026DataRow,\n    ) -\u003e ConflictableTransactionResult\u003c(), Error\u003e {\n        for index in self.indexes.iter() {\n            self.delete_index(index, data_key, row).await?;\n        }\n\n        Ok(())\n    }\n\n    pub async fn delete_index(\n        \u0026self,\n        index: \u0026SchemaIndex,\n        data_key: \u0026IVec,\n        row: \u0026DataRow,\n    ) -\u003e ConflictableTransactionResult\u003c(), Error\u003e {\n        let SchemaIndex {\n            name: index_name,\n            expr: index_expr,\n            ..\n        } = index;\n\n        let index_key = \u0026evaluate_index_key(\n            self.table_name,\n            index_name,\n            index_expr,\n            self.columns.as_deref(),\n            row,\n        )\n        .await?;\n\n        self.delete_index_data(index_key, data_key)?;\n\n        Ok(())\n    }\n\n    fn insert_index_data(\n        \u0026self,\n        index_key: \u0026[u8],\n        data_key: \u0026IVec,\n    ) -\u003e ConflictableTransactionResult\u003c(), Error\u003e {\n        let data_keys: Vec\u003cSnapshot\u003cVec\u003cu8\u003e\u003e\u003e = self\n            .tree\n            .get(index_key)?\n            .map(|v| bincode::deserialize(\u0026v))\n            .transpose()\n            .map_err(err_into)\n            .map_err(ConflictableTransactionError::Abort)?\n            .unwrap_or_default();\n\n        let key_snapshot = Snapshot::\u003cVec\u003cu8\u003e\u003e::new(self.txid, data_key.to_vec());\n        let data_keys = Vector::from(data_keys).push(key_snapshot);\n        let data_keys = bincode::serialize(\u0026Vec::from(data_keys))\n            .map_err(err_into)\n            .map_err(ConflictableTransactionError::Abort)?;\n\n        let temp_key = key::temp_index(self.txid, index_key);\n\n        self.tree.insert(index_key, data_keys)?;\n        self.tree.insert(temp_key, index_key)?;\n\n        Ok(())\n    }\n\n    fn delete_index_data(\n        \u0026self,\n        index_key: \u0026[u8],\n        data_key: \u0026IVec,\n    ) -\u003e ConflictableTransactionResult\u003c(), Error\u003e {\n        let data_keys: Vec\u003cSnapshot\u003cVec\u003cu8\u003e\u003e\u003e = self\n            .tree\n            .get(index_key)?\n            .map(|v| bincode::deserialize(\u0026v))\n            .ok_or_else(|| IndexError::ConflictOnIndexDataDeleteSync.into())\n            .map_err(ConflictableTransactionError::Abort)?\n            .map_err(err_into)\n            .map_err(ConflictableTransactionError::Abort)?;\n\n        let data_keys = data_keys\n            .into_iter()\n            .map(|snapshot| {\n                let key = snapshot.get(self.txid, None);\n\n                if Some(data_key) == key.map(IVec::from).as_ref() {\n                    snapshot.delete(self.txid).0\n                } else {\n                    snapshot\n                }\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let data_keys = bincode::serialize(\u0026data_keys)\n            .map_err(err_into)\n            .map_err(ConflictableTransactionError::Abort)?;\n\n        let temp_key = key::temp_index(self.txid, index_key);\n\n        self.tree.insert(index_key, data_keys)?;\n        self.tree.insert(temp_key, index_key)?;\n\n        Ok(())\n    }\n}\n\nasync fn evaluate_index_key(\n    table_name: \u0026str,\n    index_name: \u0026str,\n    index_expr: \u0026Expr,\n    columns: Option\u003c\u0026[String]\u003e,\n    row: \u0026DataRow,\n) -\u003e ConflictableTransactionResult\u003cVec\u003cu8\u003e, Error\u003e {\n    let context = Some(row.as_context(columns));\n    let evaluated = evaluate_stateless(context, index_expr)\n        .await\n        .map_err(ConflictableTransactionError::Abort)?;\n    let value: Value = evaluated\n        .try_into()\n        .map_err(ConflictableTransactionError::Abort)?;\n\n    build_index_key(table_name, index_name, value).map_err(ConflictableTransactionError::Abort)\n}\n\npub fn build_index_key_prefix(table_name: \u0026str, index_name: \u0026str) -\u003e Vec\u003cu8\u003e {\n    format!(\"index/{}/{}/\", table_name, index_name).into_bytes()\n}\n\npub fn build_index_key(table_name: \u0026str, index_name: \u0026str, value: Value) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    Ok(build_index_key_prefix(table_name, index_name)\n        .into_iter()\n        .chain(value.to_cmp_be_bytes()?)\n        .collect::\u003cVec\u003c_\u003e\u003e())\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":150},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","key.rs"],"content":"use sled::IVec;\n\nconst TEMP_DATA: \u0026str = \"temp_data/\";\nconst TEMP_SCHEMA: \u0026str = \"temp_schema/\";\nconst TEMP_INDEX: \u0026str = \"temp_index/\";\n\npub fn data_prefix(table_name: \u0026str) -\u003e String {\n    format!(\"data/{table_name}/\")\n}\n\npub fn data(table_name: \u0026str, key: Vec\u003cu8\u003e) -\u003e IVec {\n    let key = data_prefix(table_name).into_bytes().into_iter().chain(key);\n\n    IVec::from_iter(key)\n}\n\nmacro_rules! prefix {\n    ($txid: ident, $prefix: ident) =\u003e {\n        $prefix\n            .to_owned()\n            .into_bytes()\n            .into_iter()\n            .chain($txid.to_be_bytes().iter().copied())\n    };\n}\n\npub fn temp_data_prefix(txid: u64) -\u003e IVec {\n    IVec::from_iter(prefix!(txid, TEMP_DATA))\n}\n\npub fn temp_schema_prefix(txid: u64) -\u003e IVec {\n    IVec::from_iter(prefix!(txid, TEMP_SCHEMA))\n}\n\npub fn temp_index_prefix(txid: u64) -\u003e IVec {\n    IVec::from_iter(prefix!(txid, TEMP_INDEX))\n}\n\npub fn temp_data(txid: u64, data_key: \u0026IVec) -\u003e IVec {\n    IVec::from_iter(prefix!(txid, TEMP_DATA).chain(data_key.iter().copied()))\n}\n\npub fn temp_data_str(txid: u64, data_key: \u0026str) -\u003e IVec {\n    IVec::from_iter(prefix!(txid, TEMP_DATA).chain(data_key.as_bytes().iter().copied()))\n}\n\npub fn temp_schema(txid: u64, table_name: \u0026str) -\u003e IVec {\n    IVec::from_iter(prefix!(txid, TEMP_SCHEMA).chain(table_name.as_bytes().iter().copied()))\n}\n\npub fn temp_index(txid: u64, index_key: \u0026[u8]) -\u003e IVec {\n    IVec::from_iter(prefix!(txid, TEMP_INDEX).chain(index_key.iter().copied()))\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","lib.rs"],"content":"#![deny(clippy::str_to_string)]\n\nmod alter_table;\nmod error;\nmod gc;\nmod index;\nmod index_mut;\nmod index_sync;\nmod key;\nmod lock;\nmod snapshot;\nmod store;\nmod store_mut;\nmod transaction;\n\n// re-export\npub use sled;\n\nuse {\n    self::snapshot::Snapshot,\n    error::{err_into, tx_err_into},\n    gluesql_core::{\n        data::Schema,\n        error::{Error, Result},\n        store::Metadata,\n    },\n    sled::{\n        Config, Db,\n        transaction::{\n            ConflictableTransactionError, ConflictableTransactionResult, TransactionalTree,\n        },\n    },\n};\n\n/// default transaction timeout : 1 hour\nconst DEFAULT_TX_TIMEOUT: u128 = 3600 * 1000;\n\n#[derive(Debug, Clone)]\npub enum State {\n    Idle,\n    Transaction {\n        txid: u64,\n        created_at: u128,\n        autocommit: bool,\n    },\n}\n\n#[derive(Debug, Clone)]\npub struct SledStorage {\n    pub tree: Db,\n    pub id_offset: u64,\n    pub state: State,\n    /// transaction timeout in milliseconds\n    pub tx_timeout: Option\u003cu128\u003e,\n}\n\ntype ExportData\u003cT\u003e = (u64, Vec\u003c(Vec\u003cu8\u003e, Vec\u003cu8\u003e, T)\u003e);\n\nimpl SledStorage {\n    pub fn new\u003cP: AsRef\u003cstd::path::Path\u003e\u003e(filename: P) -\u003e Result\u003cSelf\u003e {\n        let tree = sled::open(filename).map_err(err_into)?;\n        let id_offset = get_id_offset(\u0026tree)?;\n        let state = State::Idle;\n        let tx_timeout = Some(DEFAULT_TX_TIMEOUT);\n\n        Ok(Self {\n            tree,\n            id_offset,\n            state,\n            tx_timeout,\n        })\n    }\n\n    pub fn set_transaction_timeout(\u0026mut self, tx_timeout: Option\u003cu128\u003e) {\n        self.tx_timeout = tx_timeout;\n    }\n\n    pub fn export(\u0026self) -\u003e Result\u003cExportData\u003cimpl Iterator\u003cItem = Vec\u003cVec\u003cu8\u003e\u003e\u003e\u003e\u003e {\n        let id_offset = self.id_offset + self.tree.generate_id().map_err(err_into)?;\n        let data = self.tree.export();\n\n        Ok((id_offset, data))\n    }\n\n    pub fn import(\u0026mut self, export: ExportData\u003cimpl Iterator\u003cItem = Vec\u003cVec\u003cu8\u003e\u003e\u003e\u003e) -\u003e Result\u003c()\u003e {\n        let (new_id_offset, data) = export;\n        let old_id_offset = get_id_offset(\u0026self.tree)?;\n\n        self.tree.import(data);\n\n        if new_id_offset \u003e old_id_offset {\n            self.tree\n                .insert(\"id_offset\", \u0026new_id_offset.to_be_bytes())\n                .map_err(err_into)?;\n\n            self.id_offset = new_id_offset;\n        }\n\n        Ok(())\n    }\n}\n\nimpl TryFrom\u003cConfig\u003e for SledStorage {\n    type Error = Error;\n\n    fn try_from(config: Config) -\u003e Result\u003cSelf\u003e {\n        let tree = config.open().map_err(err_into)?;\n        let id_offset = get_id_offset(\u0026tree)?;\n        let state = State::Idle;\n        let tx_timeout = Some(DEFAULT_TX_TIMEOUT);\n\n        Ok(Self {\n            tree,\n            id_offset,\n            state,\n            tx_timeout,\n        })\n    }\n}\n\nfn get_id_offset(tree: \u0026Db) -\u003e Result\u003cu64\u003e {\n    tree.get(\"id_offset\")\n        .map_err(err_into)?\n        .map(|id| {\n            id.as_ref()\n                .try_into()\n                .map_err(err_into)\n                .map(u64::from_be_bytes)\n        })\n        .unwrap_or(Ok(0))\n}\n\nfn fetch_schema(\n    tree: \u0026TransactionalTree,\n    table_name: \u0026str,\n) -\u003e ConflictableTransactionResult\u003c(String, Option\u003cSnapshot\u003cSchema\u003e\u003e), Error\u003e {\n    let key = format!(\"schema/{}\", table_name);\n    let value = tree.get(key.as_bytes())?;\n    let schema_snapshot = value\n        .map(|v| bincode::deserialize(\u0026v))\n        .transpose()\n        .map_err(err_into)\n        .map_err(ConflictableTransactionError::Abort)?;\n\n    Ok((key, schema_snapshot))\n}\n\nimpl Metadata for SledStorage {}\nimpl gluesql_core::store::CustomFunction for SledStorage {}\nimpl gluesql_core::store::CustomFunctionMut for SledStorage {}\n","traces":[{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":53},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","lock.rs"],"content":"use {\n    super::{State, err_into},\n    gluesql_core::error::{Error, Result},\n    serde::{Deserialize, Serialize},\n    sled::{\n        Db,\n        transaction::{\n            ConflictableTransactionError, ConflictableTransactionResult, TransactionalTree,\n        },\n    },\n    std::time::{SystemTime, UNIX_EPOCH},\n};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct TxData {\n    pub txid: u64,\n    pub alive: bool,\n    pub created_at: u128,\n}\n\n#[derive(Debug, Default, Serialize, Deserialize)]\npub struct Lock {\n    pub lock_txid: Option\u003cu64\u003e,\n    pub lock_created_at: u128,\n    pub gc_txid: Option\u003cu64\u003e,\n    // TODO: support serializable transaction isolation level\n    // - prev_done_at: u128,\n}\n\npub fn get_txdata_key(txid: u64) -\u003e Vec\u003cu8\u003e {\n    \"tx_data/\"\n        .to_owned()\n        .into_bytes()\n        .into_iter()\n        .chain(txid.to_be_bytes().iter().copied())\n        .collect::\u003cVec\u003c_\u003e\u003e()\n}\n\npub fn register(tree: \u0026Db, id_offset: u64) -\u003e Result\u003c(u64, u128)\u003e {\n    let txid = id_offset + tree.generate_id().map_err(err_into)?;\n    let key = get_txdata_key(txid);\n    let created_at = SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map_err(err_into)?\n        .as_millis();\n\n    let tx_data = TxData {\n        txid,\n        alive: true,\n        created_at,\n    };\n\n    bincode::serialize(\u0026tx_data)\n        .map_err(err_into)\n        .map(|tx_data| tree.insert(key, tx_data))?\n        .map_err(err_into)?;\n\n    Ok((txid, created_at))\n}\n\npub fn fetch(\n    tree: \u0026Db,\n    txid: u64,\n    created_at: u128,\n    tx_timeout: Option\u003cu128\u003e,\n) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n    let Lock {\n        lock_txid, gc_txid, ..\n    } = tree\n        .get(\"lock/\")\n        .map_err(err_into)?\n        .map(|l| bincode::deserialize(\u0026l))\n        .transpose()\n        .map_err(err_into)?\n        .unwrap_or_default();\n\n    let now = SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map_err(err_into)?\n        .as_millis();\n\n    if tx_timeout.map(|tx_timeout| now \u003e= tx_timeout + created_at) == Some(true) {\n        return Err(Error::StorageMsg(\n            \"fetch failed - expired transaction has used (timeout)\".to_owned(),\n        ));\n    } else if gc_txid.is_some() \u0026\u0026 Some(txid) \u003c= gc_txid {\n        return Err(Error::StorageMsg(\n            \"fetch failed - expired transaction has used (txid)\".to_owned(),\n        ));\n    }\n\n    Ok(lock_txid)\n}\n\npub enum LockAcquired {\n    Success { txid: u64, autocommit: bool },\n    RollbackAndRetry { lock_txid: u64 },\n}\n\npub fn acquire(\n    tree: \u0026TransactionalTree,\n    state: \u0026State,\n    tx_timeout: Option\u003cu128\u003e,\n) -\u003e ConflictableTransactionResult\u003cLockAcquired, Error\u003e {\n    let Lock {\n        lock_txid,\n        lock_created_at,\n        gc_txid,\n    } = tree\n        .get(\"lock/\")?\n        .map(|l| bincode::deserialize(\u0026l))\n        .transpose()\n        .map_err(err_into)\n        .map_err(ConflictableTransactionError::Abort)?\n        .unwrap_or_default();\n\n    let (txid, created_at, autocommit) = match state {\n        State::Transaction {\n            txid,\n            created_at,\n            autocommit,\n        } =\u003e (*txid, *created_at, *autocommit),\n        State::Idle =\u003e {\n            return Err(ConflictableTransactionError::Abort(Error::StorageMsg(\n                \"conflict - cannot acquire lock from idle state\".to_owned(),\n            )));\n        }\n    };\n\n    let now = SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map_err(err_into)\n        .map_err(ConflictableTransactionError::Abort)?\n        .as_millis();\n\n    if tx_timeout.map(|tx_timeout| now \u003e= tx_timeout + created_at) == Some(true) {\n        return Err(ConflictableTransactionError::Abort(Error::StorageMsg(\n            \"acquire failed - expired transaction has used (timeout)\".to_owned(),\n        )));\n    } else if gc_txid.is_some() \u0026\u0026 Some(txid) \u003c= gc_txid {\n        return Err(ConflictableTransactionError::Abort(Error::StorageMsg(\n            \"acquire failed - expired transaction has used (txid)\".to_owned(),\n        )));\n    }\n\n    let txid = match lock_txid {\n        Some(lock_txid) =\u003e {\n            if tx_timeout.map(|tx_timeout| now \u003e= tx_timeout + lock_created_at) == Some(true) {\n                return Ok(LockAcquired::RollbackAndRetry { lock_txid });\n            } else if txid != lock_txid {\n                return Err(ConflictableTransactionError::Abort(Error::StorageMsg(\n                    \"database is locked\".to_owned(),\n                )));\n            }\n\n            txid\n        }\n        None =\u003e {\n            let lock = Lock {\n                lock_txid: Some(txid),\n                lock_created_at: created_at,\n                gc_txid,\n            };\n\n            bincode::serialize(\u0026lock)\n                .map_err(err_into)\n                .map_err(ConflictableTransactionError::Abort)\n                .map(|lock| tree.insert(\"lock/\", lock))??;\n\n            txid\n        }\n    };\n\n    Ok(LockAcquired::Success { txid, autocommit })\n}\n\npub fn unregister(tree: \u0026Db, txid: u64) -\u003e Result\u003c()\u003e {\n    let key = get_txdata_key(txid);\n    let mut tx_data: TxData = tree\n        .get(\u0026key)\n        .map_err(err_into)?\n        .ok_or_else(|| Error::StorageMsg(\"conflict - lock does not exist\".to_owned()))\n        .map(|tx_data| bincode::deserialize(\u0026tx_data))?\n        .map_err(err_into)?;\n\n    tx_data.alive = false;\n\n    bincode::serialize(\u0026tx_data)\n        .map(|tx_data| tree.insert(key, tx_data))\n        .map_err(err_into)?\n        .map_err(err_into)?;\n\n    Ok(())\n}\n\npub fn release(tree: \u0026TransactionalTree, txid: u64) -\u003e ConflictableTransactionResult\u003c(), Error\u003e {\n    let Lock {\n        gc_txid, lock_txid, ..\n    } = tree\n        .get(\"lock/\")?\n        .map(|l| bincode::deserialize(\u0026l))\n        .transpose()\n        .map_err(err_into)\n        .map_err(ConflictableTransactionError::Abort)?\n        .unwrap_or_default();\n\n    if Some(txid) == lock_txid {\n        let lock = Lock {\n            lock_txid: None,\n            lock_created_at: 0,\n            gc_txid,\n        };\n\n        bincode::serialize(\u0026lock)\n            .map_err(err_into)\n            .map_err(ConflictableTransactionError::Abort)\n            .map(|lock| tree.insert(\"lock/\", lock))??;\n    }\n\n    let key = get_txdata_key(txid);\n    let tx_data: Option\u003cTxData\u003e = tree\n        .get(\u0026key)?\n        .map(|tx_data| bincode::deserialize(\u0026tx_data))\n        .transpose()\n        .map_err(err_into)\n        .map_err(ConflictableTransactionError::Abort)?;\n\n    let mut tx_data = match tx_data {\n        Some(tx_data) =\u003e tx_data,\n        None =\u003e {\n            return Ok(());\n        }\n    };\n\n    tx_data.alive = false;\n\n    bincode::serialize(\u0026tx_data)\n        .map_err(err_into)\n        .map_err(ConflictableTransactionError::Abort)\n        .map(|tx_data| tree.insert(key, tx_data))??;\n\n    Ok(())\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":110},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","snapshot.rs"],"content":"use {\n    serde::{Deserialize, Serialize},\n    std::fmt::Debug,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct SnapshotItem\u003cT\u003e {\n    data: T,\n    created_by: u64,\n    deleted_by: Option\u003cu64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Snapshot\u003cT\u003e(Vec\u003cSnapshotItem\u003cT\u003e\u003e);\n\nimpl\u003cT: Clone\u003e Snapshot\u003cT\u003e {\n    pub fn new(txid: u64, data: T) -\u003e Self {\n        Self(vec![SnapshotItem {\n            data,\n            created_by: txid,\n            deleted_by: None,\n        }])\n    }\n\n    pub fn update(mut self, txid: u64, data: T) -\u003e (Self, Option\u003cT\u003e) {\n        let old_data = (!self.0.is_empty()).then(|| {\n            if self.0[0].deleted_by.is_none() {\n                self.0[0].deleted_by = Some(txid);\n            }\n\n            self.0[0].data.clone()\n        });\n\n        let new_item = SnapshotItem {\n            data,\n            created_by: txid,\n            deleted_by: None,\n        };\n\n        self.0.insert(0, new_item);\n\n        (self, old_data)\n    }\n\n    pub fn delete(mut self, txid: u64) -\u003e (Self, Option\u003cT\u003e) {\n        if !self.0.is_empty() {\n            self.0[0].deleted_by = Some(txid);\n\n            let data = self.0[0].data.clone();\n\n            (self, Some(data))\n        } else {\n            (self, None)\n        }\n    }\n\n    pub fn rollback(self, txid: u64) -\u003e Option\u003cSelf\u003e {\n        let items = self\n            .0\n            .into_iter()\n            .filter_map(|mut item| {\n                if item.created_by == txid {\n                    None\n                } else if item.deleted_by == Some(txid) {\n                    item.deleted_by = None;\n\n                    Some(item)\n                } else {\n                    Some(item)\n                }\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        (!items.is_empty()).then_some(Snapshot(items))\n    }\n\n    pub fn extract(self, txid: u64, lock_txid: Option\u003cu64\u003e) -\u003e Option\u003cT\u003e {\n        let lock_txid = if Some(txid) == lock_txid {\n            None\n        } else {\n            lock_txid\n        };\n\n        for item in self.0 {\n            if Some(item.created_by) == lock_txid {\n                continue;\n            }\n\n            let deleted = item.deleted_by.is_some()\n                \u0026\u0026 item.deleted_by != lock_txid\n                \u0026\u0026 Some(txid) \u003e= item.deleted_by;\n\n            if txid \u003e= item.created_by \u0026\u0026 !deleted {\n                return Some(item.data);\n            }\n        }\n\n        None\n    }\n\n    pub fn get(\u0026self, txid: u64, lock_txid: Option\u003cu64\u003e) -\u003e Option\u003cT\u003e {\n        let lock_txid = if Some(txid) == lock_txid {\n            None\n        } else {\n            lock_txid\n        };\n\n        for item in self.0.iter() {\n            if Some(item.created_by) == lock_txid {\n                continue;\n            }\n\n            let deleted = item.deleted_by.is_some()\n                \u0026\u0026 item.deleted_by != lock_txid\n                \u0026\u0026 Some(txid) \u003e= item.deleted_by;\n\n            if txid \u003e= item.created_by \u0026\u0026 !deleted {\n                return Some(item.data.clone());\n            }\n        }\n\n        None\n    }\n\n    pub fn gc(self, txid: u64) -\u003e Option\u003cSelf\u003e {\n        let items = self\n            .0\n            .into_iter()\n            .skip_while(|SnapshotItem { deleted_by, .. }| match deleted_by {\n                Some(d_txid) =\u003e d_txid \u003c= \u0026txid,\n                None =\u003e false,\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        (!items.is_empty()).then_some(Self(items))\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":62},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","store.rs"],"content":"use {\n    super::{SledStorage, Snapshot, State, err_into, key, lock},\n    async_trait::async_trait,\n    futures::stream::iter,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::{Error, Result},\n        store::{DataRow, RowIter, Store},\n    },\n    std::str,\n};\n\nimpl SledStorage {\n    const SCHEMA_PREFIX: \u0026'static str = \"schema/\";\n}\n\n#[async_trait(?Send)]\nimpl Store for SledStorage {\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let (txid, created_at) = match self.state {\n            State::Transaction {\n                txid, created_at, ..\n            } =\u003e (txid, created_at),\n            State::Idle =\u003e lock::register(\u0026self.tree, self.id_offset)?,\n        };\n        let lock_txid = lock::fetch(\u0026self.tree, txid, created_at, self.tx_timeout)?;\n\n        self.tree\n            .scan_prefix(SledStorage::SCHEMA_PREFIX)\n            .map(move |item| {\n                let (_, value) = item.map_err(err_into)?;\n                let snapshot: Snapshot\u003cSchema\u003e = bincode::deserialize(\u0026value).map_err(err_into)?;\n                let schema = snapshot.extract(txid, lock_txid);\n\n                Ok(schema)\n            })\n            .filter_map(|result| result.transpose())\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n    }\n\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        let (txid, created_at, temp) = match self.state {\n            State::Transaction {\n                txid, created_at, ..\n            } =\u003e (txid, created_at, false),\n            State::Idle =\u003e lock::register(\u0026self.tree, self.id_offset)\n                .map(|(txid, created_at)| (txid, created_at, true))?,\n        };\n        let lock_txid = lock::fetch(\u0026self.tree, txid, created_at, self.tx_timeout)?;\n\n        let key = format!(\"schema/{}\", table_name);\n        let schema = self\n            .tree\n            .get(key.as_bytes())\n            .map_err(err_into)?\n            .map(|v| bincode::deserialize(\u0026v))\n            .transpose()\n            .map_err(err_into)?\n            .and_then(|snapshot: Snapshot\u003cSchema\u003e| snapshot.extract(txid, lock_txid));\n\n        if temp {\n            lock::unregister(\u0026self.tree, txid)?;\n        }\n\n        Ok(schema)\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, key: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        let (txid, created_at) = match self.state {\n            State::Transaction {\n                txid, created_at, ..\n            } =\u003e (txid, created_at),\n            State::Idle =\u003e {\n                return Err(Error::StorageMsg(\n                    \"conflict - fetch_data failed, lock does not exist\".to_owned(),\n                ));\n            }\n        };\n        let lock_txid = lock::fetch(\u0026self.tree, txid, created_at, self.tx_timeout)?;\n\n        let key = key\n            .to_cmp_be_bytes()\n            .map(|key| key::data(table_name, key))?;\n        let row = self\n            .tree\n            .get(\u0026key)\n            .map_err(err_into)?\n            .map(|v| bincode::deserialize(\u0026v))\n            .transpose()\n            .map_err(err_into)?\n            .and_then(|snapshot: Snapshot\u003cDataRow\u003e| snapshot.extract(txid, lock_txid));\n\n        Ok(row)\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        let (txid, created_at) = match self.state {\n            State::Transaction {\n                txid, created_at, ..\n            } =\u003e (txid, created_at),\n            State::Idle =\u003e {\n                return Err(Error::StorageMsg(\n                    \"conflict - scan_data failed, lock does not exist\".to_owned(),\n                ));\n            }\n        };\n        let lock_txid = lock::fetch(\u0026self.tree, txid, created_at, self.tx_timeout)?;\n\n        let prefix = key::data_prefix(table_name);\n        let prefix_len = prefix.len();\n        let result_set = self\n            .tree\n            .scan_prefix(prefix.as_bytes())\n            .map(move |item| {\n                let (key, value) = item.map_err(err_into)?;\n                let key = key.subslice(prefix_len, key.len() - prefix_len).to_vec();\n                let snapshot: Snapshot\u003cDataRow\u003e = bincode::deserialize(\u0026value).map_err(err_into)?;\n                let row = snapshot.extract(txid, lock_txid);\n                let item = row.map(|row| (Key::Bytea(key), row));\n\n                Ok(item)\n            })\n            .filter_map(|item| item.transpose());\n\n        Ok(Box::pin(iter(result_set)))\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":72},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","store_mut.rs"],"content":"use {\n    super::{\n        SledStorage, Snapshot, err_into,\n        index_sync::IndexSync,\n        key,\n        lock::{self, LockAcquired},\n        transaction::TxPayload,\n        tx_err_into,\n    },\n    async_io::block_on,\n    async_trait::async_trait,\n    gluesql_core::{\n        data::{Key, Schema},\n        error::{Error, IndexError, Result},\n        store::{DataRow, StoreMut},\n    },\n    sled::transaction::{ConflictableTransactionError, ConflictableTransactionResult},\n};\n\n#[async_trait(?Send)]\nimpl StoreMut for SledStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let state = \u0026self.state;\n        let tx_timeout = self.tx_timeout;\n\n        let tx_result = self.tree.transaction(move |tree| {\n            let txid = match lock::acquire(tree, state, tx_timeout)? {\n                LockAcquired::Success { txid, .. } =\u003e txid,\n                LockAcquired::RollbackAndRetry { lock_txid } =\u003e {\n                    return Ok(TxPayload::RollbackAndRetry(lock_txid));\n                }\n            };\n\n            let key = format!(\"schema/{}\", schema.table_name);\n            let temp_key = key::temp_schema(txid, \u0026schema.table_name);\n\n            let snapshot: Option\u003cSnapshot\u003cSchema\u003e\u003e = tree\n                .get(key.as_bytes())?\n                .map(|v| bincode::deserialize(\u0026v))\n                .transpose()\n                .map_err(err_into)\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let schema = schema.clone();\n            let snapshot = match snapshot {\n                Some(snapshot) =\u003e snapshot.update(txid, schema).0,\n                None =\u003e Snapshot::\u003cSchema\u003e::new(txid, schema),\n            };\n            let snapshot = bincode::serialize(\u0026snapshot)\n                .map_err(err_into)\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            tree.insert(key.as_bytes(), snapshot)?;\n            tree.insert(temp_key, key.as_bytes())?;\n\n            Ok(TxPayload::Success)\n        });\n\n        if let TxPayload::RollbackAndRetry(lock_txid) = tx_result.map_err(tx_err_into)? {\n            self.rollback_txid(lock_txid)?;\n            self.tree\n                .transaction(move |tree| lock::release(tree, lock_txid))\n                .map_err(tx_err_into)?;\n\n            self.insert_schema(schema).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let prefix = format!(\"data/{}/\", table_name);\n        let items = self\n            .tree\n            .scan_prefix(prefix.as_bytes())\n            .map(|item| item.map_err(err_into))\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n\n        let state = \u0026self.state;\n        let tx_timeout = self.tx_timeout;\n\n        let tx_result = self.tree.transaction(move |tree| {\n            let txid = match lock::acquire(tree, state, tx_timeout)? {\n                LockAcquired::Success { txid, .. } =\u003e txid,\n                LockAcquired::RollbackAndRetry { lock_txid } =\u003e {\n                    return Ok(TxPayload::RollbackAndRetry(lock_txid));\n                }\n            };\n\n            let key = format!(\"schema/{}\", table_name);\n            let temp_key = key::temp_schema(txid, table_name);\n\n            let snapshot: Option\u003cSnapshot\u003cSchema\u003e\u003e = tree\n                .get(key.as_bytes())?\n                .map(|v| bincode::deserialize(\u0026v))\n                .transpose()\n                .map_err(err_into)\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            let (snapshot, schema) = match snapshot.map(|snapshot| snapshot.delete(txid)) {\n                Some((snapshot, Some(schema))) =\u003e (snapshot, schema),\n                Some((_, None)) | None =\u003e {\n                    return Ok(TxPayload::Success);\n                }\n            };\n            let snapshot = bincode::serialize(\u0026snapshot)\n                .map_err(err_into)\n                .map_err(ConflictableTransactionError::Abort)?;\n\n            tree.insert(key.as_bytes(), snapshot)?;\n            tree.insert(temp_key, key.as_bytes())?;\n\n            let index_sync = IndexSync::from_schema(tree, txid, \u0026schema);\n\n            // delete data\n            block_on(async {\n                for (row_key, row_snapshot) in items.iter() {\n                    let row_snapshot: Snapshot\u003cDataRow\u003e = bincode::deserialize(row_snapshot)\n                        .map_err(err_into)\n                        .map_err(ConflictableTransactionError::Abort)?;\n\n                    let (row_snapshot, deleted_row) = row_snapshot.delete(txid);\n                    let deleted_row = match deleted_row {\n                        Some(row) =\u003e row,\n                        None =\u003e {\n                            continue;\n                        }\n                    };\n\n                    let row_snapshot = bincode::serialize(\u0026row_snapshot)\n                        .map_err(err_into)\n                        .map_err(ConflictableTransactionError::Abort)?;\n\n                    let temp_row_key = key::temp_data(txid, row_key);\n\n                    tree.insert(row_key, row_snapshot)?;\n                    tree.insert(temp_row_key, row_key)?;\n\n                    index_sync.delete(row_key, \u0026deleted_row).await?;\n                }\n\n                Ok(()) as ConflictableTransactionResult\u003c(), Error\u003e\n            })?;\n\n            Ok(TxPayload::Success)\n        });\n\n        if let TxPayload::RollbackAndRetry(lock_txid) = tx_result.map_err(tx_err_into)? {\n            self.rollback_txid(lock_txid)?;\n            self.tree\n                .transaction(move |tree| lock::release(tree, lock_txid))\n                .map_err(tx_err_into)?;\n\n            self.delete_schema(table_name).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let id_offset = self.id_offset;\n        let state = \u0026self.state;\n        let tx_timeout = self.tx_timeout;\n        let tx_rows = \u0026rows;\n\n        let tx_result = self.tree.transaction(move |tree| {\n            let (txid, autocommit) = match lock::acquire(tree, state, tx_timeout)? {\n                LockAcquired::Success { txid, autocommit } =\u003e (txid, autocommit),\n                LockAcquired::RollbackAndRetry { lock_txid } =\u003e {\n                    return Ok(TxPayload::RollbackAndRetry(lock_txid));\n                }\n            };\n\n            let index_sync = IndexSync::new(tree, txid, table_name)?;\n\n            block_on(async {\n                for row in tx_rows.iter() {\n                    let id = id_offset + tree.generate_id()?;\n                    let id = id.to_be_bytes();\n                    let key = key::data(table_name, id.to_vec());\n\n                    index_sync.insert(\u0026key, row).await?;\n\n                    let snapshot = Snapshot::new(txid, row.clone());\n                    let snapshot = bincode::serialize(\u0026snapshot)\n                        .map_err(err_into)\n                        .map_err(ConflictableTransactionError::Abort)?;\n\n                    tree.insert(\u0026key, snapshot)?;\n\n                    if !autocommit {\n                        let temp_key = key::temp_data(txid, \u0026key);\n\n                        tree.insert(temp_key, key)?;\n                    }\n                }\n\n                Ok(()) as ConflictableTransactionResult\u003c(), Error\u003e\n            })?;\n\n            Ok(TxPayload::Success)\n        });\n\n        if let TxPayload::RollbackAndRetry(lock_txid) = tx_result.map_err(tx_err_into)? {\n            self.rollback_txid(lock_txid)?;\n            self.tree\n                .transaction(move |tree| lock::release(tree, lock_txid))\n                .map_err(tx_err_into)?;\n\n            self.append_data(table_name, rows).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        let state = \u0026self.state;\n        let tx_timeout = self.tx_timeout;\n        let tx_rows = \u0026rows;\n\n        let tx_result = self.tree.transaction(move |tree| {\n            let (txid, autocommit) = match lock::acquire(tree, state, tx_timeout)? {\n                LockAcquired::Success { txid, autocommit } =\u003e (txid, autocommit),\n                LockAcquired::RollbackAndRetry { lock_txid } =\u003e {\n                    return Ok(TxPayload::RollbackAndRetry(lock_txid));\n                }\n            };\n\n            let index_sync = IndexSync::new(tree, txid, table_name)?;\n\n            block_on(async {\n                for (key, new_row) in tx_rows.iter() {\n                    let key = key\n                        .to_cmp_be_bytes()\n                        .map_err(ConflictableTransactionError::Abort)\n                        .map(|key| key::data(table_name, key))?;\n\n                    let snapshot = match tree.get(\u0026key)? {\n                        Some(snapshot) =\u003e {\n                            let snapshot: Snapshot\u003cDataRow\u003e = bincode::deserialize(\u0026snapshot)\n                                .map_err(err_into)\n                                .map_err(ConflictableTransactionError::Abort)?;\n\n                            let (snapshot, old_row) = snapshot.update(txid, new_row.clone());\n                            let old_row = match old_row {\n                                Some(row) =\u003e row,\n                                None =\u003e {\n                                    continue;\n                                }\n                            };\n\n                            index_sync.update(\u0026key, \u0026old_row, new_row).await?;\n\n                            snapshot\n                        }\n                        None =\u003e {\n                            index_sync.insert(\u0026key, new_row).await?;\n\n                            Snapshot::new(txid, new_row.clone())\n                        }\n                    };\n\n                    let snapshot = bincode::serialize(\u0026snapshot)\n                        .map_err(err_into)\n                        .map_err(ConflictableTransactionError::Abort)?;\n\n                    tree.insert(\u0026key, snapshot)?;\n\n                    if !autocommit {\n                        let temp_key = key::temp_data(txid, \u0026key);\n\n                        tree.insert(temp_key, key)?;\n                    }\n                }\n                Ok(()) as ConflictableTransactionResult\u003c(), Error\u003e\n            })?;\n\n            Ok(TxPayload::Success)\n        });\n\n        if let TxPayload::RollbackAndRetry(lock_txid) = tx_result.map_err(tx_err_into)? {\n            self.rollback_txid(lock_txid)?;\n            self.tree\n                .transaction(move |tree| lock::release(tree, lock_txid))\n                .map_err(tx_err_into)?;\n\n            self.insert_data(table_name, rows).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        let state = \u0026self.state;\n        let tx_timeout = self.tx_timeout;\n        let tx_keys = \u0026keys;\n\n        let tx_result = self.tree.transaction(move |tree| {\n            let (txid, autocommit) = match lock::acquire(tree, state, tx_timeout)? {\n                LockAcquired::Success { txid, autocommit } =\u003e (txid, autocommit),\n                LockAcquired::RollbackAndRetry { lock_txid } =\u003e {\n                    return Ok(TxPayload::RollbackAndRetry(lock_txid));\n                }\n            };\n\n            let index_sync = IndexSync::new(tree, txid, table_name)?;\n\n            block_on(async {\n                for key in tx_keys.iter() {\n                    let key = key\n                        .to_cmp_be_bytes()\n                        .map_err(ConflictableTransactionError::Abort)\n                        .map(|key| key::data(table_name, key))?;\n\n                    let snapshot = tree\n                        .get(\u0026key)?\n                        .ok_or_else(|| IndexError::ConflictOnEmptyIndexValueDelete.into())\n                        .map_err(ConflictableTransactionError::Abort)?;\n                    let snapshot: Snapshot\u003cDataRow\u003e = bincode::deserialize(\u0026snapshot)\n                        .map_err(err_into)\n                        .map_err(ConflictableTransactionError::Abort)?;\n\n                    let (snapshot, row) = snapshot.delete(txid);\n                    let row = match row {\n                        Some(row) =\u003e row,\n                        None =\u003e {\n                            continue;\n                        }\n                    };\n\n                    bincode::serialize(\u0026snapshot)\n                        .map_err(err_into)\n                        .map_err(ConflictableTransactionError::Abort)\n                        .map(|snapshot| tree.insert(\u0026key, snapshot))??;\n\n                    index_sync.delete(\u0026key, \u0026row).await?;\n\n                    if !autocommit {\n                        let temp_key = key::temp_data(txid, \u0026key);\n\n                        tree.insert(temp_key, key)?;\n                    }\n                }\n\n                Ok(()) as ConflictableTransactionResult\u003c(), Error\u003e\n            })?;\n\n            Ok(TxPayload::Success)\n        });\n\n        if let TxPayload::RollbackAndRetry(lock_txid) = tx_result.map_err(tx_err_into)? {\n            self.rollback_txid(lock_txid)?;\n            self.tree\n                .transaction(move |tree| lock::release(tree, lock_txid))\n                .map_err(tx_err_into)?;\n\n            self.delete_data(table_name, keys).await?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":211},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","src","transaction.rs"],"content":"use {\n    super::{\n        SledStorage, Snapshot, State, err_into, key,\n        lock::{self, Lock},\n        tx_err_into,\n    },\n    async_trait::async_trait,\n    gluesql_core::{\n        data::Schema,\n        error::{Error, Result},\n        store::{DataRow, Transaction},\n    },\n    serde::{Serialize, de::DeserializeOwned},\n    sled::{\n        IVec,\n        transaction::{\n            ConflictableTransactionError, ConflictableTransactionResult, TransactionError,\n            TransactionalTree,\n        },\n    },\n    std::result::Result as StdResult,\n};\n\npub enum TxPayload {\n    Success,\n    RollbackAndRetry(u64),\n}\n\n#[async_trait(?Send)]\nimpl Transaction for SledStorage {\n    async fn begin(\u0026mut self, autocommit: bool) -\u003e Result\u003cbool\u003e {\n        match (\u0026self.state, autocommit) {\n            (State::Transaction { .. }, false) =\u003e Err(Error::StorageMsg(\n                \"nested transaction is not supported\".to_owned(),\n            )),\n            (State::Transaction { autocommit, .. }, true) =\u003e Ok(*autocommit),\n            (State::Idle, _) =\u003e {\n                let (txid, created_at) = lock::register(\u0026self.tree, self.id_offset)?;\n\n                self.state = State::Transaction {\n                    txid,\n                    created_at,\n                    autocommit,\n                };\n\n                Ok(autocommit)\n            }\n        }\n    }\n\n    async fn rollback(\u0026mut self) -\u003e Result\u003c()\u003e {\n        let txid = match self.state {\n            State::Transaction { txid, .. } =\u003e txid,\n            State::Idle =\u003e {\n                return Err(Error::StorageMsg(\"no transaction to rollback\".to_owned()));\n            }\n        };\n\n        let rollback = || {\n            let Lock { lock_txid, .. } = self\n                .tree\n                .get(\"lock/\")\n                .map_err(err_into)?\n                .map(|l| bincode::deserialize(\u0026l))\n                .transpose()\n                .map_err(err_into)?\n                .unwrap_or_default();\n\n            if Some(txid) == lock_txid {\n                self.rollback_txid(txid).map(|_| lock_txid)\n            } else {\n                Ok(None)\n            }\n        };\n\n        let lock_txid = rollback()?;\n\n        self.tree\n            .transaction(move |tree| {\n                lock_txid\n                    .map(|lock_txid| lock::release(tree, lock_txid))\n                    .transpose()\n            })\n            .map_err(tx_err_into)?;\n\n        self.state = State::Idle;\n        Ok(())\n    }\n\n    async fn commit(\u0026mut self) -\u003e Result\u003c()\u003e {\n        let (txid, created_at) = match self.state {\n            State::Transaction {\n                txid, created_at, ..\n            } =\u003e (txid, created_at),\n            State::Idle =\u003e {\n                return Err(Error::StorageMsg(\"no transaction to commit\".to_owned()));\n            }\n        };\n\n        lock::fetch(\u0026self.tree, txid, created_at, self.tx_timeout)?;\n\n        self.tree\n            .transaction(move |tree| lock::release(tree, txid))\n            .map_err(tx_err_into)?;\n\n        self.state = State::Idle;\n\n        if self.tree.get(\"gc_lock\").map_err(err_into)?.is_some() {\n            return Ok(());\n        }\n\n        self.tree.insert(\"gc_lock\", \u0026[1]).map_err(err_into)?;\n\n        let gc_result = self.gc();\n\n        self.tree.remove(\"gc_lock\").map_err(err_into)?;\n\n        gc_result\n    }\n}\n\nimpl SledStorage {\n    pub fn rollback_txid(\u0026self, txid: u64) -\u003e Result\u003c()\u003e {\n        let fetch_items = |prefix| {\n            self.tree\n                .scan_prefix(prefix)\n                .map(|item| item.map_err(err_into))\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n        };\n\n        fn rollback_items\u003cT: Clone + Serialize + DeserializeOwned\u003e(\n            tree: \u0026TransactionalTree,\n            txid: u64,\n            items: \u0026[(IVec, IVec)],\n        ) -\u003e ConflictableTransactionResult\u003c(), Error\u003e {\n            for (temp_key, value_key) in items.iter() {\n                tree.remove(temp_key)?;\n\n                let snapshot = tree\n                    .get(value_key)?\n                    .map(|l| bincode::deserialize(\u0026l))\n                    .transpose()\n                    .map_err(err_into)\n                    .map_err(ConflictableTransactionError::Abort)?;\n\n                let snapshot: Snapshot\u003cT\u003e = match snapshot {\n                    Some(snapshot) =\u003e snapshot,\n                    None =\u003e {\n                        continue;\n                    }\n                };\n\n                match snapshot.rollback(txid) {\n                    Some(snapshot) =\u003e {\n                        let snapshot = bincode::serialize(\u0026snapshot)\n                            .map_err(err_into)\n                            .map_err(ConflictableTransactionError::Abort)?;\n\n                        tree.insert(value_key, snapshot)?;\n                    }\n                    None =\u003e {\n                        tree.remove(value_key)?;\n                    }\n                };\n            }\n\n            Ok(())\n        }\n\n        let data_items = fetch_items(key::temp_data_prefix(txid))?;\n        let schema_items = fetch_items(key::temp_schema_prefix(txid))?;\n        let index_items = fetch_items(key::temp_index_prefix(txid))?;\n\n        self.tree\n            .transaction(move |tree| {\n                rollback_items::\u003cDataRow\u003e(tree, txid, \u0026data_items)?;\n                rollback_items::\u003cSchema\u003e(tree, txid, \u0026schema_items)?;\n\n                for (temp_key, value_key) in index_items.iter() {\n                    tree.remove(temp_key)?;\n\n                    let snapshots = tree\n                        .get(value_key)?\n                        .map(|l| bincode::deserialize(\u0026l))\n                        .transpose()\n                        .map_err(err_into)\n                        .map_err(ConflictableTransactionError::Abort)?;\n\n                    let snapshots: Vec\u003cSnapshot\u003cVec\u003cu8\u003e\u003e\u003e = match snapshots {\n                        Some(snapshots) =\u003e snapshots,\n                        None =\u003e {\n                            continue;\n                        }\n                    };\n\n                    let snapshots = snapshots\n                        .into_iter()\n                        .filter_map(|snapshot| snapshot.rollback(txid))\n                        .collect::\u003cVec\u003c_\u003e\u003e();\n\n                    if snapshots.is_empty() {\n                        tree.remove(value_key)?;\n                    } else {\n                        let snapshots = bincode::serialize(\u0026snapshots)\n                            .map_err(err_into)\n                            .map_err(ConflictableTransactionError::Abort)?;\n\n                        tree.insert(value_key, snapshots)?;\n                    }\n                }\n\n                Ok(())\n            })\n            .map_err(tx_err_into)\n    }\n\n    pub fn check_retry(\n        \u0026mut self,\n        tx_result: StdResult\u003cTxPayload, TransactionError\u003cError\u003e\u003e,\n    ) -\u003e Result\u003cbool\u003e {\n        if let TxPayload::RollbackAndRetry(lock_txid) = tx_result.map_err(tx_err_into)? {\n            self.rollback_txid(lock_txid)?;\n            self.tree\n                .transaction(move |tree| lock::release(tree, lock_txid))\n                .map_err(tx_err_into)?;\n\n            Ok(true)\n        } else {\n            Ok(false)\n        }\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":113},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","tests","export_and_import.rs"],"content":"use {gluesql_core::prelude::*, gluesql_sled_storage::SledStorage, sled::Config};\n\n#[tokio::test]\nasync fn export_and_import() {\n    let path1 = \"tmp/export_and_import1\";\n    let path2 = \"tmp/export_and_import2\";\n    let config1 = Config::default().path(path1).temporary(true);\n    let config2 = Config::default().path(path2).temporary(true);\n\n    let storage1 = SledStorage::try_from(config1).unwrap();\n    let mut glue1 = Glue::new(storage1);\n\n    glue1\n        .execute(\"CREATE TABLE Foo (id INTEGER);\")\n        .await\n        .unwrap();\n    glue1\n        .execute(\"INSERT INTO Foo VALUES (1), (2), (3);\")\n        .await\n        .unwrap();\n\n    let data1 = glue1.execute(\"SELECT * FROM Foo;\").await.unwrap();\n    let export = glue1.storage.export().unwrap();\n\n    let mut storage2 = SledStorage::try_from(config2).unwrap();\n    storage2.import(export).unwrap();\n    let mut glue2 = Glue::new(storage2);\n\n    let data2 = glue2.execute(\"SELECT * FROM Foo;\").await.unwrap();\n\n    assert_eq!(data1, data2);\n}\n\n#[tokio::test]\nasync fn export_and_import_multiple_times() {\n    let path1 = \"tmp/repeated_export_and_import1\";\n    let path2 = \"tmp/repeated_export_and_import2\";\n    let path3 = \"tmp/repeated_export_and_import3\";\n    let config1 = Config::default().path(path1).temporary(true);\n    let config2 = Config::default().path(path2).temporary(true);\n    let config3 = Config::default().path(path3).temporary(true);\n\n    let storage1 = SledStorage::try_from(config1).unwrap();\n    let mut glue1 = Glue::new(storage1);\n\n    glue1\n        .execute(\"CREATE TABLE Foo (id INTEGER);\")\n        .await\n        .unwrap();\n    glue1\n        .execute(\"INSERT INTO Foo VALUES (1), (2), (3);\")\n        .await\n        .unwrap();\n\n    let data1 = glue1.execute(\"SELECT * FROM Foo;\").await.unwrap();\n    let export = glue1.storage.export().unwrap();\n\n    let mut storage2 = SledStorage::try_from(config2).unwrap();\n    storage2.import(export).unwrap();\n    let mut glue2 = Glue::new(storage2);\n\n    let data2 = glue2.execute(\"SELECT * FROM Foo;\").await.unwrap();\n    let export2 = glue2.storage.export().unwrap();\n    assert_eq!(data1, data2);\n\n    let mut storage3 = SledStorage::try_from(config3).unwrap();\n    storage3.import(export2).unwrap();\n    let mut glue3 = Glue::new(storage3);\n\n    let data3 = glue3.execute(\"SELECT * FROM Foo;\").await.unwrap();\n    assert_eq!(data1, data3);\n}\n\n#[test]\nfn invalid_id_offset() {\n    // value in \"id_offset\" key must have u64 big endian format data\n\n    let path1 = \"tmp/import_error1\";\n    let path2 = \"tmp/import_error2\";\n    let config1 = Config::default().path(path1).temporary(true);\n    let config2 = Config::default().path(path2).temporary(true);\n\n    let storage1 = SledStorage::try_from(config1).unwrap();\n    let export = storage1.export().unwrap();\n\n    let mut storage2 = SledStorage::try_from(config2).unwrap();\n    storage2\n        .tree\n        .insert(\"id_offset\", \"something wrong value\")\n        .unwrap();\n\n    assert_eq!(\n        storage2.import(export),\n        Err(Error::StorageMsg(\n            \"could not convert slice to array\".to_owned()\n        ))\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","tests","sled_storage.rs"],"content":"use {\n    async_trait::async_trait, gluesql_core::prelude::Glue, gluesql_sled_storage::SledStorage,\n    test_suite::*,\n};\n\nstruct SledTester {\n    glue: Glue\u003cSledStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cSledStorage\u003e for SledTester {\n    async fn new(namespace: \u0026str) -\u003e Self {\n        let path = format!(\"data/{}\", namespace);\n\n        match std::fs::remove_dir_all(\u0026path) {\n            Ok(()) =\u003e (),\n            Err(e) =\u003e {\n                println!(\"fs::remove_file {:?}\", e);\n            }\n        }\n\n        let config = sled::Config::default()\n            .path(path)\n            .temporary(true)\n            .mode(sled::Mode::HighThroughput);\n\n        let storage = SledStorage::try_from(config).expect(\"SledStorage::new\");\n        let glue = Glue::new(storage);\n\n        SledTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cSledStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\n#[tokio::test]\nasync fn sled_basic() {\n    use gluesql_core::prelude::*;\n\n    let mut tester = SledTester::new(\"delete\").await;\n    let glue = tester.get_glue();\n\n    macro_rules! execute {\n        ($sql:expr) =\u003e {{\n            let mut payloads = glue.execute($sql).await.unwrap();\n            payloads.remove(0)\n        }};\n    }\n\n    macro_rules! select {\n        ($label: literal, $rows:expr) =\u003e {\n            Payload::Select {\n                labels: vec![$label.to_owned()],\n                rows: $rows,\n            }\n        };\n\n        ($label: literal) =\u003e {\n            Payload::Select {\n                labels: vec![$label.to_owned()],\n                rows: vec![],\n            }\n        };\n    }\n\n    execute!(\"CREATE TABLE Foo(id INTEGER PRIMARY KEY);\");\n    execute!(\"INSERT INTO Foo VALUES (1), (2);\");\n\n    assert_eq!(\n        execute!(\"SELECT * FROM Foo;\"),\n        select!(\"id\", vec![vec![Value::I64(1)], vec![Value::I64(2)]])\n    );\n\n    execute!(\"DELETE FROM Foo where id = 1;\");\n    assert_eq!(\n        execute!(\"SELECT * FROM Foo;\"),\n        select!(\"id\", vec![vec![Value::I64(2)]])\n    );\n\n    execute!(\"INSERT INTO Foo VALUES(1);\");\n    assert_eq!(\n        execute!(\"SELECT * FROM Foo;\"),\n        select!(\"id\", vec![vec![Value::I64(1)], vec![Value::I64(2)]])\n    );\n}\n\ngenerate_store_tests!(tokio::test, SledTester);\ngenerate_index_tests!(tokio::test, SledTester);\ngenerate_transaction_tests!(tokio::test, SledTester);\ngenerate_alter_table_tests!(tokio::test, SledTester);\ngenerate_alter_table_index_tests!(tokio::test, SledTester);\ngenerate_transaction_alter_table_tests!(tokio::test, SledTester);\ngenerate_transaction_index_tests!(tokio::test, SledTester);\ngenerate_metadata_index_tests!(tokio::test, SledTester);\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","sled-storage","tests","sled_transaction.rs"],"content":"//! # SledStorage transaction tests\n//!\n//! REPEATABLE READ or SNAPSHOT ISOLATION is a transaction level which SledStorage provides.\n//! Therefore, SledStorage is safe from READ UNCOMMITTED or READ COMMITTED concurrency conflict\n//! scenarios, but not PHANTOM READ safe.\n\nuse {\n    gluesql_core::{\n        executor::FetchError,\n        prelude::{Value::*, *},\n        store::StoreMut,\n        *,\n    },\n    gluesql_sled_storage::{self, SledStorage, State},\n    std::{\n        fs,\n        time::{SystemTime, UNIX_EPOCH},\n    },\n    test_suite::*,\n};\n\nconst PATH_PREFIX: \u0026str = \"tmp/gluesql\";\n\nmacro_rules! exec {\n    ($glue: ident $sql: literal) =\u003e {\n        $glue.execute($sql).await.unwrap();\n    };\n}\n\nmacro_rules! test {\n    ($glue: ident $sql: literal, $result: expr) =\u003e {\n        let actual = $glue.execute($sql).await;\n        assert_eq!(actual, $result.map(|payload| vec![payload]));\n    };\n}\n\nmacro_rules! test_idx {\n    ($glue: ident $sql: literal, $idx: expr, $result: expr) =\u003e {\n        let statements = $glue.plan($sql).await.unwrap();\n        assert_eq!(statements.len(), 1);\n        let first = \u0026statements[0];\n        test_indexes(first, Some($idx));\n        assert_eq!($glue.execute_stmt(first).await, $result);\n    };\n}\n\n#[tokio::test]\nasync fn sled_transaction_basic() {\n    let path = \u0026format!(\"{}/basic\", PATH_PREFIX);\n    fs::remove_dir_all(path).unwrap_or(());\n\n    let storage = SledStorage::new(path).unwrap();\n    let storage2 = storage.clone();\n    let mut glue = Glue::new(storage);\n    let mut glue2 = Glue::new(storage2);\n\n    exec!(glue \"BEGIN\");\n    test!(glue \"BEGIN\", Err(Error::StorageMsg(\"nested transaction is not supported\".to_owned())));\n    exec!(glue \"COMMIT;\");\n\n    test!(glue \"ROLLBACK\", Err(Error::StorageMsg(\"no transaction to rollback\".to_owned())));\n    test!(glue \"COMMIT\", Err(Error::StorageMsg(\"no transaction to commit\".to_owned())));\n\n    exec!(glue \"BEGIN;\");\n    exec!(glue \"CREATE TABLE AcquireLock (id INTEGER);\");\n    test!(\n        glue2 \"CREATE TABLE MeTooTheLock (id INTEGER);\",\n        Err(Error::StorageMsg(\"database is locked\".to_owned()))\n    );\n\n    exec!(glue2 \"BEGIN;\");\n    exec!(glue2 \"COMMIT;\");\n    test!(\n        glue2 \"SELECT * FROM AcquireLock;\",\n        Err(FetchError::TableNotFound(\"AcquireLock\".to_owned()).into())\n    );\n}\n\n#[tokio::test]\nasync fn sled_transaction_read_uncommitted() {\n    let path = \u0026format!(\"{}/read_uncommitted\", PATH_PREFIX);\n    fs::remove_dir_all(path).unwrap_or(());\n\n    let storage1 = SledStorage::new(path).unwrap();\n    let storage2 = storage1.clone();\n    let mut glue1 = Glue::new(storage1);\n    let mut glue2 = Glue::new(storage2);\n\n    exec!(glue1 \"BEGIN;\");\n    exec!(glue1 \"CREATE TABLE Sample (id INTEGER);\");\n    exec!(glue1 \"INSERT INTO Sample VALUES (30);\");\n\n    test!(\n        glue2 \"SELECT * FROM Sample\",\n        Err(FetchError::TableNotFound(\"Sample\".to_owned()).into())\n    );\n    exec!(glue2 \"BEGIN;\");\n    test!(\n        glue2 \"SELECT * FROM Sample\",\n        Err(FetchError::TableNotFound(\"Sample\".to_owned()).into())\n    );\n    exec!(glue2 \"COMMIT;\");\n    exec!(glue1 \"COMMIT;\");\n}\n\n#[tokio::test]\nasync fn sled_transaction_read_committed() {\n    let path = \u0026format!(\"{}/read_committed\", PATH_PREFIX);\n    fs::remove_dir_all(path).unwrap_or(());\n\n    let storage1 = SledStorage::new(path).unwrap();\n    let storage2 = storage1.clone();\n    let mut glue1 = Glue::new(storage1);\n    let mut glue2 = Glue::new(storage2);\n\n    exec!(glue2 \"BEGIN;\");\n\n    exec!(glue1 \"BEGIN;\");\n    exec!(glue1 \"CREATE TABLE Sample (id INTEGER);\");\n    exec!(glue1 \"INSERT INTO Sample VALUES (30);\");\n    exec!(glue1 \"COMMIT;\");\n\n    test!(\n        glue2 \"SELECT * FROM Sample\",\n        Err(FetchError::TableNotFound(\"Sample\".to_owned()).into())\n    );\n    exec!(glue2 \"COMMIT;\");\n\n    test!(\n        glue2 \"SELECT * FROM Sample\",\n        Ok(select!(id I64; 30))\n    );\n}\n\n#[tokio::test]\nasync fn sled_transaction_schema_mut() {\n    let path = \u0026format!(\"{}/transaction_schema_mut\", PATH_PREFIX);\n    fs::remove_dir_all(path).unwrap_or(());\n\n    let storage1 = SledStorage::new(path).unwrap();\n    let storage2 = storage1.clone();\n    let mut glue1 = Glue::new(storage1);\n    let mut glue2 = Glue::new(storage2);\n\n    exec!(glue1 \"CREATE TABLE Sample (id INTEGER);\");\n    exec!(glue1 \"INSERT INTO Sample VALUES (1);\");\n\n    exec!(glue2 \"BEGIN;\");\n    exec!(glue1 \"BEGIN;\");\n    exec!(glue1 \"DROP TABLE Sample;\");\n    test!(\n        glue1 \"SELECT * FROM Sample;\",\n        Err(FetchError::TableNotFound(\"Sample\".to_owned()).into())\n    );\n    test!(\n        glue2 \"SELECT * FROM Sample;\",\n        Ok(select!(id I64; 1))\n    );\n\n    exec!(glue1 \"COMMIT;\");\n    exec!(glue1 \"CREATE TABLE Sample (new_id INTEGER);\");\n    exec!(glue1 \"INSERT INTO Sample VALUES (5);\");\n    test!(\n        glue1 \"SELECT * FROM Sample;\",\n        Ok(select!(new_id I64; 5))\n    );\n    test!(\n        glue2 \"SELECT * FROM Sample;\",\n        Ok(select!(id I64; 1))\n    );\n    exec!(glue2 \"COMMIT;\");\n    test!(\n        glue2 \"SELECT * FROM Sample;\",\n        Ok(select!(new_id I64; 5))\n    );\n}\n\n#[tokio::test]\nasync fn sled_transaction_data_mut() {\n    let path = \u0026format!(\"{}/transaction_data_mut\", PATH_PREFIX);\n    fs::remove_dir_all(path).unwrap_or(());\n\n    let storage1 = SledStorage::new(path).unwrap();\n    let storage2 = storage1.clone();\n    let mut glue1 = Glue::new(storage1);\n    let mut glue2 = Glue::new(storage2);\n\n    exec!(glue1 \"CREATE TABLE Sample (id INTEGER);\");\n    exec!(glue1 \"INSERT INTO Sample VALUES (1);\");\n\n    exec!(glue2 \"BEGIN;\");\n    exec!(glue1 \"BEGIN;\");\n\n    test!(\n        glue2 \"SELECT * FROM Sample;\",\n        Ok(select!(id I64; 1))\n    );\n\n    exec!(glue1 \"DELETE FROM Sample;\");\n    test!(\n        glue1 \"SELECT * FROM Sample;\",\n        Ok(Payload::Select {\n            labels: vec![\"id\".to_owned()],\n            rows: vec![],\n        })\n    );\n    test!(\n        glue2 \"SELECT * FROM Sample;\",\n        Ok(select!(id I64; 1))\n    );\n\n    exec!(glue1 \"INSERT INTO Sample VALUES (3), (5);\");\n    test!(\n        glue1 \"SELECT * FROM Sample;\",\n        Ok(select!(id I64; 3; 5))\n    );\n    test!(\n        glue2 \"SELECT * FROM Sample;\",\n        Ok(select!(id I64; 1))\n    );\n\n    exec!(glue1 \"UPDATE Sample SET id = id + 1;\");\n    test!(\n        glue1 \"SELECT * FROM Sample;\",\n        Ok(select!(id I64; 4; 6))\n    );\n    test!(\n        glue2 \"SELECT * FROM Sample;\",\n        Ok(select!(id I64; 1))\n    );\n\n    exec!(glue1 \"COMMIT;\");\n    test!(\n        glue1 \"SELECT * FROM Sample;\",\n        Ok(select!(id I64; 4; 6))\n    );\n    test!(\n        glue2 \"SELECT * FROM Sample;\",\n        Ok(select!(id I64; 1))\n    );\n\n    exec!(glue2 \"COMMIT;\");\n    test!(\n        glue1 \"SELECT * FROM Sample;\",\n        Ok(select!(id I64; 4; 6))\n    );\n    test!(\n        glue2 \"SELECT * FROM Sample;\",\n        Ok(select!(id I64; 4; 6))\n    );\n}\n\n#[tokio::test]\nasync fn sled_transaction_index_mut() {\n    use ast::IndexOperator::Eq;\n\n    let path = \u0026format!(\"{}/transaction_index_mut\", PATH_PREFIX);\n    fs::remove_dir_all(path).unwrap_or(());\n\n    let storage1 = SledStorage::new(path).unwrap();\n    let storage2 = storage1.clone();\n    let mut glue1 = Glue::new(storage1);\n    let mut glue2 = Glue::new(storage2);\n\n    exec!(glue1 \"CREATE TABLE Sample (id INTEGER);\");\n    exec!(glue1 \"INSERT INTO Sample VALUES (1);\");\n\n    exec!(glue2 \"BEGIN;\");\n    exec!(glue1 \"BEGIN;\");\n\n    exec!(glue1 \"CREATE INDEX idx_id ON Sample (id);\");\n\n    test_idx!(\n        glue1 \"SELECT * FROM Sample WHERE id = 1;\",\n        idx!(idx_id, Eq, \"1\"),\n        Ok(select!(id I64; 1))\n    );\n    test_idx!(\n        glue2 \"SELECT * FROM Sample WHERE id = 1;\",\n        idx!(),\n        Ok(select!(id I64; 1))\n    );\n\n    exec!(glue1 \"COMMIT;\");\n    test_idx!(\n        glue2 \"SELECT * FROM Sample WHERE id = 1;\",\n        idx!(),\n        Ok(select!(id I64; 1))\n    );\n\n    exec!(glue2 \"COMMIT;\");\n    test_idx!(\n        glue1 \"SELECT * FROM Sample WHERE id = 1;\",\n        idx!(idx_id, Eq, \"1\"),\n        Ok(select!(id I64; 1))\n    );\n\n    exec!(glue2 \"BEGIN;\");\n    exec!(glue1 \"BEGIN;\");\n\n    exec!(glue1 \"DROP INDEX Sample.idx_id;\");\n\n    test_idx!(\n        glue2 \"SELECT * FROM Sample WHERE id = 1;\",\n        idx!(idx_id, Eq, \"1\"),\n        Ok(select!(id I64; 1))\n    );\n    test_idx!(\n        glue1 \"SELECT * FROM Sample WHERE id = 1;\",\n        idx!(),\n        Ok(select!(id I64; 1))\n    );\n\n    exec!(glue1 \"COMMIT;\");\n    test_idx!(\n        glue2 \"SELECT * FROM Sample WHERE id = 1;\",\n        idx!(idx_id, Eq, \"1\"),\n        Ok(select!(id I64; 1))\n    );\n\n    exec!(glue2 \"COMMIT;\");\n    test_idx!(\n        glue1 \"SELECT * FROM Sample WHERE id = 1;\",\n        idx!(),\n        Ok(select!(id I64; 1))\n    );\n    test_idx!(\n        glue2 \"SELECT * FROM Sample WHERE id = 1;\",\n        idx!(),\n        Ok(select!(id I64; 1))\n    );\n}\n\n#[tokio::test]\nasync fn sled_transaction_gc() {\n    let path = \u0026format!(\"{}/transaction_gc\", PATH_PREFIX);\n    fs::remove_dir_all(path).unwrap_or(());\n\n    let storage1 = SledStorage::new(path).unwrap();\n    let storage2 = storage1.clone();\n    let tree = storage1.clone().tree;\n\n    let mut glue1 = Glue::new(storage1);\n    let mut glue2 = Glue::new(storage2);\n\n    macro_rules! assert_some {\n        () =\u003e {\n            assert!(tree.scan_prefix(\"temp_\").next().is_some());\n        };\n    }\n    macro_rules! assert_none {\n        () =\u003e {\n            assert!(tree.scan_prefix(\"temp_\").next().is_none());\n        };\n    }\n\n    // COMMIT runs GC and all temp_ data must be removed.\n    exec!(glue1 \"BEGIN;\");\n    exec!(glue1 \"CREATE TABLE Garlic (id INTEGER);\");\n    assert_some!();\n    exec!(glue1 \"CREATE INDEX idx_id ON Garlic (id);\");\n    exec!(glue1 \"INSERT INTO Garlic VALUES (1), (2);\");\n    exec!(glue1 \"CREATE INDEX idx_gc ON Garlic (id + 2);\");\n    exec!(glue1 \"ALTER TABLE Garlic ADD COLUMN num INTEGER NULL;\");\n    assert_some!();\n    exec!(glue1 \"COMMIT;\");\n    assert_none!();\n\n    // Though glue1 COMMIT, glue2 transaction is still alive.\n    // Until glue2 COMMIT, temp_ must survive.\n    exec!(glue2 \"BEGIN;\");\n    exec!(glue1 \"BEGIN;\");\n    exec!(glue1 \"CREATE TABLE NewGarlic (gar BOOLEAN);\");\n    exec!(glue1 \"INSERT INTO NewGarlic VALUES (True);\");\n    assert_some!();\n    exec!(glue1 \"COMMIT;\");\n    assert_some!();\n    exec!(glue2 \"COMMIT;\");\n    assert_none!();\n\n    // force change, txid -\u003e 0\n    exec!(glue1 \"BEGIN;\");\n\n    glue1.storage.state = State::Transaction {\n        txid: 0,\n        created_at: SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_millis(),\n        autocommit: false,\n    };\n\n    test!(glue1 \"SELECT * FROM NewGarlic\", Err(Error::StorageMsg(\"fetch failed - expired transaction has used (txid)\".to_owned())));\n    assert_eq!(\n        glue1\n            .storage\n            .insert_data(\"NewGarlic\", vec![])\n            .await\n            .unwrap_err(),\n        Error::StorageMsg(\"acquire failed - expired transaction has used (txid)\".to_owned()),\n    );\n}\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\nmod timeout_tests {\n    use {super::*, std::time::Duration};\n\n    const TX_TIMEOUT: Option\u003cu128\u003e = Some(200);\n    const TX_SLEEP_TICK: Duration = Duration::from_millis(201);\n\n    fn sleep() {\n        std::thread::sleep(TX_SLEEP_TICK);\n    }\n\n    #[tokio::test]\n    async fn sled_transaction_timeout_store() {\n        let path = \u0026format!(\"{}/transaction_timeout_store\", PATH_PREFIX);\n        fs::remove_dir_all(path).unwrap_or(());\n\n        let mut storage1 = SledStorage::new(path).unwrap();\n        storage1.set_transaction_timeout(TX_TIMEOUT);\n        let storage2 = storage1.clone();\n\n        let mut glue1 = Glue::new(storage1);\n        let mut glue2 = Glue::new(storage2);\n\n        exec!(glue1 \"BEGIN;\");\n\n        // glue1 acquires lock\n        exec!(glue1 \"CREATE TABLE TxGarlic (id INTEGER);\");\n\n        // glue1 lock gets expired due to the timeout\n        sleep();\n\n        // timeout errors\n        test!(glue1 \"COMMIT;\", Err(Error::StorageMsg(\"fetch failed - expired transaction has used (timeout)\".to_owned())));\n        test!(glue1 \"SELECT * FROM TxGarlic\", Err(Error::StorageMsg(\"fetch failed - expired transaction has used (timeout)\".to_owned())));\n        assert_eq!(\n            glue1\n                .storage\n                .clone()\n                .insert_data(\"TxGarlic\", vec![])\n                .await\n                .unwrap_err(),\n            Error::StorageMsg(\"acquire failed - expired transaction has used (timeout)\".to_owned()),\n        );\n\n        exec!(glue2 \"BEGIN;\");\n        exec!(glue2 \"CREATE TABLE RealGarlic (id INTEGER);\");\n        exec!(glue1 \"ROLLBACK;\");\n        exec!(glue2 \"ROLLBACK;\");\n\n        // glue2 lock gets expired\n        sleep();\n\n        // glue1 must succeed to create tables: TxGarlic \u0026 RealGarlic\n        exec!(glue1 \"CREATE TABLE TxGarlic (id2 INTEGER);\");\n        exec!(glue1 \"CREATE TABLE RealGarlic (id2 INTEGER);\");\n\n        exec!(glue1 \"BEGIN;\");\n        exec!(glue1 \"INSERT INTO TxGarlic VALUES (10);\");\n        sleep();\n        exec!(glue2 \"INSERT INTO TxGarlic VALUES (20);\");\n        test!(glue1 \"COMMIT;\", Err(Error::StorageMsg(\"fetch failed - expired transaction has used (timeout)\".to_owned())));\n        exec!(glue1 \"ROLLBACK;\");\n\n        // glue1 lock has expired, so TxGarlic table has only a single row (20)\n        test!(\n            glue1 \"SELECT * FROM TxGarlic;\",\n            Ok(select!(id2 I64; 20))\n        );\n\n        exec!(glue1 \"BEGIN;\");\n        exec!(glue1 \"UPDATE TxGarlic SET id2 = id2 * 2;\");\n        test!(\n            glue1 \"SELECT * FROM TxGarlic;\",\n            Ok(select!(id2 I64; 40))\n        );\n\n        // glue1 lock gets expired\n        sleep();\n\n        // glue1 tx must rollback\n        test!(\n            glue2 \"SELECT * FROM TxGarlic;\",\n            Ok(select!(id2 I64; 20))\n        );\n\n        exec!(glue1 \"ROLLBACK;\");\n        test!(\n            glue1 \"SELECT * FROM TxGarlic;\",\n            Ok(select!(id2 I64; 20))\n        );\n        test!(\n            glue2 \"SELECT * FROM TxGarlic;\",\n            Ok(select!(id2 I64; 20))\n        );\n\n        // UPDATE\n        exec!(glue1 \"BEGIN;\");\n        exec!(glue1 \"UPDATE TxGarlic SET id2 = id2 + 1;\");\n        sleep();\n        exec!(glue2 \"BEGIN;\");\n        exec!(glue2 \"UPDATE TxGarlic SET id2 = id2 + 1;\");\n        exec!(glue2 \"ROLLBACK;\");\n        exec!(glue1 \"ROLLBACK;\");\n\n        // DELETE\n        exec!(glue1 \"BEGIN;\");\n        exec!(glue1 \"DELETE FROM TxGarlic;\");\n        test!(glue1 \"SELECT * FROM TxGarlic;\", Ok(select!(id2)));\n        sleep();\n        test!(glue2 \"SELECT * FROM TxGarlic;\", Ok(select!(id2 I64; 20)));\n        exec!(glue2 \"BEGIN;\");\n        exec!(glue2 \"DELETE FROM TxGarlic\");\n        exec!(glue1 \"ROLLBACK;\");\n        exec!(glue2 \"ROLLBACK;\");\n        test!(glue1 \"SELECT * FROM TxGarlic;\", Ok(select!(id2 I64; 20)));\n        test!(glue2 \"SELECT * FROM TxGarlic;\", Ok(select!(id2 I64; 20)));\n\n        // DROP TABLE\n        exec!(glue2 \"BEGIN;\");\n        exec!(glue2 \"DROP TABLE TxGarlic;\");\n        sleep();\n        test!(glue2 \"COMMIT;\", Err(Error::StorageMsg(\"fetch failed - expired transaction has used (timeout)\".to_owned())));\n        exec!(glue1 \"DROP TABLE TxGarlic;\");\n        test!(\n            glue1 \"SELECT * FROM TxGarlic;\",\n            Err(FetchError::TableNotFound(\"TxGarlic\".to_owned()).into())\n        );\n        exec!(glue2 \"ROLLBACK;\");\n        test!(\n            glue2 \"SELECT * FROM TxGarlic;\",\n            Err(FetchError::TableNotFound(\"TxGarlic\".to_owned()).into())\n        );\n    }\n\n    #[tokio::test]\n    async fn sled_transaction_timeout_alter() {\n        let path = \u0026format!(\"{}/transaction_timeout_alter\", PATH_PREFIX);\n        fs::remove_dir_all(path).unwrap_or(());\n\n        let mut storage1 = SledStorage::new(path).unwrap();\n        storage1.set_transaction_timeout(TX_TIMEOUT);\n        let storage2 = storage1.clone();\n\n        let mut glue1 = Glue::new(storage1);\n        let mut glue2 = Glue::new(storage2);\n\n        exec!(glue1 \"CREATE TABLE TxAlter (id INTEGER, num INTEGER);\");\n        exec!(glue1 \"INSERT INTO TxAlter VALUES (1, 100);\");\n\n        // DROP COLUMN\n        exec!(glue1 \"BEGIN;\");\n        exec!(glue1 \"ALTER TABLE TxAlter DROP COLUMN num;\");\n        test!(glue1 \"SELECT * FROM TxAlter;\", Ok(select!(id I64; 1)));\n        test!(glue2 \"SELECT * FROM TxAlter;\", Ok(select!(id | num I64 | I64; 1 100)));\n        sleep();\n        test!(glue2 \"SELECT * FROM TxAlter;\", Ok(select!(id | num I64 | I64; 1 100)));\n        exec!(glue2 \"BEGIN;\");\n        exec!(glue2 \"ALTER TABLE TxAlter DROP COLUMN num;\");\n        exec!(glue2 \"ROLLBACK;\");\n        test!(glue2 \"SELECT * FROM TxAlter;\", Ok(select!(id | num I64 | I64; 1 100)));\n\n        // ADD COLUMN\n        exec!(glue2 \"BEGIN;\");\n        exec!(glue2 \"ALTER TABLE TxAlter ADD COLUMN flag BOOLEAN DEFAULT TRUE;\");\n        test!(glue2 \"SELECT * FROM TxAlter;\", Ok(select!(id | num | flag I64 | I64 | Bool; 1 100 true)));\n\n        exec!(glue1 \"ROLLBACK;\");\n        test!(glue1 \"SELECT * FROM TxAlter;\", Ok(select!(id | num I64 | I64; 1 100)));\n        sleep();\n        test!(glue1 \"SELECT * FROM TxAlter;\", Ok(select!(id | num I64 | I64; 1 100)));\n        exec!(glue2 \"ROLLBACK;\");\n        test!(glue2 \"SELECT * FROM TxAlter;\", Ok(select!(id | num I64 | I64; 1 100)));\n\n        // RENAME COLUMN\n        exec!(glue1 \"BEGIN;\");\n        exec!(glue1 \"ALTER TABLE TxAlter RENAME COLUMN id TO jd;\");\n        test!(glue1 \"SELECT * FROM TxAlter;\", Ok(select!(jd | num I64 | I64; 1 100)));\n        test!(glue2 \"SELECT * FROM TxAlter;\", Ok(select!(id | num I64 | I64; 1 100)));\n        sleep();\n        exec!(glue2 \"BEGIN;\");\n        exec!(glue2 \"ALTER TABLE TxAlter RENAME COLUMN id TO kd;\");\n        exec!(glue2 \"COMMIT;\");\n        exec!(glue1 \"ROLLBACK;\");\n        test!(glue1 \"SELECT * FROM TxAlter;\", Ok(select!(kd | num I64 | I64; 1 100)));\n        test!(glue2 \"SELECT * FROM TxAlter;\", Ok(select!(kd | num I64 | I64; 1 100)));\n\n        // RENAME TABLE\n        exec!(glue2 \"BEGIN;\");\n        exec!(glue2 \"ALTER TABLE TxAlter RENAME TO TxAltericano;\");\n        test!(glue2 \"SELECT * FROM TxAltericano;\", Ok(select!(kd | num I64 | I64; 1 100)));\n        test!(\n            glue2 \"SELECT * FROM TxAlter;\",\n            Err(FetchError::TableNotFound(\"TxAlter\".to_owned()).into())\n        );\n        test!(glue1 \"SELECT * FROM TxAlter;\", Ok(select!(kd | num I64 | I64; 1 100)));\n        test!(\n            glue1 \"SELECT * FROM TxAlterericano;\",\n            Err(FetchError::TableNotFound(\"TxAlterericano\".to_owned()).into())\n        );\n        sleep();\n        exec!(glue1 \"ALTER TABLE TxAlter RENAME TO TxSoprano;\");\n        test!(glue1 \"SELECT * FROM TxSoprano;\", Ok(select!(kd | num I64 | I64; 1 100)));\n        exec!(glue2 \"ROLLBACK;\");\n        test!(glue2 \"SELECT * FROM TxSoprano;\", Ok(select!(kd | num I64 | I64; 1 100)));\n    }\n\n    #[tokio::test]\n    async fn sled_transaction_timeout_index() {\n        use crate::ast::IndexOperator::Eq;\n\n        let path = \u0026format!(\"{}/transaction_timeout_index\", PATH_PREFIX);\n        fs::remove_dir_all(path).unwrap_or(());\n\n        let mut storage1 = SledStorage::new(path).unwrap();\n        storage1.set_transaction_timeout(TX_TIMEOUT);\n        let storage2 = storage1.clone();\n\n        let mut glue1 = Glue::new(storage1);\n        let mut glue2 = Glue::new(storage2);\n\n        exec!(glue1 \"CREATE TABLE TxIndex (id INTEGER);\");\n        exec!(glue1 \"INSERT INTO TxIndex VALUES (1);\");\n\n        // CREATE INDEX\n        exec!(glue1 \"BEGIN;\");\n        exec!(glue1 \"CREATE INDEX idx_id ON TxIndex (id);\");\n        test_idx!(\n            glue1 \"SELECT * FROM TxIndex WHERE id = 1;\",\n            idx!(idx_id, Eq, \"1\"),\n            Ok(select!(id I64; 1))\n        );\n        sleep();\n        exec!(glue2 \"CREATE INDEX idx_id ON TxIndex (id);\");\n        test_idx!(\n            glue2 \"SELECT * FROM TxIndex WHERE id = 1;\",\n            idx!(idx_id, Eq, \"1\"),\n            Ok(select!(id I64; 1))\n        );\n        exec!(glue1 \"ROLLBACK;\");\n        test_idx!(\n            glue1 \"SELECT * FROM TxIndex WHERE id = 1;\",\n            idx!(idx_id, Eq, \"1\"),\n            Ok(select!(id I64; 1))\n        );\n\n        // DROP INDEX\n        exec!(glue1 \"BEGIN;\");\n        exec!(glue1 \"DROP INDEX TxIndex.idx_id;\");\n        test_idx!(\n            glue2 \"SELECT * FROM TxIndex WHERE id = 1;\",\n            idx!(idx_id, Eq, \"1\"),\n            Ok(select!(id I64; 1))\n        );\n        sleep();\n        test_idx!(\n            glue2 \"SELECT * FROM TxIndex WHERE id = 1;\",\n            idx!(idx_id, Eq, \"1\"),\n            Ok(select!(id I64; 1))\n        );\n        exec!(glue1 \"ROLLBACK;\");\n        test_idx!(\n            glue1 \"SELECT * FROM TxIndex WHERE id = 1;\",\n            idx!(idx_id, Eq, \"1\"),\n            Ok(select!(id I64; 1))\n        );\n        test_idx!(\n            glue2 \"SELECT * FROM TxIndex WHERE id = 1;\",\n            idx!(idx_id, Eq, \"1\"),\n            Ok(select!(id I64; 1))\n        );\n\n        // DROP AND DROP INDEX\n        exec!(glue1 \"BEGIN;\");\n        exec!(glue1 \"DROP INDEX TxIndex.idx_id;\");\n        exec!(glue1 \"CREATE INDEX idx_id ON TxIndex (id);\");\n        sleep();\n        test_idx!(\n            glue2 \"SELECT * FROM TxIndex WHERE id = 1;\",\n            idx!(idx_id, Eq, \"1\"),\n            Ok(select!(id I64; 1))\n        );\n        exec!(glue1 \"ROLLBACK;\");\n        test_idx!(\n            glue2 \"SELECT * FROM TxIndex WHERE id = 1;\",\n            idx!(idx_id, Eq, \"1\"),\n            Ok(select!(id I64; 1))\n        );\n        test_idx!(\n            glue1 \"SELECT * FROM TxIndex WHERE id = 1;\",\n            idx!(idx_id, Eq, \"1\"),\n            Ok(select!(id I64; 1))\n        );\n\n        exec!(glue1 \"BEGIN;\");\n        exec!(glue1 \"DROP INDEX TxIndex.idx_id;\");\n        sleep();\n        exec!(glue2 \"DROP INDEX TxIndex.idx_id;\");\n        sleep();\n        exec!(glue1 \"ROLLBACK;\");\n        exec!(glue1 \"CREATE INDEX idx_id ON TxIndex (id);\");\n        test_idx!(\n            glue2 \"SELECT * FROM TxIndex WHERE id = 1;\",\n            idx!(idx_id, Eq, \"1\"),\n            Ok(select!(id I64; 1))\n        );\n        test_idx!(\n            glue1 \"SELECT * FROM TxIndex WHERE id = 1;\",\n            idx!(idx_id, Eq, \"1\"),\n            Ok(select!(id I64; 1))\n        );\n    }\n}\n\n#[tokio::test]\nasync fn sled_transaction_dictionary() {\n    macro_rules! test_tables {\n        ($glue: ident $( $table_name: literal )*) =\u003e {\n            let expected = Payload::ShowVariable(PayloadVariable::Tables(\n                vec![$( $table_name.to_owned() ),*]\n            ));\n\n            assert_eq!($glue.execute(\"SHOW TABLES\").await, Ok(vec![expected]));\n        };\n    }\n\n    let path = \u0026format!(\"{}/dictionary\", PATH_PREFIX);\n    fs::remove_dir_all(path).unwrap_or(());\n\n    let storage = SledStorage::new(path).unwrap();\n    let mut glue1 = Glue::new(storage.clone());\n    let mut glue2 = Glue::new(storage.clone());\n    let mut glue3 = Glue::new(storage);\n\n    exec!(glue2 \"BEGIN\");\n    exec!(glue1 \"BEGIN\");\n\n    exec!(glue1 \"CREATE TABLE Foo (id INTEGER);\");\n    test_tables!(glue1 \"Foo\");\n    test_tables!(glue2);\n    test_tables!(glue3);\n\n    exec!(glue1 \"COMMIT\");\n    test_tables!(glue1 \"Foo\");\n    test_tables!(glue2);\n    test_tables!(glue3 \"Foo\");\n\n    exec!(glue2 \"CREATE TABLE Bar (id INTEGER);\");\n    exec!(glue2 \"CREATE TABLE Qux (id INTEGER);\");\n    test_tables!(glue1 \"Foo\");\n    test_tables!(glue2 \"Bar\" \"Qux\");\n    test_tables!(glue3 \"Foo\");\n\n    exec!(glue2 \"ROLLBACK\");\n    test_tables!(glue1 \"Foo\");\n    test_tables!(glue2 \"Foo\");\n    test_tables!(glue3 \"Foo\");\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","web-storage","src","lib.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n#![deny(clippy::str_to_string)]\n\nuse {\n    async_trait::async_trait,\n    futures::stream::iter,\n    gloo_storage::{LocalStorage, SessionStorage, Storage, errors::StorageError},\n    gluesql_core::{\n        ast::ColumnUniqueOption,\n        data::{Key, Schema},\n        error::{Error, Result},\n        store::{\n            AlterTable, CustomFunction, CustomFunctionMut, DataRow, Index, IndexMut, Metadata,\n            RowIter, Store, StoreMut, Transaction,\n        },\n    },\n    serde::{Deserialize, Serialize},\n    uuid::Uuid,\n};\n\n/// gluesql-schema-names -\u003e {Vec\u003cString\u003e}\nconst TABLE_NAMES_PATH: \u0026str = \"gluesql-schema-names\";\n\n/// gluesql-schema/{schema_name} -\u003e {Schema}\nconst SCHEMA_PATH: \u0026str = \"gluesql-schema\";\n\n/// gluesql-data/{table_name} -\u003e {Vec\u003cDataRow\u003e}\nconst DATA_PATH: \u0026str = \"gluesql-data\";\n\n#[derive(Clone, Copy, Default, Serialize, Deserialize)]\npub enum WebStorageType {\n    #[default]\n    Local,\n    Session,\n}\n\n#[derive(Clone, Default, Serialize, Deserialize)]\npub struct WebStorage {\n    storage_type: WebStorageType,\n}\n\nimpl WebStorage {\n    pub fn new(storage_type: WebStorageType) -\u003e Self {\n        Self { storage_type }\n    }\n\n    pub fn raw(\u0026self) -\u003e web_sys::Storage {\n        match self.storage_type {\n            WebStorageType::Local =\u003e LocalStorage::raw(),\n            WebStorageType::Session =\u003e SessionStorage::raw(),\n        }\n    }\n\n    pub fn get\u003cT\u003e(\u0026self, key: impl AsRef\u003cstr\u003e) -\u003e Result\u003cOption\u003cT\u003e\u003e\n    where\n        T: for\u003c'de\u003e Deserialize\u003c'de\u003e,\n    {\n        let value = match self.storage_type {\n            WebStorageType::Local =\u003e LocalStorage::get(key),\n            WebStorageType::Session =\u003e SessionStorage::get(key),\n        };\n\n        match value {\n            Ok(value) =\u003e Ok(Some(value)),\n            Err(StorageError::KeyNotFound(_)) =\u003e Ok(None),\n            Err(e) =\u003e Err(Error::StorageMsg(e.to_string())),\n        }\n    }\n\n    pub fn set\u003cT\u003e(\u0026self, key: impl AsRef\u003cstr\u003e, value: T) -\u003e Result\u003c()\u003e\n    where\n        T: Serialize,\n    {\n        match self.storage_type {\n            WebStorageType::Local =\u003e LocalStorage::set(key, value),\n            WebStorageType::Session =\u003e SessionStorage::set(key, value),\n        }\n        .map_err(|e| Error::StorageMsg(e.to_string()))\n    }\n\n    pub fn delete(\u0026self, key: impl AsRef\u003cstr\u003e) {\n        match self.storage_type {\n            WebStorageType::Local =\u003e LocalStorage::delete(key),\n            WebStorageType::Session =\u003e SessionStorage::delete(key),\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl Store for WebStorage {\n    async fn fetch_all_schemas(\u0026self) -\u003e Result\u003cVec\u003cSchema\u003e\u003e {\n        let mut table_names: Vec\u003cString\u003e = self.get(TABLE_NAMES_PATH)?.unwrap_or_default();\n        table_names.sort();\n\n        table_names\n            .iter()\n            .filter_map(|table_name| {\n                self.get(format!(\"{}/{}\", SCHEMA_PATH, table_name))\n                    .transpose()\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()\n    }\n\n    async fn fetch_schema(\u0026self, table_name: \u0026str) -\u003e Result\u003cOption\u003cSchema\u003e\u003e {\n        self.get(format!(\"{}/{}\", SCHEMA_PATH, table_name))\n    }\n\n    async fn fetch_data(\u0026self, table_name: \u0026str, target: \u0026Key) -\u003e Result\u003cOption\u003cDataRow\u003e\u003e {\n        let path = format!(\"{}/{}\", DATA_PATH, table_name);\n        let row = self\n            .get::\u003cVec\u003c(Key, DataRow)\u003e\u003e(path)?\n            .unwrap_or_default()\n            .into_iter()\n            .find_map(|(key, row)| (\u0026key == target).then_some(row));\n\n        Ok(row)\n    }\n\n    async fn scan_data\u003c'a\u003e(\u0026'a self, table_name: \u0026str) -\u003e Result\u003cRowIter\u003c'a\u003e\u003e {\n        let path = format!(\"{}/{}\", DATA_PATH, table_name);\n        let mut rows = self.get::\u003cVec\u003c(Key, DataRow)\u003e\u003e(path)?.unwrap_or_default();\n\n        match self.get(format!(\"{}/{}\", SCHEMA_PATH, table_name))? {\n            Some(Schema {\n                column_defs: Some(column_defs),\n                ..\n            }) if column_defs.iter().any(|column_def| {\n                matches!(\n                    column_def.unique,\n                    Some(ColumnUniqueOption { is_primary: true })\n                )\n            }) =\u003e\n            {\n                rows.sort_by(|(key_a, _), (key_b, _)| key_a.cmp(key_b));\n            }\n            _ =\u003e {}\n        }\n\n        Ok(Box::pin(iter(rows.into_iter().map(Ok))))\n    }\n}\n\n#[async_trait(?Send)]\nimpl StoreMut for WebStorage {\n    async fn insert_schema(\u0026mut self, schema: \u0026Schema) -\u003e Result\u003c()\u003e {\n        let mut table_names: Vec\u003cString\u003e = self.get(TABLE_NAMES_PATH)?.unwrap_or_default();\n        table_names.push(schema.table_name.clone());\n\n        self.set(TABLE_NAMES_PATH, table_names)?;\n        self.set(format!(\"{}/{}\", SCHEMA_PATH, schema.table_name), schema)\n    }\n\n    async fn delete_schema(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let mut table_names: Vec\u003cString\u003e = self.get(TABLE_NAMES_PATH)?.unwrap_or_default();\n        table_names\n            .iter()\n            .position(|name| name == table_name)\n            .map(|i| table_names.remove(i));\n\n        self.set(TABLE_NAMES_PATH, table_names)?;\n        self.delete(format!(\"{}/{}\", SCHEMA_PATH, table_name));\n        self.delete(format!(\"{}/{}\", DATA_PATH, table_name));\n        Ok(())\n    }\n\n    async fn append_data(\u0026mut self, table_name: \u0026str, new_rows: Vec\u003cDataRow\u003e) -\u003e Result\u003c()\u003e {\n        let path = format!(\"{}/{}\", DATA_PATH, table_name);\n        let rows = self.get::\u003cVec\u003c(Key, DataRow)\u003e\u003e(\u0026path)?.unwrap_or_default();\n        let new_rows = new_rows.into_iter().map(|row| {\n            let key = Key::Uuid(Uuid::new_v4().as_u128());\n\n            (key, row)\n        });\n\n        let rows = rows.into_iter().chain(new_rows).collect::\u003cVec\u003c_\u003e\u003e();\n\n        self.set(path, rows)\n    }\n\n    async fn insert_data(\u0026mut self, table_name: \u0026str, new_rows: Vec\u003c(Key, DataRow)\u003e) -\u003e Result\u003c()\u003e {\n        let path = format!(\"{}/{}\", DATA_PATH, table_name);\n        let mut rows = self.get::\u003cVec\u003c(Key, DataRow)\u003e\u003e(\u0026path)?.unwrap_or_default();\n\n        for (key, row) in new_rows.into_iter() {\n            if let Some(i) = rows.iter().position(|(k, _)| k == \u0026key) {\n                rows[i] = (key, row);\n            } else {\n                rows.push((key, row));\n            }\n        }\n\n        self.set(path, rows)\n    }\n\n    async fn delete_data(\u0026mut self, table_name: \u0026str, keys: Vec\u003cKey\u003e) -\u003e Result\u003c()\u003e {\n        let path = format!(\"{}/{}\", DATA_PATH, table_name);\n        let mut rows = self.get::\u003cVec\u003c(Key, DataRow)\u003e\u003e(\u0026path)?.unwrap_or_default();\n\n        for key in keys.iter() {\n            if let Some(i) = rows.iter().position(|(k, _)| k == key) {\n                rows.remove(i);\n            }\n        }\n\n        self.set(path, rows)\n    }\n}\n\nimpl AlterTable for WebStorage {}\nimpl Index for WebStorage {}\nimpl IndexMut for WebStorage {}\nimpl Transaction for WebStorage {}\nimpl Metadata for WebStorage {}\nimpl CustomFunction for WebStorage {}\nimpl CustomFunctionMut for WebStorage {}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":30},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","web-storage","tests","local_storage.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n\nuse {\n    async_trait::async_trait,\n    gluesql_core::prelude::Glue,\n    gluesql_web_storage::{WebStorage, WebStorageType},\n    test_suite::*,\n    wasm_bindgen_test::{wasm_bindgen_test, wasm_bindgen_test_configure},\n};\n\nwasm_bindgen_test_configure!(run_in_browser);\n\nstruct LocalStorageTester {\n    glue: Glue\u003cWebStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cWebStorage\u003e for LocalStorageTester {\n    async fn new(_: \u0026str) -\u003e Self {\n        let storage = WebStorage::new(WebStorageType::Local);\n        storage.raw().clear().unwrap();\n\n        let glue = Glue::new(storage);\n\n        LocalStorageTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cWebStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(wasm_bindgen_test, LocalStorageTester);\ngenerate_alter_table_tests!(wasm_bindgen_test, LocalStorageTester);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","storages","web-storage","tests","session_storage.rs"],"content":"#![cfg(target_arch = \"wasm32\")]\n\nuse {\n    async_trait::async_trait,\n    gluesql_core::prelude::Glue,\n    gluesql_web_storage::{WebStorage, WebStorageType},\n    test_suite::*,\n    wasm_bindgen_test::{wasm_bindgen_test, wasm_bindgen_test_configure},\n};\n\nwasm_bindgen_test_configure!(run_in_browser);\n\nstruct SessionStorageTester {\n    glue: Glue\u003cWebStorage\u003e,\n}\n\n#[async_trait(?Send)]\nimpl Tester\u003cWebStorage\u003e for SessionStorageTester {\n    async fn new(_: \u0026str) -\u003e Self {\n        let storage = WebStorage::new(WebStorageType::Session);\n        storage.raw().clear().unwrap();\n\n        let glue = Glue::new(storage);\n\n        SessionStorageTester { glue }\n    }\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cWebStorage\u003e {\n        \u0026mut self.glue\n    }\n}\n\ngenerate_store_tests!(wasm_bindgen_test, SessionStorageTester);\ngenerate_alter_table_tests!(wasm_bindgen_test, SessionStorageTester);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","aggregate","avg.rs"],"content":"use {crate::*, gluesql_core::prelude::Value::*};\n\ntest_case!(avg, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Item (\n            id INTEGER,\n            quantity INTEGER,\n            age INTEGER NULL,\n            total INTEGER\n        );\n    \",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Item (id, quantity, age, total) VALUES\n            (1, 10,   11, 1),\n            (2,  0,   90, 2),\n            (3,  9, NULL, 3),\n            (4,  3,    3, 1),\n            (5, 25, NULL, 1);\n    \",\n    )\n    .await;\n\n    let test_cases = [\n        (\n            \"SELECT AVG(age) FROM Item\",\n            select_with_null!(\"AVG(age)\"; Null),\n        ),\n        (\n            \"SELECT AVG(id), AVG(quantity) FROM Item\",\n            select!(\n                \"AVG(id)\" | \"AVG(quantity)\"\n                F64       | F64;\n                3.0         9.4\n            ),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","aggregate","count.rs"],"content":"use {crate::*, gluesql_core::prelude::Value::*};\n\ntest_case!(count, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Item (\n            id INTEGER,\n            quantity INTEGER NULL,\n            age INTEGER NULL,\n            total INTEGER\n        );\n    \",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Item (id, quantity, age, total) VALUES\n            (1, NULL,   11, 1),\n            (2,  0,   90, 2),\n            (3,  9, NULL, 3),\n            (4,  3,    3, 1),\n            (5, 25, NULL, 1);\n    \",\n    )\n    .await;\n\n    let test_cases = [\n        (\n            \"SELECT COUNT(*) FROM Item;\",\n            select!(\n                \"COUNT(*)\";\n                I64;\n                5\n            ),\n        ),\n        (\n            \"SELECT COUNT(age), COUNT(quantity) FROM Item;\",\n            select!(\n                \"COUNT(age)\" | \"COUNT(quantity)\";\n                I64          |               I64;\n                3                              4\n            ),\n        ),\n        (\n            \"SELECT COUNT(NULL);\",\n            select!(\n                \"COUNT(NULL)\";\n                I64;\n                0\n            ),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","aggregate","error.rs"],"content":"use {\n    crate::*,\n    gluesql_core::error::{EvaluateError, TranslateError},\n};\n\ntest_case!(error, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Item (\n            id INTEGER,\n            quantity INTEGER,\n            age INTEGER NULL,\n            total INTEGER\n        );\n    \",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Item (id, quantity, age, total) VALUES\n            (1, 10,   11, 1),\n            (2,  0,   90, 2),\n            (3,  9, NULL, 3),\n            (4,  3,    3, 1),\n            (5, 25, NULL, 1);\n    \",\n    )\n    .await;\n\n    let test_cases = [\n        (\n            \"SELECT SUM(num) FROM Item;\",\n            EvaluateError::IdentifierNotFound(\"num\".to_owned()).into(),\n        ),\n        (\n            \"SELECT COUNT(Foo.*) FROM Item;\",\n            TranslateError::QualifiedWildcardInCountNotSupported(\"Foo.*\".to_owned()).into(),\n        ),\n        (\n            \"SELECT SUM(*) FROM Item;\",\n            TranslateError::WildcardFunctionArgNotAccepted.into(),\n        ),\n    ];\n\n    for (sql, error) in test_cases {\n        g.test(sql, Err(error)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","aggregate","group_by.rs"],"content":"use {crate::*, gluesql_core::prelude::Value::*};\n\ntest_case!(group_by, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Item (\n            id INTEGER,\n            quantity INTEGER NULL,\n            city TEXT,\n            ratio FLOAT\n        );\n    \",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Item (id, quantity, city, ratio) VALUES\n            (1,   10,   'Seoul',  0.2),\n            (2,    0,   'Dhaka', 6.11),\n            (3, NULL, 'Beijing',  1.1),\n            (3,   30, 'Daejeon',  0.2),\n            (4,   11,   'Seoul',  1.1),\n            (5,   24, 'Seattle', 6.11);\n    \",\n    )\n    .await;\n    let test_cases = [\n        (\n            \"SELECT id, COUNT(*) FROM Item GROUP BY id\",\n            select!(\n                id  | \"COUNT(*)\";\n                I64 | I64;\n                1       1;\n                2       1;\n                3       2;\n                4       1;\n                5       1\n            ),\n        ),\n        (\n            \"SELECT id FROM Item GROUP BY id\",\n            select!(id; I64; 1; 2; 3; 4; 5),\n        ),\n        (\n            \"SELECT SUM(quantity), COUNT(*), city FROM Item GROUP BY city\",\n            select_with_null!(\n                \"SUM(quantity)\" | \"COUNT(*)\" | city;\n                I64(21)           I64(2)       Str(\"Seoul\".to_owned());\n                I64(0)            I64(1)       Str(\"Dhaka\".to_owned());\n                Null              I64(1)       Str(\"Beijing\".to_owned());\n                I64(30)           I64(1)       Str(\"Daejeon\".to_owned());\n                I64(24)           I64(1)       Str(\"Seattle\".to_owned())\n            ),\n        ),\n        (\n            \"SELECT id, city FROM Item GROUP BY city\",\n            select!(\n                id  | city\n                I64 | Str;\n                1     \"Seoul\".to_owned();\n                2     \"Dhaka\".to_owned();\n                3     \"Beijing\".to_owned();\n                3     \"Daejeon\".to_owned();\n                5     \"Seattle\".to_owned()\n            ),\n        ),\n        (\n            \"SELECT ratio, COUNT(*) FROM Item GROUP BY ratio\",\n            select!(\n                ratio | \"COUNT(*)\"\n                F64   | I64;\n                0.2     2;\n                6.11    2;\n                1.1     2\n            ),\n        ),\n        (\n            \"SELECT ratio FROM Item GROUP BY id, city\",\n            select!(ratio; F64; 0.2; 6.11; 1.1; 0.2; 1.1; 6.11),\n        ),\n        (\n            \"SELECT id, ratio FROM Item GROUP BY id, city HAVING ratio \u003e 6\",\n            select!(id | ratio; I64 | F64; 2 6.11; 5 6.11),\n        ),\n        (\n            \"SELECT SUM(quantity), COUNT(*), city FROM Item GROUP BY city HAVING COUNT(*) \u003e 1\",\n            select!(\n                \"SUM(quantity)\" | \"COUNT(*)\" | city\n                I64             | I64        | Str;\n                21                2            \"Seoul\".to_owned()\n            ),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n\n    g.run(\"CREATE TABLE Sub (id INTEGER);\").await;\n    g.run(\"INSERT INTO Sub VALUES (101), (102), (103), (104), (105);\")\n        .await;\n    g.named_test(\n        \"HAVING - nested select context handling edge case\",\n        \"\n            SELECT id\n            FROM Sub\n            WHERE (id - 100) IN (\n                SELECT id\n                FROM Item\n                GROUP BY id\n                HAVING id \u003c= 3\n            )\",\n        Ok(select!(id I64; 101; 102; 103)),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","aggregate","max.rs"],"content":"use {crate::*, gluesql_core::prelude::Value::*};\n\ntest_case!(max, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Item (\n            id INTEGER,\n            quantity INTEGER,\n            age INTEGER NULL,\n            total INTEGER\n        );\n    \",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Item (id, quantity, age, total) VALUES\n            (1, 10,   11, 1),\n            (2,  0,   90, 2),\n            (3,  9, NULL, 3),\n            (4,  3,    3, 1),\n            (5, 25, NULL, 1);\n    \",\n    )\n    .await;\n\n    let test_cases = [\n        (\n            \"SELECT MAX(age) FROM Item\",\n            select_with_null!(\n                \"MAX(age)\";\n                I64(90)\n            ),\n        ),\n        (\n            \"SELECT MAX(id), MAX(quantity) FROM Item\",\n            select!(\n                \"MAX(id)\" | \"MAX(quantity)\"\n                I64       | I64;\n                5           25\n            ),\n        ),\n        (\n            \"SELECT MAX(id - quantity) FROM Item;\",\n            select!(\n                \"MAX(id - quantity)\"\n                I64;\n                2\n            ),\n        ),\n        (\n            \"SELECT SUM(quantity) * 2 + MAX(quantity) - 3 / 1 FROM Item\",\n            select!(\"SUM(quantity) * 2 + MAX(quantity) - 3 / 1\"; I64; 116),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","aggregate","min.rs"],"content":"use {crate::*, gluesql_core::prelude::Value::*};\n\ntest_case!(min, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Item (\n            id INTEGER,\n            quantity INTEGER,\n            age INTEGER NULL,\n            total INTEGER\n        );\n    \",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Item (id, quantity, age, total) VALUES\n            (1, 10,   11, 1),\n            (2,  0,   90, 2),\n            (3,  9, NULL, 3),\n            (4,  3,    3, 1),\n            (5, 25, NULL, 1);\n    \",\n    )\n    .await;\n    let test_cases = [\n        (\n            \"SELECT MIN(age) FROM Item\",\n            select_with_null!(\n                \"MIN(age)\";\n                I64(3)\n            ),\n        ),\n        (\n            \"SELECT MIN(id), MIN(quantity) FROM Item\",\n            select!(\n                \"MIN(id)\" | \"MIN(quantity)\"\n                I64       | I64;\n                1           0\n            ),\n        ),\n        (\n            \"SELECT MIN(id + quantity) FROM Item;\",\n            select!(\n                \"MIN(id + quantity)\"\n                I64;\n                2\n            ),\n        ),\n        (\n            \"SELECT SUM(quantity) * 2 + MIN(quantity) - 3 / 1 FROM Item;\",\n            select!(\n                \"SUM(quantity) * 2 + MIN(quantity) - 3 / 1\"\n                I64;\n                91\n            ),\n        ),\n        (\n            \"SELECT MIN(CASE WHEN quantity \u003e 5 THEN id END) FROM Item;\",\n            select!(\n                \"MIN(CASE WHEN quantity \u003e 5 THEN id END)\"\n                I64;\n                1\n            ),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","aggregate","stdev.rs"],"content":"use {crate::*, gluesql_core::prelude::Value::*};\n\ntest_case!(stdev, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n    CREATE TABLE Item (\n        id INTEGER,\n        quantity INTEGER,\n        age INTEGER NULL,\n        total INTEGER\n    );\n    \",\n    )\n    .await;\n    g.run(\n        \"\n    INSERT INTO Item (id, quantity, age, total) VALUES\n        (1, 10,   11, 1),\n        (2,  0,   90, 2),\n        (3,  9, NULL, 3),\n        (4,  3,    3, 1),\n        (5, 25, NULL, 1);\n    \",\n    )\n    .await;\n\n    let test_cases = [\n        (\n            \"SELECT STDEV(age) FROM Item\",\n            select_with_null!(\"STDEV(age)\"; Null),\n        ),\n        (\n            \"SELECT STDEV(total) FROM Item\",\n            select!(\n                \"STDEV(total)\"\n                F64;\n                0.8\n            ),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","aggregate","sum.rs"],"content":"use {crate::*, gluesql_core::prelude::Value::*};\n\ntest_case!(sum, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Item (\n            id INTEGER,\n            quantity INTEGER,\n            age INTEGER NULL,\n            total INTEGER\n        );\n    \",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Item (id, quantity, age, total) VALUES\n            (1, 10,   11, 1),\n            (2,  0,   90, 2),\n            (3,  9, NULL, 3),\n            (4,  3,    3, 1),\n            (5, 25, NULL, 1);\n    \",\n    )\n    .await;\n\n    let test_cases = [\n        (\n            \"SELECT SUM(age) FROM Item\",\n            select_with_null!(\n                \"SUM(age)\";\n                Null\n            ),\n        ),\n        (\n            \"SELECT SUM(id), SUM(quantity) FROM Item\",\n            select!(\n                \"SUM(id)\" | \"SUM(quantity)\"\n                I64             | I64;\n                15                47\n            ),\n        ),\n        (\n            \"SELECT SUM(ifnull(age, 0)) from Item;\",\n            select!(\n                \"SUM(ifnull(age, 0))\"\n                I64;\n                104\n            ),\n        ),\n        (\n            \"SELECT SUM(1 + 2) FROM Item;\",\n            select!(\n                \"SUM(1 + 2)\"\n                I64;\n                15\n            ),\n        ),\n        (\n            \"SELECT SUM(id + 1) FROM Item;\",\n            select!(\n                \"SUM(id + 1)\"\n                I64;\n                20\n            ),\n        ),\n        (\n            \"SELECT SUM(id * quantity) FROM Item;\",\n            select!(\n                \"SUM(id * quantity)\"\n                I64;\n                174\n            ),\n        ),\n        (\n            \"SELECT SUM(CASE WHEN id \u003e 3 THEN quantity ELSE 0 END) FROM Item;\",\n            select!(\n                \"SUM(CASE WHEN id \u003e 3 THEN quantity ELSE 0 END)\"\n                I64;\n                28\n            ),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","aggregate","variance.rs"],"content":"use {crate::*, gluesql_core::prelude::Value::*};\n\ntest_case!(variance, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n    CREATE TABLE Item (\n        id INTEGER,\n        quantity INTEGER,\n        age INTEGER NULL,\n        total INTEGER\n    );\n    \",\n    )\n    .await;\n    g.run(\n        \"\n    INSERT INTO Item (id, quantity, age, total) VALUES\n        (1, 10,   11, 1),\n        (2,  0,   90, 2),\n        (3,  9, NULL, 3),\n        (4,  3,    3, 1),\n        (5, 25, NULL, 1);\n    \",\n    )\n    .await;\n\n    let test_cases = [\n        (\n            \"SELECT VARIANCE(age) FROM Item\",\n            select_with_null!(\"VARIANCE(age)\"; Null),\n        ),\n        (\n            \"SELECT VARIANCE(id), VARIANCE(quantity) FROM Item\",\n            select!(\n                \"VARIANCE(id)\" | \"VARIANCE(quantity)\"\n                F64            | F64;\n                2.0              74.64\n            ),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","aggregate.rs"],"content":"pub mod avg;\npub mod count;\npub mod error;\npub mod group_by;\npub mod max;\npub mod min;\npub mod stdev;\npub mod sum;\npub mod variance;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","alter","alter_table.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast::*,\n        data::Value::*,\n        error::{AlterError, AlterTableError, EvaluateError, TranslateError},\n        executor::Referencing,\n        prelude::Payload,\n    },\n};\n\ntest_case!(alter_table_rename, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Foo (id INTEGER, name TEXT);\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO Foo VALUES (1, 'a'), (2, 'b'), (3, 'c');\",\n            Ok(Payload::Insert(3)),\n        ),\n        (\"SELECT id FROM Foo\", Ok(select!(id; I64; 1; 2; 3))),\n        (\n            \"ALTER TABLE Foo2 RENAME TO Bar;\",\n            Err(AlterTableError::TableNotFound(\"Foo2\".to_owned()).into()),\n        ),\n        (\"ALTER TABLE Foo RENAME TO Bar;\", Ok(Payload::AlterTable)),\n        (\"SELECT id FROM Bar\", Ok(select!(id; I64; 1; 2; 3))),\n        (\n            \"ALTER TABLE Bar RENAME COLUMN id TO new_id\",\n            Ok(Payload::AlterTable),\n        ),\n        (\"SELECT new_id FROM Bar\", Ok(select!(new_id; I64; 1; 2; 3))),\n        (\n            \"ALTER TABLE Bar RENAME COLUMN hello TO idid\",\n            Err(AlterTableError::RenamingColumnNotFound.into()),\n        ),\n        (\n            // Cannot rename to duplicated column name\n            \"ALTER TABLE Bar RENAME COLUMN name TO new_id\",\n            Err(AlterTableError::AlreadyExistingColumn(\"new_id\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(alter_table_add_drop, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\"CREATE TABLE Foo (id INTEGER);\", Ok(Payload::Create)),\n        (\"INSERT INTO Foo VALUES (1), (2);\", Ok(Payload::Insert(2))),\n        (\"SELECT * FROM Foo;\", Ok(select!(id; I64; 1; 2))),\n        (\n            \"ALTER TABLE Foo ADD COLUMN amount INTEGER NOT NULL\",\n            Err(AlterTableError::DefaultValueRequired(ColumnDef {\n                name: \"amount\".to_owned(),\n                data_type: DataType::Int,\n                nullable: false,\n                default: None,\n                unique: None,\n                comment: None,\n            })\n            .into()),\n        ),\n        (\n            \"ALTER TABLE Foo ADD COLUMN id INTEGER\",\n            Err(AlterTableError::AlreadyExistingColumn(\"id\".to_owned()).into()),\n        ),\n        (\n            \"ALTER TABLE Foo ADD COLUMN amount INTEGER DEFAULT 10\",\n            Ok(Payload::AlterTable),\n        ),\n        (\n            \"SELECT * FROM Foo;\",\n            Ok(select!(id | amount; I64 | I64; 1 10; 2 10)),\n        ),\n        (\n            \"ALTER TABLE Foo ADD COLUMN opt BOOLEAN NULL\",\n            Ok(Payload::AlterTable),\n        ),\n        (\n            \"SELECT * FROM Foo;\",\n            Ok(select_with_null!(\n                id     | amount  | opt;\n                I64(1)   I64(10)   Null;\n                I64(2)   I64(10)   Null\n            )),\n        ),\n        (\n            \"ALTER TABLE Foo ADD COLUMN opt2 BOOLEAN NULL DEFAULT true\",\n            Ok(Payload::AlterTable),\n        ),\n        (\n            \"SELECT * FROM Foo;\",\n            Ok(select_with_null!(\n                id     | amount  | opt  | opt2;\n                I64(1)   I64(10)   Null   Bool(true);\n                I64(2)   I64(10)   Null   Bool(true)\n            )),\n        ),\n        (\n            \"ALTER TABLE Foo ADD COLUMN something INTEGER DEFAULT (SELECT id FROM Bar LIMIT 1)\",\n            Err(\n                EvaluateError::UnsupportedStatelessExpr(expr(\"(SELECT id FROM Bar LIMIT 1)\"))\n                    .into(),\n            ),\n        ),\n        (\n            \"ALTER TABLE Foo ADD COLUMN something SOMEWHAT\",\n            Err(TranslateError::UnsupportedDataType(\"SOMEWHAT\".to_owned()).into()),\n        ),\n        (\n            \"ALTER TABLE Foo ADD COLUMN something FLOAT UNIQUE\",\n            Err(AlterError::UnsupportedDataTypeForUniqueColumn(\n                \"something\".to_owned(),\n                DataType::Float,\n            )\n            .into()),\n        ),\n        (\n            \"ALTER TABLE Foo DROP COLUMN IF EXISTS something;\",\n            Ok(Payload::AlterTable),\n        ),\n        (\n            \"ALTER TABLE Foo DROP COLUMN something;\",\n            Err(AlterTableError::DroppingColumnNotFound(\"something\".to_owned()).into()),\n        ),\n        (\n            \"ALTER TABLE Foo DROP COLUMN amount;\",\n            Ok(Payload::AlterTable),\n        ),\n        (\n            \"SELECT * FROM Foo;\",\n            Ok(select_with_null!(\n                id     | opt  | opt2;\n                I64(1)   Null   Bool(true);\n                I64(2)   Null   Bool(true)\n            )),\n        ),\n        (\n            \"ALTER TABLE Foo DROP COLUMN IF EXISTS opt2;\",\n            Ok(Payload::AlterTable),\n        ),\n        (\n            \"SELECT * FROM Foo;\",\n            Ok(select_with_null!(\n                id     | opt;\n                I64(1)   Null;\n                I64(2)   Null\n            )),\n        ),\n        (\n            r#\"ALTER TABLE Foo ADD CONSTRAINT \"hey\" PRIMARY KEY (asdf);\"#,\n            Err(TranslateError::UnsupportedAlterTableOperation(\n                r#\"ADD CONSTRAINT \"hey\" PRIMARY KEY (asdf)\"#.to_owned(),\n            )\n            .into()),\n        ),\n        (\n            \"ALTER TABLE Foo ADD CONSTRAINT hello UNIQUE (id)\",\n            Err(TranslateError::UnsupportedAlterTableOperation(\n                \"ADD CONSTRAINT hello UNIQUE (id)\".to_owned(),\n            )\n            .into()),\n        ),\n        (\n            \"CREATE TABLE Referenced (id INTEGER PRIMARY KEY);\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"CREATE TABLE Referencing (\n                id INTEGER,\n                referenced_id INTEGER,\n                FOREIGN KEY (referenced_id) REFERENCES Referenced (id)\n          );\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"ALTER TABLE Referenced DROP COLUMN id\",\n            Err(AlterError::CannotAlterReferencedColumn {\n                referencing: Referencing {\n                    table_name: \"Referencing\".to_owned(),\n                    foreign_key: ForeignKey {\n                        name: \"FK_referenced_id-Referenced_id\".to_owned(),\n                        referencing_column_name: \"referenced_id\".to_owned(),\n                        referenced_table_name: \"Referenced\".to_owned(),\n                        referenced_column_name: \"id\".to_owned(),\n                        on_delete: ReferentialAction::NoAction,\n                        on_update: ReferentialAction::NoAction,\n                    },\n                },\n            }\n            .into()),\n        ),\n        (\n            \"ALTER TABLE Referenced RENAME COLUMN id to new_id\",\n            Err(AlterError::CannotAlterReferencedColumn {\n                referencing: Referencing {\n                    table_name: \"Referencing\".to_owned(),\n                    foreign_key: ForeignKey {\n                        name: \"FK_referenced_id-Referenced_id\".to_owned(),\n                        referencing_column_name: \"referenced_id\".to_owned(),\n                        referenced_table_name: \"Referenced\".to_owned(),\n                        referenced_column_name: \"id\".to_owned(),\n                        on_delete: ReferentialAction::NoAction,\n                        on_update: ReferentialAction::NoAction,\n                    },\n                },\n            }\n            .into()),\n        ),\n        (\n            \"ALTER TABLE Referencing DROP COLUMN referenced_id\",\n            Err(AlterError::CannotAlterReferencingColumn {\n                referencing: Referencing {\n                    table_name: \"Referencing\".to_owned(),\n                    foreign_key: ForeignKey {\n                        name: \"FK_referenced_id-Referenced_id\".to_owned(),\n                        referencing_column_name: \"referenced_id\".to_owned(),\n                        referenced_table_name: \"Referenced\".to_owned(),\n                        referenced_column_name: \"id\".to_owned(),\n                        on_delete: ReferentialAction::NoAction,\n                        on_update: ReferentialAction::NoAction,\n                    },\n                },\n            }\n            .into()),\n        ),\n        (\n            \"ALTER TABLE Referencing RENAME COLUMN referenced_id to new_id\",\n            Err(AlterError::CannotAlterReferencingColumn {\n                referencing: Referencing {\n                    table_name: \"Referencing\".to_owned(),\n                    foreign_key: ForeignKey {\n                        name: \"FK_referenced_id-Referenced_id\".to_owned(),\n                        referencing_column_name: \"referenced_id\".to_owned(),\n                        referenced_table_name: \"Referenced\".to_owned(),\n                        referenced_column_name: \"id\".to_owned(),\n                        on_delete: ReferentialAction::NoAction,\n                        on_update: ReferentialAction::NoAction,\n                    },\n                },\n            }\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","alter","create_table.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        data::value::Value::{I64, Null, Str},\n        error::{AlterError, EvaluateError, TranslateError},\n        prelude::Payload,\n    },\n};\n\ntest_case!(create_table, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"\n        CREATE TABLE CreateTable1 (\n            id INTEGER NULL,\n            num INTEGER,\n            name TEXT\n        )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"\n        CREATE TABLE CreateTable1 (\n            id INTEGER NULL,\n            num INTEGER,\n            name TEXT COMMENT 'this is comment for name column'\n        )\",\n            Err(AlterError::TableAlreadyExists(\"CreateTable1\".to_owned()).into()),\n        ),\n        (\n            \"\n        CREATE TABLE IF NOT EXISTS CreateTable2 (\n            id INTEGER NULL,\n            num INTEGER,\n            name TEXT\n        )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"\n        CREATE TABLE IF NOT EXISTS CreateTable2 (\n            id2 INTEGER NULL\n        )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO CreateTable2 VALUES (NULL, 1, '1');\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"INSERT INTO CreateTable2 VALUES (2, 2, '2');\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"CREATE TABLE Gluery (id SOMEWHAT);\",\n            Err(TranslateError::UnsupportedDataType(\"SOMEWHAT\".to_owned()).into()),\n        ),\n        (\n            \"CREATE TABLE Gluery (id GLOBE);\",\n            Err(TranslateError::UnsupportedDataType(\"GLOBE\".to_owned()).into()),\n        ),\n        (\n            \"CREATE TABLE Gluery (id INTEGER CHECK (true));\",\n            Err(TranslateError::UnsupportedColumnOption(\"CHECK (true)\".to_owned()).into()),\n        ),\n        (\n            \"\n        CREATE TABLE CreateTable3 (\n            id INTEGER,\n            ratio FLOAT UNIQUE\n        )\",\n            Err(AlterError::UnsupportedDataTypeForUniqueColumn(\n                \"ratio\".to_owned(),\n                gluesql_core::ast::DataType::Float,\n            )\n            .into()),\n        ),\n        (\n            \"CREATE TABLE Gluery (id INTEGER DEFAULT (SELECT id FROM Wow))\",\n            Err(EvaluateError::UnsupportedStatelessExpr(expr(\"(SELECT id FROM Wow)\")).into()),\n        ),\n        (\n            // Create schema only\n            \"CREATE TABLE TargetTable AS SELECT * FROM CreateTable2 WHERE 1 = 0\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"CREATE TABLE TargetTableWithData AS SELECT * FROM CreateTable2\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"SELECT * FROM TargetTableWithData\",\n            Ok(select_with_null!(\n                id     | num    | name;\n                Null     I64(1)   Str(\"1\".to_owned());\n                I64(2)   I64(2)   Str(\"2\".to_owned())\n            )),\n        ),\n        (\n            \"CREATE TABLE TargetTableWithLimit AS SELECT * FROM CreateTable2 LIMIT 1\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"SELECT * FROM TargetTableWithLimit\",\n            Ok(select_with_null!(\n                id     | num    | name;\n                Null     I64(1)   Str(\"1\".to_owned())\n            )),\n        ),\n        (\n            \"CREATE TABLE TargetTableWithOffset AS SELECT * FROM CreateTable2 OFFSET 1\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"SELECT * FROM TargetTableWithOffset\",\n            Ok(select_with_null!(\n                id     | num    | name;\n                I64(2)   I64(2)   Str(\"2\".to_owned())\n            )),\n        ),\n        (\n            // Target Table already exists\n            \"CREATE TABLE TargetTableWithData AS SELECT * FROM CreateTable2\",\n            Err(AlterError::TableAlreadyExists(\"TargetTableWithData\".to_owned()).into()),\n        ),\n        (\n            // Source table does not exists\n            \"CREATE TABLE TargetTableWithData2 AS SELECT * FROM NonExistentTable\",\n            Err(AlterError::CtasSourceTableNotFound(\"NonExistentTable\".to_owned()).into()),\n        ),\n        (\n            // Cannot create table with duplicate column name\n            \"CREATE TABLE DuplicateColumns (id INT, id INT)\",\n            Err(AlterError::DuplicateColumnName(\"id\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","alter","drop_indexed.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast::IndexOperator::*,\n        error::{AlterError, FetchError, TranslateError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(drop_indexed_table, {\n    let g = get_tester!();\n\n    g.run(\"DROP TABLE IF EXISTS Test;\").await;\n    g.run(\"CREATE TABLE Test (id INTEGER);\").await;\n    g.run(\"INSERT INTO Test VALUES (1), (2);\").await;\n    g.run(\"CREATE INDEX idx_id ON Test (id)\").await;\n    g.test_idx(\n        \"SELECT * FROM Test WHERE id = 1\",\n        Ok(select!(id I64; 1)),\n        idx!(idx_id, Eq, \"1\"),\n    )\n    .await;\n\n    g.run(\"DROP TABLE Test;\").await;\n    g.test(\n        \"SELECT * FROM Test;\",\n        Err(FetchError::TableNotFound(\"Test\".to_owned()).into()),\n    )\n    .await;\n\n    g.run(\"CREATE TABLE Test (id INTEGER);\").await;\n    g.run(\"INSERT INTO Test VALUES (3), (4);\").await;\n    g.test_idx(\n        \"SELECT * FROM Test WHERE id = 3\",\n        Ok(select!(id I64; 3)),\n        idx!(),\n    )\n    .await;\n\n    g.run(\"CREATE INDEX idx_id ON Test (id)\").await;\n    g.test_idx(\n        \"SELECT * FROM Test WHERE id \u003c 10\",\n        Ok(select!(id I64; 3; 4)),\n        idx!(idx_id, Lt, \"10\"),\n    )\n    .await;\n\n    g.test(\n        \"DROP INDEX Test\",\n        Err(TranslateError::InvalidParamsInDropIndex.into()),\n    )\n    .await;\n    g.test(\n        \"DROP INDEX Test.idx_id.IndexC\",\n        Err(TranslateError::InvalidParamsInDropIndex.into()),\n    )\n    .await;\n});\n\ntest_case!(drop_indexed_column, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE Test (\n    id INTEGER,\n    num INTEGER,\n    name TEXT\n)\",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO Test\n            (id, num, name)\n        VALUES\n            (1, 2, 'Hello');\n    \",\n    )\n    .await;\n\n    // create indexes\n    for query in [\n        \"CREATE INDEX idx_name ON Test (num + 1)\",\n        \"CREATE INDEX idx_id ON Test (id)\",\n        \"CREATE INDEX idx_typed_string ON Test ((id))\",\n        \"CREATE INDEX idx_binary_op ON Test (id || name);\",\n        \"CREATE INDEX idx_unary_op ON Test (-id);\",\n        \"CREATE INDEX idx_cast ON Test (CAST(id AS TEXT));\",\n    ] {\n        g.run(query).await;\n    }\n\n    // check indexes working\n    g.test(\n        \"CREATE INDEX idx_literal ON Test (100)\",\n        Err(AlterError::IdentifierNotFound(expr(\"100\")).into()),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id \u003c= 1\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_id, LtEq, \"1\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id \u003c= (1)\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_id, LtEq, \"(1)\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id || name = '1Hello'\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_binary_op, Eq, \"'1Hello'\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE -id \u003e= -7\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_unary_op, GtEq, \"-7\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE -id \u003e -7\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_unary_op, Gt, \"-7\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE CAST(id AS TEXT) = '1'\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_cast, Eq, \"'1'\"),\n    )\n    .await;\n\n    g.test(\n        \"ALTER TABLE Noname DROP COLUMN id\",\n        Err(AlterError::TableNotFound(\"Noname\".to_owned()).into()),\n    )\n    .await;\n\n    g.run(\"ALTER TABLE Test DROP COLUMN id\").await;\n\n    g.test_idx(\n        \"SELECT * FROM Test\",\n        Ok(select!(\n            num | name\n            I64 | Str;\n            2     \"Hello\".to_owned()\n        )),\n        idx!(),\n    )\n    .await;\n\n    let schema = g\n        .get_glue()\n        .storage\n        .fetch_schema(\"Test\")\n        .await\n        .expect(\"error fetching schema\")\n        .expect(\"table not found\");\n    assert_eq!(schema.indexes.len(), 1, \"Only idx_name remains.\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","alter","drop_table.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{AlterError, FetchError, TranslateError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(drop_table, {\n    let g = get_tester!();\n\n    let create_sql = \"\nCREATE TABLE DropTable (\n    id INT,\n    num INT,\n    name TEXT\n)\";\n\n    g.run(create_sql).await;\n\n    let sqls = [\"INSERT INTO DropTable (id, num, name) VALUES (1, 2, 'Hello')\"];\n\n    for sql in sqls {\n        g.run(sql).await;\n    }\n\n    let sqls = [\n        (\n            \"SELECT id, num, name FROM DropTable;\",\n            Ok(select!(\n                id  | num | name\n                I64 | I64 | Str;\n                1     2     \"Hello\".to_owned()\n            )),\n        ),\n        (\"DROP TABLE DropTable;\", Ok(Payload::DropTable(1))),\n        (\n            \"DROP TABLE DropTable;\",\n            Err(AlterError::TableNotFound(\"DropTable\".to_owned()).into()),\n        ),\n        (\n            \"\nCREATE TABLE DropTable (\n    id INT,\n    num INT,\n    name TEXT\n)\",\n            Ok(Payload::Create),\n        ),\n        (\"DROP TABLE IF EXISTS DropTable;\", Ok(Payload::DropTable(1))),\n        (\"DROP TABLE IF EXISTS DropTable;\", Ok(Payload::DropTable(0))),\n        (\n            \"SELECT id, num, name FROM DropTable;\",\n            Err(FetchError::TableNotFound(\"DropTable\".to_owned()).into()),\n        ),\n        (create_sql, Ok(Payload::Create)),\n        (\n            \"SELECT id, num, name FROM DropTable;\",\n            Ok(select!(id | num | name)),\n        ),\n        (\n            \"DROP VIEW DropTable;\",\n            Err(TranslateError::UnsupportedStatement(\"DROP VIEW DropTable\".to_owned()).into()),\n        ),\n        (\n            \"\n        CREATE TABLE DropTable1 (\n            id INT,\n            num INT,\n            name TEXT\n        )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"\n        CREATE TABLE DropTable2 (\n            id INT,\n            num INT,\n            name TEXT\n        )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"DROP TABLE DropTable1, DropTable2;\",\n            Ok(Payload::DropTable(2)),\n        ),\n        (\n            \"SELECT id, num, name FROM DropTable1;\",\n            Err(FetchError::TableNotFound(\"DropTable1\".to_owned()).into()),\n        ),\n        (\n            \"SELECT id, num, name FROM DropTable2;\",\n            Err(FetchError::TableNotFound(\"DropTable2\".to_owned()).into()),\n        ),\n        (\n            \"\n        CREATE TABLE DropTable1 (\n            id INT,\n            num INT,\n            name TEXT\n        )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"\n        CREATE TABLE DropTable2 (\n            id INT,\n            num INT,\n            name TEXT\n        )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"DROP TABLE IF EXISTS DropTable1, DropTable2;\",\n            Ok(Payload::DropTable(2)),\n        ),\n        (\n            \"SELECT id, num, name FROM DropTable1;\",\n            Err(FetchError::TableNotFound(\"DropTable1\".to_owned()).into()),\n        ),\n        (\n            \"SELECT id, num, name FROM DropTable2;\",\n            Err(FetchError::TableNotFound(\"DropTable2\".to_owned()).into()),\n        ),\n        (\n            \"\n        CREATE TABLE DropTable1 (\n            id INT,\n            num INT,\n            name TEXT\n        )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"DROP TABLE IF EXISTS DropTable1, DropTable2;\",\n            Ok(Payload::DropTable(1)),\n        ),\n        (\n            \"SELECT id, num, name FROM DropTable1;\",\n            Err(FetchError::TableNotFound(\"DropTable1\".to_owned()).into()),\n        ),\n        (\n            \"SELECT id, num, name FROM DropTable2;\",\n            Err(FetchError::TableNotFound(\"DropTable2\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in sqls {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","alter.rs"],"content":"mod alter_table;\nmod create_table;\nmod drop_indexed;\nmod drop_table;\n\npub use {\n    alter_table::{alter_table_add_drop, alter_table_rename},\n    create_table::create_table,\n    drop_indexed::{drop_indexed_column, drop_indexed_table},\n    drop_table::drop_table,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","arithmetic","error.rs"],"content":"use {\n    crate::*,\n    bigdecimal::BigDecimal,\n    gluesql_core::{\n        ast::BinaryOperator,\n        data::{Literal, NumericBinaryOperator},\n        error::{EvaluateError, LiteralError, UpdateError, ValueError},\n        prelude::Value,\n    },\n    std::borrow::Cow,\n};\ntest_case!(error, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Arith (\n            id INTEGER,\n            num INTEGER,\n            name TEXT\n        );\n    \",\n    )\n    .await;\n    g.run(\"DELETE FROM Arith\").await;\n    g.run(\n        \"\n        INSERT INTO Arith (id, num, name) VALUES\n            (1, 6, 'A'),\n            (2, 8, 'B'),\n            (3, 4, 'C'),\n            (4, 2, 'D'),\n            (5, 3, 'E');\n    \",\n    )\n    .await;\n\n    let test_cases = [\n        (\n            \"SELECT * FROM Arith WHERE name + id \u003c 1\",\n            ValueError::NonNumericMathOperation {\n                lhs: Value::Str(\"A\".to_owned()),\n                operator: NumericBinaryOperator::Add,\n                rhs: Value::I64(1),\n            }\n            .into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE name - id \u003c 1\",\n            ValueError::NonNumericMathOperation {\n                lhs: Value::Str(\"A\".to_owned()),\n                operator: NumericBinaryOperator::Subtract,\n                rhs: Value::I64(1),\n            }\n            .into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE name * id \u003c 1\",\n            ValueError::NonNumericMathOperation {\n                lhs: Value::Str(\"A\".to_owned()),\n                operator: NumericBinaryOperator::Multiply,\n                rhs: Value::I64(1),\n            }\n            .into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE name / id \u003c 1\",\n            ValueError::NonNumericMathOperation {\n                lhs: Value::Str(\"A\".to_owned()),\n                operator: NumericBinaryOperator::Divide,\n                rhs: Value::I64(1),\n            }\n            .into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE name % id \u003c 1\",\n            ValueError::NonNumericMathOperation {\n                lhs: Value::Str(\"A\".to_owned()),\n                operator: NumericBinaryOperator::Modulo,\n                rhs: Value::I64(1),\n            }\n            .into(),\n        ),\n        (\n            \"UPDATE Arith SET aaa = 1\",\n            UpdateError::ColumnNotFound(\"aaa\".to_owned()).into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE TRUE + 1 = 1\",\n            LiteralError::UnsupportedBinaryOperation {\n                left: format!(\"{:?}\", Literal::Boolean(true)),\n                op: BinaryOperator::Plus,\n                right: format!(\"{:?}\", Literal::Number(Cow::Owned(BigDecimal::from(1)))),\n            }\n            .into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE id = 2 / 0\",\n            LiteralError::DivisorShouldNotBeZero.into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE id = 2 / 0.0\",\n            LiteralError::DivisorShouldNotBeZero.into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE id = INTERVAL '2' HOUR / 0\",\n            ValueError::DivisorShouldNotBeZero.into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE id = INTERVAL '2' HOUR / 0.0\",\n            ValueError::DivisorShouldNotBeZero.into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE id = 2 % 0\",\n            LiteralError::DivisorShouldNotBeZero.into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE id = 2 % 0.0\",\n            LiteralError::DivisorShouldNotBeZero.into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE TRUE AND 'hello'\",\n            EvaluateError::BooleanTypeRequired(format!(\n                \"{:?}\",\n                Literal::Text(Cow::Owned(\"hello\".to_owned()))\n            ))\n            .into(),\n        ),\n        (\n            \"SELECT * FROM Arith WHERE name AND id\",\n            EvaluateError::BooleanTypeRequired(format!(\"{:?}\", Value::Str(\"A\".to_owned()))).into(),\n        ),\n    ];\n\n    for (sql, error) in test_cases {\n        g.test(sql, Err(error)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","arithmetic","on_where.rs"],"content":"use crate::*;\n\ntest_case!(on_where, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Arith (\n            id INTEGER,\n            num INTEGER,\n            name TEXT\n        );\n    \",\n    )\n    .await;\n    g.run(\"DELETE FROM Arith\").await;\n    g.run(\n        \"\n        INSERT INTO Arith (id, num, name) VALUES\n            (1, 6, 'A'),\n            (2, 8, 'B'),\n            (3, 4, 'C'),\n            (4, 2, 'D'),\n            (5, 3, 'E');\n    \",\n    )\n    .await;\n\n    let test_cases = [\n        // add on WHERE\n        (1, \"SELECT * FROM Arith WHERE id = 1 + 1;\"),\n        (5, \"SELECT * FROM Arith WHERE id \u003c id + 1;\"),\n        (5, \"SELECT * FROM Arith WHERE id \u003c num + id;\"),\n        (3, \"SELECT * FROM Arith WHERE id + 1 \u003c 5;\"),\n        // subtract on WHERE\n        (1, \"SELECT * FROM Arith WHERE id = 2 - 1;\"),\n        (1, \"SELECT * FROM Arith WHERE 2 - 1 = id;\"),\n        (5, \"SELECT * FROM Arith WHERE id \u003e id - 1;\"),\n        (5, \"SELECT * FROM Arith WHERE id \u003e id - num;\"),\n        (3, \"SELECT * FROM Arith WHERE 5 - id \u003c 3;\"),\n        // multiply on WHERE\n        (1, \"SELECT * FROM Arith WHERE id = 2 * 2;\"),\n        (0, \"SELECT * FROM Arith WHERE id \u003e id * 2;\"),\n        (0, \"SELECT * FROM Arith WHERE id \u003e num * id;\"),\n        (1, \"SELECT * FROM Arith WHERE 3 * id \u003c 4;\"),\n        // divide on WHERE\n        (0, \"SELECT * FROM Arith WHERE id = 5 / 2;\"),\n        (5, \"SELECT * FROM Arith WHERE id \u003e id / 2;\"),\n        (3, \"SELECT * FROM Arith WHERE id \u003e num / id;\"),\n        (2, \"SELECT * FROM Arith WHERE 10 / id = 2;\"),\n        // modulo on WHERE\n        (1, \"SELECT * FROM Arith WHERE id = 5 % 2;\"),\n        (5, \"SELECT * FROM Arith WHERE id \u003e num % id;\"),\n        (1, \"SELECT * FROM Arith WHERE num % id \u003e 2;\"),\n        (2, \"SELECT * FROM Arith WHERE num % 3 \u003c 2 % id;\"),\n        // etc\n        (1, \"SELECT * FROM Arith WHERE 1 + 1 = id;\"),\n        (5, \"UPDATE Arith SET id = id + 1;\"),\n        (0, \"SELECT * FROM Arith WHERE id = 1;\"),\n        (4, \"UPDATE Arith SET id = id - 1 WHERE id != 6;\"),\n        (2, \"SELECT * FROM Arith WHERE id \u003c= 2;\"),\n        (5, \"UPDATE Arith SET id = id * 2;\"),\n        (5, \"UPDATE Arith SET id = id / 2;\"),\n        (2, \"SELECT * FROM Arith WHERE id \u003c= 2;\"),\n    ];\n\n    for (num, sql) in test_cases {\n        g.count(sql, num).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","arithmetic","project.rs"],"content":"use {\n    crate::*,\n    gluesql_core::prelude::Value::{self, *},\n};\n\ntest_case!(project, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Arith (\n            id INTEGER,\n            num INTEGER\n        );\n    \",\n    )\n    .await;\n    g.run(\"DELETE FROM Arith\").await;\n    g.run(\n        \"\n        INSERT INTO Arith (id, num) VALUES\n            (1, 6),\n            (2, 8),\n            (3, 4),\n            (4, 2),\n            (5, 3);\n    \",\n    )\n    .await;\n\n    let test_cases = [\n        (\n            \"SELECT 1 * 2 + 1 - 3 / 1 FROM Arith LIMIT 1;\",\n            select!(\"1 * 2 + 1 - 3 / 1\"; I64; 0),\n        ),\n        (\n            \"SELECT id, id + 1, id + num, 1 + 1 FROM Arith\",\n            select!(\n                id  | \"id + 1\" | \"id + num\" | \"1 + 1\"\n                I64 | I64      | I64        | I64;\n                1     2          7            2;\n                2     3          10           2;\n                3     4          7            2;\n                4     5          6            2;\n                5     6          8            2\n            ),\n        ),\n        (\n            \"SELECT a.id + b.id FROM Arith a JOIN Arith b ON a.id = b.id + 1\",\n            select!(\"a.id + b.id\"; I64; 3; 5; 7; 9),\n        ),\n        (\n            \"SELECT TRUE XOR TRUE, FALSE XOR FALSE, TRUE XOR FALSE, FALSE XOR TRUE FROM Arith LIMIT 1\",\n            select!(\n                \"true XOR true\" | \"false XOR false\" | \"true XOR false\" | \"false XOR true\"\n                Value::Bool     | Value::Bool       | Value::Bool      | Value::Bool;\n                false             false               true               true\n            ),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","arithmetic.rs"],"content":"pub mod error;\npub mod on_where;\npub mod project;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","array.rs"],"content":"use {\n    crate::*,\n    gluesql_core::prelude::{Payload, Value::*},\n};\n\ntest_case!(array, {\n    let g = get_tester!();\n    g.run(\"CREATE TABLE Test (id INTEGER DEFAULT 1,name LIST NOT NULL);\")\n        .await;\n\n    g.named_test(\n        \"basic insert - single item\",\n        \"INSERT INTO Test (id, name) VALUES (1, ['Seongbin','Bernie']);\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n    g.named_test(\"insert multiple rows\",\"INSERT INTO Test (id, name) VALUES (3,Array['Seongbin','Bernie','Chobobdev']), (2,Array['devgony','Henry']);\", Ok(Payload::Insert(2)),).await;\n    g.test(\n        \"INSERT INTO Test VALUES(5,['Jhon']);\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n    g.test(\n        \"INSERT INTO Test (name) VALUES (['Jane']);\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n    g.test(\n        \"INSERT INTO Test (name) VALUES (['GlueSQL']);\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n    g.test(\"SELECT * FROM Test;\",Ok(select_with_null!(\n            id          | name;\n            I64(1)        List(vec![Str(\"Seongbin\".to_owned()),Str(\"Bernie\".to_owned())]);\n            I64(3)        List(vec![Str(\"Seongbin\".to_owned()),Str(\"Bernie\".to_owned()),Str(\"Chobobdev\".to_owned())]);\n            I64(2)        List(vec![Str(\"devgony\".to_owned()),Str(\"Henry\".to_owned())]);\n            I64(5)        List(vec![Str(\"Jhon\".to_owned())]);\n            I64(1)        List(vec![Str(\"Jane\".to_owned())]);\n            I64(1)        List(vec![Str(\"GlueSQL\".to_owned())])\n        )),\n    )\n\n    .await;\n    g.test(\n        \"SELECT ['name', 1, True] AS list;\",\n        Ok(Payload::Select {\n            labels: vec![\"list\".to_owned()],\n            rows: vec![vec![List(vec![Str(\"name\".to_owned()), I64(1), Bool(true)])]],\n        }),\n    )\n    .await;\n\n    g.test(\n        \"SELECT ['GlueSQL', 1, True] [0] AS list;\",\n        Ok(Payload::Select {\n            labels: vec![\"list\".to_owned()],\n            rows: vec![vec![Str(\"GlueSQL\".to_owned())]],\n        }),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","alias_as.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast_builder::*, executor::Payload, prelude::Value::*},\n};\n\ntest_case!(alias_as, {\n    let glue = get_glue!();\n\n    // create table - Category\n    let actual = table(\"Category\")\n        .create_table()\n        .add_column(\"category_id INTEGER PRIMARY KEY\")\n        .add_column(\"category_name TEXT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Category\");\n\n    // create table - Item\n    let actual = table(\"Item\")\n        .create_table()\n        .add_column(\"item_id INTEGER\")\n        .add_column(\"category_id INTEGER\")\n        .add_column(\"item_name TEXT\")\n        .add_column(\"price INTEGER\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Item\");\n\n    // insert into Category\n    let actual = table(\"Category\")\n        .insert()\n        .values(vec![\"1, 'Fruit'\", \"2, 'Meat'\", \"3, 'Drink'\"])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(3));\n    assert_eq!(actual, expected, \"insert into Category\");\n\n    // insert into Item\n    let actual = table(\"Item\")\n        .insert()\n        .values(vec![\n            \"100, 1, 'Pineapple', 40\",\n            \"200, 2, 'Pork belly', 90\",\n            \"300, 1, 'Strawberry', 30\",\n            \"400, 3, 'Coffee', 25\",\n            \"500, 3, 'Orange juice', 60\",\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(5));\n    assert_eq!(actual, expected, \"insert into Item\");\n\n    // select -\u003e derived subquery\n    let actual = table(\"Item\")\n        .select()\n        .alias_as(\"Sub\")\n        .select()\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        item_id  | category_id | item_name                 | price;\n        I64      | I64         | Str                       | I64;\n        100        1             \"Pineapple\".to_owned()      40;\n        200        2             \"Pork belly\".to_owned()     90;\n        300        1             \"Strawberry\".to_owned()     30;\n        400        3             \"Coffee\".to_owned()         25;\n        500        3             \"Orange juice\".to_owned()   60\n    ));\n    assert_eq!(actual, expected, \"select -\u003e derived subquery\");\n\n    // select -\u003e filter -\u003e derived subquery\n    let actual = table(\"Item\")\n        .select()\n        .filter(\"item_id = 300\")\n        .alias_as(\"Sub\")\n        .select()\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        item_id  | category_id | item_name               | price;\n        I64      | I64         | Str                     | I64;\n        300        1             \"Strawberry\".to_owned()   30\n    ));\n    assert_eq!(actual, expected, \"select -\u003e filter -\u003e derived subquery\");\n\n    // select -\u003e project -\u003e derived subquery\n    let actual = table(\"Item\")\n        .select()\n        .project(\"item_id\")\n        .alias_as(\"Sub\")\n        .select()\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        item_id;\n        I64;\n        100;\n        200;\n        300;\n        400;\n        500\n    ));\n    assert_eq!(actual, expected, \"select -\u003e project -\u003e derived subquery\");\n\n    // select -\u003e join(cartesian) -\u003e derived subquery\n    let actual = table(\"Item\")\n        .alias_as(\"i\")\n        .select()\n        .join_as(\"Category\", \"c\")\n        .alias_as(\"Sub\")\n        .select()\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        item_id | category_id | item_name                 | price | category_id | category_name;\n        I64     | I64         | Str                       | I64   | I64         | Str;\n        100       1             \"Pineapple\".to_owned()      40      1             \"Fruit\".to_owned();\n        100       1             \"Pineapple\".to_owned()      40      2             \"Meat\".to_owned();\n        100       1             \"Pineapple\".to_owned()      40      3             \"Drink\".to_owned();\n        200       2             \"Pork belly\".to_owned()     90      1             \"Fruit\".to_owned();\n        200       2             \"Pork belly\".to_owned()     90      2             \"Meat\".to_owned();\n        200       2             \"Pork belly\".to_owned()     90      3             \"Drink\".to_owned();\n        300       1             \"Strawberry\".to_owned()     30      1             \"Fruit\".to_owned();\n        300       1             \"Strawberry\".to_owned()     30      2             \"Meat\".to_owned();\n        300       1             \"Strawberry\".to_owned()     30      3             \"Drink\".to_owned();\n        400       3             \"Coffee\".to_owned()         25      1             \"Fruit\".to_owned();\n        400       3             \"Coffee\".to_owned()         25      2             \"Meat\".to_owned();\n        400       3             \"Coffee\".to_owned()         25      3             \"Drink\".to_owned();\n        500       3             \"Orange juice\".to_owned()   60      1             \"Fruit\".to_owned();\n        500       3             \"Orange juice\".to_owned()   60      2             \"Meat\".to_owned();\n        500       3             \"Orange juice\".to_owned()   60      3             \"Drink\".to_owned()\n    ));\n    assert_eq!(\n        actual, expected,\n        \"select -\u003e join(cartesian) -\u003e derived subquery\"\n    );\n\n    // select -\u003e join -\u003e on -\u003e derived subquery\n    let actual = table(\"Item\")\n        .alias_as(\"i\")\n        .select()\n        .join_as(\"Category\", \"c\")\n        .on(\"c.category_id = i.category_id\")\n        .alias_as(\"Sub\")\n        .select()\n        .project(\"item_name\")\n        .project(\"category_name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        item_name                 | category_name;\n        Str                       | Str;\n        \"Pineapple\".to_owned()      \"Fruit\".to_owned();\n        \"Pork belly\".to_owned()     \"Meat\".to_owned();\n        \"Strawberry\".to_owned()     \"Fruit\".to_owned();\n        \"Coffee\".to_owned()         \"Drink\".to_owned();\n        \"Orange juice\".to_owned()   \"Drink\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"select -\u003e join -\u003e on -\u003e derived subquery\");\n\n    // select -\u003e join -\u003e hash -\u003e derived subquery\n    let actual = table(\"Item\")\n        .select()\n        .join(\"Category\")\n        .hash_executor(\"Category.category_id\", \"Item.category_id\")\n        .alias_as(\"Sub\")\n        .select()\n        .project(\"item_name\")\n        .project(\"category_name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        item_name                 | category_name;\n        Str                       | Str;\n        \"Pineapple\".to_owned()      \"Fruit\".to_owned();\n        \"Pork belly\".to_owned()     \"Meat\".to_owned();\n        \"Strawberry\".to_owned()     \"Fruit\".to_owned();\n        \"Coffee\".to_owned()         \"Drink\".to_owned();\n        \"Orange juice\".to_owned()   \"Drink\".to_owned()\n    ));\n    assert_eq!(\n        actual, expected,\n        \"select -\u003e join -\u003e hash -\u003e derived subquery\"\n    );\n\n    // select -\u003e project -\u003e derived subquery -\u003e select -\u003e group_by -\u003e derived subquery\n    let actual = table(\"Category\")\n        .select()\n        .project(\"category_name\")\n        .alias_as(\"Sub1\")\n        .select()\n        .group_by(\"category_name\")\n        .alias_as(\"Sub2\")\n        .select()\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        category_name;\n        Str;\n        \"Fruit\".to_owned();\n        \"Meat\".to_owned();\n        \"Drink\".to_owned()\n    ));\n    assert_eq!(\n        actual, expected,\n        \"select -\u003e project -\u003e derived subquery -\u003e select -\u003e group_by -\u003e derived subquery\"\n    );\n\n    // select -\u003e project -\u003e derived subquery -\u003e select -\u003e group_by -\u003e having -\u003e derived subquery\n    let actual = table(\"Category\")\n        .select()\n        .project(\"category_name\")\n        .alias_as(\"Sub1\")\n        .select()\n        .group_by(\"category_name\")\n        .having(\"category_name = 'Meat'\")\n        .alias_as(\"Sub2\")\n        .select()\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        category_name;\n        Str;\n        \"Meat\".to_owned()\n    ));\n    assert_eq!(\n        actual, expected,\n        \"select -\u003e project -\u003e derived subquery -\u003e select -\u003e group_by -\u003e having -\u003e derived subquery\"\n    );\n\n    // select -\u003e order_by -\u003e derived subquery\n    let actual = table(\"Item\")\n        .select()\n        .order_by(\"price DESC\")\n        .alias_as(\"Sub\")\n        .select()\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        item_id  | category_id | item_name                 | price;\n        I64      | I64         | Str                       | I64;\n        200        2             \"Pork belly\".to_owned()     90;\n        500        3             \"Orange juice\".to_owned()   60;\n        100        1             \"Pineapple\".to_owned()      40;\n        300        1             \"Strawberry\".to_owned()     30;\n        400        3             \"Coffee\".to_owned()         25\n    ));\n    assert_eq!(actual, expected, \"select -\u003e order_by -\u003e derived subquery\");\n\n    // select -\u003e offset -\u003e derived subquery\n    let actual = table(\"Item\")\n        .select()\n        .offset(4)\n        .alias_as(\"Sub\")\n        .select()\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        item_id  | category_id | item_name                 | price;\n        I64      | I64         | Str                       | I64;\n        500        3             \"Orange juice\".to_owned()   60\n    ));\n    assert_eq!(actual, expected, \"select -\u003e offset -\u003e derived subquery\");\n\n    // select -\u003e limit -\u003e derived subquery\n    let actual = table(\"Item\")\n        .select()\n        .limit(1)\n        .alias_as(\"Sub\")\n        .select()\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        item_id  | category_id | item_name                 | price;\n        I64      | I64         | Str                       | I64;\n        100        1             \"Pineapple\".to_owned()      40\n    ));\n    assert_eq!(actual, expected, \"select -\u003e limit -\u003e derived subquery\");\n\n    // select -\u003e offset -\u003e limit -\u003e derived subquery\n    let actual = table(\"Item\")\n        .select()\n        .offset(3)\n        .limit(1)\n        .alias_as(\"Sub\")\n        .select()\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n         item_id  | category_id | item_name                 | price;\n         I64      | I64         | Str                       | I64;\n         400        3             \"Coffee\".to_owned()         25\n    ));\n    assert_eq!(\n        actual, expected,\n        \"select -\u003e offset -\u003e limit -\u003e derived subquery\"\n    );\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","basic.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast_builder::*, executor::Payload, prelude::Value::*},\n};\n\ntest_case!(basic, {\n    let glue = get_glue!();\n\n    let actual = table(\"Foo\")\n        .create_table()\n        .add_column(\"id INTEGER\")\n        .add_column(\"name TEXT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table\");\n\n    let actual = table(\"Foo\")\n        .insert()\n        .columns(\"id, name\")\n        .values(vec![\n            vec![num(100), text(\"Pickle\")],\n            vec![num(200), text(\"Lemon\")],\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(2));\n    assert_eq!(actual, expected, \"insert\");\n\n    let actual = table(\"Foo\")\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        100   \"Pickle\".to_owned();\n        200   \"Lemon\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"select\");\n\n    let actual = table(\"Foo\")\n        .update()\n        .filter(col(\"id\").eq(200))\n        .set(\"id\", col(\"id\").mul(2))\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Update(1));\n    assert_eq!(actual, expected, \"update\");\n\n    let actual = table(\"Foo\")\n        .select()\n        .filter(\"name = 'Lemon'\")\n        .project(\"id, name\")\n        .build()\n        .expect(\"build and execute\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        400   \"Lemon\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"select after update\");\n\n    let actual = table(\"Foo\")\n        .delete()\n        .filter(col(\"id\").gt(200))\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Delete(1));\n    assert_eq!(actual, expected, \"delete\");\n\n    let actual = table(\"Foo\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        100   \"Pickle\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"select after delete\");\n\n    let actual = table(\"Foo\").drop_table().execute(glue).await;\n    let expected = Ok(Payload::DropTable(1));\n    assert_eq!(actual, expected, \"drop table\");\n\n    let actual = table(\"Foo\")\n        .select()\n        .filter(num(\"NAN\").gt(300))\n        .execute(glue)\n        .await;\n    let expected = Err(AstBuilderError::FailedToParseNumeric(\"NAN\".to_owned()).into());\n    assert_eq!(actual, expected, \"error\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","delete.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast_builder::*, executor::Payload, prelude::Value::*},\n};\n\ntest_case!(delete, {\n    let glue = get_glue!();\n\n    let actual = table(\"Foo\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"score INTEGER\")\n        .add_column(\"flag BOOLEAN\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Foo\");\n\n    let actual = table(\"Foo\")\n        .insert()\n        .values(vec![\n            vec![num(1), num(100), true.into()],\n            vec![num(2), num(300), false.into()],\n            vec![num(3), num(700), true.into()],\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(3));\n    assert_eq!(actual, expected, \"insert into Foo\");\n\n    let actual = table(\"Foo\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | score | flag\n        I64 | I64   | Bool;\n        1     100     true;\n        2     300     false;\n        3     700     true\n    ));\n    assert_eq!(actual, expected, \"select * from Foo\");\n\n    // delete using filter\n    let actual = table(\"Foo\")\n        .delete()\n        .filter(col(\"flag\").eq(false))\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Delete(1));\n    assert_eq!(actual, expected, \"delete using filter\");\n\n    let actual = table(\"Foo\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | score | flag\n        I64 | I64   | Bool;\n        1     100     true;\n        3     700     true\n    ));\n    assert_eq!(actual, expected, \"select * from Foo\");\n\n    // delete all\n    let actual = table(\"Foo\").delete().execute(glue).await;\n    let expected = Ok(Payload::Delete(2));\n    assert_eq!(actual, expected, \"delete all\");\n\n    let actual = table(\"Foo\").select().execute(glue).await;\n    let expected = Ok(Payload::Select {\n        labels: vec![\"id\".to_owned(), \"score\".to_owned(), \"flag\".to_owned()],\n        rows: vec![],\n    });\n    assert_eq!(actual, expected, \"select * from Foo\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","expr","pattern_matching.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast_builder::*, executor::Payload, prelude::Value::*},\n};\n\ntest_case!(pattern_matching, {\n    let glue = get_glue!();\n\n    // create table - Category\n    let actual = table(\"Category\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"name TEXT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Category\");\n\n    // insert into Category\n    let actual = table(\"Category\")\n        .insert()\n        .values(vec![\"1, 'Meat'\", \"2, 'meat'\", \"3, 'Drink'\", \"4, 'drink'\"])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(4));\n    assert_eq!(actual, expected, \"insert into - Category\");\n\n    // like\n    let actual = table(\"Category\")\n        .select()\n        .filter(\n            col(\"name\")\n                .like(text(\"D%\"))\n                .or(col(\"name\").like(text(\"M___\"))),\n        )\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Meat\".to_owned();\n        3     \"Drink\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"like\");\n\n    // ilike\n    let actual = table(\"Category\")\n        .select()\n        .filter(\n            col(\"name\")\n                .ilike(text(\"D%\"))\n                .or(col(\"name\").ilike(text(\"M___\"))),\n        )\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Meat\".to_owned();\n        2     \"meat\".to_owned();\n        3     \"Drink\".to_owned();\n        4     \"drink\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"ilike\");\n\n    // not_like\n    let actual = table(\"Category\")\n        .select()\n        .filter(\n            col(\"name\")\n                .not_like(text(\"D%\"))\n                .and(col(\"name\").not_like(text(\"M___\"))),\n        )\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        2     \"meat\".to_owned();\n        4     \"drink\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"not_like\");\n\n    // not_ilike\n    let actual = table(\"Category\")\n        .select()\n        .filter(\n            col(\"name\")\n                .not_ilike(text(\"D%\"))\n                .and(col(\"name\").not_ilike(text(\"M___\"))),\n        )\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Select {\n        labels: vec![\"id\".to_owned(), \"name\".to_owned()],\n        rows: vec![],\n    });\n    assert_eq!(actual, expected, \"not_ilike\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","expr.rs"],"content":"pub mod pattern_matching;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","datetime","conversion.rs"],"content":"use {\n    crate::*,\n    chrono::{NaiveDate, NaiveTime},\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        executor::Payload,\n        prelude::Value::*,\n    },\n};\n\ntest_case!(conversion, {\n    let glue = get_glue!();\n\n    let actual = table(\"Visitor\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"name TEXT\")\n        .add_column(\"visit_date TEXT\")\n        .add_column(\"visit_time TEXT\")\n        .add_column(\"visit_time_stamp TEXT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Visitor\");\n\n    let actual = table(\"Visitor\")\n        .insert()\n        .values(vec![\n            \"1, 'Bryanna', '2022-12-23', '13:05:26', '2022-12-23 13:05:26'\",\n            \"2, 'Ash', '2023-04-01', '23:24:11', '2023-04-01 23:24:11'\",\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(2));\n    assert_eq!(actual, expected, \"insert - Visitor\");\n\n    // Date\n    let actual = table(\"Visitor\")\n        .select()\n        .project(\"id\")\n        .project(\"name\")\n        .project(col(\"visit_date\").to_date(\"'%Y-%m-%d'\"))\n        .project(f::to_date(\"visit_date\", \"'%Y-%m-%d'\"))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name                | \"TO_DATE(\\\"visit_date\\\", '%Y-%m-%d')\"          | \"TO_DATE(\\\"visit_date\\\", '%Y-%m-%d')\"\n        I64 | Str                 | Date                                           | Date;\n        1    \"Bryanna\".to_owned()   NaiveDate::from_ymd_opt(2022, 12, 23).unwrap()   NaiveDate::from_ymd_opt(2022, 12, 23).unwrap();\n        2    \"Ash\".to_owned()       NaiveDate::from_ymd_opt(2023, 4, 1).unwrap()     NaiveDate::from_ymd_opt(2023, 4, 1).unwrap()\n    ));\n    assert_eq!(actual, expected, \"to_date\");\n\n    // Time\n    let actual = table(\"Visitor\")\n        .select()\n        .project(\"id\")\n        .project(\"name\")\n        .project(col(\"visit_time\").to_time(\"'%H:%M:%S'\"))\n        .project(f::to_time(\"visit_time\", \"'%H:%M:%S'\"))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name                | \"TO_TIME(\\\"visit_time\\\", '%H:%M:%S')\"       | \"TO_TIME(\\\"visit_time\\\", '%H:%M:%S')\"\n        I64 | Str                 | Time                                        | Time;\n        1    \"Bryanna\".to_owned()   NaiveTime::from_hms_opt(13, 5, 26).unwrap()   NaiveTime::from_hms_opt(13, 5, 26).unwrap();\n        2    \"Ash\".to_owned()       NaiveTime::from_hms_opt(23, 24, 11).unwrap()  NaiveTime::from_hms_opt(23, 24, 11).unwrap()\n    ));\n    assert_eq!(actual, expected, \"to_time\");\n\n    // Timestamp\n    let actual = table(\"Visitor\")\n        .select()\n        .project(\"id\")\n        .project(\"name\")\n        .project(col(\"visit_time_stamp\").to_timestamp(\"'%Y-%m-%d %H:%M:%S'\"))\n        .project(f::to_timestamp(\"visit_time_stamp\", \"'%Y-%m-%d %H:%M:%S'\"))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name                 | \"TO_TIMESTAMP(\\\"visit_time_stamp\\\", '%Y-%m-%d %H:%M:%S')\"                      | \"TO_TIMESTAMP(\\\"visit_time_stamp\\\", '%Y-%m-%d %H:%M:%S')\"\n        I64 | Str                  | Timestamp                                                                      | Timestamp;\n        1    \"Bryanna\".to_owned()    NaiveDate::from_ymd_opt(2022, 12, 23).unwrap().and_hms_opt(13, 5, 26).unwrap()   NaiveDate::from_ymd_opt(2022, 12, 23).unwrap().and_hms_opt(13, 5, 26).unwrap();\n        2    \"Ash\".to_owned()        NaiveDate::from_ymd_opt(2023, 4, 1).unwrap().and_hms_opt(23, 24, 11).unwrap()    NaiveDate::from_ymd_opt(2023, 4, 1).unwrap().and_hms_opt(23, 24, 11).unwrap()\n    ));\n    assert_eq!(actual, expected, \"to_timestamp\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","datetime","current_date_and_time.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(current_date_and_time, {\n    macro_rules! t {\n        ($timestamp: expr) =\u003e {\n            $timestamp.parse().unwrap()\n        };\n    }\n\n    let glue = get_glue!();\n\n    let actual = table(\"Record\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"time_stamp TIMESTAMP\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Record\");\n\n    let actual = table(\"Record\")\n        .insert()\n        .values(vec![\n            \"1, '2022-12-23T05:30:11.164932863'\",\n            \"2, NOW()\",\n            \"3, '9999-12-31T23:59:40.364832862'\",\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(3));\n    assert_eq!(actual, expected, \"insert - Record\");\n\n    // Now\n    let actual = table(\"Record\")\n        .select()\n        .filter(col(\"time_stamp\").gt(f::now()))\n        .project(\"id, time_stamp\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | time_stamp\n        I64 | Timestamp;\n        3     t!(\"9999-12-31T23:59:40.364832862\")\n    ));\n    assert_eq!(actual, expected, \"now\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","datetime","formatting.rs"],"content":"use {\n    crate::*,\n    chrono::{NaiveDate, NaiveTime},\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        executor::Payload,\n        prelude::Value::*,\n    },\n};\ntest_case!(formatting, {\n    let glue = get_glue!();\n\n    // create table -\"Visitor\"\n    let actual = table(\"Visitor\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"name TEXT\")\n        .add_column(\"visit_date DATE\")\n        .add_column(\"visit_time TIME\")\n        .add_column(\"visit_timestamp TIMESTAMP\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Visitor\");\n\n    // insert\n    let actual = table(\"Visitor\")\n        .insert()\n        .values(vec![\n            vec![\n                num(1),\n                text(\"Bryanna\"),\n                date(\"2017-06-15\"),\n                time(\"13:05:26\"),\n                timestamp(\"2015-09-05 23:56:04\"),\n            ],\n            vec![\n                num(2),\n                text(\"Ash\"),\n                date(\"2023-04-01\"),\n                time(\"23:24:11\"),\n                timestamp(\"2023-04-01 23:24:11\"),\n            ],\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(2));\n    assert_eq!(actual, expected, \"insert - Visitor\");\n\n    // format date\n    let actual = table(\"Visitor\")\n        .select()\n        .project(\"name\")\n        .project(\"visit_date\")\n        .project(col(\"visit_date\").format(text(\"%Y-%m\")))\n        .project(f::format(col(\"visit_date\"), text(\"%m\")))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        name                    | visit_date                                       | r#\"FORMAT(\"visit_date\", '%Y-%m')\"#          | r#\"FORMAT(\"visit_date\", '%m')\"#\n        Str                     | Date                                             | Str                                        | Str;\n        \"Bryanna\".to_owned()    NaiveDate::from_ymd_opt(2017, 6, 15).unwrap()     \"2017-06\".to_owned()                        \"06\".to_owned();\n        \"Ash\".to_owned()        NaiveDate::from_ymd_opt(2023, 4, 1).unwrap()     \"2023-04\".to_owned()                        \"04\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"format date - Visitor\");\n\n    // format time\n    let actual = table(\"Visitor\")\n        .select()\n        .project(\"name\")\n        .project(\"visit_time\")\n        .project(col(\"visit_time\").format(text(\"%H:%M:%S\")))\n        .project(f::format(col(\"visit_time\"), text(\"%M:%S\")))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        name                    | visit_time                                       | r#\"FORMAT(\"visit_time\", '%H:%M:%S')\"#          | r#\"FORMAT(\"visit_time\", '%M:%S')\"#\n        Str                     | Time                                             | Str                                        | Str;\n        \"Bryanna\".to_owned()    NaiveTime::from_hms_opt(13, 5, 26).unwrap()     \"13:05:26\".to_owned()                        \"05:26\".to_owned();\n        \"Ash\".to_owned()        NaiveTime::from_hms_opt(23, 24, 11).unwrap()     \"23:24:11\".to_owned()                        \"24:11\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"format time - Visitor\");\n\n    // format timestamp\n    let actual = table(\"Visitor\")\n        .select()\n        .project(\"name\")\n        .project(\"visit_timestamp\")\n        .project(col(\"visit_timestamp\").format(text(\"%Y-%m-%d %H:%M:%S\")))\n        .project(f::format(col(\"visit_timestamp\"), text(\"%Y-%m-%d %H:%M:%S\")))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        name                    | visit_timestamp                                                                   | r#\"FORMAT(\"visit_timestamp\", '%Y-%m-%d %H:%M:%S')\"#           | r#\"FORMAT(\"visit_timestamp\", '%Y-%m-%d %H:%M:%S')\"#\n        Str                     | Timestamp                                                                         | Str                                                           | Str;\n        \"Bryanna\".to_owned()    NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap()     \"2015-09-05 23:56:04\".to_owned()                                 \"2015-09-05 23:56:04\".to_owned();\n        \"Ash\".to_owned()        NaiveDate::from_ymd_opt(2023, 4, 1).unwrap().and_hms_opt(23, 24, 11).unwrap()     \"2023-04-01 23:24:11\".to_owned()                                 \"2023-04-01 23:24:11\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"format timestamp - Visitor\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","datetime.rs"],"content":"mod conversion;\nmod current_date_and_time;\nmod formatting;\n\npub use {\n    conversion::conversion, current_date_and_time::current_date_and_time, formatting::formatting,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","math","basic_arithmetic.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        executor::Payload,\n        prelude::Value::*,\n    },\n};\n\ntest_case!(basic_arithmetic, {\n    let glue = get_glue!();\n\n    // Create table - Number\n    let actual = table(\"Number\")\n        .create_table()\n        .add_column(\"id INTEGER\")\n        .add_column(\"number INTEGER\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Number\");\n\n    // Insert a row into the Number\n    let actual = table(\"Number\")\n        .insert()\n        .values(vec![\"0, 0\", \"1, 3\", \"2, 4\", \"3, 29\"])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(4));\n    assert_eq!(actual, expected, \"insert into Number\");\n\n    // Example Using ABS\n    let actual = values(vec![\"0, 0\", \"1, -3\", \"2, 4\", \"3, -29\"])\n        .alias_as(\"number\")\n        .select()\n        .project(\"column1\")\n        .project(f::abs(\"column2\"))\n        .project(col(\"column2\").abs())\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        column1 | r#\"ABS(\"column2\")\"#   | r#\"ABS(\"column2\")\"#\n        I64     | I64                   | I64;\n        0         0                       0;\n        1         3                       3;\n        2         4                       4;\n        3         29                      29\n    ));\n    assert_eq!(actual, expected, \"Example Using ABS\");\n\n    //Example Using DIV\n    let actual = table(\"Number\")\n        .select()\n        .project(\"id\")\n        .project(f::divide(\"number\", 3))\n        .project(f::divide(col(\"number\"), 3))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | r#\"DIV(\"number\", 3)\"# | r#\"DIV(\"number\", 3)\"#\n        I64 | I64                   | I64;\n        0     0                       0;\n        1     1                       1;\n        2     1                       1;\n        3     9                       9\n    ));\n    assert_eq!(actual, expected, \"Example Using DIV\");\n\n    //Example Using MOD\n    let actual = table(\"Number\")\n        .select()\n        .project(\"id\")\n        .project(f::modulo(\"number\", 4))\n        .project(f::modulo(col(\"number\"), 4))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | r#\"MOD(\"number\", 4)\"# | r#\"MOD(\"number\", 4)\"#\n        I64 | I64                   | I64;\n        0     0                       0;\n        1     3                       3;\n        2     0                       0;\n        3     1                       1\n    ));\n    assert_eq!(actual, expected, \"Example Using MOD\");\n\n    //Example Using GCD\n    let actual = table(\"Number\")\n        .select()\n        .project(\"id\")\n        .project(f::gcd(\"number\", 12))\n        .project(f::gcd(col(\"number\"), 12))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | r#\"GCD(\"number\", 12)\"# | r#\"GCD(\"number\", 12)\"#\n        I64 | I64                   | I64;\n        0     12                      12;\n        1     3                       3;\n        2     4                       4;\n        3     1                       1\n    ));\n    assert_eq!(actual, expected, \"Example Using GCD\");\n\n    //Example Using LCM\n    let actual = table(\"Number\")\n        .select()\n        .project(\"id\")\n        .project(f::lcm(\"number\", 3))\n        .project(f::lcm(col(\"number\"), 3))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | r#\"LCM(\"number\", 3)\"# | r#\"LCM(\"number\", 3)\"#\n        I64 | I64                   | I64;\n        0     0                       0;\n        1     3                       3;\n        2     12                      12;\n        3     87                      87\n    ));\n    assert_eq!(actual, expected, \"Example Using LCM\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","math","conversion.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        executor::Payload,\n        prelude::Value::*,\n    },\n    std::f64::consts::*,\n};\n\ntest_case!(conversion, {\n    let glue = get_glue!();\n\n    // Create table - Number\n    let actual = table(\"Number\")\n        .create_table()\n        .add_column(\"input INTEGER\")\n        .add_column(\"number FLOAT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Number\");\n\n    // Insert a row into the Number\n    let actual = table(\"Number\")\n        .insert()\n        .values(vec![\"0, 0.0\", \"90, 90.0\", \"180, 180.0\", \"360, 360.0\"])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(4));\n    assert_eq!(actual, expected, \"insert into Number\");\n\n    // Example Using DEGREES\n    let actual = table(\"Number\")\n        .select()\n        .project(\"input\")\n        .project(f::degrees(\"number\"))\n        .project(col(\"number\").degrees())\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        input   | r#\"DEGREES(\"number\")\"#    | r#\"DEGREES(\"number\")\"#\n        I64     | F64                       | F64;\n        0         0.0                         0.0;\n        90        5156.620156177409           5156.620156177409;\n        180       10313.240312354817          10313.240312354817;\n        360       20626.480624709635          20626.480624709635\n    ));\n    assert_eq!(actual, expected, \"Example Using DEGREES\");\n\n    // Example Using RADIANS\n    let actual = table(\"Number\")\n        .select()\n        .project(\"input\")\n        .project(f::radians(\"number\"))\n        .project(col(\"number\").radians())\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        input   | r#\"RADIANS(\"number\")\"#    | r#\"RADIANS(\"number\")\"#\n        I64     | F64                       | F64;\n        0         0.0                         0.0;\n        90        FRAC_PI_2                   FRAC_PI_2;\n        180       PI                          PI;\n        360       TAU                         TAU\n    ));\n    assert_eq!(actual, expected, \"Example Using RADIANS\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","math","rounding.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        executor::Payload,\n        prelude::Value::*,\n    },\n};\n\ntest_case!(rounding, {\n    let glue = get_glue!();\n\n    // create table - Number\n    let actual = table(\"Number\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"number FLOAT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Number\");\n\n    // insert into Number\n    let actual = table(\"Number\")\n        .insert()\n        .values(vec![\"1, 0.3\", \"2, -0.8\", \"3, 10\", \"4, 6.87421\"])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(4));\n    assert_eq!(actual, expected, \"insert into Number\");\n\n    // ceil\n    let actual = table(\"Number\")\n        .select()\n        .project(\"id\")\n        .project(f::ceil(\"number\"))\n        .project(col(\"number\").ceil())\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | \"CEIL(\\\"number\\\")\" | \"CEIL(\\\"number\\\")\"\n        I64 | F64                | F64;\n        1     1.0                  1.0;\n        2     0.0                  0.0;\n        3     10.0                 10.0;\n        4     7.0                  7.0\n    ));\n    assert_eq!(actual, expected, \"ceil\");\n\n    //floor\n    let actual = table(\"Number\")\n        .select()\n        .project(\"id\")\n        .project(f::floor(\"number\"))\n        .project(col(\"number\").floor())\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | \"FLOOR(\\\"number\\\")\" | \"FLOOR(\\\"number\\\")\"\n        I64 | F64                 | F64;\n        1     0.0                   0.0;\n        2     f64::from(-1)         f64::from(-1);\n        3     10.0                  10.0;\n        4     6.0                   6.0\n    ));\n    assert_eq!(actual, expected, \"floor\");\n\n    //round\n    let actual = table(\"Number\")\n        .select()\n        .project(\"id\")\n        .project(f::round(\"number\"))\n        .project(col(\"number\").round())\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | \"ROUND(\\\"number\\\")\" | \"ROUND(\\\"number\\\")\"\n        I64 | F64                 | F64;\n        1     0.0                   0.0;\n        2     f64::from(-1)         f64::from(-1);\n        3     10.0                  10.0;\n        4     7.0                   7.0\n    ));\n    assert_eq!(actual, expected, \"round\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","math.rs"],"content":"mod basic_arithmetic;\nmod conversion;\nmod rounding;\npub use {basic_arithmetic::basic_arithmetic, conversion::conversion, rounding::rounding};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","other","coalesce.rs"],"content":"use {\n    crate::*,\n    chrono::{NaiveDate, NaiveDateTime},\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        executor::Payload,\n        prelude::Value::*,\n    },\n};\n\ntest_case!(coalesce, {\n    let glue = get_glue!();\n\n    // create table - Foo\n    let actual = table(\"Foo\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"first TEXT\")\n        .add_column(\"second INTEGER\")\n        .add_column(\"third TIMESTAMP\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Foo\");\n\n    // insert into Foo\n    let actual = table(\"Foo\")\n        .insert()\n        .columns(\"id, first, second, third\")\n        .values(vec![\n            vec![num(100), text(\"visible\"), null(), null()],\n            vec![num(200), null(), num(42), null()],\n            vec![num(300), null(), null(), timestamp(\"2023-06-01 12:00:00\")],\n            vec![num(400), null(), null(), null()],\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(4));\n    assert_eq!(actual, expected, \"insert into Foo\");\n\n    let actual = table(\"Foo\")\n        .select()\n        .project(\"id\")\n        .project(f::coalesce(vec![\n            null(),\n            col(\"first\"),\n            col(\"second\"),\n            col(\"third\"),\n        ]))\n        .order_by(\"id\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select_with_null!(\n        id        | r#\"COALESCE(NULL, \"first\", \"second\", \"third\")\"#;\n        I64(100)    Str(\"visible\".to_owned());\n        I64(200)    I64(42);\n        I64(300)    Timestamp(\"2023-06-01T12:00:00\".parse::\u003cNaiveDateTime\u003e().unwrap());\n        I64(400)    Null\n    ));\n    assert_eq!(actual, expected, \"coalesce with table columns\");\n\n    let actual = values(vec![\n        vec![f::coalesce(vec![text(\"\")])],\n        vec![f::coalesce(vec![null(), num(1)])],\n        vec![f::coalesce(vec![null(), null(), date(\"2000-01-01\")])],\n    ])\n    .execute(glue)\n    .await;\n    let expected = Ok(select_with_null!(\n        column1;\n        Str(\"\".to_owned());\n        I64(1);\n        Date(\"2000-01-01\".parse::\u003cNaiveDate\u003e().unwrap())\n    ));\n    assert_eq!(actual, expected, \"coalesce without table\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","other","ifnull.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        executor::Payload,\n        prelude::Value::*,\n    },\n};\n\ntest_case!(ifnull, {\n    let glue = get_glue!();\n\n    // create table - Foo\n    let actual = table(\"Foo\")\n        .create_table()\n        .add_column(\"id INTEGER\")\n        .add_column(\"name TEXT\")\n        .add_column(\"nickname TEXT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Foo\");\n\n    // insert into Foo\n    let actual = table(\"Foo\")\n        .insert()\n        .columns(\"id, name nickname\")\n        .values(vec![\n            vec![num(100), text(\"Pickle\"), text(\"Pi\")],\n            vec![num(200), null(), text(\"Hello\")],\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(2));\n    assert_eq!(actual, expected, \"insert into Foo\");\n\n    // Replace with text using ifnull\n    let actual = table(\"Foo\")\n        .select()\n        .project(\"id\")\n        .project(col(\"name\").ifnull(text(\"isnull\")))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | \"IFNULL(\\\"name\\\", 'isnull')\"\n        I64 | Str;\n        100   \"Pickle\".to_owned();\n        200   \"isnull\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"replace with text using ifnull\");\n\n    // Replace with other column using ifnull\n    let actual = table(\"Foo\")\n        .select()\n        .project(\"id\")\n        .project(col(\"name\").ifnull(col(\"nickname\")))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | \"IFNULL(\\\"name\\\", \\\"nickname\\\")\"\n        I64 | Str;\n        100   \"Pickle\".to_owned();\n        200   \"Hello\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"replace with other column using ifnull\");\n\n    // ifnull without table\n    let actual = values(vec![\n        vec![f::ifnull(text(\"HELLO\"), text(\"WORLD\"))],\n        vec![f::ifnull(null(), text(\"WORLD\"))],\n    ])\n    .execute(glue)\n    .await;\n    let expected = Ok(select!(\n        \"column1\"\n        Str;\n        \"HELLO\".to_owned();\n        \"WORLD\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"ifnull without table\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","other","iif.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast::ToSql, ast_builder::{function as f, expr, *}},\n};\n\n// Verify SQL generation for IIF in AST Builder DSL (free function and method)\ntest_case!(iif, {\n    // Free function style\n    let actual = values(vec![vec![f::iif(expr(\"1 \u003c 2\"), num(10), num(20))]])\n        .build()\n        .unwrap();\n    assert_eq!(actual.to_sql(), \"VALUES (IIF(1 \u003c 2, 10, 20))\");\n\n    // Chained method style\n    let actual = values(vec![vec![col(\"flag\").iif(text(\"yes\"), text(\"no\"))]])\n        .build()\n        .unwrap();\n    assert_eq!(actual.to_sql(), \"VALUES (IIF(flag, 'yes', 'no'))\");\n}); ","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","other","nullif.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        executor::Payload,\n        prelude::Value::*,\n    },\n};\n\ntest_case!(nullif, {\n    let glue = get_glue!();\n\n    // create table - Foo\n    let actual = table(\"Foo\")\n        .create_table()\n        .add_column(\"id INTEGER \")\n        .add_column(\"name TEXT\")\n        .add_column(\"nickname TEXT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Foo\");\n\n    // insert into Foo\n    let actual = table(\"Foo\")\n        .insert()\n        .columns(\"id, name nickname\")\n        .values(vec![\n            vec![num(100), text(\"hello\"), text(\"bye\")],\n            vec![num(200), text(\"world\"), text(\"world\")],\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(2));\n    assert_eq!(actual, expected, \"insert into Foo\");\n\n    // Return null when text equal\n    let actual = table(\"Foo\")\n        .select()\n        .project(\"id\")\n        .project(col(\"name\").nullif(text(\"hello\")))\n        .execute(glue)\n        .await;\n    let expected = Ok(select_with_null!(\n        id | \"NULLIF(\\\"name\\\", 'hello')\";\n        I64(100)   Null;\n        I64(200)   Str(\"world\".to_owned())\n    ));\n    assert_eq!(actual, expected, \"return null when text value equal\");\n\n    // Return first argument when other column text different\n    let actual = table(\"Foo\")\n        .select()\n        .project(\"id\")\n        .project(col(\"name\").nullif(col(\"nickname\")))\n        .execute(glue)\n        .await;\n    let expected = Ok(select_with_null!(\n        id | \"NULLIF(\\\"name\\\", \\\"nickname\\\")\";\n        I64(100) Str(\"hello\".to_owned());\n        I64(200) Null\n    ));\n    assert_eq!(\n        actual, expected,\n        \"return first argument with other column using nullif\"\n    );\n\n    // nullif without table\n    let actual = values(vec![\n        vec![f::nullif(text(\"HELLO\"), text(\"WORLD\"))],\n        vec![f::nullif(text(\"WORLD\"), text(\"WORLD\"))],\n    ])\n    .execute(glue)\n    .await;\n    let expected = Ok(select_with_null!(\n        \"column1\" | Str;\n        Str(\"HELLO\".to_owned());\n        Null\n    ));\n    assert_eq!(actual, expected, \"nullif without table\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","other.rs"],"content":"pub mod coalesce;\npub mod ifnull;\npub mod nullif;\npub mod iif;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","text","case_conversion.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        executor::Payload,\n        prelude::Value::*,\n    },\n};\n\ntest_case!(case_conversion, {\n    let glue = get_glue!();\n\n    let actual = table(\"Item\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"name TEXT DEFAULT UPPER('abc')\")\n        .add_column(\"opt_name TEXT DEFAULT LOWER('ABC')\")\n        .add_column(\"capped_name TEXT DEFAULT 'pascal'\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Item\");\n\n    let actual = table(\"Item\")\n        .insert()\n        .values(vec![\n            vec![num(1), text(\"abcd\"), text(\"efgi\"), text(\"h/i jk\")],\n            vec![num(2), text(\"Abcd\"), null(), null()],\n            vec![num(3), text(\"ABCD\"), text(\"EfGi\"), text(\"H/I JK\")],\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(3));\n    assert_eq!(actual, expected, \"insert - Item\");\n\n    //check upper,lower case\n    let actual = table(\"Item\")\n        .select()\n        .filter(col(\"name\").lower().eq(\"'abcd'\"))\n        .project(\"name\")\n        .project(f::lower(\"name\"))\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        name                | r#\"LOWER(\"name\")\"#\n        Str                 | Str;\n        \"abcd\".to_owned()    \"abcd\".to_owned();\n        \"Abcd\".to_owned()    \"abcd\".to_owned();\n        \"ABCD\".to_owned()    \"abcd\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"check lower case\");\n\n    let actual = table(\"Item\")\n        .select()\n        .project(col(\"name\").lower())\n        .project(col(\"name\").upper())\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        r#\"LOWER(\"name\")\"#  | \"UPPER(\\\"name\\\")\"\n        Str                 | Str;\n        \"abcd\".to_owned()    \"ABCD\".to_owned();\n        \"abcd\".to_owned()    \"ABCD\".to_owned();\n        \"abcd\".to_owned()    \"ABCD\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"check upper case\");\n\n    let actual = table(\"Item\")\n        .select()\n        .project(col(\"opt_name\").lower())\n        .project(col(\"opt_name\").upper())\n        .execute(glue)\n        .await;\n    let expected = Ok(select_with_null!(\n        r#\"LOWER(\"opt_name\")\"#  | \"UPPER(\\\"opt_name\\\")\";\n        Str(\"efgi\".to_owned())    Str(\"EFGI\".to_owned());\n        Null                      Null;\n        Str(\"efgi\".to_owned())    Str(\"EFGI\".to_owned())\n    ));\n    assert_eq!(actual, expected, \"check upper \u0026 lower null case\");\n\n    //check initcap case\n    let actual = table(\"Item\")\n        .select()\n        .filter(col(\"capped_name\").initcap().eq(\"'H/I Jk'\"))\n        .project(\"capped_name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        capped_name\n        Str;\n        \"h/i jk\".to_owned();\n        \"H/I JK\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"check initcap case\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","text","character_conversion.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(character_conversion, {\n    let glue = get_glue!();\n\n    let actual = values(vec![\n        vec![f::ascii(\"'\\t'\"), f::chr(9)],\n        vec![f::ascii(\"'\\n'\"), f::chr(10)],\n        vec![f::ascii(\"'\\r'\"), f::chr(13)],\n        vec![f::ascii(\"' '\"), f::chr(32)],\n        vec![f::ascii(\"'!'\"), f::chr(33)],\n        vec![f::ascii(\"'\\\"'\"), f::chr(34)],\n        vec![f::ascii(\"'#'\"), f::chr(35)],\n        vec![f::ascii(\"'$'\"), f::chr(36)],\n        vec![f::ascii(\"'%'\"), f::chr(37)],\n        vec![f::ascii(\"'\u0026'\"), f::chr(38)],\n        vec![f::ascii(\"''''\"), f::chr(39)],\n        vec![f::ascii(\"','\"), f::chr(44)],\n    ])\n    .alias_as(\"Sub\")\n    .select()\n    .project(\"column1 AS ascii\")\n    .project(\"column2 AS char\")\n    .execute(glue)\n    .await;\n    let expected = Ok(select!(\n        ascii | char\n        U8    | Str;\n        9        \"\\t\".to_owned();\n        10       \"\\n\".to_owned();\n        13       \"\\r\".to_owned();\n        32       \" \".to_owned();\n        33       \"!\".to_owned();\n        34       \"\\\"\".to_owned();\n        35       \"#\".to_owned();\n        36       \"$\".to_owned();\n        37       \"%\".to_owned();\n        38       \"\u0026\".to_owned();\n        39       \"'\".to_owned();\n        44        \",\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"ascii and char set should match\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","text","padding.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        prelude::Value::{Null, Str},\n    },\n};\n\ntest_case!(padding, {\n    let glue = get_glue!();\n\n    let actual = values(vec![\n        vec![f::lpad(\"'hello'\", 10, None), f::rpad(\"'hello'\", 10, None)],\n        vec![\n            f::lpad(\"'hello'\", 10, Some(\"'ab'\".into())),\n            f::rpad(\"'hello'\", 10, Some(\"'ab'\".into())),\n        ],\n        vec![f::lpad(\"'hello'\", 3, None), f::rpad(\"'hello'\", 3, None)],\n        vec![\n            f::lpad(\"'hello'\", 3, Some(\"'ab'\".into())),\n            f::rpad(\"'hello'\", 3, Some(\"'ab'\".into())),\n        ],\n        vec![f::lpad(\"NULL\", 5, None), f::rpad(\"NULL\", 5, None)],\n    ])\n    .alias_as(\"Sub\")\n    .select()\n    .project(\"column1 AS lpaded\")\n    .project(\"column2 AS rpaded\")\n    .execute(glue)\n    .await;\n    let expected = Ok(select_with_null!(\n        lpaded                       | rpaded;\n        Str(\"     hello\".to_owned())   Str(\"hello     \".to_owned());\n        Str(\"ababahello\".to_owned())   Str(\"helloababa\".to_owned());\n        Str(\"hel\".to_owned())          Str(\"hel\".to_owned());\n        Str(\"hel\".to_owned())          Str(\"hel\".to_owned());\n        Null                           Null\n    ));\n    assert_eq!(\n        actual, expected,\n        \"lpad and rpad should pad the string with given length\"\n    );\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","text","position_and_indexing.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        executor::Payload,\n        prelude::Value::*,\n    },\n};\n\ntest_case!(position_and_indexing, {\n    // test - find_idx\n\n    let glue = get_glue!();\n\n    // create table - Item\n    let actual = table(\"Item\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"index INTEGER\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Item\");\n\n    // insert table - Item\n    let test_num = f::find_idx(text(\"strawberry\"), text(\"berry\"), None);\n    let actual = table(\"Item\")\n        .insert()\n        .columns(\"id, index\")\n        .values(vec![vec![num(1), test_num]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected, \"insert - find_idx\");\n\n    // select - table - Item\n    let actual = table(\"Item\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | index\n        I64 | I64;\n        1     6\n    ));\n    assert_eq!(actual, expected, \"select from Item\");\n\n    let test_num = f::find_idx(\n        text(\"Oracle Database 12c Release\"),\n        text(\"as\"),\n        Some(num(15)),\n    );\n    let actual = table(\"Item\")\n        .insert()\n        .columns(\"id, index\")\n        .values(vec![vec![num(2), test_num]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected, \"insert - find_idx\");\n\n    // select - table - Item\n    let actual = table(\"Item\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | index\n        I64 | I64;\n        1     6;\n        2     25\n    ));\n    assert_eq!(actual, expected, \"select from Item\");\n\n    let test_num = text(\"Oracle Database 12c Release\").find_idx(text(\"as\"), Some(num(15)));\n    let actual = table(\"Item\")\n        .insert()\n        .columns(\"id, index\")\n        .values(vec![vec![num(3), test_num]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected, \"insert - find_idx\");\n\n    // select - table - Item\n    let actual = table(\"Item\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | index\n        I64 | I64;\n        1     6;\n        2     25;\n        3     25\n    ));\n    assert_eq!(actual, expected, \"select from Item\");\n\n    // test - position\n    let test_num = f::position(text(\"cake\"), text(\"ke\"));\n\n    // insert table - Item\n    let actual = table(\"Item\")\n        .insert()\n        .columns(\"id, index\")\n        .values(vec![vec![num(4), test_num]])\n        .execute(glue)\n        .await;\n\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected, \"insert - position\");\n\n    // select - table - Item\n    let actual = table(\"Item\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | index\n        I64 | I64;\n        1     6;\n        2     25;\n        3     25;\n        4     3\n    ));\n    assert_eq!(actual, expected, \"select from Item\");\n\n    // test - left\n    let actual = table(\"LeftRight\")\n        .create_table()\n        .add_column(\"value TEXT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - LeftRight\");\n\n    let test_str = f::left(text(\"Hello, World\"), num(7));\n\n    // insert table - Item\n    let actual = table(\"LeftRight\")\n        .insert()\n        .values(vec![vec![test_str]])\n        .execute(glue)\n        .await;\n\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected, \"insert - left\");\n\n    // select - table - Item\n    let actual = table(\"LeftRight\").select().execute(glue).await;\n    let expected = Ok(select!(\n        value\n        Str;\n        \"Hello, \".to_owned()\n    ));\n    assert_eq!(actual, expected, \"select from LeftRight\");\n\n    // test - right\n    let test_str = f::right(text(\"Hello, World\"), num(7));\n    // insert table - Item\n    let actual = table(\"LeftRight\")\n        .insert()\n        .values(vec![vec![test_str]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected, \"insert - right\");\n\n    // select - table - Item\n    let actual = table(\"LeftRight\").select().execute(glue).await;\n    let expected = Ok(select!(\n        value\n        Str;\n        \"Hello, \".to_owned();\n        \", World\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"select from LeftRight\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","text","trimming.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast_builder::{function as f, *},\n        executor::Payload,\n        prelude::Value::*,\n    },\n};\n\ntest_case!(trimming, {\n    let glue = get_glue!();\n\n    // rtrim test\n    let actual = table(\"Food\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"name TEXT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Food\");\n\n    let actual = table(\"Food\")\n        .insert()\n        .columns(\"id, name\")\n        .values(vec![vec![\n            num(1),\n            text(\"chicken   \").rtrim(Some(text(\" \"))),\n        ]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected, \"insert - rtrim\");\n\n    let actual = table(\"Food\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"chicken\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"select from Food\");\n\n    // ltrim test\n    let actual = table(\"Food\")\n        .insert()\n        .columns(\"id, name\")\n        .values(vec![vec![\n            num(2),\n            f::ltrim(text(\"   chicken\"), Some(text(\" \"))),\n        ]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected, \"insert - ltirm\");\n\n    let actual = table(\"Food\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"chicken\".to_owned();\n        2     \"chicken\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"select from Food\");\n\n    // ltrim and rtrim test\n    let test_text = text(\"chicken\").ltrim(Some(text(\"ch\"))).rtrim(None);\n    let actual = table(\"Food\")\n        .insert()\n        .columns(\"id, name\")\n        .values(vec![vec![num(3), test_text]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected, \"insert - ltrim and rtrim\");\n\n    let actual = table(\"Food\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"chicken\".to_owned();\n        2     \"chicken\".to_owned();\n        3     \"icken\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"select from Food\");\n\n    // rtrim and ltrim test\n    let test_text = text(\"chicken\").rtrim(Some(text(\"en\"))).ltrim(None);\n    let actual = table(\"Food\")\n        .insert()\n        .columns(\"id, name\")\n        .values(vec![vec![num(4), test_text]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected, \"insert - rtrim and ltrim\");\n\n    let actual = table(\"Food\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"chicken\".to_owned();\n        2     \"chicken\".to_owned();\n        3     \"icken\".to_owned();\n        4     \"chick\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"select from Food\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function","text.rs"],"content":"mod trimming;\npub use trimming::trimming;\n\nmod case_conversion;\npub use case_conversion::case_conversion;\n\nmod character_conversion;\npub use character_conversion::character_conversion;\n\nmod padding;\npub use padding::padding;\n\nmod position_and_indexing;\npub use position_and_indexing::position_and_indexing;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","function.rs"],"content":"pub mod datetime;\npub mod math;\npub mod other;\npub mod text;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","index_by.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast_builder::*,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(index_by, {\n    let glue = get_glue!();\n\n    let actual = table(\"Foo\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"name TEXT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Foo\");\n\n    let actual = table(\"Foo\")\n        .insert()\n        .columns(\"id, name\")\n        .values(vec![vec![num(1), text(\"Drink\")]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected, \"insert - specifying columns\");\n\n    let actual = table(\"Foo\")\n        .index_by(primary_key().eq(\"1\"))\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Drink\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"basic select with index by\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","insert.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast_builder::*, executor::Payload, prelude::Value::*},\n};\n\ntest_case!(insert, {\n    let glue = get_glue!();\n\n    // create table - Foo\n    let actual = table(\"Foo\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"name TEXT\")\n        .add_column(\"rate FLOAT DEFAULT 0.0\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Foo\");\n\n    // create table - Bar\n    let actual = table(\"Bar\")\n        .create_table()\n        .add_column(\"id INTEGER UNIQUE NOT NULL\")\n        .add_column(\"name TEXT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Bar\");\n\n    // insert - basic\n    let actual = table(\"Foo\")\n        .insert()\n        .values(vec![\"1, 'Fruit', 0.1\", \"2, 'Meat', 0.8\"])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(2));\n    assert_eq!(actual, expected, \"insert - basic\");\n\n    // insert - specifying columns\n    let actual = table(\"Foo\")\n        .insert()\n        .columns(\"id, name\")\n        .values(vec![vec![num(3), text(\"Drink\")]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected, \"insert - specifying columns\");\n\n    // insert - from source\n    let actual = table(\"Bar\")\n        .insert()\n        .as_select(table(\"Foo\").select().project(\"id, name\"))\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(3));\n    assert_eq!(actual, expected, \"insert - from source\");\n\n    // select from Foo\n    let actual = table(\"Foo\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | name               | rate\n        I64 | Str                | F64;\n        1     \"Fruit\".to_owned()   0.1;\n        2     \"Meat\".to_owned()    0.8;\n        3     \"Drink\".to_owned()   0.0\n    ));\n    assert_eq!(actual, expected, \"select from Foo\");\n\n    // select from Bar\n    let actual = table(\"Bar\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Fruit\".to_owned();\n        2     \"Meat\".to_owned();\n        3     \"Drink\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"select from Bar\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","schemaless","basic.rs"],"content":"use {\n    crate::*,\n    gluesql_core::prelude::Value,\n    gluesql_core::{ast_builder::*, executor::Payload},\n    serde_json::json,\n};\n\ntest_case!(basic, {\n    let glue = get_glue!();\n\n    let actual = table(\"Logs\").create_table().execute(glue).await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create schemaless table\");\n\n    let row1 = json!({ \"id\": 1, \"value\": 30 }).to_string();\n    let row2 = json!({ \"id\": 2, \"rate\": 3.5, \"list\": [1, 2, 3] }).to_string();\n\n    let actual = table(\"Logs\")\n        .insert()\n        .values(vec![vec![text(\u0026row1)], vec![text(\u0026row2)]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(2));\n    assert_eq!(actual, expected, \"insert schemaless data\");\n\n    let actual = table(\"Logs\").select().execute(glue).await;\n    let expected = Ok(select_map![\n        json!({ \"id\": 1, \"value\": 30 }),\n        json!({ \"id\": 2, \"rate\": 3.5, \"list\": [1, 2, 3] })\n    ]);\n    assert_eq!(actual, expected, \"select schemaless data\");\n\n    let actual = table(\"Logs\").delete().filter(\"id = 1\").execute(glue).await;\n    let expected = Ok(Payload::Delete(1));\n    assert_eq!(actual, expected, \"delete schemaless row\");\n\n    let actual = table(\"Logs\").select().execute(glue).await;\n    let expected = Ok(select_map![\n        json!({ \"id\": 2, \"rate\": 3.5, \"list\": [1, 2, 3] })\n    ]);\n    assert_eq!(actual, expected, \"select after delete\");\n\n    let actual = table(\"Logs\").drop_table().execute(glue).await;\n    let expected = Ok(Payload::DropTable(1));\n    assert_eq!(actual, expected, \"drop schemaless table\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","schemaless.rs"],"content":"pub mod basic;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","select.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast_builder::*, executor::Payload, prelude::Value::*},\n};\n\ntest_case!(select, {\n    let glue = get_glue!();\n\n    // create table - Category\n    let actual = table(\"Category\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"name TEXT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Category\");\n\n    // create table - Item\n    let actual = table(\"Item\")\n        .create_table()\n        .add_column(\"id INTEGER\")\n        .add_column(\"category_id INTEGER\")\n        .add_column(\"name TEXT\")\n        .add_column(\"price INTEGER\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Item\");\n\n    // insert into Category\n    let actual = table(\"Category\")\n        .insert()\n        .values(vec![\"1, 'Fruit'\", \"2, 'Meat'\", \"3, 'Drink'\"])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(3));\n    assert_eq!(actual, expected, \"insert into Category\");\n\n    // insert into Item\n    let actual = table(\"Item\")\n        .insert()\n        .values(vec![\n            \"100, 1, 'Pineapple', 40\",\n            \"200, 2, 'Pork belly', 90\",\n            \"300, 1, 'Strawberry', 30\",\n            \"400, 3, 'Coffee', 25\",\n            \"500, 3, 'Orange juice', 60\",\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(5));\n    assert_eq!(actual, expected, \"insert into Item\");\n\n    // basic select\n    let actual = table(\"Category\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Fruit\".to_owned();\n        2     \"Meat\".to_owned();\n        3     \"Drink\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"basic select\");\n\n    // filter (WHERE name = \"Meat\")\n    let actual = table(\"Category\")\n        .select()\n        .filter(\"name = 'Meat'\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        2     \"Meat\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"filter (WHERE name = 'Meat')\");\n\n    // inner join\n    let actual = table(\"Item\")\n        .alias_as(\"i\")\n        .select()\n        .join_as(\"Category\", \"c\")\n        .on(\"c.id = i.category_id\")\n        .filter(\"c.name = 'Fruit' OR c.name = 'Meat'\")\n        .project(\"i.name AS item\")\n        .project(\"c.name AS category\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        item                    | category\n        Str                     | Str;\n        \"Pineapple\".to_owned()    \"Fruit\".to_owned();\n        \"Pork belly\".to_owned()   \"Meat\".to_owned();\n        \"Strawberry\".to_owned()   \"Fruit\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"inner join\");\n\n    // left outer join\n    let actual = table(\"Category\")\n        .select()\n        .left_join(\"Item\")\n        .on(col(\"Category.id\")\n            .eq(col(\"Item.category_id\"))\n            .and(col(\"price\").gt(50)))\n        .project(vec![\n            \"Category.name AS category\",\n            \"Item.name AS item\",\n            \"price\",\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(select_with_null!(\n        category                | item                           | price;\n        Str(\"Fruit\".to_owned())   Null                             Null;\n        Str(\"Meat\".to_owned())    Str(\"Pork belly\".to_owned())     I64(90);\n        Str(\"Drink\".to_owned())   Str(\"Orange juice\".to_owned())   I64(60)\n    ));\n    assert_eq!(actual, expected, \"left outer join\");\n\n    // group by - having\n    let actual = table(\"Item\")\n        .select()\n        .join(\"Category\")\n        .on(col(\"Category.id\").eq(\"Item.category_id\"))\n        .group_by(\"Item.category_id\")\n        .having(\"SUM(Item.price) \u003e 80\")\n        .project(\"Category.name AS category\")\n        .project(\"SUM(Item.price) AS sum_price\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        category           | sum_price\n        Str                | I64;\n        \"Meat\".to_owned()    90;\n        \"Drink\".to_owned()   85\n    ));\n    assert_eq!(actual, expected, \"group by - having\");\n\n    // order by\n    let actual = table(\"Item\")\n        .select()\n        .project(\"name, price\")\n        .order_by(\"price DESC\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        name                      | price\n        Str                       | I64;\n        \"Pork belly\".to_owned()     90;\n        \"Orange juice\".to_owned()   60;\n        \"Pineapple\".to_owned()      40;\n        \"Strawberry\".to_owned()     30;\n        \"Coffee\".to_owned()         25\n    ));\n    assert_eq!(actual, expected, \"order by\");\n\n    // offset, limit\n    let actual = table(\"Item\")\n        .select()\n        .project(\"name, price\")\n        .order_by(\"price DESC\")\n        .offset(1)\n        .limit(2)\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        name                      | price\n        Str                       | I64;\n        \"Orange juice\".to_owned()   60;\n        \"Pineapple\".to_owned()      40\n    ));\n    assert_eq!(actual, expected, \"offset, limit\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","statements","querying","data_aggregation.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast_builder::*, executor::Payload, prelude::Value::*},\n};\n\ntest_case!(data_aggregation, {\n    let glue = get_glue!();\n\n    let actual = table(\"User\")\n        .create_table()\n        .add_column(\"id INT\")\n        .add_column(\"name TEXT\")\n        .add_column(\"age INT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table\");\n\n    let actual = table(\"User\")\n        .insert()\n        .columns(\"id, name, age\")\n        .values(vec![\n            vec![num(1), text(\"Alice\"), num(20)],\n            vec![num(2), text(\"Bob\"), num(30)],\n            vec![num(3), text(\"Carol\"), num(30)],\n            vec![num(4), text(\"Dave\"), num(50)],\n            vec![num(5), text(\"Eve\"), num(50)],\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(5));\n    assert_eq!(actual, expected, \"insert\");\n\n    let actual = table(\"User\")\n        .select()\n        .group_by(\"age\")\n        .project(\"age, count(*)\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        age | r#\"count(*)\"#;\n        I64 | I64;\n        20    1;\n        30    2;\n        50    2\n    ));\n    assert_eq!(actual, expected, \"group by\");\n\n    let actual = table(\"User\")\n        .select()\n        .group_by(\"age\")\n        .having(\"count(*) \u003e 1\")\n        .project(\"age, count(*)\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        age | r#\"count(*)\"#;\n        I64 | I64;\n        30    2;\n        50    2\n    ));\n    assert_eq!(actual, expected, \"having\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","statements","querying","data_selection_and_projection.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast_builder::*, executor::Payload, prelude::Value::*},\n};\n\ntest_case!(data_selection_and_projection, {\n    let glue = get_glue!();\n\n    let actual = table(\"User\")\n        .create_table()\n        .add_column(\"id INT\")\n        .add_column(\"name TEXT\")\n        .add_column(\"age INT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table\");\n\n    let actual = table(\"User\")\n        .insert()\n        .columns(\"id, name, age\")\n        .values(vec![\n            vec![num(1), text(\"Alice\"), num(20)],\n            vec![num(2), text(\"Bob\"), num(30)],\n            vec![num(3), text(\"Carol\"), num(30)],\n            vec![num(4), text(\"Dave\"), num(50)],\n            vec![num(5), text(\"Eve\"), num(50)],\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(5));\n    assert_eq!(actual, expected, \"insert\");\n\n    let actual = table(\"User\")\n        .select()\n        .filter(col(\"age\").gt(30))\n        .project(\"id, age, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | age | name;\n        I64 | I64 | Str;\n        4     50    \"Dave\".to_owned();\n        5     50    \"Eve\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"filter\");\n\n    let actual = table(\"User\")\n        .select()\n        .project(\"id, age, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | age | name;\n        I64 | I64 | Str;\n        1     20    \"Alice\".to_owned();\n        2     30    \"Bob\".to_owned();\n        3     30    \"Carol\".to_owned();\n        4     50    \"Dave\".to_owned();\n        5     50    \"Eve\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"project\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","statements","querying.rs"],"content":"pub mod data_aggregation;\npub use data_aggregation::data_aggregation;\n\npub mod data_selection_and_projection;\npub use data_selection_and_projection::data_selection_and_projection;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","statements.rs"],"content":"pub mod querying;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","update.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast_builder::*, executor::Payload, prelude::Value::*},\n};\n\ntest_case!(update, {\n    let glue = get_glue!();\n\n    let actual = table(\"Foo\")\n        .create_table()\n        .add_column(\"id INTEGER PRIMARY KEY\")\n        .add_column(\"score INTEGER\")\n        .add_column(\"flag BOOLEAN\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected, \"create table - Foo\");\n\n    let actual = table(\"Foo\")\n        .insert()\n        .values(vec![\n            vec![num(1), num(100), true.into()],\n            vec![num(2), num(300), false.into()],\n            vec![num(3), num(700), true.into()],\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(3));\n    assert_eq!(actual, expected, \"insert into Foo\");\n\n    let actual = table(\"Foo\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | score | flag\n        I64 | I64   | Bool;\n        1     100     true;\n        2     300     false;\n        3     700     true\n    ));\n    assert_eq!(actual, expected, \"select * from Foo\");\n\n    // update all\n    let actual = table(\"Foo\")\n        .update()\n        .set(\"score\", col(\"score\").div(10))\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Update(3));\n    assert_eq!(actual, expected, \"update all\");\n\n    let actual = table(\"Foo\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | score | flag\n        I64 | I64   | Bool;\n        1     10      true;\n        2     30      false;\n        3     70      true\n    ));\n    assert_eq!(actual, expected, \"select * from Foo\");\n\n    // update set multiple and use filter\n    let actual = table(\"Foo\")\n        .update()\n        .filter(col(\"score\").lte(30))\n        .set(\"score\", \"score * 2 + 5\")\n        .set(\"flag\", col(\"flag\").negate())\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Update(2));\n    assert_eq!(actual, expected, \"update set multiple and use filter\");\n\n    let actual = table(\"Foo\").select().execute(glue).await;\n    let expected = Ok(select!(\n        id  | score | flag\n        I64 | I64   | Bool;\n        1     25      false;\n        2     65      true;\n        3     70      true\n    ));\n    assert_eq!(actual, expected, \"select * from Foo\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder","values.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast_builder::*, prelude::Value::*},\n};\n\ntest_case!(values, {\n    use gluesql_core::ast_builder::values;\n    let glue = get_glue!();\n\n    let actual = values(vec![\"1, 'Glue'\", \"2, 'SQL'\", \"3, 'Rust'\"])\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        column1 | column2\n        I64     | Str;\n        1         \"Glue\".to_owned();\n        2         \"SQL\".to_owned();\n        3         \"Rust\".to_owned()\n\n    ));\n    assert_eq!(actual, expected, \"values - row as string\");\n\n    let actual = values(vec![\n        vec![\"1\", \"'Glue'\"],\n        vec![\"2\", \"'SQL'\"],\n        vec![\"3\", \"'Rust'\"],\n    ])\n    .execute(glue)\n    .await;\n    let expected = Ok(select!(\n        column1 | column2\n        I64     | Str;\n        1         \"Glue\".to_owned();\n        2         \"SQL\".to_owned();\n        3         \"Rust\".to_owned()\n\n    ));\n    assert_eq!(actual, expected, \"values - row as vec\");\n\n    let actual = values(vec![\"1, 'Glue'\", \"2, 'SQL'\", \"3, 'Rust'\"])\n        .order_by(\"column2 desc\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        column1 | column2\n        I64     | Str;\n        2         \"SQL\".to_owned();\n        3         \"Rust\".to_owned();\n        1         \"Glue\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"values - order by\");\n\n    let actual = values(vec![\"1, 'Glue'\", \"2, 'SQL'\", \"3, 'Rust'\"])\n        .offset(1)\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        column1 | column2\n        I64     | Str;\n        2         \"SQL\".to_owned();\n        3         \"Rust\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"values - offset\");\n\n    let actual = values(vec![\"1, 'Glue'\", \"2, 'SQL'\", \"3, 'Rust'\"])\n        .limit(2)\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        column1 | column2\n        I64     | Str;\n        1         \"Glue\".to_owned();\n        2         \"SQL\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"values - limit\");\n\n    let actual = values(vec![\"1, 'Glue'\", \"2, 'SQL'\", \"3, 'Rust'\"])\n        .alias_as(\"Sub\")\n        .select()\n        .project(\"column1 AS id\")\n        .project(\"column2 AS name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Glue\".to_owned();\n        2     \"SQL\".to_owned();\n        3     \"Rust\".to_owned()\n    ));\n    assert_eq!(actual, expected, \"values - alias as\");\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ast_builder.rs"],"content":"pub mod alias_as;\npub mod basic;\npub mod delete;\npub mod expr;\npub mod function;\npub mod index_by;\npub mod insert;\npub mod schemaless;\npub mod select;\npub mod statements;\npub mod update;\npub mod values;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","basic.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::TranslateError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(basic, {\n    let g = get_tester!();\n\n    let queries = [\n        r#\"\n        CREATE TABLE Test (\n            id INTEGER,\n            num INTEGER,\n            name TEXT\n        )\n        \"#,\n        r#\"\n        CREATE TABLE TestA (\n            id INTEGER,\n            num INTEGER,\n            name TEXT\n        )\n        \"#,\n        \"CREATE TABLE EmptyTest\",\n        \"INSERT INTO Test (id, num, name) VALUES (1, 2, 'Hello')\",\n        \"INSERT INTO Test (id, num, name) VALUES (1, 9, 'World')\",\n        \"INSERT INTO Test (id, num, name) VALUES (3, 4, 'Great'), (4, 7, 'Job')\",\n        \"INSERT INTO TestA (id, num, name) SELECT id, num, name FROM Test\",\n        \"CREATE TABLE TestB (id INTEGER);\",\n        \"INSERT INTO TestB (id) SELECT id FROM Test\",\n    ];\n\n    for query in queries {\n        g.run(query).await;\n    }\n\n    g.named_test(\n        \"select all from table\",\n        \"SELECT * FROM TestB\",\n        Ok(select!(\n            id I64;\n            1; 1; 3; 4\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, num, name FROM TestA\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned();\n            1     9     \"World\".to_owned();\n            3     4     \"Great\".to_owned();\n            4     7     \"Job\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\"SELECT * FROM EmptyTest\", Ok(Payload::SelectMap(vec![])))\n        .await;\n\n    g.test(\n        \"SELECT * FROM (SELECT * FROM EmptyTest) AS Empty\",\n        Ok(Payload::SelectMap(vec![])),\n    )\n    .await;\n\n    g.count(\"SELECT * FROM Test\", 4).await;\n\n    g.run(\"UPDATE Test SET id = 2\").await;\n\n    g.test(\n        \"SELECT id FROM Test\",\n        Ok(select!(\n            id I64;\n            2; 2; 2; 2\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, num FROM Test\",\n        Ok(select!(\n            id  | num;\n            I64 | I64;\n            2     2;\n            2     9;\n            2     4;\n            2     7\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id FROM FOO.Test\",\n        Err(TranslateError::CompoundObjectNotSupported(\"FOO.Test\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","bitwise_and.rs"],"content":"use {\n    crate::*,\n    bigdecimal::BigDecimal,\n    gluesql_core::{ast::BinaryOperator, data::Literal, error::LiteralError, prelude::Value::*},\n    std::{borrow::Cow, str::FromStr},\n};\n\ntest_case!(bitwise_and, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Test (\n            id INTEGER,\n            lhs INTEGER,\n            rhs INTEGER\n        );\n        \",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO Test\n        VALUES\n            (1, 29, 15);\n        \",\n    )\n    .await;\n\n    g.named_test(\n        \"bitwise-and for values\",\n        \"SELECT lhs \u0026 rhs AS and_result FROM Test\",\n        Ok(select!(and_result I64; 13)),\n    )\n    .await;\n\n    g.named_test(\n        \"bitwise-and for literals\",\n        \"SELECT 29 \u0026 15 AS column1;\",\n        Ok(select!(column1 I64; 13)),\n    )\n    .await;\n\n    g.named_test(\n        \"bitwise-and between a value and a literal\",\n        \"SELECT 29 \u0026 rhs AS and_result FROM Test\",\n        Ok(select!(and_result I64; 13)),\n    )\n    .await;\n\n    g.named_test(\n        \"bitwise_and between multiple values\",\n        \"SELECT 29 \u0026 rhs \u0026 3 AS and_result FROM Test\",\n        Ok(select!(and_result I64; 1)),\n    )\n    .await;\n\n    g.named_test(\n        \"bitwise_and between wrong type values shoud occurs error\",\n        \"SELECT 1.1 \u0026 12 AS and_result FROM Test\",\n        Err(LiteralError::UnsupportedBinaryOperation {\n            left: format!(\n                \"{:?}\",\n                Literal::Number(Cow::Owned(BigDecimal::from_str(\"1.1\").unwrap()))\n            ),\n            op: BinaryOperator::BitwiseAnd,\n            right: format!(\"{:?}\", Literal::Number(Cow::Owned(BigDecimal::from(12)))),\n        }\n        .into()),\n    )\n    .await;\n\n    // About NULL\n    g.named_test(\n        \"bitwise_and between null and value\",\n        \"SELECT null \u0026 rhs AS and_result from Test\",\n        Ok(select_with_null!(and_result; Null)),\n    )\n    .await;\n    g.named_test(\n        \"bitwise_and between value and null\",\n        \"SELECT rhs \u0026 null AS and_result from Test\",\n        Ok(select_with_null!(and_result; Null)),\n    )\n    .await;\n    g.named_test(\n        \"bitwise_and between null and literal\",\n        \"SELECT null \u0026 12 AS and_result from Test\",\n        Ok(select_with_null!(and_result; Null)),\n    )\n    .await;\n    g.named_test(\n        \"bitwise_and between literal and null\",\n        \"SELECT 12 \u0026 null AS and_result from Test\",\n        Ok(select_with_null!(and_result; Null)),\n    )\n    .await;\n\n    g.named_test(\n        \"bitwise_and for unsupported value\",\n        \"SELECT 'ss' \u0026 'sp' AS and_result from Test\",\n        Err(LiteralError::UnsupportedBinaryOperation {\n            left: format!(\"{:?}\", Literal::Text(Cow::Owned(\"ss\".to_owned()))),\n            op: BinaryOperator::BitwiseAnd,\n            right: format!(\"{:?}\", Literal::Text(Cow::Owned(\"sp\".to_owned()))),\n        }\n        .into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","bitwise_shift_left.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{data::NumericBinaryOperator, error::ValueError, prelude::Value::*},\n};\n\ntest_case!(bitwise_shift_left, {\n    let g = get_tester!();\n\n    g.run(\n        r#\"\nCREATE TABLE Test (\n    id INTEGER,\n    num INTEGER\n)\"#,\n    )\n    .await;\n\n    g.run(\n        r#\"\nCREATE TABLE OverflowTest (\n    id INTEGER,\n    num INTEGER\n)\"#,\n    )\n    .await;\n\n    g.run(\n        r#\"\nCREATE TABLE NullTest (\n    id INTEGER,\n    num INTEGER\n)\"#,\n    )\n    .await;\n\n    g.run(\"INSERT INTO Test (id, num) VALUES (1, 1)\").await;\n    g.run(\"INSERT INTO Test (id, num) VALUES (1, 2)\").await;\n    g.run(\"INSERT INTO Test (id, num) VALUES (3, 4), (4, 8)\")\n        .await;\n\n    g.run(\"INSERT INTO OverflowTest (id, num) VALUES (1, 1)\")\n        .await;\n\n    g.run(\"INSERT INTO NullTest (id, num) VALUES (NULL, 1)\")\n        .await;\n\n    g.named_test(\n        \"select all from table\",\n        \"SELECT (num \u003c\u003c 1) as num FROM Test\",\n        Ok(select!(num I64; 2; 4; 8; 16)),\n    )\n    .await;\n\n    g.named_test(\n        \"test bit shift overflow\",\n        \"SELECT (num \u003c\u003c 65) as overflowed FROM OverflowTest\",\n        Err(ValueError::BinaryOperationOverflow {\n            lhs: I64(1),\n            rhs: U32(65),\n            operator: NumericBinaryOperator::BitwiseShiftLeft,\n        }\n        .into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, num FROM NullTest\",\n        Ok(select_with_null!(\n            id     | num;\n            Null     I64(1)\n        )),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","bitwise_shift_right.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{data::NumericBinaryOperator, error::ValueError, prelude::Value::*},\n};\n\ntest_case!(bitwise_shift_right, {\n    let g = get_tester!();\n\n    g.run(\n        r#\"\nCREATE TABLE Test (\n    id INTEGER,\n    num INTEGER\n)\"#,\n    )\n    .await;\n\n    g.run(\n        r#\"\nCREATE TABLE OverflowTest (\n    id INTEGER,\n    num INTEGER\n)\"#,\n    )\n    .await;\n\n    g.run(\n        r#\"\nCREATE TABLE NullTest (\n    id INTEGER,\n    num INTEGER\n)\"#,\n    )\n    .await;\n\n    g.run(\"INSERT INTO Test (id, num) VALUES (1, 1)\").await;\n    g.run(\"INSERT INTO Test (id, num) VALUES (1, 2)\").await;\n    g.run(\"INSERT INTO Test (id, num) VALUES (3, 4), (4, 8)\")\n        .await;\n\n    g.run(\"INSERT INTO OverflowTest (id, num) VALUES (1, 1)\")\n        .await;\n\n    g.run(\"INSERT INTO NullTest (id, num) VALUES (NULL, 1)\")\n        .await;\n\n    g.named_test(\n        \"select all from table\",\n        \"SELECT (num \u003e\u003e 1) as num FROM Test\",\n        Ok(select!(num I64; 0; 1; 2; 4)),\n    )\n    .await;\n\n    g.named_test(\n        \"test bit shift overflow\",\n        \"SELECT (num \u003e\u003e 65) as overflowed FROM OverflowTest\",\n        Err(ValueError::BinaryOperationOverflow {\n            lhs: I64(1),\n            rhs: U32(65),\n            operator: NumericBinaryOperator::BitwiseShiftRight,\n        }\n        .into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, num FROM NullTest\",\n        Ok(select_with_null!(\n            id     | num;\n            Null     I64(1)\n        )),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","case.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::TranslateError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(case, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Item (id INTEGER, name TEXT);\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"\n            INSERT INTO \n            Item (id, name)\n            VALUES\n                (1, 'Harry'), (2, 'Ron'), (3, 'Hermione');\n            \",\n            Ok(Payload::Insert(3)),\n        ),\n        (\n            \"\n            SELECT CASE id\n                WHEN 1 THEN name\n                WHEN 2 THEN name \n                WHEN 4 THEN name \n                ELSE 'Malfoy' END\n            AS case FROM Item;\n            \",\n            Ok(select!(\n                case\n                Str;\n                \"Harry\".to_owned();\n                \"Ron\".to_owned();\n                \"Malfoy\".to_owned()\n            )),\n        ),\n        (\n            \"\n            SELECT CASE id\n                WHEN 1 THEN name\n                WHEN 2 THEN name \n                WHEN 4 THEN name \n                END\n            AS case FROM Item;\n            \",\n            Ok(select_with_null!(\n                \"case\";\n                Str(\"Harry\".to_owned());\n                Str(\"Ron\".to_owned());\n                Null\n            )),\n        ),\n        (\n            \"\n            SELECT CASE\n                WHEN name = 'Harry' THEN id\n                WHEN name = 'Ron' THEN id\n                WHEN name = 'Hermione' THEN id\n                ELSE 404 END\n            AS case FROM Item;\n            \",\n            Ok(select!(\n                case\n                I64;\n                1;\n                2;\n                3\n            )),\n        ),\n        (\n            \"\n            SELECT CASE\n                WHEN name = 'Harry' THEN id\n                WHEN name = 'Ron' THEN id \n                WHEN name = 'Hermion' THEN id \n                END\n            AS case FROM Item;\n            \",\n            Ok(select_with_null!(\n                \"case\";\n                I64(1);\n                I64(2);\n                Null\n            )),\n        ),\n        (\n            \"\n            SELECT CASE\n                WHEN (name = 'Harry') OR (name = 'Ron') THEN (id + 1)\n                WHEN name = ('Hermi' || 'one') THEN (id + 2)\n                ELSE 404 END\n            AS case FROM Item;\n            \",\n            Ok(select!(\n                case\n                I64;\n                2;\n                3;\n                5\n            )),\n        ),\n        (\n            \"\n            SELECT CASE 1 COLLATE Item\n                WHEN name = 'Harry' THEN id\n                WHEN name = 'Ron' THEN id \n                WHEN 'Hermione' THEN id \n                END\n            AS case FROM Item;\n            \",\n            Err(TranslateError::UnsupportedExpr(\"1 COLLATE Item\".to_owned()).into()),\n        ),\n        (\n            \"SELECT 1 COLLATE Item FROM Item;\",\n            Err(TranslateError::UnsupportedExpr(\"1 COLLATE Item\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","column_alias.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::FetchError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(column_alias, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE InnerTable (\n                id INTEGER,\n                name TEXT \n            )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"CREATE TABLE User (\n                id INTEGER,\n                name TEXT\n            )\",\n            Ok(Payload::Create),\n        ),\n        (\"CREATE TABLE EmptyTable\", Ok(Payload::Create)),\n        (\n            \"INSERT INTO InnerTable VALUES (1, 'GLUE'), (2, 'SQL'), (3, 'SQL')\",\n            Ok(Payload::Insert(3)),\n        ),\n        (\n            \"INSERT INTO User VALUES (1, 'Taehoon'), (2, 'Mike'), (3, 'Jorno')\",\n            Ok(Payload::Insert(3)),\n        ),\n        (\n            \"SELECT * FROM InnerTable\",\n            Ok(select!(\n                    id  | name\n                    I64 | Str;\n                    1     \"GLUE\".to_owned();\n                    2     \"SQL\".to_owned();\n                    3     \"SQL\".to_owned()\n            )),\n        ),\n        (\n            // column alias with wildcard\n            \"SELECT * FROM User AS Table(a, b)\",\n            Ok(select!(\n                a   | b\n                I64 | Str;\n                1     \"Taehoon\".to_owned();\n                2     \"Mike\".to_owned();\n                3     \"Jorno\".to_owned()\n            )),\n        ),\n        (\n            // partial column alias\n            \"SELECT * FROM User AS Table(a)\",\n            Ok(select!(\n                a   | name\n                I64 | Str;\n                1     \"Taehoon\".to_owned();\n                2     \"Mike\".to_owned();\n                3     \"Jorno\".to_owned()\n            )),\n        ),\n        (\n            // column alias (identifier)\n            \"SELECT a FROM User AS Table(a, b)\",\n            Ok(select!( a; I64; 1; 2; 3)),\n        ),\n        (\n            // too many column alias\n            \"Select * from User as Table(a, b, c)\",\n            Err(FetchError::TooManyColumnAliases(\"User\".to_owned(), 2, 3).into()),\n        ),\n        // InlineView\n        (\n            // column alias with wildcard\n            \"SELECT * FROM (SELECT * FROM InnerTable) AS InlineView(a, b)\",\n            Ok(select!(\n                    a   | b\n                    I64 | Str;\n                    1     \"GLUE\".to_owned();\n                    2     \"SQL\".to_owned();\n                    3     \"SQL\".to_owned()\n            )),\n        ),\n        (\n            // column alias (identifier)\n            \"SELECT a, b FROM (SELECT * FROM InnerTable) AS InlineView(a, b)\",\n            Ok(select!(\n                    a   | b\n                    I64 | Str;\n                    1     \"GLUE\".to_owned();\n                    2     \"SQL\".to_owned();\n                    3     \"SQL\".to_owned()\n            )),\n        ),\n        (\n            // partial column alias\n            \"SELECT * FROM (SELECT * FROM InnerTable) AS InlineView(a)\",\n            Ok(select!(\n                    a   | name\n                    I64 | Str;\n                    1     \"GLUE\".to_owned();\n                    2     \"SQL\".to_owned();\n                    3     \"SQL\".to_owned()\n            )),\n        ),\n        (\n            // too many column alias\n            \"SELECT * FROM (SELECT * FROM InnerTable) AS InlineView(a, b, c)\",\n            Err(FetchError::TooManyColumnAliases(\"InlineView\".into(), 2, 3).into()),\n        ),\n        (\n            \"SELECT * FROM (VALUES (1, 'a'), (2, 'b')) AS Derived(id)\",\n            Ok(select!(\n                id      | column2;\n                I64     | Str;\n                1         \"a\".to_owned();\n                2         \"b\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT * FROM (VALUES (1, 'a'), (2, 'b')) AS Derived(id, name)\",\n            Ok(select!(\n                id      | name;\n                I64     | Str;\n                1         \"a\".to_owned();\n                2         \"b\".to_owned()\n            )),\n        ),\n        (\n            // column alias (identifier)\n            \"SELECT Derived.id, Derived.name FROM (VALUES (1, 'a'), (2, 'b')) AS Derived(id, name)\",\n            Ok(select!(\n                id      | name;\n                I64     | Str;\n                1         \"a\".to_owned();\n                2         \"b\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT * FROM (VALUES (1, 'a'), (2, 'b')) AS Derived(id, name, dummy)\",\n            Err(FetchError::TooManyColumnAliases(\"Derived\".into(), 2, 3).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","concat.rs"],"content":"use {crate::*, gluesql_core::prelude::Value::*};\n\ntest_case!(concat, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Concat (\n            id INTEGER,\n            rate FLOAT,\n            flag BOOLEAN,\n            text TEXT,\n            null_value TEXT NULL\n        );\n    \",\n    )\n    .await;\n    g.run(\"INSERT INTO Concat VALUES (1, 2.3, TRUE, 'Foo', NULL);\")\n        .await;\n\n    g.test(\n        \"\n        SELECT\n            text || text AS value_value,\n            text || 'Bar' AS value_literal,\n            'Bar' || text AS literal_value,\n            'Foo' || 'Bar' AS literal_literal\n        FROM Concat;\n        \",\n        Ok(select!(\n            value_value         | value_literal       | literal_value       | literal_literal\n            Str                 | Str                 | Str                 | Str;\n            \"FooFoo\".to_owned()   \"FooBar\".to_owned()   \"BarFoo\".to_owned()   \"FooBar\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT\n            id || null_value AS id_n,\n            rate || null_value AS rate_n,\n            flag || null_value AS flag_n,\n            text || null_value AS text_n,\n            null_value || id AS n_id,\n            null_value || text AS n_text\n        FROM\n            Concat;\",\n        Ok(select_with_null!(\n            id_n | rate_n | flag_n | text_n | n_id | n_text;\n            Null   Null     Null     Null     Null   Null\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT\n            id || CAST(rate * 10 AS INT) AS Case1,\n            CAST(rate * 10 AS INT) || flag AS Case2,\n            flag || text AS Case3,\n            id || text AS Case4\n        FROM\n            Concat;\",\n        Ok(select!(\n            Case1            | Case2               | Case3                | Case4\n            Str              | Str                 | Str                  | Str;\n            \"123\".to_owned()   \"23TRUE\".to_owned()   \"TRUEFoo\".to_owned()   \"1Foo\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT\n            1 || 2.3 AS int_float,\n            2.3 || TRUE AS float_bool,\n            FALSE || 'Foo' AS bool_text,\n            1 || 'Bar' AS int_text\n        FROM\n            Concat;\",\n        Ok(select!(\n            int_float         | float_bool           | bool_text             | int_text\n            Str               | Str                  | Str                   | Str;\n            \"12.3\".to_owned()   \"2.3TRUE\".to_owned()   \"FALSEFoo\".to_owned()   \"1Bar\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT\n            1 || id || CAST(rate * 10 AS INT) || 'Bar' AS Case1,\n            id || flag || 3.5 || text AS Case2,\n            flag || 'wow' || null_value AS Case3\n        FROM\n            Concat;\",\n        Ok(select_with_null!(\n            Case1                     | Case2                         | Case3;\n            Str(\"1123Bar\".to_owned())   Str(\"1TRUE3.5Foo\".to_owned())   Null\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT 'sand' || SUBSTR('swich', 2) AS test FROM Concat;\",\n        Ok(select!(\n           test\n           Str;\n           \"sandwich\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT SUBSTR('ssand', 2) || 'wich' AS test from Concat;\",\n        Ok(select!(\n           test\n           Str;\n           \"sandwich\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT LOWER('SAND') || SUBSTR('swich', 2) AS test FROM Concat;\",\n        Ok(select!(\n           test\n           Str;\n           \"sandwich\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT SUBSTR('ssand', 2) || LOWER('WICH') AS test FROM Concat;\",\n        Ok(select!(\n           test\n           Str;\n           \"sandwich\".to_owned()\n        )),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","custom_function.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{AlterError, EvaluateError, TranslateError},\n        prelude::{Payload, PayloadVariable, Value::*},\n    },\n};\n\ntest_case!(custom, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE FUNCTION add_none()\",\n            Err(TranslateError::UnsupportedEmptyFunctionBody.into()),\n        ),\n        (\n            \"CREATE FUNCTION add_none() RETURN null\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"CREATE FUNCTION add_zero(n INT) RETURN n\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"CREATE FUNCTION add_zero(n INT) RETURN n\",\n            Err(AlterError::FunctionAlreadyExists(\"add_zero\".to_owned()).into()),\n        ),\n        (\n            \"CREATE FUNCTION add_one (n INT, x INT DEFAULT 1) RETURN n + x\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"CREATE FUNCTION add_two (n INT, x INT DEFAULT 1, y INT) RETURN n + x + y\",\n            Err(AlterError::NonDefaultArgumentFollowsDefaultArgument.into()),\n        ),\n        (\n            \"CREATE FUNCTION add_two (n INT, x INT DEFAULT 1, y INT DEFAULT 1) RETURN n + x + y\",\n            Ok(Payload::Create),\n        ),\n        (\"SELECT add_none() AS r\", Ok(select_with_null!(r; Null))),\n        (\n            \"SELECT add_one(1) AS r\",\n            Ok(select!(\n                r\n                I64;\n                2\n            )),\n        ),\n        (\n            \"SELECT add_one(1, 8) AS r\",\n            Ok(select!(\n                r\n                I64;\n                9\n            )),\n        ),\n        (\n            \"SELECT add_one(1, 2, 4)\",\n            Err(EvaluateError::FunctionArgsLengthNotWithinRange {\n                name: \"add_one\".to_owned(),\n                expected_minimum: 1,\n                expected_maximum: 2,\n                found: 3,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT add_one()\",\n            Err(EvaluateError::FunctionArgsLengthNotWithinRange {\n                name: \"add_one\".to_owned(),\n                expected_minimum: 1,\n                expected_maximum: 2,\n                found: 0,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT add_two(1, null, 2) as r\",\n            Ok(select_with_null!(\n                r; Null\n            )),\n        ),\n        (\n            \"SELECT add_two(1) as r\",\n            Ok(select!(\n                r\n                I64;\n                3\n            )),\n        ),\n        (\"DROP FUNCTION add_none\", Ok(Payload::DropFunction)),\n        (\n            \"SHOW FUNCTIONS\",\n            Ok(Payload::ShowVariable(PayloadVariable::Functions(vec![\n                \"add_one(n: INT, x: INT)\".to_owned(),\n                \"add_two(n: INT, x: INT, y: INT)\".to_owned(),\n                \"add_zero(n: INT)\".to_owned(),\n            ]))),\n        ),\n        (\n            \"DROP FUNCTION add_none\",\n            Err(AlterError::FunctionNotFound(\"add_none\".to_owned()).into()),\n        ),\n        (\n            \"DROP FUNCTION IF EXISTS add_zero, add_one, add_two\",\n            Ok(Payload::DropFunction),\n        ),\n        (\n            \"CREATE FUNCTION test(INT) RETURN 1\",\n            Err(TranslateError::UnNamedFunctionArgNotSupported.into()),\n        ),\n        (\n            \"CREATE FUNCTION test(a INT DEFAULT test()) RETURN 1\",\n            Err(EvaluateError::UnsupportedCustomFunction.into()),\n        ),\n        (\n            \"CREATE FUNCTION test(a INT, a BOOLEAN) RETURN 1\",\n            Err(AlterError::DuplicateArgName(\"a\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","bytea.rs"],"content":"use {\n    crate::*,\n    bigdecimal::BigDecimal,\n    gluesql_core::{\n        ast::DataType,\n        data::Literal,\n        error::{LiteralError, ValueError},\n        prelude::{Payload, Value::Bytea},\n    },\n    std::borrow::Cow,\n};\n\ntest_case!(bytea, {\n    let g = get_tester!();\n\n    let bytea = |v| hex::decode(v).unwrap();\n\n    let test_cases = [\n        (\"CREATE TABLE Bytea (bytes BYTEA)\", Ok(Payload::Create)),\n        (\n            \"INSERT INTO Bytea VALUES\n                (X'123456'),\n                ('ab0123'),\n                (X'936DA0');\n            \",\n            Ok(Payload::Insert(3)),\n        ),\n        (\n            \"SELECT * FROM Bytea\",\n            Ok(select!(\n                bytes\n                Bytea;\n                bytea(\"123456\");\n                bytea(\"ab0123\");\n                bytea(\"936DA0\")\n            )),\n        ),\n        (\n            \"INSERT INTO Bytea VALUES (0)\",\n            Err(ValueError::IncompatibleLiteralForDataType {\n                data_type: DataType::Bytea,\n                literal: format!(\"{:?}\", Literal::Number(Cow::Owned(BigDecimal::from(0)))),\n            }\n            .into()),\n        ),\n        (\n            r#\"INSERT INTO Bytea VALUES (X'123')\"#,\n            Err(LiteralError::FailedToDecodeHexString(\"123\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","date.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::ValueError, prelude::Value::*},\n};\n\ntest_case!(date, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE DateLog (\n    id INTEGER,\n    date1 DATE,\n    date2 DATE\n)\",\n    )\n    .await;\n\n    g.run(\n        \"\nINSERT INTO DateLog VALUES\n    (1, '2020-06-11', '2021-03-01'),\n    (2, '2020-09-30', '1989-01-01'),\n    (3, '2021-05-01', '2021-05-01');\n\",\n    )\n    .await;\n\n    macro_rules! date {\n        ($date: expr) =\u003e {\n            $date.parse().unwrap()\n        };\n    }\n\n    g.test(\n        \"SELECT id, date1, date2 FROM DateLog\",\n        Ok(select!(\n            id  | date1               | date2\n            I64 | Date                | Date;\n            1     date!(\"2020-06-11\")   date!(\"2021-03-01\");\n            2     date!(\"2020-09-30\")   date!(\"1989-01-01\");\n            3     date!(\"2021-05-01\")   date!(\"2021-05-01\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM DateLog WHERE date1 \u003e date2\",\n        Ok(select!(\n            id  | date1               | date2\n            I64 | Date                | Date;\n            2     date!(\"2020-09-30\")   date!(\"1989-01-01\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM DateLog WHERE date1 \u003c= date2\",\n        Ok(select!(\n            id  | date1               | date2\n            I64 | Date                | Date;\n            1     date!(\"2020-06-11\")   date!(\"2021-03-01\");\n            3     date!(\"2021-05-01\")   date!(\"2021-05-01\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM DateLog WHERE date1 = DATE '2020-06-11';\",\n        Ok(select!(\n            id  | date1               | date2\n            I64 | Date                | Date;\n            1     date!(\"2020-06-11\")   date!(\"2021-03-01\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM DateLog WHERE date2 \u003c '2000-01-01';\",\n        Ok(select!(\n            id  | date1               | date2\n            I64 | Date                | Date;\n            2     date!(\"2020-09-30\")   date!(\"1989-01-01\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM DateLog WHERE '1999-01-03' \u003c DATE '2000-01-01';\",\n        Ok(select!(\n            id  | date1               | date2\n            I64 | Date                | Date;\n            1     date!(\"2020-06-11\")   date!(\"2021-03-01\");\n            2     date!(\"2020-09-30\")   date!(\"1989-01-01\");\n            3     date!(\"2021-05-01\")   date!(\"2021-05-01\")\n        )),\n    )\n    .await;\n\n    let days = gluesql_core::data::Interval::days;\n    let timestamp = |y, m, d| {\n        chrono::NaiveDate::from_ymd_opt(y, m, d)\n            .unwrap()\n            .and_hms_opt(0, 0, 0)\n            .unwrap()\n    };\n\n    g.test(\n        \"SELECT\n            id,\n            date1 - date2 AS date_sub,\n            date1 - INTERVAL '1' DAY AS sub,\n            date2 + INTERVAL '1' MONTH AS add\n        FROM DateLog;\",\n        Ok(select!(\n            id  | date_sub     | sub                    | add\n            I64 | Interval     | Timestamp              | Timestamp;\n            1     days(-263)     timestamp(2020, 6, 10)   timestamp(2021, 4, 1);\n            2     days(11_595)   timestamp(2020, 9, 29)   timestamp(1989, 2, 1);\n            3     days(0)        timestamp(2021, 4, 30)   timestamp(2021, 6, 1)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO DateLog VALUES (1, '12345-678', '2021-05-01')\",\n        Err(ValueError::FailedToParseDate(\"12345-678\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","decimal.rs"],"content":"use {crate::*, gluesql_core::prelude::Value::*, rust_decimal::prelude::Decimal as D};\n\ntest_case!(decimal, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE DECIMAL_ITEM (v DECIMAL)\").await;\n    g.run(\"INSERT INTO DECIMAL_ITEM VALUES (1)\").await;\n\n    g.test(\n        \"\n            SELECT\n                v AS a,\n                v + 1 AS b,\n                1 + v AS c,\n                v - 1 AS d,\n                1 - v AS e,\n                v * 2 AS f,\n                2 * v AS g\n            FROM DECIMAL_ITEM\n                \",\n        Ok(select!(\n            a       | b       | c   | d       | e   | f       | g;\n            Decimal | Decimal | I64 | Decimal | I64 | Decimal | I64;\n            D::ONE    D::TWO    2     D::ZERO   0     D::TWO    2\n        )),\n    )\n    .await;\n\n    g.test(\n        \"\n            SELECT\n                v / 2 AS h,\n                2 / v AS i,\n                2 % v AS j,\n                v % 2 AS k\n            FROM DECIMAL_ITEM\n                \",\n        Ok(select!(\n            h            | i   | j   | k;\n            Decimal      | I64 | I64 | Decimal;\n            D::new(5, 1)   2     0     D::ONE\n        )),\n    )\n    .await;\n\n    g.run(\"INSERT INTO DECIMAL_ITEM VALUES (1.5), (2.0), (25.12)\")\n        .await;\n\n    g.test(\n        \"SELECT v FROM DECIMAL_ITEM WHERE v \u003e 1.5 AND v \u003c= 25.12\",\n        Ok(select!(\n            v;\n            Decimal;\n            D::new(2, 0);\n            D::new(2512, 2)\n        )),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","float32.rs"],"content":"use {\n    crate::*,\n    gluesql_core::prelude::{Payload, Value::*},\n};\n\ntest_case!(float32, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE line (x FLOAT32, y FLOAT32)\",\n            Ok(Payload::Create),\n        ),\n        (\n            r#\"INSERT INTO line VALUES (0.3134, 0.156)\"#,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            r#\"SELECT x, y FROM line;\"#,\n            Ok(select!(\n                x          |  y\n                F32        |  F32;\n                0.3134_f32    0.156_f32\n            )),\n        ),\n        (\n            r#\"UPDATE line SET x=2.0, y=1.0 WHERE x=0.3134 AND y=0.156\"#,\n            Ok(Payload::Update(1)),\n        ),\n        (\n            r#\"SELECT x, y FROM line\"#,\n            Ok(select!(\n                x       |   y\n                F32     |   F32;\n                2.0_f32     1.0_f32\n            )),\n        ),\n        (\n            r#\"DELETE FROM line WHERE x=2.0 AND y=1.0\"#,\n            Ok(Payload::Delete(1)),\n        ),\n        (\n            r#\"SELECT CAST('-71.064544' AS FLOAT32) AS float32\"#,\n            Ok(select!(\n                float32\n                F32;\n                -71.064544_f32\n\n            )),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","inet.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::ValueError,\n        prelude::{Payload, Value::Inet},\n    },\n    std::{net::IpAddr, str::FromStr},\n};\n\ntest_case!(inet, {\n    let g = get_tester!();\n\n    let inet = |v| IpAddr::from_str(v).unwrap();\n\n    let test_cases = [\n        (\"CREATE TABLE computer (ip INET)\", Ok(Payload::Create)),\n        (\n            \"INSERT INTO computer VALUES\n                ('::1'),\n                ('127.0.0.1'),\n                ('0.0.0.0'),\n                (4294967295),\n                (9876543210);\n            \",\n            Ok(Payload::Insert(5)),\n        ),\n        (\n            \"SELECT * FROM computer\",\n            Ok(select!(\n                ip\n                Inet;\n                inet(\"::1\");\n                inet(\"127.0.0.1\");\n                inet(\"0.0.0.0\");\n                inet(\"255.255.255.255\");\n                inet(\"::2:4cb0:16ea\")\n            )),\n        ),\n        (\n            \"SELECT * FROM computer WHERE ip \u003e '127.0.0.1'\",\n            Ok(select!(\n                ip\n                Inet;\n                inet(\"::1\");\n                inet(\"255.255.255.255\");\n                inet(\"::2:4cb0:16ea\")\n            )),\n        ),\n        (\n            \"SELECT * FROM computer WHERE ip = '127.0.0.1'\",\n            Ok(select!(\n                ip\n                Inet;\n                inet(\"127.0.0.1\")\n            )),\n        ),\n        (\"INSERT INTO computer VALUES (0)\", Ok(Payload::Insert(1))),\n        (\n            r#\"INSERT INTO computer VALUES ('127.0.0.0.1')\"#,\n            Err(ValueError::FailedToParseInetString(\"127.0.0.0.1\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","int128.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::ValueError,\n        prelude::{DataType, Value::*},\n    },\n};\n\ntest_case!(int128, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE Item (\n        field_one INT128,\n        field_two INT128\n    );\",\n    )\n    .await;\n    g.run(\"INSERT INTO Item VALUES (1, -1), (-2, 2), (3, 3), (-4, -4);\")\n        .await;\n\n    let parse_i128 = |text: \u0026str| -\u003e i128 { text.parse().unwrap() };\n\n    // int128::MAX+1\n    let invalid_large_str = \"170141183460469231731687303715884105728\";\n    // int128::MIN-1\n    let invalid_small_str = \"-170141183460469231731687303715884105729\";\n\n    g.test(\n        \u0026format!(\n            \"INSERT INTO Item VALUES ({}, {})\",\n            invalid_large_str, invalid_large_str\n        ),\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n\n    g.test(\n        \u0026format!(\n            \"INSERT INTO Item VALUES ({}, {})\",\n            invalid_small_str, invalid_small_str\n        ),\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n\n    // cast i128::MAX+1\n    g.test(\n        \u0026format!(\"select cast({} as INT128) from Item\", invalid_large_str),\n        Err(ValueError::LiteralCastToDataTypeFailed(\n            DataType::Int128,\n            invalid_large_str.to_owned(),\n        )\n        .into()),\n    )\n    .await;\n\n    // cast i128::MIN-1\n    g.test(\n        \u0026format!(\"select cast({} as INT128) from Item\", invalid_small_str),\n        Err(ValueError::LiteralCastToDataTypeFailed(\n            DataType::Int128,\n            invalid_small_str.to_owned(),\n        )\n        .into()),\n    )\n    .await;\n\n    // lets try some valid SQL\n    g.test(\n        \"SELECT field_one, field_two FROM Item\",\n        Ok(select!(\n            field_one          | field_two\n            I128               |  I128;\n            1                    parse_i128(\"-1\");\n            parse_i128(\"-2\")     2;\n            3                    3;\n            parse_i128(\"-4\")     parse_i128(\"-4\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = 1\",\n        Ok(select!(field_one I128; 1)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e 0\",\n        Ok(select!(field_one I128; 1; 3)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e= 0\",\n        Ok(select!(field_one I128; 1; 3)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = -2\",\n        Ok(select!(field_one I128; -2)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003c 0\",\n        Ok(select!(field_one I128; -2; -4)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003c= 0\",\n        Ok(select!(field_one I128; -2; -4)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one + field_two AS plus FROM Item;\",\n        Ok(select!(plus I128; 0; 0; 6; -8)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one - field_two AS sub FROM Item;\",\n        Ok(select!(sub I128; 2; -4; 0; 0)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one * field_two AS mul FROM Item;\",\n        Ok(select!(mul I128; -1; -4; 9; 16)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one / field_two AS div FROM Item;\",\n        Ok(select!(div I128; -1; -1; 1; 1)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one % field_two AS modulo FROM Item;\",\n        Ok(select!(modulo I128; 0; 0; 0; 0)),\n    )\n    .await;\n\n    g.run(\"DELETE FROM Item\").await;\n});\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","int16.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::ValueError, prelude::Value::*},\n};\n\ntest_case!(int16, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE Item (\n        field_one INT16,\n        field_two INT16\n    );\",\n    )\n    .await;\n    g.run(\"INSERT INTO Item VALUES (1, -1), (-2, 2), (3, 3), (-4, -4);\")\n        .await;\n\n    let parse_i16 = |text: \u0026str| -\u003e i16 { text.parse().unwrap() };\n\n    g.test(\n        \"INSERT INTO Item VALUES (32768, 32768);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n    g.test(\n        \"INSERT INTO Item VALUES (-32769, -32769);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one, field_two FROM Item\",\n        Ok(select!(\n            field_one        |  field_two\n            I16              |  I16;\n            1                   parse_i16(\"-1\");\n            parse_i16(\"-2\")     2;\n            3                   3;\n            parse_i16(\"-4\")     parse_i16(\"-4\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e 0\",\n        Ok(select!(field_one I16; 1; 3)),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e= 0\",\n        Ok(select!(field_one I16; 1; 3)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = -2\",\n        Ok(select!(field_one I16; -2)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003c 0\",\n        Ok(select!(field_one I16; -2; -4)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003c= 0\",\n        Ok(select!(field_one I16; -2; -4)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one + field_two AS plus FROM Item;\",\n        Ok(select!(plus I16; 0; 0; 6; -8)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one - field_two AS sub FROM Item;\",\n        Ok(select!(sub I16; 2; -4; 0; 0)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one * field_two AS mul FROM Item;\",\n        Ok(select!(mul I16; -1; -4; 9; 16)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one / field_two AS div FROM Item;\",\n        Ok(select!(div I16; -1; -1; 1; 1)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one % field_two AS modulo FROM Item;\",\n        Ok(select!(modulo I16; 0; 0; 0; 0)),\n    )\n    .await;\n\n    g.run(\"DELETE FROM Item\").await;\n});\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","int32.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::ValueError,\n        prelude::{DataType, Payload, Value::*},\n    },\n};\n\ntest_case!(int32, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE Item (\n        field_one INT32,\n        field_two INT32\n    );\",\n    )\n    .await;\n    g.run(\"INSERT INTO Item VALUES (1, -1), (-2, 2), (3, 3), (-4, -4);\")\n        .await;\n\n    let parse_i32 = |text: \u0026str| -\u003e i32 { text.parse().unwrap() };\n\n    g.test(\n        \u0026format!(\n            \"INSERT INTO Item VALUES ({}, {i64})\",\n            i32::MAX as i64 + 1_i64,\n            i64 = i32::MIN as i64 - 1_i64\n        ),\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n\n    g.test(\n        \u0026format!(\n            \"select cast({} as INT32) from Item\",\n            i32::MAX as i64 + 1_i64\n        ),\n        Err(ValueError::LiteralCastToDataTypeFailed(\n            DataType::Int32,\n            (i32::MAX as i64 + 1_i64).to_string(),\n        )\n        .into()),\n    )\n    .await;\n\n    g.test(\n        \u0026format!(\n            \"select cast({} as INT32) from Item\",\n            i32::MIN as i64 - 1_i64\n        ),\n        Err(ValueError::LiteralCastToDataTypeFailed(\n            DataType::Int32,\n            (i32::MIN as i64 - 1_i64).to_string(),\n        )\n        .into()),\n    )\n    .await;\n\n    // lets try some valid SQL\n    g.test(\n        \"SELECT field_one, field_two FROM Item\",\n        Ok(select!(\n            field_one          | field_two\n            I32                |    I32;\n            1                  parse_i32(\"-1\");\n            parse_i32(\"-2\")    2;\n            3                  3;\n            parse_i32(\"-4\")    parse_i32(\"-4\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = 1\",\n        Ok(select!(field_one I32; 1)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e 0\",\n        Ok(select!(field_one I32; 1; 3)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e= 0\",\n        Ok(select!(field_one I32; 1; 3)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = -2\",\n        Ok(select!(field_one I32; -2)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003c 0\",\n        Ok(select!(field_one I32; -2; -4)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003c= 0\",\n        Ok(select!(field_one I32; -2; -4)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one + field_two AS plus FROM Item;\",\n        Ok(select!(plus I32; 0; 0; 6; -8)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one - field_two AS sub FROM Item;\",\n        Ok(select!(sub I32; 2; -4; 0; 0)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one * field_two AS mul FROM Item;\",\n        Ok(select!(mul I32; -1; -4; 9; 16)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one / field_two AS div FROM Item;\",\n        Ok(select!(div I32; -1; -1; 1; 1)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one % field_two AS modulo FROM Item;\",\n        Ok(select!(modulo I32; 0; 0; 0; 0)),\n    )\n    .await;\n\n    // try inserting i32 max and i32 min\n    g.test(\n        \u0026format!(\"INSERT INTO Item VALUES ({}, {})\", i32::MAX, i32::MIN),\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n\n    g.run(\"DELETE FROM Item\").await;\n});\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","int64.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::ValueError,\n        prelude::{DataType, Value::*},\n    },\n};\n\n#[cfg(not(target_arch = \"wasm32\"))]\nuse gluesql_core::prelude::Payload;\n\ntest_case!(int64, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE Item (\n        field_one INT,\n        field_two INT\n    );\",\n    )\n    .await;\n    g.run(\"INSERT INTO Item VALUES (1, -1), (-2, 2), (3, 3), (-4, -4);\")\n        .await;\n\n    let parse_i64 = |text: \u0026str| -\u003e i64 { text.parse().unwrap() };\n\n    g.test(\n        \u0026format!(\n            \"INSERT INTO Item VALUES ({:?}, {:?})\",\n            i64::MAX as i128 + 1,\n            i64::MIN as i128 - 1\n        ),\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n\n    // cast i64::MAX+1\n    g.test(\n        \u0026format!(\"select cast({} as INT) from Item\", i64::MAX as i128 + 1),\n        Err(ValueError::LiteralCastToDataTypeFailed(\n            DataType::Int,\n            (i64::MAX as i128 + 1).to_string(),\n        )\n        .into()),\n    )\n    .await;\n\n    // cast i64::MIN-1\n    g.test(\n        \u0026format!(\"select cast({} as INT) from Item\", i64::MIN as i128 - 1),\n        Err(ValueError::LiteralCastToDataTypeFailed(\n            DataType::Int,\n            (i64::MIN as i128 - 1).to_string(),\n        )\n        .into()),\n    )\n    .await;\n\n    // lets try some valid SQL\n    g.test(\n        \"SELECT field_one, field_two FROM Item\",\n        Ok(select!(\n            field_one          | field_two\n            I64                |    I64;\n            1                  parse_i64(\"-1\");\n            parse_i64(\"-2\")    2;\n            3                  3;\n            parse_i64(\"-4\")    parse_i64(\"-4\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = 1\",\n        Ok(select!(field_one I64; 1)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e 0\",\n        Ok(select!(field_one I64; 1; 3)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e= 0\",\n        Ok(select!(field_one I64; 1; 3)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = -2\",\n        Ok(select!(field_one I64; -2)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003c 0\",\n        Ok(select!(field_one I64; -2; -4)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003c= 0\",\n        Ok(select!(field_one I64; -2; -4)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one + field_two AS plus FROM Item;\",\n        Ok(select!(plus I64; 0; 0; 6; -8)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one - field_two AS sub FROM Item;\",\n        Ok(select!(sub I64; 2; -4; 0; 0)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one * field_two AS mul FROM Item;\",\n        Ok(select!(mul I64; -1; -4; 9; 16)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one / field_two AS div FROM Item;\",\n        Ok(select!(div I64; -1; -1; 1; 1)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one % field_two AS modulo FROM Item;\",\n        Ok(select!(modulo I64; 0; 0; 0; 0)),\n    )\n    .await;\n\n    // try inserting i64 max and i64 min\n    #[cfg(not(target_arch = \"wasm32\"))]\n    g.test(\n        \u0026format!(\"INSERT INTO Item VALUES ({}, {})\", i64::MAX, i64::MIN),\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n\n    g.run(\"DELETE FROM Item\").await;\n});\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","int8.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::ValueError, prelude::Value::*},\n};\n\ntest_case!(int8, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE Item (\n        field_one INT8,\n        field_two INT8\n    );\",\n    )\n    .await;\n    g.run(\"INSERT INTO Item VALUES (1, -1), (-2, 2), (3, 3), (-4, -4);\")\n        .await;\n\n    let parse_i8 = |text: \u0026str| -\u003e i8 { text.parse().unwrap() };\n\n    g.test(\n        \"INSERT INTO Item VALUES (128, 128);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n    g.test(\n        \"INSERT INTO Item VALUES (-129, -129);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one, field_two FROM Item\",\n        Ok(select!(\n            field_one        | field_two\n            I8               |    I8;\n            1                   parse_i8(\"-1\");\n            parse_i8(\"-2\")         2;\n            3                      3;\n            parse_i8(\"-4\")      parse_i8(\"-4\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e 0\",\n        Ok(select!(field_one I8; 1; 3)),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e= 0\",\n        Ok(select!(field_one I8; 1; 3)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = -2\",\n        Ok(select!(field_one I8; -2)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003c 0\",\n        Ok(select!(field_one I8; -2; -4)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003c= 0\",\n        Ok(select!(field_one I8; -2; -4)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one + field_two AS plus FROM Item;\",\n        Ok(select!(plus I8; 0; 0; 6; -8)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one - field_two AS sub FROM Item;\",\n        Ok(select!(sub I8; 2; -4; 0; 0)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one * field_two AS mul FROM Item;\",\n        Ok(select!(mul I8; -1; -4; 9; 16)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one / field_two AS div FROM Item;\",\n        Ok(select!(div I8; -1; -1; 1; 1)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT field_one % field_two AS modulo FROM Item;\",\n        Ok(select!(modulo I8; 0; 0; 0; 0)),\n    )\n    .await;\n\n    g.run(\"DELETE FROM Item\").await;\n});\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","interval.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{data::Interval as I, error::IntervalError, prelude::Value::*},\n};\n\ntest_case!(interval, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE IntervalLog (\n    id INTEGER,\n    interval1 INTERVAL,\n    interval2 INTERVAL\n)\",\n    )\n    .await;\n\n    g.run(\n        \"\nINSERT INTO IntervalLog VALUES\n    (1, INTERVAL '1-2' YEAR TO MONTH,         INTERVAL 30 MONTH),\n    (2, INTERVAL 12 DAY,                      INTERVAL '35' HOUR),\n    (3, INTERVAL '12' MINUTE,                 INTERVAL 300 SECOND),\n    (4, INTERVAL '-3 14' DAY TO HOUR,         INTERVAL '3 12:30' DAY TO MINUTE),\n    (5, INTERVAL '3 14:00:00' DAY TO SECOND,  INTERVAL '3 12:30:12.1324' DAY TO SECOND),\n    (6, INTERVAL '12:00' HOUR TO MINUTE,      INTERVAL '-12:30:12' HOUR TO SECOND),\n    (7, INTERVAL '-1000-11' YEAR TO MONTH,    INTERVAL '-30:11' MINUTE TO SECOND);\n\",\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM IntervalLog;\",\n        Ok(select!(\n            id  | interval1           | interval2\n            I64 | Interval            | Interval;\n            1     I::months(14)         I::months(30);\n            2     I::days(12)           I::hours(35);\n            3     I::minutes(12)        I::minutes(5);\n            4     I::hours(-86)         I::minutes(84 * 60 + 30);\n            5     I::minutes(86 * 60)   I::microseconds((((84 * 60) + 30) * 60 + 12) * 1_000_000 + 132_400);\n            6     I::hours(12)          I::seconds(-(12 * 3600 + 30 * 60 + 12));\n            7     I::months(-12_011)    I::seconds(-(30 * 60 + 11))\n        ))\n    ).await;\n\n    g.test(\n        \"SELECT\n            id,\n            interval1 * 2 AS i1,\n            interval2 - INTERVAL '-3' YEAR AS i2\n        FROM IntervalLog WHERE id = 1\",\n        Ok(select!(\n            id  | i1            | i2\n            I64 | Interval      | Interval;\n            1     I::months(28)   I::months(66)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT\n            id,\n            interval1 / 3 AS i1,\n            interval2 - INTERVAL 3600 SECOND AS i2,\n            INTERVAL (20 + 10) SECOND + INTERVAL (10 * 3) SECOND AS i3\n        FROM IntervalLog WHERE id = 2;\",\n        Ok(select!(\n            id  | i1         | i2           | i3\n            I64 | Interval   | Interval     | Interval;\n            2     I::days(4)   I::hours(34)   I::minutes(1)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO IntervalLog VALUES (1, INTERVAL '20:00' MINUTE TO HOUR, INTERVAL '1-2' YEAR TO MONTH)\",\n        Err(IntervalError::UnsupportedRange(\"Minute\".to_owned(), \"Hour\".to_owned()).into())\n    ).await;\n\n    g.test(\n        \"SELECT INTERVAL '1' YEAR + INTERVAL '1' HOUR FROM IntervalLog;\",\n        Err(IntervalError::AddBetweenYearToMonthAndHourToSecond.into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT INTERVAL '1' YEAR - INTERVAL '1' HOUR FROM IntervalLog;\",\n        Err(IntervalError::SubtractBetweenYearToMonthAndHourToSecond.into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT INTERVAL '1.4' YEAR FROM IntervalLog;\",\n        Err(IntervalError::FailedToParseInteger(\"1.4\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT INTERVAL '1.4ab' HOUR FROM IntervalLog;\",\n        Err(IntervalError::FailedToParseDecimal(\"1.4ab\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT INTERVAL '111:34' HOUR TO MINUTE FROM IntervalLog;\",\n        Err(IntervalError::FailedToParseTime(\"111:34\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT INTERVAL '111' YEAR TO MONTH FROM IntervalLog;\",\n        Err(IntervalError::FailedToParseYearToMonth(\"111\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT INTERVAL '111' DAY TO HOUR FROM IntervalLog;\",\n        Err(IntervalError::FailedToParseDayToHour(\"111\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT INTERVAL '111' DAY TO HOUR FROM IntervalLog;\",\n        Err(IntervalError::FailedToParseDayToHour(\"111\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT INTERVAL '111' DAY TO MINUTE FROM IntervalLog;\",\n        Err(IntervalError::FailedToParseDayToMinute(\"111\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT INTERVAL '111' DAY TO Second FROM IntervalLog;\",\n        Err(IntervalError::FailedToParseDayToSecond(\"111\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","list.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{KeyError, ValueError},\n        prelude::Value::{self, *},\n    },\n};\n\ntest_case!(list, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE ListType (\n    id INTEGER,\n    items LIST\n)\",\n    )\n    .await;\n\n    g.run(\n        r#\"\nINSERT INTO ListType VALUES\n    (1, '[1, 2, 3]'),\n    (2, '[\"hello\", \"world\", 30, true, [9,8]]'),\n    (3, '[{ \"foo\": 100, \"bar\": [true, 0, [10.5, false] ] }, 10, 20]');\n\"#,\n    )\n    .await;\n\n    let l = |s: \u0026str| Value::parse_json_list(s).unwrap();\n    let s = |v: \u0026str| Str(v.to_owned());\n\n    g.test(\n        \"SELECT id, items FROM ListType\",\n        Ok(select_with_null!(\n            id     | items;\n            I64(1)   l(\"[1,2,3]\");\n            I64(2)   l(r#\"[\"hello\",\"world\",30,true,[9,8]]\"#);\n            I64(3)   l(r#\"[{\"foo\":100, \"bar\": [true, 0, [10.5, false]]},10,20]\"#)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT\n            id,\n            UNWRAP(items, '1') AS foo,\n            UNWRAP(items, '0.foo') + 100 AS bar,\n            UNWRAP(items, '4') AS a,\n            UNWRAP(items, '0.bar.2.0') + UNWRAP(items, '2') AS b\n        FROM ListType\",\n        Ok(select_with_null!(\n            id     | foo        | bar      | a             | b;\n            I64(1)   I64(2)       Null       Null            Null;\n            I64(2)   s(\"world\")   Null       l(r#\"[9,8]\"#)   Null;\n            I64(3)   I64(10)      I64(200)   Null            F64(30.5)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, items[1] AS second FROM ListType\",\n        Ok(select_with_null!(\n            id     | second;\n            I64(1)   I64(2);\n            I64(2)   s(\"world\");\n            I64(3)   I64(10)\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"select index expr without alias\",\n        \"SELECT id, items[1] FROM ListType\",\n        Ok(select_with_null!(\n            id     | \"items[1]\";\n            I64(1)   I64(2);\n            I64(2)   s(\"world\");\n            I64(3)   I64(10)\n        )),\n    )\n    .await;\n\n    g.run(\n        \"\nCREATE TABLE ListType2 (\n    id INTEGER,\n    items LIST\n)\",\n    )\n    .await;\n\n    g.run(\n        r#\"\nINSERT INTO ListType2 VALUES\n    (1, '[1, 2, 3, { \"hi\": \"bye\" }]'),\n    (2, '[\"one\", \"two\", \"three\", [100, 200]]'),\n    (3, '[\"first\", \"second\", \"third\", { \"foo\": true, \"bar\": false }]');\n\"#,\n    )\n    .await;\n\n    g.test(\n        \"SELECT\n            id,\n            items['0'] AS foo,\n            items['1'] AS bar,\n            items['3']['0'] AS hundred\n        FROM ListType2\",\n        Ok(select_with_null!(\n            id     | foo        | bar        | hundred;\n            I64(1)   I64(1)       I64(2)       Null;\n            I64(2)   s(\"one\")     s(\"two\")     I64(100);\n            I64(3)   s(\"first\")   s(\"second\")  Null\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"cast literal to LIST\",\n        r#\"SELECT CAST('[1, 2, 3]' AS LIST) AS list\"#,\n        Ok(select_with_null!(\n            list;\n            l(\"[1,2,3]\")\n        )),\n    )\n    .await;\n\n    g.test(\n        r#\"SELECT id, items['not']['list'] AS foo FROM ListType2\"#,\n        Err(ValueError::SelectorRequiresMapOrListTypes.into()),\n    )\n    .await;\n\n    g.test(\n        r#\"SELECT id FROM ListType GROUP BY items\"#,\n        Err(KeyError::ListTypeKeyNotSupported.into()),\n    )\n    .await;\n    g.test(\n        r#\"INSERT INTO ListType VALUES (1, '{ \"a\": 10 }');\"#,\n        Err(ValueError::JsonArrayTypeRequired.into()),\n    )\n    .await;\n    g.test(\n        \"INSERT INTO ListType VALUES (1, '{{ ok [1, 2, 3] }');\",\n        Err(ValueError::InvalidJsonString(\"{{ ok [1, 2, 3] }\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","map.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, KeyError, ValueError},\n        prelude::Value::{self, *},\n    },\n};\n\ntest_case!(map, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE MapType (\n    id INTEGER NULL DEFAULT UNWRAP(NULL, 'a'),\n    nested MAP\n)\",\n    )\n    .await;\n\n    g.run(\n        r#\"\nINSERT INTO MapType VALUES\n    (1, '{\"a\": true, \"b\": 2}'),\n    (2, '{\"a\": {\"foo\": \"ok\", \"b\": \"steak\"}, \"b\": 30}'),\n    (3, '{\"a\": {\"b\": {\"c\": {\"d\": 10}}}}');\n\"#,\n    )\n    .await;\n\n    let m = |s: \u0026str| Value::parse_json_map(s).unwrap();\n    let s = |v: \u0026str| Str(v.to_owned());\n\n    g.test(\n        \"SELECT id, nested FROM MapType LIMIT 1\",\n        Ok(select_with_null!(\n            id     | nested;\n            I64(1)   m(r#\"{\"a\": true, \"b\": 2}\"#)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT\n            id,\n            UNWRAP(nested, 'a.foo') || '.yeah' AS foo,\n            UNWRAP(nested, 'a.b.c.d') as good,\n            UNWRAP(nested, 'a.b.c.d') * 2 as good2,\n            UNWRAP(nested, 'a.b') as b\n        FROM MapType\",\n        Ok(select_with_null!(\n            id     | foo          | good    | good2   | b;\n            I64(1)   Null           Null      Null      Null;\n            I64(2)   s(\"ok.yeah\")   Null      Null      s(\"steak\");\n            I64(3)   Null           I64(10)   I64(20)   m(r#\"{\"c\": { \"d\": 10 } }\"#)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT\n            id,\n            UNWRAP(NULL, 'a.b') as foo,\n            UNWRAP(nested, NULL) as bar\n        FROM MapType LIMIT 1\",\n        Ok(select_with_null!(id | foo | bar; I64(1) Null Null)),\n    )\n    .await;\n\n    g.run(\n        \"\nCREATE TABLE MapType2 (\n    id INTEGER,\n    nested MAP\n)\",\n    )\n    .await;\n\n    g.run(\n        r#\"\nINSERT INTO MapType2 VALUES\n    (1, '{\"a\": {\"red\": \"apple\", \"blue\": 1}, \"b\": 10}'),\n    (2, '{\"a\": {\"red\": \"cherry\", \"blue\": 2}, \"b\": 20}'),\n    (3, '{\"a\": {\"red\": \"berry\", \"blue\": 3}, \"b\": 30, \"c\": true}');\n\"#,\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, nested['b'] as b FROM MapType2\",\n        Ok(select_with_null!(\n            id     | b;\n            I64(1)   I64(10);\n            I64(2)   I64(20);\n            I64(3)   I64(30)\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"select index expr without alias\",\n        \"SELECT id, nested['b'] FROM MapType2\",\n        Ok(select_with_null!(\n            id     | \"nested['b']\";\n            I64(1)   I64(10);\n            I64(2)   I64(20);\n            I64(3)   I64(30)\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"index expr with non-existent key from MapType Value returns Null\",\n        \"SELECT\n            id,\n            nested['a']['red'] AS fruit,\n            nested['a']['blue'] + nested['b'] as sum,\n            nested['c'] AS c\n        FROM MapType2\",\n        Ok(select_with_null!(\n                id     | fruit        | sum      | c;\n                I64(1)   s(\"apple\")     I64(11)    Null;\n                I64(2)   s(\"cherry\")    I64(22)    Null;\n                I64(3)   s(\"berry\")     I64(33)    Bool(true)\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"cast literal to MAP\",\n        r#\"SELECT CAST('{\"a\": 1}' AS MAP) AS map\"#,\n        Ok(select_with_null!(\n            map;\n            m(r#\"{\"a\": 1}\"#)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT UNWRAP('abc', 'a.b.c') FROM MapType\",\n        Err(EvaluateError::FunctionRequiresMapValue(\"UNWRAP\".to_owned()).into()),\n    )\n    .await;\n    g.test(\n        \"SELECT UNWRAP(id, 'a.b.c') FROM MapType\",\n        Err(ValueError::SelectorRequiresMapOrListTypes.into()),\n    )\n    .await;\n    g.test(\n        \"SELECT id, nested['a']['blue']['first'] FROM MapType2\",\n        Err(ValueError::SelectorRequiresMapOrListTypes.into()),\n    )\n    .await;\n    g.test(\n        \"SELECT id FROM MapType GROUP BY nested\",\n        Err(KeyError::MapTypeKeyNotSupported.into()),\n    )\n    .await;\n    g.test(\n        \"INSERT INTO MapType VALUES (1, '{{ ok [1, 2, 3] }');\",\n        Err(ValueError::InvalidJsonString(\"{{ ok [1, 2, 3] }\".to_owned()).into()),\n    )\n    .await;\n    g.test(\n        \"INSERT INTO MapType VALUES (1, '[1, 2, 3]');\",\n        Err(ValueError::JsonObjectTypeRequired.into()),\n    )\n    .await;\n});\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","point.rs"],"content":"use {\n    crate::*,\n    bigdecimal::BigDecimal,\n    gluesql_core::{\n        ast::DataType,\n        data::Literal,\n        error::{TranslateError, ValueError},\n        prelude::{Payload, Value::*},\n    },\n    std::borrow::Cow,\n};\n\ntest_case!(point, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE POINT (point_field POINT)\",\n            Ok(Payload::Create),\n        ),\n        (\n            r#\"INSERT INTO POINT VALUES (POINT(0.3134, 0.156))\"#,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            r#\"SELECT point_field AS point_field FROM POINT;\"#,\n            Ok(select!(\n                point_field\n                Point;\n                gluesql_core::data::Point::new(0.3134, 0.156)\n            )),\n        ),\n        (\n            r#\"UPDATE POINT SET point_field=POINT(2.0, 1.0) WHERE point_field=POINT(0.3134, 0.156)\"#,\n            Ok(Payload::Update(1)),\n        ),\n        (\n            r#\"SELECT point_field AS point_field FROM POINT\"#,\n            Ok(select!(\n                point_field\n                Point;\n                gluesql_core::data::Point::new(2.0, 1.0)\n            )),\n        ),\n        (\n            r#\"DELETE FROM POINT WHERE point_field=POINT(2.0, 1.0)\"#,\n            Ok(Payload::Delete(1)),\n        ),\n        (\n            r#\"INSERT INTO POINT VALUES (0)\"#,\n            Err(ValueError::IncompatibleLiteralForDataType {\n                data_type: DataType::Point,\n                literal: format!(\"{:?}\", Literal::Number(Cow::Owned(BigDecimal::from(0)))),\n            }\n            .into()),\n        ),\n        (\n            r#\"INSERT INTO POINT VALUES (POINT(0.3134))\"#,\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"POINT\".to_owned(),\n                expected: 2,\n                found: 1,\n            }\n            .into()),\n        ),\n        (\n            r#\"SELECT CAST('POINT(-71.064544 42.28787)' AS POINT) AS pt\"#,\n            Ok(select!(\n                pt\n                Point;\n                gluesql_core::data::Point::new(-71.064544, 42.28787)\n\n            )),\n        ),\n        (\n            r#\"SELECT CAST('POINT(-71.06454t4 42.28787)' AS POINT) AS pt\"#,\n            Err(ValueError::FailedToParsePoint(\n                Str(\"POINT(-71.06454t4 42.28787)\".to_owned()).into(),\n            )\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","sql_types.rs"],"content":"use crate::*;\n\ntest_case!(sql_types, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Item (\n            id INTEGER,\n            content TEXT,\n            verified BOOLEAN,\n            ratio FLOAT\n        );\n    \",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Item\n            (id,   content, verified, ratio)\n        VALUES\n            ( 1, 'Hello',     True,   0.1),\n            ( 1, 'World',    False,   0.9),\n            ( 1, 'test',    False,   0.0);\n    \",\n    )\n    .await;\n\n    let test_sqls = [\n        (3, \"SELECT * FROM Item;\"),\n        (1, \"SELECT * FROM Item WHERE verified = True;\"),\n        (1, \"SELECT * FROM Item WHERE ratio \u003e 0.5;\"),\n        (1, \"SELECT * FROM Item WHERE ratio = 0.1;\"),\n        (1, \"UPDATE Item SET content='Foo' WHERE content='World';\"),\n        (0, \"SELECT * FROM Item WHERE content='World';\"),\n        (1, \"SELECT * FROM Item WHERE content='Foo';\"),\n        (1, \"SELECT * FROM Item WHERE content='Foo';\"),\n        (1, \"UPDATE Item SET id = 11 WHERE content='Foo';\"),\n        (1, \"UPDATE Item SET id = 14 WHERE content='Foo';\"),\n        (3, \"SELECT * FROM Item;\"),\n    ];\n\n    for (num, sql) in test_sqls {\n        g.count(sql, num).await;\n    }\n\n    g.run(\"DELETE FROM Item\").await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","time.rs"],"content":"use {\n    crate::*,\n    chrono::{NaiveDate, NaiveTime},\n    gluesql_core::{\n        error::{IntervalError, ValueError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(time, {\n    let g = get_tester!();\n\n    g.run(\n        r#\"\nCREATE TABLE TimeLog (\n    id INTEGER,\n    time1 TIME,\n    time2 TIME\n)\"#,\n    )\n    .await;\n\n    g.run(\n        \"\nINSERT INTO TimeLog VALUES\n    (1, '12:30:00', '13:31:01.123'),\n    (2, '9:2:1', 'AM 08:02:01.001'),\n    (3, 'PM 2:59', '9:00:00 AM');\n\",\n    )\n    .await;\n\n    let t = |hour: u32, min: u32, sec: u32, milli: u32| {\n        NaiveTime::from_hms_milli_opt(hour, min, sec, milli).unwrap()\n    };\n    let i = |h, m, s, ms| {\n        gluesql_core::data::Interval::milliseconds(\n            (t(h, m, s, ms) - NaiveTime::from_hms_opt(0, 0, 0).unwrap()).num_milliseconds(),\n        )\n    };\n\n    g.test(\n        \"SELECT id, time1, time2 FROM TimeLog;\",\n        Ok(select!(\n            id  | time1           | time2\n            I64 | Time            | Time;\n            1     t(12, 30, 0, 0)   t(13, 31, 1, 123);\n            2     t(9, 2, 1, 0)     t(8, 2, 1, 1);\n            3     t(14, 59, 0, 0)   t(9, 0, 0, 0)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM TimeLog WHERE time1 \u003e time2\",\n        Ok(select!(\n            id  | time1           | time2\n            I64 | Time            | Time;\n            2     t(9, 2, 1, 0)     t(8, 2, 1, 1);\n            3     t(14, 59, 0, 0)   t(9, 0, 0, 0)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM TimeLog WHERE time1 \u003c= time2\",\n        Ok(select!(\n            id  | time1           | time2\n            I64 | Time            | Time;\n            1     t(12, 30, 0, 0)   t(13, 31, 1, 123)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM TimeLog WHERE time1 = TIME '14:59:00'\",\n        Ok(select!(\n            id  | time1           | time2\n            I64 | Time            | Time;\n            3     t(14, 59, 0, 0)   t(9, 0, 0, 0)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM TimeLog WHERE time1 \u003c '1:00 PM'\",\n        Ok(select!(\n            id  | time1           | time2\n            I64 | Time            | Time;\n            1     t(12, 30, 0, 0)   t(13, 31, 1, 123);\n            2     t(9, 2, 1, 0)     t(8, 2, 1, 1)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM TimeLog WHERE TIME '23:00:00.123' \u003e 'PM 1:00';\",\n        Ok(select!(\n            id  | time1           | time2\n            I64 | Time            | Time;\n            1     t(12, 30, 0, 0)   t(13, 31, 1, 123);\n            2     t(9, 2, 1, 0)     t(8, 2, 1, 1);\n            3     t(14, 59, 0, 0)   t(9, 0, 0, 0)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT\n        id,\n        time1 - time2 AS time_sub,\n        time1 + INTERVAL '1' HOUR AS add,\n        time2 - INTERVAL '250' MINUTE AS sub\n        FROM TimeLog;\",\n        Ok(select!(\n            id  | time_sub                      | add             | sub\n            I64 | Interval                      | Time            | Time;\n            1     i(1, 1, 1, 123).unary_minus()   t(13, 30, 0, 0)    t(9, 21, 1, 123);\n            2     i(0, 59, 59, 999)               t(10, 2, 1, 0)     t(3, 52, 1, 1);\n            3     i(5, 59, 0, 0)                  t(15, 59, 0, 0)    t(4, 50, 0, 0)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT\n            id,\n            DATE '2021-01-05' + time2 AS timestamp\n        FROM TimeLog LIMIT 1;\",\n        Ok(select!(\n            id  | timestamp\n            I64 | Timestamp;\n            1     NaiveDate::from_ymd_opt(2021, 1, 5).unwrap().and_hms_milli_opt(13, 31, 1, 123).unwrap()\n        ))\n    ).await;\n\n    g.test(\n        \"SELECT * FROM TimeLog WHERE time1 \u003e time2 + INTERVAL '1' YEAR\",\n        Err(IntervalError::AddYearOrMonthToTime {\n            time: t(13, 31, 1, 123),\n            interval: gluesql_core::data::Interval::years(1),\n        }\n        .into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM TimeLog WHERE time1 \u003e time2 - INTERVAL '1-2' YEAR TO MONTH\",\n        Err(IntervalError::SubtractYearOrMonthToTime {\n            time: t(13, 31, 1, 123),\n            interval: gluesql_core::data::Interval::months(14),\n        }\n        .into()),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO TimeLog VALUES (1, '12345-678', '20:05:01')\",\n        Err(ValueError::FailedToParseTime(\"12345-678\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","timestamp.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::ValueError, prelude::Value::*},\n};\n\ntest_case!(timestamp, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE TimestampLog (\n    id INTEGER,\n    t1 TIMESTAMP,\n    t2 TIMESTAMP\n)\",\n    )\n    .await;\n\n    g.run(\n        \"\nINSERT INTO TimestampLog VALUES\n    (1, '2020-06-11 11:23:11Z',           '2021-03-01'),\n    (2, '2020-09-30 12:00:00 -07:00',     '1989-01-01T00:01:00+09:00'),\n    (3, '2021-04-30T07:00:00.1234-17:00', '2021-05-01T09:00:00.1234+09:00');\n\",\n    )\n    .await;\n\n    macro_rules! t {\n        ($timestamp: expr) =\u003e {\n            $timestamp.parse().unwrap()\n        };\n    }\n\n    g.test(\n        \"SELECT id, t1, t2 FROM TimestampLog\",\n        Ok(select!(\n            id  | t1                             | t2\n            I64 | Timestamp                      | Timestamp;\n            1     t!(\"2020-06-11T11:23:11\")        t!(\"2021-03-01T00:00:00\");\n            2     t!(\"2020-09-30T19:00:00\")        t!(\"1988-12-31T15:01:00\");\n            3     t!(\"2021-05-01T00:00:00.1234\")   t!(\"2021-05-01T00:00:00.1234\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM TimestampLog WHERE t1 \u003e t2\",\n        Ok(select!(\n            id  | t1                        | t2\n            I64 | Timestamp                 | Timestamp;\n            2     t!(\"2020-09-30T19:00:00\")   t!(\"1988-12-31T15:01:00\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM TimestampLog WHERE t1 = t2\",\n        Ok(select!(\n            id  | t1                             | t2\n            I64 | Timestamp                      | Timestamp;\n            3     t!(\"2021-05-01T00:00:00.1234\")   t!(\"2021-05-01T00:00:00.1234\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM TimestampLog WHERE t1 = '2020-06-11T14:23:11+0300';\",\n        Ok(select!(\n            id  | t1                        | t2\n            I64 | Timestamp                 | Timestamp;\n            1     t!(\"2020-06-11T11:23:11\")   t!(\"2021-03-01T00:00:00\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM TimestampLog WHERE t2 \u003c TIMESTAMP '2000-01-01';\",\n        Ok(select!(\n            id  | t1                        | t2\n            I64 | Timestamp                 | Timestamp;\n            2     t!(\"2020-09-30T19:00:00\")   t!(\"1988-12-31T15:01:00\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM TimestampLog WHERE TIMESTAMP '1999-01-03' \u003c '2000-01-01';\",\n        Ok(select!(\n            id  | t1                             | t2\n            I64 | Timestamp                      | Timestamp;\n            1     t!(\"2020-06-11T11:23:11\")        t!(\"2021-03-01T00:00:00\");\n            2     t!(\"2020-09-30T19:00:00\")        t!(\"1988-12-31T15:01:00\");\n            3     t!(\"2021-05-01T00:00:00.1234\")   t!(\"2021-05-01T00:00:00.1234\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, t1 - t2 AS timestamp_sub FROM TimestampLog;\",\n        Ok(select!(\n            id  | timestamp_sub\n            I64 | Interval;\n            1     gluesql_core::data::Interval::seconds(-22_682_209);\n            2     gluesql_core::data::Interval::seconds(1_001_908_740);\n            3     gluesql_core::data::Interval::seconds(0)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT\n            id,\n            t1 - INTERVAL '1' DAY AS sub,\n            t2 + INTERVAL '1' MONTH AS add\n        FROM TimestampLog;\",\n        Ok(select!(\n            id  | sub                            | add\n            I64 | Timestamp                      | Timestamp;\n            1     t!(\"2020-06-10T11:23:11\")        t!(\"2021-04-01T00:00:00\");\n            2     t!(\"2020-09-29T19:00:00\")        t!(\"1989-01-31T15:01:00\");\n            3     t!(\"2021-04-30T00:00:00.1234\")   t!(\"2021-06-01T00:00:00.1234\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO TimestampLog VALUES (1, '12345-678', '2021-05-01')\",\n        Err(ValueError::FailedToParseTimestamp(\"12345-678\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","uint128.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::ValueError, prelude::Value::*},\n};\n\ntest_case!(uint128, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE Item (\n            field_one UINT128,\n            field_two UINT128\n        );\",\n    )\n    .await;\n    g.run(r#\"INSERT INTO Item VALUES (1, 1), (2, 2), (3, 3), (4, 4);\"#)\n        .await;\n\n    g.test(\n        \"INSERT INTO Item VALUES (340282366920938463463374607431768211456,340282366920938463463374607431768211456);\",\n        Err(ValueError::FailedToParseNumber.into())\n    ).await;\n\n    g.test(\n        \"INSERT INTO Item VALUES (-32769, -32769);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one, field_two FROM Item\",\n        Ok(select!(\n            field_one         | field_two\n            U128              | U128;\n            1                   1;\n            2                   2;\n            3                   3;\n            4                   4\n        )),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e 0\",\n        Ok(select!(field_one U128; 1; 2;3;4)),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e= 0\",\n        Ok(select!(field_one U128; 1; 2;3;4)),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = 2\",\n        Ok(select!(field_one U128; 2)),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","uint16.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::ValueError, prelude::Value::*},\n};\n\ntest_case!(uint16, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE Item (\n            field_one UINT16,\n            field_two UINT16\n        );\",\n    )\n    .await;\n    g.run(r#\"INSERT INTO Item VALUES (1, 1), (2, 2), (3, 3), (4, 4);\"#)\n        .await;\n\n    g.test(\n        \"INSERT INTO Item VALUES (327689,327689);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO Item VALUES (-32769, -32769);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one, field_two FROM Item\",\n        Ok(select!(\n            field_one         | field_two\n            U16               | U16;\n            1                   1;\n            2                   2;\n            3                   3;\n            4                   4\n        )),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e 0\",\n        Ok(select!(field_one U16; 1; 2;3;4)),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e= 0\",\n        Ok(select!(field_one U16; 1; 2;3;4)),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = 2\",\n        Ok(select!(field_one U16; 2)),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","uint32.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::ValueError, prelude::Value::*},\n};\n\ntest_case!(uint32, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE Item (\n            field_one UINT32,\n            field_two UINT32\n        );\",\n    )\n    .await;\n    g.run(r#\"INSERT INTO Item VALUES (1, 1), (2, 2), (3, 3), (4, 4);\"#)\n        .await;\n\n    g.test(\n        \"INSERT INTO Item VALUES (4294967296,4294967296);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO Item VALUES (-32769, -32769);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one, field_two FROM Item\",\n        Ok(select!(\n            field_one         | field_two\n            U32               | U32;\n            1                   1;\n            2                   2;\n            3                   3;\n            4                   4\n        )),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e 0\",\n        Ok(select!(field_one U32; 1; 2;3;4)),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e= 0\",\n        Ok(select!(field_one U32; 1; 2;3;4)),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = 2\",\n        Ok(select!(field_one U32; 2)),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","uint64.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::ValueError, prelude::Value::*},\n};\n\ntest_case!(uint64, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE Item (\n            field_one UINT64,\n            field_two UINT64\n        );\",\n    )\n    .await;\n    g.run(r#\"INSERT INTO Item VALUES (1, 1), (2, 2), (3, 3), (4, 4);\"#)\n        .await;\n\n    g.test(\n        \"INSERT INTO Item VALUES (18446744073709551616,18446744073709551616);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO Item VALUES (-32769, -32769);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one, field_two FROM Item\",\n        Ok(select!(\n            field_one         | field_two\n            U64               | U64;\n            1                   1;\n            2                   2;\n            3                   3;\n            4                   4\n        )),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e 0\",\n        Ok(select!(field_one U64; 1; 2;3;4)),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e= 0\",\n        Ok(select!(field_one U64; 1; 2;3;4)),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = 2\",\n        Ok(select!(field_one U64; 2)),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","uint8.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::ValueError, prelude::Value::*},\n};\n\ntest_case!(uint8, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE Item (\n            field_one UINT8,\n            field_two UINT8\n        );\",\n    )\n    .await;\n    g.run(r#\"INSERT INTO Item VALUES (1, 1), (2, 2), (3, 3), (4, 4);\"#)\n        .await;\n\n    g.test(\n        \"INSERT INTO Item VALUES (256, 256);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO Item VALUES (-129, -129);\",\n        Err(ValueError::FailedToParseNumber.into()),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one, field_two FROM Item\",\n        Ok(select!(\n            field_one        | field_two\n            U8               |    U8;\n            1                      1;\n            2                      2;\n            3                      3;\n            4                      4\n        )),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e 0\",\n        Ok(select!(field_one U8; 1; 2; 3; 4)),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one \u003e= 0\",\n        Ok(select!(field_one U8; 1; 2; 3; 4)),\n    )\n    .await;\n    g.test(\n        \"SELECT field_one FROM Item WHERE field_one = 2\",\n        Ok(select!(field_one U8; 2)),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type","uuid.rs"],"content":"use {\n    crate::*,\n    bigdecimal::BigDecimal,\n    gluesql_core::{\n        ast::DataType,\n        data::Literal,\n        error::ValueError,\n        prelude::{Payload, Value::*},\n    },\n    std::borrow::Cow,\n    uuid::Uuid as UUID,\n};\n\ntest_case!(uuid, {\n    let g = get_tester!();\n\n    let parse_uuid = |v| UUID::parse_str(v).unwrap().as_u128();\n\n    {\n        let uuid = UUID::now_v7();\n\n        let test_cases = [\n            (\n                \"CREATE TABLE posts (id UUID PRIMARY KEY)\",\n                Ok(Payload::Create),\n            ),\n            (\n                \u0026format!(r#\"INSERT INTO posts (\"id\") VALUES ('{uuid}')\"#),\n                Ok(Payload::Insert(1)),\n            ),\n        ];\n\n        for (sql, expected) in test_cases {\n            g.test(sql, expected).await;\n        }\n\n        let glue = g.get_glue();\n        let sql = format!(\"SELECT id FROM posts WHERE id = '{uuid}';\", uuid = uuid);\n        let payload = glue.execute(sql).await.unwrap();\n\n        assert_eq!(payload, vec![select!( id Uuid; uuid.as_u128() )]);\n    }\n\n    let test_cases = [\n        (\"CREATE TABLE UUID (uuid_field UUID)\", Ok(Payload::Create)),\n        (\n            r#\"INSERT INTO UUID VALUES (0)\"#,\n            Err(ValueError::IncompatibleLiteralForDataType {\n                data_type: DataType::Uuid,\n                literal: format!(\"{:?}\", Literal::Number(Cow::Owned(BigDecimal::from(0)))),\n            }\n            .into()),\n        ),\n        (\n            r#\"INSERT INTO UUID VALUES (X'1234')\"#,\n            Err(ValueError::FailedToParseUUID(\"1234\".to_owned()).into()),\n        ),\n        (\n            r#\"INSERT INTO UUID VALUES ('NOT_UUID')\"#,\n            Err(ValueError::FailedToParseUUID(\"NOT_UUID\".to_owned()).into()),\n        ),\n        (\n            r#\"INSERT INTO UUID VALUES\n            (X'936DA01F9ABD4d9d80C702AF85C822A8'),\n            ('550e8400-e29b-41d4-a716-446655440000'),\n            ('urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4')\"#,\n            Ok(Payload::Insert(3)),\n        ),\n        (\n            r#\"SELECT uuid_field AS uuid_field FROM UUID;\"#,\n            Ok(select!(\n                uuid_field\n                Uuid;\n                parse_uuid(\"936DA01F9ABD4d9d80C702AF85C822A8\");\n                parse_uuid(\"550e8400-e29b-41d4-a716-446655440000\");\n                parse_uuid(\"urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4\")\n            )),\n        ),\n        (\n            r#\"UPDATE UUID SET uuid_field = 'urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4' WHERE uuid_field='550e8400-e29b-41d4-a716-446655440000'\"#,\n            Ok(Payload::Update(1)),\n        ),\n        (\n            r#\"SELECT uuid_field AS uuid_field, COUNT(*) FROM UUID GROUP BY uuid_field\"#,\n            Ok(select!(\n                uuid_field | \"COUNT(*)\"\n                Uuid | I64;\n                parse_uuid(\"936DA01F9ABD4d9d80C702AF85C822A8\")  1;\n                parse_uuid(\"urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4\")  2\n            )),\n        ),\n        (\n            r#\"DELETE FROM UUID WHERE uuid_field='550e8400-e29b-41d4-a716-446655440000'\"#,\n            Ok(Payload::Delete(0)),\n        ),\n        (\n            r#\"DELETE FROM UUID WHERE uuid_field='urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4'\"#,\n            Ok(Payload::Delete(2)),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","data_type.rs"],"content":"pub mod bytea;\npub mod date;\npub mod decimal;\npub mod float32;\npub mod inet;\npub mod int128;\npub mod int16;\npub mod int32;\npub mod int64;\npub mod int8;\npub mod interval;\npub mod list;\npub mod map;\npub mod point;\npub mod sql_types;\npub mod time;\npub mod timestamp;\npub mod uint128;\npub mod uint16;\npub mod uint32;\npub mod uint64;\npub mod uint8;\npub mod uuid;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","default.rs"],"content":"use {\n    crate::*,\n    chrono::NaiveDate,\n    gluesql_core::{\n        error::EvaluateError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(default, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Test (\n                id INTEGER DEFAULT 1,\n                num INTEGER,\n                flag BOOLEAN NULL DEFAULT false\n            )\",\n            Payload::Create,\n        ),\n        (\"INSERT INTO Test VALUES (8, 80, true);\", Payload::Insert(1)),\n        (\"INSERT INTO Test (num) VALUES (10);\", Payload::Insert(1)),\n        (\n            \"INSERT INTO Test (num, id) VALUES (20, 2);\",\n            Payload::Insert(1),\n        ),\n        (\n            \"INSERT INTO Test (num, flag) VALUES (30, NULL), (40, true);\",\n            Payload::Insert(2),\n        ),\n        (\n            \"SELECT * FROM Test;\",\n            select_with_null!(\n                id     | num     | flag;\n                I64(8)   I64(80)   Bool(true);\n                I64(1)   I64(10)   Bool(false);\n                I64(2)   I64(20)   Bool(false);\n                I64(1)   I64(30)   Null;\n                I64(1)   I64(40)   Bool(true)\n            ),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n\n    let stateless_function_test_cases = [\n        (\n            \"CREATE TABLE FunctionTest (\n                uuid UUID,\n                num FLOAT\n            )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO FunctionTest VALUES (GENERATE_UUID(), 1.0)\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"INSERT INTO FunctionTest VALUES (GENERATE_UUID(), (SELECT id FROM Foo))\",\n            Err(EvaluateError::UnsupportedStatelessExpr(expr(\"(SELECT id FROM Foo)\")).into()),\n        ),\n    ];\n\n    for (sql, expected) in stateless_function_test_cases {\n        g.test(sql, expected).await;\n    }\n\n    g.test(\n        \"\n        CREATE TABLE TestExpr (\n            id INTEGER,\n            date DATE DEFAULT DATE '2020-01-01',\n            num INTEGER DEFAULT -(-1 * +2),\n            flag BOOLEAN DEFAULT CAST('TRUE' AS BOOLEAN),\n            flag2 BOOLEAN DEFAULT 1 IN (1, 2, 3),\n            flag3 BOOLEAN DEFAULT 10 BETWEEN 1 AND 2,\n            flag4 BOOLEAN DEFAULT (1 IS NULL OR NULL IS NOT NULL)\n        )\",\n        Ok(Payload::Create),\n    )\n    .await;\n\n    g.run(\"INSERT INTO TestExpr (id) VALUES (1);\").await;\n\n    let d = |year: i32, month: u32, day: u32| NaiveDate::from_ymd_opt(year, month, day).unwrap();\n\n    g.test(\n        \"SELECT * FROM TestExpr\",\n        Ok(select!(\n            id  | date          | num | flag | flag2 | flag3 | flag4;\n            I64 | Date          | I64 | Bool | Bool  | Bool  | Bool;\n            1     d(2020, 1, 1)   2     true   true    false   false\n        )),\n    )\n    .await;\n});\n","traces":[{"line":88,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","delete.rs"],"content":"use {\n    crate::*,\n    gluesql_core::prelude::{Payload, Value::*},\n};\n\ntest_case!(delete, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Foo (\n            id INTEGER PRIMARY KEY,\n            score INTEGER,\n            flag BOOLEAN\n        );\n    \",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO Foo VALUES\n            (1, 100, TRUE),\n            (2, 300, FALSE),\n            (3, 700, TRUE);\n    \",\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM Foo\",\n        Ok(select!(\n            id  | score | flag\n            I64 | I64   | Bool;\n            1     100     true;\n            2     300     false;\n            3     700     true\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"delete using WHERE\",\n        \"DELETE FROM Foo WHERE flag = FALSE\",\n        Ok(Payload::Delete(1)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM Foo\",\n        Ok(select!(\n            id  | score | flag\n            I64 | I64   | Bool;\n            1     100     true;\n            3     700     true\n        )),\n    )\n    .await;\n\n    g.named_test(\"delete all\", \"DELETE FROM Foo;\", Ok(Payload::Delete(2)))\n        .await;\n\n    g.test(\n        \"SELECT * FROM Foo\",\n        Ok(Payload::Select {\n            labels: vec![\"id\".to_owned(), \"score\".to_owned(), \"flag\".to_owned()],\n            rows: vec![],\n        }),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","dictionary.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::TranslateError,\n        prelude::{Payload::ShowVariable, PayloadVariable, Value::*},\n    },\n};\n\ntest_case!(dictionary, {\n    let g = get_tester!();\n\n    let tables = |v: Vec\u003c\u0026str\u003e| {\n        Ok(ShowVariable(PayloadVariable::Tables(\n            v.into_iter().map(ToOwned::to_owned).collect(),\n        )))\n    };\n\n    assert!(matches!(\n        g.run(\"SHOW VERSION;\").await,\n        ShowVariable(PayloadVariable::Version(_))\n    ));\n\n    g.test(\"SHOW TABLES\", tables(Vec::new())).await;\n\n    g.run(\"CREATE TABLE Foo (id INTEGER, name TEXT NULL, type TEXT NULL) COMMENT='this is table comment';\")\n        .await;\n    g.test(\"SHOW TABLES\", tables(vec![\"Foo\"])).await;\n\n    g.run(\"CREATE TABLE Zoo (id INTEGER PRIMARY KEY COMMENT 'hello');\")\n        .await;\n    g.run(\"CREATE TABLE Bar (id INTEGER UNIQUE, name TEXT NOT NULL DEFAULT 'NONE');\")\n        .await;\n\n    g.test(\"SHOW TABLES\", tables(vec![\"Bar\", \"Foo\", \"Zoo\"]))\n        .await;\n\n    g.test(\n        \"SHOW WHATEVER\",\n        Err(TranslateError::UnsupportedShowVariableKeyword(\"WHATEVER\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"SHOW ME THE CHICKEN\",\n        Err(\n            TranslateError::UnsupportedShowVariableStatement(\"SHOW ME THE CHICKEN\".to_owned())\n                .into(),\n        ),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM GLUE_TABLES\",\n        Ok(select_with_null!(\n            TABLE_NAME            | COMMENT;\n            Str(\"Bar\".to_owned())   Null;\n            Str(\"Foo\".to_owned())   Str(\"this is table comment\".to_owned());\n            Str(\"Zoo\".to_owned())   Null\n        )),\n    )\n    .await;\n\n    let s = |v: \u0026str| Str(v.to_owned());\n\n    g.test(\n        \"SELECT * FROM GLUE_TABLE_COLUMNS\",\n        Ok(select_with_null!(\n            TABLE_NAME | COLUMN_NAME | COLUMN_ID | NULLABLE    | KEY              | DEFAULT     | COMMENT;\n            s(\"Bar\")     s(\"id\")       I64(1)      Bool(true)    s(\"UNIQUE\")        Null          Null;\n            s(\"Bar\")     s(\"name\")     I64(2)      Bool(false)   Null               s(\"'NONE'\")   Null;\n            s(\"Foo\")     s(\"id\")       I64(1)      Bool(true)    Null               Null          Null;\n            s(\"Foo\")     s(\"name\")     I64(2)      Bool(true)    Null               Null          Null;\n            s(\"Foo\")     s(\"type\")     I64(3)      Bool(true)    Null               Null          Null;\n            s(\"Zoo\")     s(\"id\")       I64(1)      Bool(false)   s(\"PRIMARY KEY\")   Null          s(\"hello\") \n        ))\n    ).await;\n});\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","dictionary_index.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::TranslateError, prelude::Value::*},\n};\n\ntest_case!(ditionary_index, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE Foo (id INT, name TEXT);\").await;\n    g.run(\"CREATE INDEX Foo_id ON Foo (id)\").await;\n    g.run(\"CREATE INDEX Foo_id_2 ON Foo (id + 2)\").await;\n    g.test(\n        \"SELECT * FROM GLUE_INDEXES\",\n        Ok(select!(\n            TABLE_NAME       | INDEX_NAME            | ORDER             | EXPRESSION         | UNIQUENESS;\n            Str              | Str                   | Str               | Str                | Bool;\n            \"Foo\".to_owned()   \"Foo_id\".to_owned()     \"BOTH\".to_owned()   \"id\".to_owned()      false;\n            \"Foo\".to_owned()   \"Foo_id_2\".to_owned()   \"BOTH\".to_owned()   \"id + 2\".to_owned()  false\n        ))\n    ).await;\n\n    g.run(\"CREATE TABLE Bar (id INT PRIMARY KEY, name TEXT);\")\n        .await;\n    g.run(\"CREATE INDEX Bar_name_concat ON Bar (name + '_')\")\n        .await;\n    g.test(\n        \"SELECT * FROM GLUE_INDEXES\",\n        Ok(select!(\n            TABLE_NAME       | INDEX_NAME                  | ORDER             | EXPRESSION               | UNIQUENESS;\n            Str              | Str                         | Str               | Str                      | Bool;\n            \"Bar\".to_owned()   \"PRIMARY\".to_owned()          \"BOTH\".to_owned()   \"id\".to_owned()            true;\n            \"Bar\".to_owned()   \"Bar_name_concat\".to_owned()  \"BOTH\".to_owned()   \"name + '_'\".to_owned()  false;\n            \"Foo\".to_owned()   \"Foo_id\".to_owned()           \"BOTH\".to_owned()   \"id\".to_owned()            false;\n            \"Foo\".to_owned()   \"Foo_id_2\".to_owned()         \"BOTH\".to_owned()   \"id + 2\".to_owned()        false\n        ))\n    ).await;\n\n    let test_cases = [\n        (\n            \"DROP INDEX Bar.PRIMARY\",\n            Err(TranslateError::CannotDropPrimary.into()),\n        ),\n        (\n            \"CREATE INDEX Primary ON Foo (id)\",\n            Err(TranslateError::ReservedIndexName(\"Primary\".to_owned()).into()),\n        ),\n    ];\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","filter.rs"],"content":"use {crate::*, gluesql_core::data::*};\n\ntest_case!(filter, {\n    let g = get_tester!();\n\n    let create_sqls = [\n        \"\n        CREATE TABLE Boss (\n            id INTEGER,\n            name TEXT,\n            strength FLOAT\n        );\",\n        \"\n        CREATE TABLE Hunter (\n            id INTEGER,\n            name TEXT\n        );\",\n    ];\n\n    for sql in create_sqls {\n        g.run(sql).await;\n    }\n\n    let insert_sqls = [\n        \"\n        INSERT INTO Boss (id, name, strength) VALUES\n            (1,    'Amelia', 10.10),\n            (2,      'Doll', 20.20),\n            (3, 'Gascoigne', 30.30),\n            (4,   'Gehrman', 40.40),\n            (5,     'Maria', 50.50);\n        \",\n        \"\n        INSERT INTO Hunter (id, name) VALUES\n            (1, 'Gascoigne'),\n            (2,   'Gehrman'),\n            (3,     'Maria');\n        \",\n    ];\n\n    for sql in insert_sqls {\n        g.run(sql).await;\n    }\n\n    let select_sqls = [\n        (3, \"SELECT id, name FROM Boss WHERE id BETWEEN 2 AND 4\"),\n        (\n            3,\n            \"SELECT id, name FROM Boss WHERE name BETWEEN 'Doll' AND 'Gehrman'\",\n        ),\n        (\n            2,\n            \"SELECT name FROM Boss WHERE name NOT BETWEEN 'Doll' AND 'Gehrman'\",\n        ),\n        (\n            2,\n            \"SELECT strength, name FROM Boss WHERE name NOT BETWEEN 'Doll' AND 'Gehrman'\",\n        ),\n        (\n            3,\n            \"SELECT name \n             FROM Boss \n             WHERE EXISTS (\n                SELECT * FROM Hunter WHERE Hunter.name = Boss.name\n             )\",\n        ),\n        (\n            2,\n            \"SELECT name \n             FROM Boss \n             WHERE NOT EXISTS (\n                SELECT * FROM Hunter WHERE Hunter.name = Boss.name\n             )\",\n        ),\n        (5, \"SELECT name FROM Boss WHERE +1 = 1\"),\n        (3, \"SELECT id FROM Hunter WHERE -1 = -1\"),\n        (5, \"SELECT name FROM Boss WHERE -2.0 \u003c -1.0\"),\n        (3, \"SELECT id FROM Hunter WHERE +2 \u003e +1.0\"),\n        (2, \"SELECT name FROM Boss WHERE id \u003c= +2\"),\n        (2, \"SELECT name FROM Boss WHERE +id \u003c= 2\"),\n    ];\n\n    for (num, sql) in select_sqls {\n        g.count(sql, num).await;\n    }\n\n    let select_opt_sqls = [\n        (5, \"SELECT name FROM Boss WHERE 2 = 1.0 + 1\"),\n        (3, \"SELECT id FROM Hunter WHERE -1.0 - 1.0 \u003c -1\"),\n        (5, \"SELECT name FROM Boss WHERE -2.0 * -3.0 = 6\"),\n        (3, \"SELECT id FROM Hunter WHERE +2 / 1.0 \u003e +1.0\"),\n    ];\n\n    for (num, sql) in select_opt_sqls {\n        g.count(sql, num).await;\n    }\n\n    let error_sqls = [\n        (\n            \"SELECT id FROM Hunter WHERE +'abcd' \u003e 1.0\",\n            LiteralError::UnaryOperationOnNonNumeric.into(),\n        ),\n        (\n            \"SELECT id FROM Hunter WHERE -'abcd' \u003c 1.0\",\n            LiteralError::UnaryOperationOnNonNumeric.into(),\n        ),\n        (\n            \"SELECT id FROM Hunter WHERE +name \u003e 1.0\",\n            ValueError::UnaryPlusOnNonNumeric.into(),\n        ),\n        (\n            \"SELECT id FROM Hunter WHERE -name \u003c 1.0\",\n            ValueError::UnaryMinusOnNonNumeric.into(),\n        ),\n    ];\n\n    for (sql, error) in error_sqls {\n        g.test(sql, Err(error)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","foreign_key.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast::{\n            DataType::{Int, Text},\n            ForeignKey, ReferentialAction,\n        },\n        error::{DeleteError, InsertError, TranslateError, UpdateError},\n        executor::{AlterError, Referencing},\n        prelude::Payload,\n    },\n};\n\ntest_case!(foreign_key, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE ReferencedTableWithoutPK (\n            id INTEGER,\n            name TEXT\n        );\",\n    )\n    .await;\n\n    g.named_test(\n        \"Creating table with foreign key should be failed if referenced table does not have primary key\",\n        \"CREATE TABLE ReferencingTable (\n            id INT, name TEXT,\n            referenced_id INT,\n            FOREIGN KEY (referenced_id) REFERENCES ReferencedTableWithoutPK (id)\n        );\",\n        Err(AlterError::ReferencingNonPKColumn {\n            referenced_table: \"ReferencedTableWithoutPK\".to_owned(),\n            referenced_column: \"id\".to_owned(),\n        }\n        .into()),\n    )\n    .await;\n\n    g.run(\n        \"CREATE TABLE ReferencedTableWithUnique (\n            id INTEGER UNIQUE,\n            name TEXT\n        );\",\n    )\n    .await;\n\n    g.named_test(\n        \"Creating table with foreign key should be failed if referenced table has only Unique constraint\",\n        \"CREATE TABLE ReferencingTable (\n            id INT,\n            name TEXT,\n            referenced_id INT,\n            FOREIGN KEY (referenced_id) REFERENCES ReferencedTableWithUnique (id)\n        );\",\n        Err(AlterError::ReferencingNonPKColumn {\n            referenced_table: \"ReferencedTableWithUnique\".to_owned(),\n            referenced_column: \"id\".to_owned(),\n        }\n        .into()),\n    )\n    .await;\n\n    g.run(\n        \"CREATE TABLE ReferencedTableWithPK (\n            id INTEGER PRIMARY KEY,\n            name TEXT\n        );\",\n    )\n    .await;\n\n    g.named_test(\n        \"Creating table with foreign key on different data type should be failed\",\n        \"CREATE TABLE ReferencingTable (\n            id TEXT,\n            name TEXT,\n            referenced_id TEXT,\n            FOREIGN KEY (referenced_id) REFERENCES ReferencedTableWithPK (id)\n        );\",\n        Err(AlterError::ForeignKeyDataTypeMismatch {\n            referencing_column: \"referenced_id\".to_owned(),\n            referencing_column_type: Text,\n            referenced_column: \"id\".to_owned(),\n            referenced_column_type: Int,\n        }\n        .into()),\n    )\n    .await;\n\n    g.named_test(\n        \"Unsupported foreign key option: CASCADE\",\n        \"CREATE TABLE ReferencingTable (\n            id INT,\n            name TEXT,\n            referenced_id INT,\n            FOREIGN KEY (referenced_id) REFERENCES ReferencedTableWithPK (id) ON DELETE CASCADE\n        );\",\n        Err(TranslateError::UnsupportedConstraint(\"CASCADE\".to_owned()).into()),\n    )\n    .await;\n\n    g.named_test(\n        \"Unsupported foreign key option: SET DEFAULT\",\n        \"CREATE TABLE ReferencingTable (\n            id INT,\n            name TEXT,\n            referenced_id INT,\n            FOREIGN KEY (referenced_id) REFERENCES ReferencedTableWithPK (id) ON DELETE SET DEFAULT\n        );\",\n        Err(TranslateError::UnsupportedConstraint(\"SET DEFAULT\".to_owned()).into()),\n    )\n    .await;\n\n    g.named_test(\n        \"Unsupported foreign key option: SET NULL\",\n        \"CREATE TABLE ReferencingTable (\n            id INT,\n            name TEXT,\n            referenced_id INT,\n            FOREIGN KEY (referenced_id) REFERENCES ReferencedTableWithPK (id) ON DELETE SET NULL\n        );\",\n        Err(TranslateError::UnsupportedConstraint(\"SET NULL\".to_owned()).into()),\n    )\n    .await;\n\n    g.named_test(\n        \"Referencing column not found\",\n        \"CREATE TABLE ReferencingTable (\n            id INT,\n            name TEXT,\n            referenced_id INT,\n            FOREIGN KEY (wrong_referencing_column) REFERENCES ReferencedTableWithPK (id)\n        );\",\n        Err(AlterError::ReferencingColumnNotFound(\"wrong_referencing_column\".to_owned()).into()),\n    )\n    .await;\n\n    g.named_test(\n        \"Referenced column not found\",\n        \"CREATE TABLE ReferencingTable (\n            id INT,\n            name TEXT,\n            referenced_id INT,\n            FOREIGN KEY (referenced_id) REFERENCES ReferencedTableWithPK (wrong_referenced_column)\n        );\",\n        Err(AlterError::ReferencedColumnNotFound(\"wrong_referenced_column\".to_owned()).into()),\n    )\n    .await;\n\n    g.named_test(\n        \"Creating table with foreign key should be succeeded if referenced table has primary key. NO ACTION(=RESTRICT) is default\",\n        \"CREATE TABLE ReferencingTable (\n            id INT,\n            name TEXT,\n            referenced_id INT,\n            CONSTRAINT MyFkConstraint FOREIGN KEY (referenced_id) REFERENCES ReferencedTableWithPK (id) ON DELETE NO ACTION ON UPDATE RESTRICT\n        );\",\n        Ok(Payload::Create),\n    )\n    .await;\n\n    g.named_test(\n        \"If there is no referenced value, insert should fail\",\n        \"INSERT INTO ReferencingTable VALUES (1, 'orphan', 1);\",\n        Err(InsertError::CannotFindReferencedValue {\n            table_name: \"ReferencedTableWithPK\".to_owned(),\n            column_name: \"id\".to_owned(),\n            referenced_value: \"1\".to_owned(),\n        }\n        .into()),\n    )\n    .await;\n\n    g.named_test(\n        \"Even If there is no referenced value, NULL should be inserted\",\n        \"INSERT INTO ReferencingTable VALUES (1, 'Null is independent', NULL);\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n\n    g.run(\"INSERT INTO ReferencedTableWithPK VALUES (1, 'referenced_table1');\")\n        .await;\n\n    g.named_test(\n        \"With valid referenced value, insert should succeed\",\n        \"INSERT INTO ReferencingTable VALUES (2, 'referencing_table with referenced_table', 1);\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n\n    g.named_test(\n        \"If there is no referenced value, update should fail\",\n        \"UPDATE ReferencingTable SET referenced_id = 2 WHERE id = 2;\",\n        Err(UpdateError::CannotFindReferencedValue {\n            table_name: \"ReferencedTableWithPK\".to_owned(),\n            column_name: \"id\".to_owned(),\n            referenced_value: \"2\".to_owned(),\n        }\n        .into()),\n    )\n    .await;\n\n    g.named_test(\n        \"Even If there is no referenced value, it should be able to update to NULL\",\n        \"UPDATE ReferencingTable SET referenced_id = NULL WHERE id = 2;\",\n        Ok(Payload::Update(1)),\n    )\n    .await;\n\n    g.named_test(\n        \"With valid referenced value, update should succeed\",\n        \"UPDATE ReferencingTable SET referenced_id = 1 WHERE id = 2;\",\n        Ok(Payload::Update(1)),\n    )\n    .await;\n\n    g.named_test(\n        \"Deleting referenced row should fail if referencing value exists (by default: NO ACTION and gets error)\",\n        \"DELETE FROM ReferencedTableWithPK WHERE id = 1;\",\n        Err(DeleteError::ReferencingColumnExists(\"ReferencingTable.referenced_id\".to_owned()).into()),\n    )\n    .await;\n\n    g.named_test(\n        \"Deleting referencing table does not care referenced table\",\n        \"DELETE FROM ReferencingTable WHERE id = 2;\",\n        Ok(Payload::Delete(1)),\n    )\n    .await;\n\n    g.run(\n        \"\n        CREATE TABLE ReferencedTableWithPK_2 (\n            id INTEGER PRIMARY KEY,\n            name TEXT\n        );\",\n    )\n    .await;\n\n    g.run(\"INSERT INTO ReferencedTableWithPK_2 VALUES (1, 'referenced_table2');\")\n        .await;\n\n    g.named_test(\n        \"Table with two foreign keys\",\n        \"CREATE TABLE ReferencingWithTwoFK (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            referenced_id_1 INTEGER,\n            referenced_id_2 INTEGER,\n            FOREIGN KEY (referenced_id_1) REFERENCES ReferencedTableWithPK (id),\n            FOREIGN KEY (referenced_id_2) REFERENCES ReferencedTableWithPK_2 (id)\n        );\",\n        Ok(Payload::Create),\n    )\n    .await;\n\n    g.run(\n        \"INSERT INTO ReferencingWithTwoFK VALUES (1, 'referencing_table with two referenced_table', 1, 1);\"\n    ).await;\n\n    g.named_test(\n        \"Cannot update referenced_id_2 if there is no referenced value\",\n        \"UPDATE ReferencingWithTwoFK SET referenced_id_2 = 9 WHERE id = 1;\",\n        Err(UpdateError::CannotFindReferencedValue {\n            table_name: \"ReferencedTableWithPK_2\".to_owned(),\n            column_name: \"id\".to_owned(),\n            referenced_value: \"9\".to_owned(),\n        }\n        .into()),\n    )\n    .await;\n\n    g.named_test(\n        \"Cannot drop referenced table if referencing table exists\",\n        \"DROP TABLE ReferencedTableWithPK;\",\n        Err(AlterError::CannotDropTableWithReferencing {\n            referenced_table_name: \"ReferencedTableWithPK\".to_owned(),\n            referencings: vec![\n                Referencing {\n                    table_name: \"ReferencingTable\".to_owned(),\n                    foreign_key: ForeignKey {\n                        name: \"MyFkConstraint\".to_owned(),\n                        referencing_column_name: \"referenced_id\".to_owned(),\n                        referenced_table_name: \"ReferencedTableWithPK\".to_owned(),\n                        referenced_column_name: \"id\".to_owned(),\n                        on_delete: ReferentialAction::NoAction,\n                        on_update: ReferentialAction::NoAction,\n                    },\n                },\n                Referencing {\n                    table_name: \"ReferencingWithTwoFK\".to_owned(),\n                    foreign_key: ForeignKey {\n                        name: \"FK_referenced_id_1-ReferencedTableWithPK_id\".to_owned(),\n                        referencing_column_name: \"referenced_id_1\".to_owned(),\n                        referenced_table_name: \"ReferencedTableWithPK\".to_owned(),\n                        referenced_column_name: \"id\".to_owned(),\n                        on_delete: ReferentialAction::NoAction,\n                        on_update: ReferentialAction::NoAction,\n                    },\n                },\n            ],\n        }\n        .into()),\n    )\n    .await;\n\n    g.named_test(\n        \"Dropping table with cascade should drop both table and constraint\",\n        \"DROP TABLE ReferencedTableWithPK CASCADE;\",\n        Ok(Payload::DropTable(1)),\n    )\n    .await;\n\n    g.named_test(\n        \"Should create self referencing table\",\n        \"CREATE TABLE SelfReferencingTable (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            referenced_id INTEGER,\n            FOREIGN KEY (referenced_id) REFERENCES SelfReferencingTable (id)\n        );\",\n        Ok(Payload::Create),\n    )\n    .await;\n\n    g.named_test(\n        \"Dropping self referencing table should succeed\",\n        \"DROP TABLE SelfReferencingTable;\",\n        Ok(Payload::DropTable(1)),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","abs.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(abs, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT ABS(1) AS ABS1, \n                    ABS(-1) AS ABS2, \n                    ABS(+1) AS ABS3\",\n            Ok(select!(\n                \"ABS1\" | \"ABS2\" | \"ABS3\";\n                I64    | I64    | I64;\n                1        1        1\n            )),\n        ),\n        (\n            \"SELECT ABS(1.5) AS ABS1, \n                    ABS(-1.5) AS ABS2, \n                    ABS(+1.5) AS ABS3;\",\n            Ok(select!(\n                \"ABS1\" | \"ABS2\" | \"ABS3\";\n                F64    | F64    | F64;\n                1.5      1.5      1.5\n            )),\n        ),\n        (\n            \"SELECT ABS(0) AS ABS1, \n                    ABS(-0) AS ABS2, \n                    ABS(+0) AS ABS3;\",\n            Ok(select!(\n                \"ABS1\" | \"ABS2\" | \"ABS3\";\n                I64    | I64    | I64;\n                0        0        0\n            )),\n        ),\n        (\n            \"CREATE TABLE SingleItem (id integer, int8 int8, dec decimal)\",\n            Ok(Payload::Create),\n        ),\n        (\n            r#\"INSERT INTO SingleItem VALUES (0, -1, -2)\"#,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"SELECT ABS(id) AS ABS1, \n                    ABS(int8) AS ABS2, \n                    ABS(dec) AS ABS3 \n            FROM SingleItem\",\n            Ok(select!(\n                \"ABS1\"  | \"ABS2\" | \"ABS3\";\n                I64     | I8     |  Decimal;\n                0         1         2.into()\n            )),\n        ),\n        (\n            \"SELECT ABS('string') AS ABS FROM SingleItem\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"ABS\")).into()),\n        ),\n        (\"SELECT ABS(NULL) AS ABS;\", Ok(select_with_null!(ABS; Null))),\n        (\n            \"SELECT ABS(TRUE) AS ABS;\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"ABS\")).into()),\n        ),\n        (\n            \"SELECT ABS(FALSE) AS ABS;\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"ABS\")).into()),\n        ),\n        (\n            \"SELECT ABS('string', 'string2') AS ABS\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"ABS\".to_owned(),\n                expected: 1,\n                found: 2,\n            }\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","add_month.rs"],"content":"use {\n    crate::*,\n    chrono::format::ParseErrorKind,\n    gluesql_core::{\n        error::EvaluateError,\n        prelude::{Error, Value},\n    },\n};\n\ntest_case!(add_month, {\n    macro_rules! date {\n        ($date: expr) =\u003e {\n            $date.parse().unwrap()\n        };\n    }\n    fn assert_chrono_error_kind_eq(error: Error, kind: ParseErrorKind) {\n        match error {\n            Error::Evaluate(EvaluateError::FormatParseError(err)) =\u003e {\n                assert_eq!(err.kind(), kind)\n            }\n            _ =\u003e panic!(\"invalid error: {error}\"),\n        }\n    }\n    let g = get_tester!();\n\n    g.named_test(\n        \"plus test on general case\",\n        \"SELECT ADD_MONTH('2017-06-15',1) AS test;\",\n        Ok(select!(\n            \"test\"\n            Value::Date;\n            date!(\"2017-07-15\")\n        )),\n    )\n    .await;\n    g.named_test(\n        \"minus test on general case\",\n        \"SELECT ADD_MONTH('2017-06-15',-1) AS test;\",\n        Ok(select!(\n            \"test\"\n            Value::Date;\n            date!(\"2017-05-15\")\n        )),\n    )\n    .await;\n    g.named_test(\n        \"the last day of February test\",\n        \"SELECT ADD_MONTH('2017-01-31',1) AS test;\",\n        Ok(select!(\n            \"test\"\n            Value::Date;\n            date!(\"2017-02-28\")\n        )),\n    )\n    .await;\n    g.named_test(\n        \"year change test\",\n        \"SELECT ADD_MONTH('2017-01-31',13) AS test;\",\n        Ok(select!(\n            \"test\"\n            Value::Date;\n            date!(\"2018-02-28\")\n        )),\n    )\n    .await;\n    g.named_test(\n        \"zero test\",\n        \"SELECT ADD_MONTH('2017-01-31',0) AS test;\",\n        Ok(select!(\n            \"test\"\n            Value::Date;\n            date!(\"2017-01-31\")\n        )),\n    )\n    .await;\n    g.named_test(\n        \"out of range test with i64::MAX\",\n        \"SELECT ADD_MONTH('2017-01-31',9223372036854775807) AS test;\",\n        Err(EvaluateError::I64ToU32ConversionFailure(\"ADD_MONTH\".to_owned()).into()),\n    )\n    .await;\n    g.named_test(\n        \"out of range test\",\n        \"SELECT ADD_MONTH('2017-01-31',10000000000000000000) AS test;\",\n        Err(EvaluateError::FunctionRequiresIntegerValue(\"ADD_MONTH\".to_owned()).into()),\n    )\n    .await;\n    g.named_test(\n        \"out of range test with i32::MAX\",\n        \"SELECT ADD_MONTH('2017-01-31',2147483648) AS test;\",\n        Err(EvaluateError::ChrFunctionRequiresIntegerValueInRange0To255.into()),\n    )\n    .await;\n    let error_cases = [\n        (\n            g.run_err(\"SELECT ADD_MONTH('2017-01-31-10',0) AS test;\")\n                .await,\n            chrono::format::ParseErrorKind::TooLong,\n        ),\n        (\n            g.run_err(\"SELECT ADD_MONTH('2017-01',0) AS test;\").await,\n            chrono::format::ParseErrorKind::TooShort,\n        ),\n        (\n            g.run_err(\"SELECT ADD_MONTH('2015-14-05',1) AS test\").await,\n            chrono::format::ParseErrorKind::OutOfRange,\n        ),\n    ];\n\n    for (error, kind) in error_cases {\n        assert_chrono_error_kind_eq(error, kind);\n    }\n});\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","append.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::EvaluateError,\n        prelude::{Payload, Value::*},\n    },\n};\ntest_case!(append, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Append (\n            id INTEGER,\n            items LIST,\n            element INTEGER,\n            element2 TEXT\n        );\n    \",\n    )\n    .await;\n    g.run(\n        r#\"\n            INSERT INTO Append VALUES\n            (1, '[1, 2, 3]', 4, 'Foo');\n        \"#,\n    )\n    .await;\n    g.test(\n        r#\"select append(items, element) as myappend from Append;\"#,\n        Ok(select!(\n           myappend\n           List;\n           vec![I64(1), I64(2), I64(3), I64(4)]\n        )),\n    )\n    .await;\n    g.test(\n        r#\"select append(items, element2) as myappend from Append;\"#,\n        Ok(select!(\n           myappend\n           List;\n           vec![I64(1), I64(2), I64(3), Str(\"Foo\".into())]\n        )),\n    )\n    .await;\n\n    g.test(\n        r#\"select append(element, element2) as myappend from Append\"#,\n        Err(EvaluateError::ListTypeRequired.into()),\n    )\n    .await;\n\n    g.test(\n        r#\"CREATE TABLE Foo (\n                elements LIST\n            );\"#,\n        Ok(Payload::Create),\n    )\n    .await;\n\n    g.run(\n        r#\"\n            INSERT INTO Foo VALUES (APPEND(CAST('[1, 2, 3]' AS LIST), 4));\n        \"#,\n    )\n    .await;\n    g.test(\n        r#\"select elements as myappend from Foo;\"#,\n        Ok(select!(\n           myappend\n           List;\n           vec![I64(1), I64(2), I64(3), I64(4)]\n        )),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","ascii.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(ascii, {\n    let g = get_tester!();\n\n    g.test(\n        \"VALUES(ASCII('A'))\",\n        Ok(select!(\n            column1\n            U8;\n            65\n        )),\n    )\n    .await;\n    g.test(\n        \"VALUES(ASCII('AB'))\",\n        Err(EvaluateError::AsciiFunctionRequiresSingleCharacterValue.into()),\n    )\n    .await;\n    g.run(\n        \"\n        CREATE TABLE Ascii (\n            id INTEGER,\n            text TEXT\n        );\n    \",\n    )\n    .await;\n    g.run(\"INSERT INTO Ascii VALUES (1, 'F');\").await;\n    g.test(\n        r#\"select ascii(text) as ascii from Ascii;\"#,\n        Ok(select!(\n            ascii\n            U8;\n            70\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select ascii('a') as ascii from Ascii;\",\n        Ok(select!(\n           ascii\n           U8;\n           97\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select ascii('A') as ascii from Ascii;\",\n        Ok(select!(\n           ascii\n           U8;\n           65\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select ascii('ab') as ascii from Ascii;\",\n        Err(EvaluateError::AsciiFunctionRequiresSingleCharacterValue.into()),\n    )\n    .await;\n\n    g.test(\n        \"select ascii('AB') as ascii from Ascii;\",\n        Err(EvaluateError::AsciiFunctionRequiresSingleCharacterValue.into()),\n    )\n    .await;\n\n    g.test(\n        \"select ascii('') as ascii from Ascii;\",\n        Err(EvaluateError::AsciiFunctionRequiresSingleCharacterValue.into()),\n    )\n    .await;\n\n    g.test(\n        \"select ascii('ukjhg') as ascii from Ascii;\",\n        Err(EvaluateError::AsciiFunctionRequiresSingleCharacterValue.into()),\n    )\n    .await;\n\n    g.test(\n        r#\"select ascii(NULL) as ascii from Ascii;\"#,\n        Ok(select_with_null!(ascii; Null)),\n    )\n    .await;\n\n    g.test(\n        \"select ascii('') as ascii from Ascii;\",\n        Err(EvaluateError::NonAsciiCharacterNotAllowed.into()),\n    )\n    .await;\n\n    g.test(\n        r#\"select ascii() as ascii from Ascii;\"#,\n        Err(TranslateError::FunctionArgsLengthNotMatching {\n            name: \"ASCII\".to_owned(),\n            expected: 1,\n            found: 0,\n        }\n        .into()),\n    )\n    .await;\n\n    g.run(\"INSERT INTO Ascii VALUES (1, 'Foo');\").await;\n\n    g.test(\n        r#\"select ascii(text) as ascii from Ascii;\"#,\n        Err(EvaluateError::AsciiFunctionRequiresSingleCharacterValue.into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","cast.rs"],"content":"use {\n    crate::*,\n    chrono::{NaiveDate, NaiveTime},\n    gluesql_core::{\n        data::{Interval as I, value::ConvertError},\n        error::ValueError,\n        prelude::{\n            DataType, Payload,\n            Value::{self, *},\n        },\n        translate::TranslateError,\n    },\n    rust_decimal::Decimal,\n};\n\ntest_case!(cast_literal, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\"CREATE TABLE Item (number TEXT)\", Ok(Payload::Create)),\n        (\"INSERT INTO Item VALUES ('1')\", Ok(Payload::Insert(1))),\n        (\n            \"CREATE TABLE test (mytext Text, myint8 Int8, myint Int, myfloat Float, mydec Decimal, mybool Boolean, mydate Date)\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"CREATE TABLE utest (mytext Text, myuint8 UINT8, myint Int, myfloat Float, mydec Decimal, mybool Boolean, mydate Date)\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO utest VALUES ('foobar', 2, 2, 2.0, 2.0, true, '2001-09-11')\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"INSERT INTO test VALUES ('foobar', -2, 2, 2.0, 2.0, true, '2001-09-11')\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"SELECT CAST('TRUE' AS BOOLEAN) AS cast FROM Item\",\n            Ok(select!(cast Bool; true)),\n        ),\n        (\"SELECT 1::BOOLEAN AS cast\", Ok(select!(cast Bool; true))),\n        (\n            \"SELECT CAST(1 AS BOOLEAN) AS cast FROM Item\",\n            Ok(select!(cast Bool; true)),\n        ),\n        (\n            \"SELECT CAST('asdf' AS BOOLEAN) AS cast FROM Item\",\n            Err(ValueError::LiteralCastToBooleanFailed(\"asdf\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST(3 AS BOOLEAN) AS cast FROM Item\",\n            Err(ValueError::LiteralCastToBooleanFailed(\"3\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST(NULL AS BOOLEAN) AS cast FROM Item\",\n            Ok(select_with_null!(cast; Null)),\n        ),\n        (\n            \"SELECT CAST('1' AS INTEGER) AS cast FROM Item\",\n            Ok(select!(cast I64; 1)),\n        ),\n        (\n            \"SELECT CAST(SUBSTR('123', 2, 3) AS INTEGER) AS cast FROM Item\",\n            Ok(select!(cast I64; 23)),\n        ),\n        (\n            \"SELECT CAST('foo' AS INTEGER) AS cast FROM Item\",\n            Err(ValueError::LiteralCastFromTextToIntegerFailed(\"foo\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST(1.1 AS INTEGER) AS cast FROM Item\",\n            Err(ValueError::LiteralCastToDataTypeFailed(DataType::Int, \"1.1\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST(TRUE AS INTEGER) AS cast FROM Item\",\n            Ok(select!(cast I64; 1)),\n        ),\n        (\n            \"SELECT CAST(NULL AS INTEGER) AS cast FROM Item\",\n            Ok(select_with_null!(cast; Null)),\n        ),\n        (\n            \"SELECT CAST(255 AS INT8) AS cast FROM Item\",\n            Err(ValueError::LiteralCastToInt8Failed(\"255\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST('foo' AS UINT8) AS cast FROM Item\",\n            Err(ValueError::LiteralCastFromTextToUnsignedInt8Failed(\"foo\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST(-1 AS UINT8) AS cast FROM Item\",\n            Err(ValueError::LiteralCastToUnsignedInt8Failed(\"-1\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST('foo' AS UINT16) AS cast FROM Item\",\n            Err(ValueError::LiteralCastFromTextToUint16Failed(\"foo\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST(-1 AS UINT16) AS cast FROM Item\",\n            Err(ValueError::LiteralCastToUint16Failed(\"-1\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST('1.1' AS FLOAT) AS cast FROM Item\",\n            Ok(select!(cast F64; 1.1)),\n        ),\n        (\n            \"SELECT CAST(1 AS FLOAT) AS cast FROM Item\",\n            Ok(select!(cast F64; 1.0)),\n        ),\n        (\n            \"SELECT CAST('foo' AS FLOAT) AS cast FROM Item\",\n            Err(ValueError::LiteralCastFromTextToFloatFailed(\"foo\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST(TRUE AS FLOAT) AS cast FROM Item\",\n            Ok(select!(cast F64; 1.0)),\n        ),\n        (\n            \"SELECT CAST(NULL AS FLOAT) AS cast FROM Item\",\n            Ok(select_with_null!(cast; Null)),\n        ),\n        (\n            \"SELECT CAST(true AS Decimal) AS cast FROM Item\",\n            Ok(select!(cast Decimal; Decimal::new(1,0))),\n        ),\n        (\n            \"SELECT CAST(false AS Decimal) AS cast FROM Item\",\n            Ok(select!(cast Decimal; Decimal::new(0,0))),\n        ),\n        (\n            \"SELECT CAST(number AS Decimal) AS cast FROM Item\",\n            Ok(select!(cast Decimal; Decimal::new(1,0))),\n        ),\n        (\n            \"SELECT CAST('1.1' AS Decimal) AS cast FROM Item\",\n            Ok(select!(cast Decimal; Decimal::new(11,1))),\n        ),\n        (\n            \"SELECT CAST(1 AS Decimal) AS cast FROM Item\",\n            Ok(select!(cast Decimal; Decimal::new(10, 1))),\n        ),\n        (\n            \"SELECT CAST(-1 AS Decimal) AS cast FROM Item\",\n            Ok(select!(cast Decimal; Decimal::new(-10, 1))),\n        ),\n        (\n            \"SELECT CAST('foo' AS Decimal) AS cast FROM Item\",\n            Err(ValueError::LiteralCastFromTextToDecimalFailed(\"foo\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST(NULL AS Decimal) AS cast FROM Item\",\n            Ok(select_with_null!(cast; Null)),\n        ),\n        (\n            \"SELECT CAST(true AS Decimal) AS cast FROM Item\",\n            Ok(select!(cast Decimal; Decimal::new(1,0))),\n        ),\n        (\n            \"SELECT CAST(false AS Decimal) AS cast FROM Item\",\n            Ok(select!(cast Decimal; Decimal::new(0,0))),\n        ),\n        (\n            \"SELECT CAST(number AS Decimal) AS cast FROM Item\",\n            Ok(select!(cast Decimal; Decimal::new(1,0))),\n        ),\n        (\n            \"SELECT CAST('1.1' AS Decimal) AS cast FROM Item\",\n            Ok(select!(cast Decimal; Decimal::new(11,1))),\n        ),\n        (\n            \"SELECT CAST(1 AS Decimal) AS cast FROM Item\",\n            Ok(select!(cast Decimal; Decimal::new(10, 1))),\n        ),\n        (\n            \"SELECT CAST(-1 AS Decimal) AS cast FROM Item\",\n            Ok(select!(cast Decimal; Decimal::new(-10, 1))),\n        ),\n        (\n            \"SELECT CAST('foo' AS Decimal) AS cast FROM Item\",\n            Err(ValueError::LiteralCastFromTextToDecimalFailed(\"foo\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST(NULL AS Decimal) AS cast FROM Item\",\n            Ok(select_with_null!(cast; Null)),\n        ),\n        (\n            \"SELECT CAST(mytext AS Decimal) AS cast FROM test\",\n            Err(ConvertError {\n                value: Str(\"foobar\".to_owned()),\n                data_type: DataType::Decimal,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT CAST(myint8 AS Decimal) AS cast FROM test\",\n            Ok(select!(cast Decimal; Decimal::new(-2,0))),\n        ),\n        (\n            \"SELECT CAST(myuint8 AS Decimal) AS cast FROM utest\",\n            Ok(select!(cast Decimal; Decimal::new(2,0))),\n        ),\n        (\n            \"SELECT CAST(myint AS Decimal) AS cast FROM test\",\n            Ok(select!(cast Decimal; Decimal::new(2,0))),\n        ),\n        (\n            \"SELECT CAST(myfloat AS Decimal) AS cast FROM test\",\n            Ok(select!(cast Decimal; Decimal::new(2,0))),\n        ),\n        (\n            \"SELECT CAST(mydec AS Decimal) AS cast FROM test\",\n            Ok(select!(cast Decimal; Decimal::new(2,0))),\n        ),\n        (\n            \"SELECT CAST(mybool AS Decimal) AS cast FROM test\",\n            Ok(select!(cast Decimal; Decimal::new(1,0))),\n        ),\n        (\n            \"SELECT CAST(not(mybool) AS Decimal) AS cast FROM test\",\n            Ok(select!(cast Decimal; Decimal::new(0,0))),\n        ),\n        (\n            \"SELECT CAST(mydate AS Decimal) AS cast FROM test\",\n            Err(ConvertError {\n                value: Value::Date(NaiveDate::from_ymd_opt(2001, 9, 11).unwrap()),\n                data_type: DataType::Decimal,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT CAST(1 AS TEXT) AS cast FROM Item\",\n            Ok(select!(cast Str; \"1\".to_owned())),\n        ),\n        (\n            \"SELECT CAST(1.1 AS TEXT) AS cast FROM Item\",\n            Ok(select!(cast Str; \"1.1\".to_owned())),\n        ),\n        (\n            \"SELECT CAST(TRUE AS TEXT) AS cast FROM Item\",\n            Ok(select!(cast Str; \"TRUE\".to_owned())),\n        ),\n        (\n            \"SELECT CAST(NULL AS TEXT) AS cast FROM Item\",\n            Ok(select_with_null!(cast; Null)),\n        ),\n        (\n            \"SELECT CAST(NULL AS INTERVAL) FROM Item\",\n            Err(ValueError::UnimplementedLiteralCast {\n                data_type: gluesql_core::ast::DataType::Interval,\n                literal: format!(\"{:?}\", gluesql_core::data::Literal::Null),\n            }\n            .into()),\n        ),\n        (\n            \"SELECT\n            CAST('''1-2'' YEAR TO MONTH' as INTERVAL) as stoi_1,\n            CAST('''12'' DAY' as INTERVAL) as stoi_2,\n            CAST('''12'' MINUTE' as INTERVAL) as stoi_3,\n            CAST('''-3 14'' DAY TO HOUR' as INTERVAL) as stoi_4,\n            CAST('''3 14:00:00'' DAY TO SECOND' as INTERVAL) as stoi_5,\n            CAST('''12:00'' HOUR TO MINUTE' as INTERVAL) as stoi_6,\n            CAST('''-1000-11'' YEAR TO MONTH' as INTERVAL) as stoi_7,\n            CAST('''30'' MONTH' as INTERVAL) as stoi_8,\n            CAST('''35'' HOUR' as INTERVAL) as stoi_9,\n            CAST('''300'' SECOND' as INTERVAL) as stoi_10,\n            CAST('''3 12:30'' DAY TO MINUTE' as INTERVAL) as stoi_11,\n            CAST('''3 12:30:12.1324'' DAY TO SECOND' as INTERVAL) as stoi_12,\n            CAST('''-12:30:12'' HOUR TO SECOND' as INTERVAL) as stoi_13,\n            CAST('''-30:11'' MINUTE TO SECOND' as INTERVAL) as stoi_14\n            FROM Item\",\n            Ok(select!(\n            stoi_1|stoi_2|stoi_3|stoi_4|stoi_5|stoi_6|stoi_7|stoi_8|stoi_9|stoi_10|stoi_11|stoi_12|stoi_13|stoi_14\n            Interval|Interval|Interval|Interval|Interval|Interval|Interval|Interval|Interval|Interval|Interval|Interval|Interval|Interval;\n            I::months(14)\n            I::days(12)\n            I::minutes(12)\n            I::hours(-86)\n            I::minutes(86 * 60)\n            I::hours(12)\n            I::months(-12_011)\n            I::months(30)\n            I::hours(35)\n            I::minutes(5)\n            I::minutes(84 * 60 + 30)\n            I::microseconds((((84 * 60) + 30) * 60 + 12) * 1_000_000 + 132_400)\n            I::seconds(-(12 * 3600 + 30 * 60 + 12))\n            I::seconds(-(30 * 60 + 11))\n            )),\n        ),\n        (\n            \"SELECT CAST('2021-08-25' AS DATE) AS cast FROM Item\",\n            Ok(select_with_null!(cast; Value::Date(NaiveDate::from_ymd_opt(2021, 8, 25).unwrap()))),\n        ),\n        (\n            \"SELECT CAST('08-25-2021' AS DATE) AS cast FROM Item\",\n            Ok(select_with_null!(cast; Value::Date(NaiveDate::from_ymd_opt(2021, 8, 25).unwrap()))),\n        ),\n        (\n            \"SELECT CAST('2021-08-025' AS DATE) FROM Item\",\n            Err(ValueError::LiteralCastToDateFailed(\"2021-08-025\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST('AM 8:05' AS TIME) AS cast FROM Item\",\n            Ok(select_with_null!(cast; Value::Time(NaiveTime::from_hms_opt(8, 5, 0).unwrap()))),\n        ),\n        (\n            \"SELECT CAST('AM 08:05' AS TIME) AS cast FROM Item\",\n            Ok(select_with_null!(cast; Value::Time(NaiveTime::from_hms_opt(8, 5, 0).unwrap()))),\n        ),\n        (\n            \"SELECT CAST('AM 8:05:30' AS TIME) AS cast FROM Item\",\n            Ok(select_with_null!(cast; Value::Time(NaiveTime::from_hms_opt(8, 5, 30).unwrap()))),\n        ),\n        (\n            \"SELECT CAST('AM 8:05:30.9' AS TIME) AS cast FROM Item\",\n            Ok(\n                select_with_null!(cast; Value::Time(NaiveTime::from_hms_milli_opt(8, 5, 30, 900).unwrap())),\n            ),\n        ),\n        (\n            \"SELECT CAST('8:05:30.9 AM' AS TIME) AS cast FROM Item\",\n            Ok(\n                select_with_null!(cast; Value::Time(NaiveTime::from_hms_milli_opt(8, 5, 30, 900).unwrap())),\n            ),\n        ),\n        (\n            \"SELECT CAST('25:08:05' AS TIME) AS cast FROM Item\",\n            Err(ValueError::LiteralCastToTimeFailed(\"25:08:05\".to_owned()).into()),\n        ),\n        (\n            \"SELECT CAST('2021-08-25 08:05:30' AS TIMESTAMP) AS cast FROM Item\",\n            Ok(\n                select_with_null!(cast; Value::Timestamp(NaiveDate::from_ymd_opt(2021, 8, 25).unwrap().and_hms_opt(8, 5, 30).unwrap())),\n            ),\n        ),\n        (\n            \"SELECT CAST('2021-08-25 08:05:30.9' AS TIMESTAMP) AS cast FROM Item\",\n            Ok(\n                select_with_null!(cast; Value::Timestamp(NaiveDate::from_ymd_opt(2021, 8, 25).unwrap().and_hms_milli_opt(8, 5, 30, 900).unwrap())),\n            ),\n        ),\n        (\n            \"SELECT CAST('2021-13-25 08:05:30' AS TIMESTAMP) AS cast FROM Item\",\n            Err(ValueError::LiteralCastToTimestampFailed(\"2021-13-25 08:05:30\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(cast_value, {\n    let g = get_tester!();\n\n    // More test cases are in `gluesql::Value` unit tests.\n\n    let test_cases = [\n        (\n            \"\n            CREATE TABLE Item (\n                id INTEGER NULL,\n                flag BOOLEAN,\n                ratio FLOAT NULL,\n                number TEXT\n            )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO Item VALUES (0, TRUE, NULL, '1')\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"SELECT CAST(LOWER(number) AS INTEGER) AS cast FROM Item\",\n            Ok(select!(cast I64; 1)),\n        ),\n        (\n            \"SELECT CAST(id AS BOOLEAN) AS cast FROM Item\",\n            Ok(select!(cast Bool; false)),\n        ),\n        (\n            \"SELECT CAST(flag AS TEXT) AS cast FROM Item\",\n            Ok(select!(cast Str; \"TRUE\".to_owned())),\n        ),\n        (\n            \"SELECT CAST(ratio AS INTEGER) AS cast FROM Item\",\n            Ok(select_with_null!(cast; Null)),\n        ),\n        (\n            \"SELECT CAST(number AS BOOLEAN) FROM Item\",\n            Err(ConvertError {\n                value: Str(\"1\".to_owned()),\n                data_type: DataType::Boolean,\n            }\n            .into()),\n        ),\n        (\n            \"\n        CREATE TABLE IntervalLog (\n        id INTEGER,\n        interval_str_1 TEXT,\n        interval_str_2 TEXT\n    )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"\n        INSERT INTO IntervalLog VALUES\n        (1, '''1-2'' YEAR TO MONTH',         '''30'' MONTH'),\n        (2, '''12'' DAY',                    '''35'' HOUR'),\n        (3, '''12'' MINUTE',                 '''300'' SECOND'),\n        (4, '''-3 14'' DAY TO HOUR',         '''3 12:30'' DAY TO MINUTE'),\n        (5, '''3 14:00:00'' DAY TO SECOND',  '''3 12:30:12.1324'' DAY TO SECOND'),\n        (6, '''12:00'' HOUR TO MINUTE',      '''-12:30:12'' HOUR TO SECOND'),\n        (7, '''-1000-11'' YEAR TO MONTH',    '''-30:11'' MINUTE TO SECOND');\n    \",\n            Ok(Payload::Insert(7)),\n        ),\n        (\n            \"SELECT id, CAST(interval_str_1 as INTERVAL) as stoi_1, CAST(interval_str_2 as INTERVAL) as stoi_2 FROM IntervalLog;\",\n            Ok(select!(\n            id  | stoi_1              | stoi_2\n            I64 | Interval            | Interval;\n            1     I::months(14)         I::months(30);\n            2     I::days(12)           I::hours(35);\n            3     I::minutes(12)        I::minutes(5);\n            4     I::hours(-86)         I::minutes(84 * 60 + 30);\n            5     I::minutes(86 * 60)   I::microseconds((((84 * 60) + 30) * 60 + 12) * 1_000_000 + 132_400);\n            6     I::hours(12)          I::seconds(-(12 * 3600 + 30 * 60 + 12));\n            7     I::months(-12_011)    I::seconds(-(30 * 60 + 11))\n            )),\n        ),\n        (\n            \"SELECT CAST(1 AS STRING FORMAT 'ASCII') AS bytes_to_string;\",\n            Err(TranslateError::UnsupportedCastFormat(\"'ASCII'\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","ceil.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(ceil, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT\n                CEIL(0.3) AS ceil1, \n                CEIL(-0.8) AS ceil2, \n                CEIL(10) AS ceil3, \n                CEIL(6.87421) AS ceil4\n            ;\",\n            Ok(select!(\n                \"ceil1\" | \"ceil2\" | \"ceil3\" | \"ceil4\";\n                F64     | F64     | F64     | F64;\n                1.0       0.0       10.0      7.0\n            )),\n        ),\n        (\n            \"SELECT CEIL('string') AS ceil;\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"CEIL\")).into()),\n        ),\n        (\n            \"SELECT CEIL(NULL) AS ceil;\",\n            Ok(select_with_null!(ceil; Null)),\n        ),\n        (\n            \"SELECT CEIL(TRUE) AS ceil;\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"CEIL\")).into()),\n        ),\n        (\n            \"SELECT CEIL(FALSE) AS ceil;\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"CEIL\")).into()),\n        ),\n        (\n            \"SELECT CEIL('string' TO DAY) AS ceil;\",\n            Err(TranslateError::UnsupportedExpr(\"CEIL('string' TO DAY)\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","chr.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::EvaluateError, prelude::Value::*},\n};\n\ntest_case!(chr, {\n    let g = get_tester!();\n\n    g.test(\n        \"VALUES(CHR(70))\",\n        Ok(select!(\n            column1\n            Str;\n            \"F\".to_owned()\n        )),\n    )\n    .await;\n    g.test(\n        \"VALUES(CHR(7070))\",\n        Err(EvaluateError::ChrFunctionRequiresIntegerValueInRange0To255.into()),\n    )\n    .await;\n    g.run(\n        \"\n        CREATE TABLE Chr (\n            id INTEGER,\n            num INTEGER\n        );\n    \",\n    )\n    .await;\n    g.run(\"INSERT INTO Chr VALUES (1, 70);\").await;\n\n    g.test(\n        \"select chr(num) as chr from Chr;\",\n        Ok(select!(\n            chr\n            Str;\n            \"F\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select chr(65) as chr from Chr;\",\n        Ok(select!(\n           chr\n           Str;\n           \"A\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select chr(532) as chr from Chr;\",\n        Err(EvaluateError::ChrFunctionRequiresIntegerValueInRange0To255.into()),\n    )\n    .await;\n    g.test(\n        \"select chr('ukjhg') as chr from Chr;\",\n        Err(EvaluateError::FunctionRequiresIntegerValue(\"CHR\".to_owned()).into()),\n    )\n    .await;\n\n    g.run(\"INSERT INTO Chr VALUES (1, 4345);\").await;\n\n    g.test(\n        \"select chr(num) as chr from Chr;\",\n        Err(EvaluateError::ChrFunctionRequiresIntegerValueInRange0To255.into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","coalesce.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::EvaluateError, prelude::Value::*},\n};\n\ntest_case!(coalesce, {\n    let g = get_tester!();\n\n    g.test(\n        // COALESCE does not allow no arguments\n        \"SELECT COALESCE() AS coalesce\",\n        Err(EvaluateError::FunctionRequiresMoreArguments {\n            function_name: \"COALESCE\".to_owned(),\n            required_minimum: 1,\n            found: 0,\n        }\n        .into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT COALESCE(NULL) AS coalesce\",\n        Ok(select_with_null!(\n            coalesce;\n            Null\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT COALESCE(NULL, 42) AS coalesce\",\n        Ok(select!(\n            coalesce\n            I64;\n            42\n        )),\n    )\n    .await;\n\n    g.test(\n        // Test subqueries in COALESCE\n        \"SELECT COALESCE((SELECT NULL), (SELECT 42)) as coalesce\",\n        Ok(select!(\n            coalesce\n            I64;\n            42\n        )),\n    )\n    .await;\n\n    g.test(\n        // Test nested COALESCE\n        \"SELECT COALESCE(\n            COALESCE(NULL),\n            COALESCE(NULL, 'Answer to the Ultimate Question of Life')\n        ) as coalesce\",\n        Ok(select!(\n            coalesce\n            Str;\n            \"Answer to the Ultimate Question of Life\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        // Test COALESCE with non-NULL value as first argument\n        \"SELECT COALESCE('Hitchhiker', NULL) AS coalesce\",\n        Ok(select!(\n            coalesce\n            Str;\n            \"Hitchhiker\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        // Test COALESCE with all NULL arguments\n        \"SELECT COALESCE(NULL, NULL, NULL) AS coalesce\",\n        Ok(select_with_null!(\n            coalesce;\n            Null\n        )),\n    )\n    .await;\n\n    g.test(\n        // Test COALESCE with integer arguments\n        \"SELECT COALESCE(NULL, 42, 84) AS coalesce\",\n        Ok(select!(\n            coalesce\n            I64;\n            42\n        )),\n    )\n    .await;\n\n    g.test(\n        // Test COALESCE with float arguments\n        \"SELECT COALESCE(NULL, 1.23, 4.56) AS coalesce\",\n        Ok(select!(\n            coalesce\n            F64;\n            1.23\n        )),\n    )\n    .await;\n\n    g.test(\n        // Test COALESCE with boolean arguments\n        \"SELECT COALESCE(NULL, TRUE, FALSE) AS coalesce\",\n        Ok(select!(\n            coalesce\n            Bool;\n            true\n        )),\n    )\n    .await;\n\n    g.test(\n        // Test invalid expression in COALESCE\n        \"SELECT COALESCE(NULL, COALESCE());\",\n        Err(EvaluateError::FunctionRequiresMoreArguments {\n            function_name: \"COALESCE\".to_owned(),\n            required_minimum: 1,\n            found: 0,\n        }\n        .into()),\n    )\n    .await;\n\n    g.run(\n        \"\n        CREATE TABLE TestCoalesce (\n            id INTEGER,\n            text_value TEXT NULL,\n            integer_value INTEGER NULL,\n            float_value FLOAT NULL,\n            boolean_value BOOLEAN NULL\n        );\",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO TestCoalesce (id, text_value, integer_value, float_value, boolean_value) VALUES \n            (1, 'Hitchhiker', NULL, NULL, NULL),\n            (2, NULL, 42, NULL, NULL),\n            (3, NULL, NULL, 1.11, NULL),\n            (4, NULL, NULL, NULL, TRUE),\n            (5, 'Universe', 84, 2.22, FALSE);\n        \",\n    )\n    .await;\n\n    g.test(\n        // Test COALESCE with table column values and different types of default values\n        \"SELECT\n            id,\n            COALESCE(text_value, 'Default') AS coalesce_text,\n            COALESCE(integer_value, 0) AS coalesce_integer,\n            COALESCE(float_value, 0.1) AS coalesce_float,\n            COALESCE(boolean_value, FALSE) AS coalesce_boolean\n        FROM TestCoalesce\n        ORDER BY id ASC\",\n        Ok(select!(\n            id  | coalesce_text                | coalesce_integer | coalesce_float | coalesce_boolean\n            I64 | Str                          | I64              | F64            | Bool;\n            1     \"Hitchhiker\".to_owned()        0                  0.1              false;\n            2     \"Default\".to_owned()           42                 0.1              false;\n            3     \"Default\".to_owned()           0                  1.11             false;\n            4     \"Default\".to_owned()           0                  0.1              true;\n            5     \"Universe\".to_owned()          84                 2.22             false\n        ))\n    ).await;\n\n    g.test(\n        // Test COALESCE with table column values - multiple columns\n        \"SELECT id, COALESCE(text_value, integer_value, float_value, boolean_value) AS coalesce FROM TestCoalesce ORDER BY id ASC\",\n        Ok(select_with_null!(\n            id     | coalesce;\n            I64(1)   Str(\"Hitchhiker\".to_owned());\n            I64(2)   I64(42);\n            I64(3)   F64(1.11);\n            I64(4)   Bool(true);\n            I64(5)   Str(\"Universe\".to_owned())\n        ))\n    ).await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","concat.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, ValueError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(concat, {\n    let g = get_tester!();\n\n    g.test(\n        \"select concat('ab', 'cd') as myc;\",\n        Ok(select!(\n           myc\n           Str;\n           \"abcd\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select concat('ab', 'cd', 'ef') as myconcat;\",\n        Ok(select!(\n           myconcat\n           Str;\n           \"abcdef\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select concat('ab', 'cd', NULL, 'ef') as myconcat;\",\n        Ok(select_with_null!(myconcat; Null)),\n    )\n    .await;\n\n    g.test(\n        \"select concat(DATE '2020-06-11', DATE '2020-16-3') as myconcat;\",\n        Err(ValueError::FailedToParseDate(\"2020-16-3\".to_owned()).into()),\n    )\n    .await;\n\n    // test with non string arguments\n    g.test(\n        \"select concat(123, 456, 3.14) as myconcat;\",\n        Ok(select!(\n           myconcat\n           Str;\n           \"1234563.14\".to_owned()\n        )),\n    )\n    .await;\n    // test with zero arguments\n    g.test(\n        r#\"select concat() as myconcat;\"#,\n        Err(EvaluateError::EmptyArgNotAllowedInConcat.into()),\n    )\n    .await;\n\n    g.test(\n        r#\"SELECT CONCAT(\n            CAST('[1, 2, 3]' AS LIST),\n            CAST('[\"one\", \"two\", \"three\"]' AS LIST)\n        ) AS myconcat;\"#,\n        Ok(select!(\n           myconcat\n           List;\n           vec![I64(1), I64(2), I64(3), Str(\"one\".to_owned()), Str(\"two\".to_owned()), Str(\"three\".to_owned())]\n        ))\n    ).await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","concat_ws.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::TranslateError, prelude::Value::*},\n};\n\ntest_case!(concat_ws, {\n    let g = get_tester!();\n\n    g.test(\n        \"VALUES(CONCAT_WS(',', 'AB', 'CD', 'EF'))\",\n        Ok(select!(\n            column1\n            Str;\n            \"AB,CD,EF\".to_owned()\n        )),\n    )\n    .await;\n\n    g.run(\n        \"\n        CREATE TABLE Concat (\n            id INTEGER,\n            flag BOOLEAN,\n            text TEXT,\n            null_value TEXT NULL\n        );\n    \",\n    )\n    .await;\n    g.run(\"INSERT INTO Concat VALUES (1, TRUE, 'Foo', NULL);\")\n        .await;\n\n    g.test(\n        \"select concat_ws('/', id, flag, null_value, text) as myc from Concat;\",\n        Ok(select!(\n           myc\n           Str;\n           \"1/TRUE/Foo\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select concat_ws('', 'ab', 'cd') as myc from Concat;\",\n        Ok(select!(\n           myc\n           Str;\n           \"abcd\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select concat_ws('', 'ab', 'cd', 'ef') as myconcat from Concat;\",\n        Ok(select!(\n           myconcat\n           Str;\n           \"abcdef\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select concat_ws(',', 'ab', 'cd', 'ef') as myconcat from Concat;\",\n        Ok(select!(\n           myconcat\n           Str;\n           \"ab,cd,ef\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select concat_ws('/', 'ab', 'cd', 'ef') as myconcat from Concat;\",\n        Ok(select!(\n           myconcat\n           Str;\n           \"ab/cd/ef\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select concat_ws('', 'ab', 'cd', NULL, 'ef') as myconcat from Concat;\",\n        Ok(select!(\n           myconcat\n           Str;\n           \"abcdef\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select concat_ws('', 123, 456, 3.14) as myconcat from Concat;\",\n        Ok(select!(\n           myconcat\n           Str;\n           \"1234563.14\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"select concat_ws() as myconcat from Concat;\",\n        Err(TranslateError::FunctionArgsLengthNotMatchingMin {\n            name: \"CONCAT_WS\".to_owned(),\n            expected_minimum: 2,\n            found: 0,\n        }\n        .into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","current_date.rs"],"content":"use {\n    crate::*,\n    gluesql_core::prelude::{Payload, Value::*},\n};\n\ntest_case!(current_date, {\n    let g = get_tester!();\n\n    macro_rules! date {\n        ($date: expr) =\u003e {\n            $date.parse().unwrap()\n        };\n    }\n\n    g.named_test(\n        \"table with CURRENT_DATE default\",\n        \"CREATE TABLE Item (date DATE DEFAULT CURRENT_DATE)\",\n        Ok(Payload::Create),\n    )\n    .await;\n\n    g.named_test(\n        \"insert date values\",\n        \"INSERT INTO Item VALUES\n            ('2021-06-15'),\n            ('9999-12-31');\",\n        Ok(Payload::Insert(2)),\n    )\n    .await;\n\n    g.named_test(\n        \"filter by CURRENT_DATE\",\n        \"SELECT date FROM Item WHERE date \u003e CURRENT_DATE;\",\n        Ok(select!(\"date\" Date; date!(\"9999-12-31\"))),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","current_time.rs"],"content":"use {\n    crate::*,\n    gluesql_core::prelude::{Payload, Value::*},\n};\n\ntest_case!(current_time, {\n    let g = get_tester!();\n\n    g.named_test(\n        \"table with CURRENT_TIME default\",\n        \"CREATE TABLE Item (time TIME DEFAULT CURRENT_TIME)\",\n        Ok(Payload::Create),\n    )\n    .await;\n\n    g.named_test(\n        \"insert time values\",\n        \"INSERT INTO Item VALUES\n            ('06:42:40'),\n            ('23:59:59');\",\n        Ok(Payload::Insert(2)),\n    )\n    .await;\n\n    g.named_test(\n        \"CURRENT_TIME is not null\",\n        \"SELECT CURRENT_TIME IS NOT NULL as is_not_null\",\n        Ok(select!(\"is_not_null\" Bool; true)),\n    )\n    .await;\n\n    g.named_test(\n        \"CURRENT_TIME in valid range\",\n        \"SELECT CURRENT_TIME \u003e= TIME '00:00:00' AND CURRENT_TIME \u003c= TIME '23:59:59' as is_valid_range\",\n        Ok(select!(\"is_valid_range\" Bool; true)),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","current_timestamp.rs"],"content":"use {\n    crate::*,\n    gluesql_core::prelude::{Payload, Value::*},\n};\n\ntest_case!(current_timestamp, {\n    let g = get_tester!();\n\n    macro_rules! t {\n        ($timestamp: expr) =\u003e {\n            $timestamp.parse().unwrap()\n        };\n    }\n\n    g.named_test(\n        \"table with CURRENT_TIMESTAMP default\",\n        \"CREATE TABLE Item (timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP)\",\n        Ok(Payload::Create),\n    )\n    .await;\n\n    g.named_test(\n        \"insert timestamp values\",\n        \"INSERT INTO Item VALUES\n            ('2021-10-13T06:42:40.364832862'),\n            ('9999-12-31T23:59:40.364832862');\",\n        Ok(Payload::Insert(2)),\n    )\n    .await;\n\n    g.named_test(\n        \"filter by CURRENT_TIMESTAMP\",\n        \"SELECT timestamp FROM Item WHERE timestamp \u003e CURRENT_TIMESTAMP;\",\n        Ok(select!(\"timestamp\" Timestamp; t!(\"9999-12-31T23:59:40.364832862\"))),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","dedup.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{executor::EvaluateError, prelude::Value::*},\n};\n\ntest_case!(dedup, {\n    let g = get_tester!();\n\n    g.named_test(\n        \"DEDUP(CAST('[1, 2, 3, 3, 4, 5, 5]' AS List)) should return '[1, 2, 3, 4, 5]'\",\n        \"SELECT DEDUP(CAST('[1, 2, 3, 3, 4, 5, 5]' AS List)) as actual\",\n        Ok(select!(actual List; vec![I64(1), I64(2), I64(3), I64(4), I64(5)])),\n    )\n    .await;\n\n    g.named_test(\n        \"DEDUP(CAST('['1', 1, '1']' AS List)) should return '['1', 1]'\",\n        r#\"SELECT DEDUP(CAST('[\"1\", 1, 1, \"1\", \"1\"]' AS List)) as actual\"#,\n        Ok(select!(actual List; vec![Str(\"1\".to_owned()), I64(1), Str(\"1\".to_owned())])),\n    )\n    .await;\n\n    g.named_test(\n        \"DEDUP with invalid value should return EvaluateError::ListTypeRequired\",\n        \"SELECT DEDUP(1) AS actual\",\n        Err(EvaluateError::ListTypeRequired.into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","degrees.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(degrees, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT\n                DEGREES(PI() / 2) as degrees_1,\n                DEGREES(PI()) as degrees_2\n            ;\",\n            Ok(select!(\n                degrees_1 | degrees_2;\n                F64       | F64;\n                90.0        180.0\n            )),\n        ),\n        (\n            \"SELECT DEGREES(PI() / 2) as degrees_with_int;\",\n            Ok(select!(\n                degrees_with_int\n                F64;\n                90.0\n            )),\n        ),\n        (\n            \"SELECT DEGREES(0) as degrees_with_zero;\",\n            Ok(select!(\n                degrees_with_zero\n                F64;\n                0.0\n            )),\n        ),\n        (\n            \"SELECT DEGREES(RADIANS(90)) as radians_to_degrees;\",\n            Ok(select!(\n                radians_to_degrees\n                F64;\n                90.0\n            )),\n        ),\n        (\n            \"SELECT DEGREES(0, 0) as degrees_arg2;\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"DEGREES\".to_owned(),\n                expected: 1,\n                found: 2,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT DEGREES() as degrees_arg0;\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"DEGREES\".to_owned(),\n                expected: 1,\n                found: 0,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT DEGREES('string') AS degrees;\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"DEGREES\")).into()),\n        ),\n        (\n            \"SELECT DEGREES(NULL) AS degrees;\",\n            Ok(select_with_null!(degrees; Null)),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","div_mod.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(div_mod, {\n    let g = get_tester!();\n\n    let eval_div = |dividend, divisor| (dividend / divisor) as i64;\n    let eval_mod = |dividend, divisor| dividend % divisor;\n    let test_cases = [\n        (\n            \"CREATE TABLE FloatDiv (\n                dividend FLOAT DEFAULT MOD(30, 11),\n                divisor FLOAT DEFAULT DIV(3, 2)\n            )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"\n            INSERT INTO \n                FloatDiv (dividend, divisor) \n            VALUES \n                (12.5, 2.5), (12.34, 56.78), (-12.3, 4.0)\n            \",\n            Ok(Payload::Insert(3)),\n        ),\n        (\n            \"\n            SELECT \n                DIV(dividend, divisor),\n                MOD(dividend, divisor) \n            FROM FloatDiv\n            \",\n            Ok(select!(\n                \"DIV(dividend, divisor)\" | \"MOD(dividend, divisor)\"\n                I64                      | F64;\n                eval_div(12.5, 2.5)        eval_mod(12.5, 2.5);\n                eval_div(12.34, 56.78)     eval_mod(12.34, 56.78);\n                eval_div(-12.3, 4.0)       eval_mod(-12.3, 4.0)\n            )),\n        ),\n        (\n            \"SELECT DIV(1.0, 0.0) AS quotient FROM FloatDiv\",\n            Err(EvaluateError::DivisorShouldNotBeZero.into()),\n        ),\n        (\n            \"SELECT DIV(1.0, 'dividend') AS quotient FROM FloatDiv\",\n            Err(EvaluateError::FunctionRequiresFloatOrIntegerValue(\"DIV\".to_owned()).into()),\n        ),\n        (\n            \"SELECT DIV(1.0) AS quotient FROM FloatDiv\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"DIV\".to_owned(),\n                expected: 2,\n                found: 1,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT MOD(1.0, 2, 3) AS remainder FROM FloatDiv\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"MOD\".to_owned(),\n                expected: 2,\n                found: 3,\n            }\n            .into()),\n        ),\n        (\n            \"CREATE TABLE IntDiv (dividend INTEGER, divisor INTEGER)\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"\n            INSERT INTO \n                IntDiv (dividend, divisor) \n            VALUES \n                (12, 3), (12, 7), (12, 34), (-12, 7)\n            \",\n            Ok(Payload::Insert(4)),\n        ),\n        (\n            \"INSERT INTO IntDiv (dividend, divisor) VALUES (12, 2)\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"\n            SELECT \n                DIV(dividend, divisor),\n                MOD(dividend, divisor) \n            FROM IntDiv \n            \",\n            Ok(select!(\n                \"DIV(dividend, divisor)\" | \"MOD(dividend, divisor)\"\n                I64                      | I64;\n                eval_div(12_f64, 3_f64)    0;\n                eval_div(12_f64, 7_f64)    5;\n                eval_div(12_f64, 34_f64)   12;\n                eval_div(-12_f64, 7_f64)   i64::from(-5);\n                eval_div(12_f64, 2_f64)    0\n            )),\n        ),\n        (\n            \"SELECT DIV(1, 0) AS quotient FROM IntDiv\",\n            Err(EvaluateError::DivisorShouldNotBeZero.into()),\n        ),\n        (\n            \"CREATE TABLE MixDiv (dividend INTEGER NULL, divisor FLOAT NULL)\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"\n            INSERT INTO \n                MixDiv (dividend, divisor) \n            VALUES \n                (12, 3.0), (12, 34.0),\n                (12, NULL), (NULL, 34.0), (NULL, NULL)\n            \",\n            Ok(Payload::Insert(5)),\n        ),\n        (\n            \"\n            SELECT \n                DIV(dividend, divisor),\n                MOD(dividend, divisor) \n            FROM MixDiv \n            \",\n            Ok(select_with_null!(\n                \"DIV(dividend, divisor)\"    | \"MOD(dividend, divisor)\";\n                I64(eval_div(12_f64, 3.0))    I64(0);\n                I64(eval_div(12_f64, 34.0))   I64(12);\n                Null                          Null;\n                Null                          Null;\n                Null                          Null\n            )),\n        ),\n    ];\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","entries.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::EvaluateError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(entries, {\n    let g = get_tester!();\n\n    g.named_test(\n        \"test entries function works while creating a table simultaneously\",\n        \"CREATE TABLE Item (map MAP)\",\n        Ok(Payload::Create),\n    )\n    .await;\n    g.named_test(\n        \"test if the sample string gets inserted to table\",\n        r#\"INSERT INTO Item VALUES ('{\"name\":\"GlueSQL\"}')\"#,\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n    g.named_test(\n        \"check id the entries function works with the previously inserted string\",\n        \"SELECT ENTRIES(map) AS test FROM Item\",\n        Ok(select!(\n            \"test\";\n            List;\n            vec![\n                List(vec![Str(\"name\".to_owned()), Str(\"GlueSQL\".to_owned())])\n            ]\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test ENTRIES function requires map value\",\n        \"SELECT ENTRIES(1) FROM Item\",\n        Err(EvaluateError::FunctionRequiresMapValue(\"ENTRIES\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","exp_log.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::EvaluateError, prelude::Value::*},\n};\n\ntest_case!(log2, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT\n                LOG2(64.0) as log2_1,\n                LOG2(0.04) as log2_2\n            ;\",\n            Ok(select!(\n                log2_1          | log2_2;\n                F64             | F64;\n                64.0_f64.log2()   0.04_f64.log2()\n            )),\n        ),\n        (\n            \"SELECT LOG2(32) as log2_with_int;\",\n            Ok(select!(\n                log2_with_int\n                F64;\n                f64::from(32).log2()\n            )),\n        ),\n        (\n            \"SELECT LOG2('string') AS log2;\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"LOG2\")).into()),\n        ),\n        (\n            \"SELECT LOG2(NULL) AS log2\",\n            Ok(select_with_null!(log2; Null)),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(log10, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT\n                LOG10(64.0) as log10_1,\n                LOG10(0.04) as log10_2\n            ;\",\n            Ok(select!(\n                log10_1           | log10_2;\n                F64               | F64;\n                64.0_f64.log10()    0.04_f64.log10()\n            )),\n        ),\n        (\n            \"SELECT LOG10(10) as log10_with_int\",\n            Ok(select!(\n                log10_with_int\n                F64;\n                f64::from(10).log10()\n            )),\n        ),\n        (\n            \"SELECT LOG10('string') AS log10\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"LOG10\")).into()),\n        ),\n        (\n            \"SELECT LOG10(NULL) AS log10\",\n            Ok(select_with_null!(log10; Null)),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(ln, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT\n                LN(64.0) as ln1,\n                LN(0.04) as ln2\n            ;\",\n            Ok(select!(\n                ln1             | ln2;\n                F64             | F64;\n                64.0_f64.ln()     0.04_f64.ln()\n            )),\n        ),\n        (\n            \"SELECT LN(10) as ln_with_int\",\n            Ok(select!(\n                ln_with_int\n                F64;\n                f64::from(10).ln()\n            )),\n        ),\n        (\n            \"SELECT LN('string') AS log10\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"LN\")).into()),\n        ),\n        (\"SELECT LN(NULL) AS ln\", Ok(select_with_null!(ln; Null))),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(log, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT\n                LOG(64.0, 2.0) as log_1,\n                LOG(0.04, 10.0) as log_2\n            ;\",\n            Ok(select!(\n                log_1               | log_2;\n                F64                 | F64;\n                64.0_f64.log(2.0)     0.04_f64.log(10.0)\n            )),\n        ),\n        (\n            \"SELECT LOG(10, 10) as log_with_int\",\n            Ok(select!(\n                log_with_int\n                F64;\n                f64::from(10).log(10.0)\n            )),\n        ),\n        (\n            \"SELECT LOG('string', 10) AS log\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"LOG\")).into()),\n        ),\n        (\n            \"SELECT LOG(10, 'string') AS log\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"LOG\")).into()),\n        ),\n        (\n            \"SELECT LOG(NULL, 10) AS log\",\n            Ok(select_with_null!(log; Null)),\n        ),\n        (\n            \"SELECT LOG(10, NULL) AS log\",\n            Ok(select_with_null!(log; Null)),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(exp, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT\n                EXP(2.0) as exp1,\n                EXP(5.5) as exp2\n            ;\",\n            Ok(select!(\n                exp1            | exp2;\n                F64             | F64;\n                2.0_f64.exp()     5.5_f64.exp()\n            )),\n        ),\n        (\n            \"SELECT EXP(3) as exp_with_int;\",\n            Ok(select!(\n                exp_with_int\n                F64;\n                f64::from(3).exp()\n            )),\n        ),\n        (\n            \"SELECT EXP('string') AS exp;\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"EXP\")).into()),\n        ),\n        (\"SELECT EXP(NULL) AS exp\", Ok(select_with_null!(exp; Null))),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","extract.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast::DateTimeField,\n        data::value::Value::{self, *},\n        error::{IntervalError, TranslateError, ValueError},\n        prelude::Payload,\n    },\n};\n\ntest_case!(extract, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            r#\"SELECT EXTRACT(HOUR FROM TIMESTAMP '2016-12-31 13:30:15') as extract\"#,\n            Ok(select!(\"extract\" I64; 13)),\n        ),\n        (\n            r#\"SELECT EXTRACT(YEAR FROM TIMESTAMP '2016-12-31 13:30:15') as extract\"#,\n            Ok(select!(\"extract\" I64; 2016)),\n        ),\n        (\n            r#\"SELECT EXTRACT(MONTH FROM TIMESTAMP '2016-12-31 13:30:15') as extract\"#,\n            Ok(select!(\"extract\" I64; 12)),\n        ),\n        (\n            r#\"SELECT EXTRACT(DAY FROM TIMESTAMP '2016-12-31 13:30:15') as extract\"#,\n            Ok(select!(\"extract\" I64; 31)),\n        ),\n        (\n            r#\"SELECT EXTRACT(MINUTE FROM TIMESTAMP '2016-12-31 13:30:15') as extract\"#,\n            Ok(select!(\"extract\" I64; 30)),\n        ),\n        (\n            r#\"SELECT EXTRACT(SECOND FROM TIMESTAMP '2016-12-31 13:30:15') as extract\"#,\n            Ok(select!(\"extract\" I64; 15)),\n        ),\n        (\n            r#\"SELECT EXTRACT(SECOND FROM TIME '17:12:28') as extract\"#,\n            Ok(select!(\"extract\" I64; 28)),\n        ),\n        (\n            r#\"SELECT EXTRACT(DAY FROM DATE '2021-10-06') as extract\"#,\n            Ok(select!(\"extract\" I64; 6)),\n        ),\n        (\n            \"SELECT EXTRACT(YEAR FROM INTERVAL '3' YEAR) as extract\",\n            Ok(select!(\"extract\" I64; 3)),\n        ),\n        (\n            \"SELECT EXTRACT(MONTH FROM INTERVAL '4' MONTH) as extract\",\n            Ok(select!(\"extract\" I64; 4)),\n        ),\n        (\n            \"SELECT EXTRACT(DAY FROM INTERVAL '5' DAY) as extract\",\n            Ok(select!(\"extract\" I64; 5)),\n        ),\n        (\n            \"SELECT EXTRACT(HOUR FROM INTERVAL '6' HOUR) as extract\",\n            Ok(select!(\"extract\" I64; 6)),\n        ),\n        (\n            \"SELECT EXTRACT(MINUTE FROM INTERVAL '7' MINUTE) as extract\",\n            Ok(select!(\"extract\" I64; 7)),\n        ),\n        (\n            \"SELECT EXTRACT(SECOND FROM INTERVAL '8' SECOND) as extract\",\n            Ok(select!(\"extract\" I64; 8)),\n        ),\n        (\"CREATE TABLE Item (number TEXT)\", Ok(Payload::Create)),\n        (\"INSERT INTO Item VALUES ('1')\", Ok(Payload::Insert(1))),\n        (\n            r#\"SELECT EXTRACT(HOUR FROM number) as extract FROM Item\"#,\n            Err(ValueError::ExtractFormatNotMatched {\n                value: Value::Str(\"1\".to_owned()),\n                field: DateTimeField::Hour,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT EXTRACT(HOUR FROM INTERVAL '7' YEAR) as extract\",\n            Err(IntervalError::FailedToExtract.into()),\n        ),\n        (\n            r#\"SELECT EXTRACT(HOUR FROM 100)\"#,\n            Err(ValueError::ExtractFormatNotMatched {\n                value: Value::I64(100),\n                field: DateTimeField::Hour,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT EXTRACT(microseconds FROM '2011-01-1');\",\n            Err(TranslateError::UnsupportedDateTimeField(\"MICROSECONDS\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","find_idx.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, ValueError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(find_idx, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\"CREATE TABLE Meal (menu Text null)\", Ok(Payload::Create)),\n        (\"INSERT INTO Meal VALUES ('pork')\", Ok(Payload::Insert(1))),\n        (\"INSERT INTO Meal VALUES ('burger')\", Ok(Payload::Insert(1))),\n        (\n            \"SELECT FIND_IDX(menu, 'rg') AS test FROM Meal\",\n            Ok(select!(test; I64; 0; 3)),\n        ),\n        (\n            \"SELECT FIND_IDX(menu, 'r', 4) AS test FROM Meal\",\n            Ok(select!(test; I64; 0; 6)),\n        ),\n        (\n            \"SELECT FIND_IDX('cheese', '') AS test\",\n            Ok(select!(test; I64; 0)),\n        ),\n        (\n            \"SELECT FIND_IDX('cheese', 's') AS test\",\n            Ok(select!(test; I64; 5)),\n        ),\n        (\n            \"SELECT FIND_IDX('cheese burger', 'e', 5) AS test\",\n            Ok(select!(test; I64; 6)),\n        ),\n        (\n            \"SELECT FIND_IDX('cheese', NULL) AS test\",\n            Ok(select_with_null!(test; Null)),\n        ),\n        (\n            \"SELECT FIND_IDX('cheese', 1) AS test\",\n            Err(EvaluateError::FunctionRequiresStringValue(String::from(\"FIND_IDX\")).into()),\n        ),\n        (\n            \"SELECT FIND_IDX('cheese', 's', '5') AS test\",\n            Err(EvaluateError::FunctionRequiresIntegerValue(String::from(\"FIND_IDX\")).into()),\n        ),\n        (\n            \"SELECT FIND_IDX('cheese', 's', -1) AS test\",\n            Err(ValueError::NonPositiveIntegerOffsetInFindIdx(String::from(\"-1\")).into()),\n        ),\n    ];\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","floor.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(floor, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            r#\"\n            SELECT \n                FLOOR(0.3) as floor1, \n                FLOOR(-0.8) as floor2, \n                FLOOR(10) as floor3, \n                FLOOR(6.87421) as floor4 \n            ;\"#,\n            Ok(select!(\n                floor1 | floor2              | floor3 | floor4\n                F64    | F64                 | F64    | F64;\n                0.0      f64::from(-1)   10.0     6.0\n            )),\n        ),\n        (\n            \"SELECT FLOOR('string') AS floor\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"FLOOR\")).into()),\n        ),\n        (\n            \"SELECT FLOOR(NULL) AS floor\",\n            Ok(select_with_null!(floor; Null)),\n        ),\n        (\n            \"SELECT FLOOR(TRUE) AS floor\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"FLOOR\")).into()),\n        ),\n        (\n            \"SELECT FLOOR(FALSE) AS floor\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"FLOOR\")).into()),\n        ),\n        (\n            \"SELECT FLOOR('string' TO DAY) AS floor\",\n            Err(TranslateError::UnsupportedExpr(\"FLOOR('string' TO DAY)\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","format.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::EvaluateError, prelude::Value::*},\n};\n\ntest_case!(format, {\n    let g = get_tester!();\n\n    let test_cases = vec![\n        (\n            \"VALUES(FORMAT(DATE '2017-06-15', '%Y-%m'))\",\n            Ok(select!(\n                column1\n                Str;\n                \"2017-06\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT FORMAT(DATE '2017-06-15','%Y-%m') AS date\",\n            Ok(select!(\n                date\n                Str;\n                \"2017-06\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT FORMAT(TIMESTAMP '2015-09-05 23:56:04', '%Y-%m-%d %H:%M:%S') AS timestamp\",\n            Ok(select!(\n                timestamp\n                Str;\n                \"2015-09-05 23:56:04\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT FORMAT(TIME '23:56:04','%H:%M') AS time\",\n            Ok(select!(\n                time\n                Str;\n                \"23:56\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT \n                FORMAT(TIMESTAMP '2015-09-05 23:56:04', '%Y') AS year\n               ,FORMAT(TIMESTAMP '2015-09-05 23:56:04', '%m') AS month\n               ,FORMAT(TIMESTAMP '2015-09-05 23:56:04', '%d') AS day\n            \",\n            Ok(select!(\n            year              | month           | day;\n            Str               | Str             | Str;\n            \"2015\".to_owned()   \"09\".to_owned()   \"05\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT FORMAT('2015-09-05 23:56:04', '%Y-%m-%d %H') AS timestamp\",\n            Err(\n                EvaluateError::UnsupportedExprForFormatFunction(\"2015-09-05 23:56:04\".to_owned())\n                    .into(),\n            ),\n        ),\n    ];\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","gcd_lcm.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::EvaluateError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(gcd_lcm, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"\n            CREATE TABLE GcdI64 (\n            left INTEGER NULL DEFAULT GCD(3, 4),\n            right INTEGER NULL DEFAULT LCM(10, 2)\n         )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO GcdI64 VALUES (0, 3), (2,4), (6,8), (3,5), (1, NULL), (NULL, 1);\",\n            Ok(Payload::Insert(6)),\n        ),\n        (\n            \"SELECT GCD(left, right) AS test FROM GcdI64\",\n            Ok(select_with_null!(\n                test;\n                I64(3);\n                I64(2);\n                I64(2);\n                I64(1);\n                Null;\n                Null\n            )),\n        ),\n        (\n            \"\n            CREATE TABLE GcdStr (\n            left TEXT,\n            right INTEGER\n         )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO GcdStr VALUES ('TEXT', 0);\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"SELECT GCD(left, right) AS test FROM GcdStr\",\n            Err(EvaluateError::FunctionRequiresIntegerValue(\"GCD\".to_owned()).into()),\n        ),\n        (\n            \"SELECT GCD(right, left) AS test FROM GcdStr\",\n            Err(EvaluateError::FunctionRequiresIntegerValue(\"GCD\".to_owned()).into()),\n        ),\n        (\n            \"\n            CREATE TABLE LcmI64 (\n            left INTEGER NULL DEFAULT true,\n            right INTEGER NULL DEFAULT true\n         )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO LcmI64 VALUES (0, 3), (2,4), (6,8), (3,5), (1, NULL), (NULL, 1);\",\n            Ok(Payload::Insert(6)),\n        ),\n        (\n            \"SELECT LCM(left, right) AS test FROM LcmI64\",\n            Ok(select_with_null!(\n                test;\n                I64(0);\n                I64(4);\n                I64(24);\n                I64(15);\n                Null;\n                Null\n            )),\n        ),\n        (\n            \"\n            CREATE TABLE LcmStr (\n            left TEXT,\n            right INTEGER\n         )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO LcmStr VALUES ('TEXT', 0);\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"SELECT LCM(left, right) AS test FROM LcmStr\",\n            Err(EvaluateError::FunctionRequiresIntegerValue(\"LCM\".to_owned()).into()),\n        ),\n        (\n            \"SELECT LCM(right, left) AS test FROM LcmStr\",\n            Err(EvaluateError::FunctionRequiresIntegerValue(\"LCM\".to_owned()).into()),\n        ),\n        // Check edge cases\n        (\n            \"SELECT GCD(0, 0) as test\",\n            Ok(select_with_null!(test; I64(0))),\n        ),\n        (\n            \"VALUES(\n                GCD(-1, -1),\n                GCD(-2, 0),\n                GCD(-14, 7)\n            )\",\n            Ok(select_with_null!(\n                column1 | column2 | column3;\n                I64(1)    I64(2)    I64(7)\n            )),\n        ),\n        (\n            // check i64::MIN overflow error\n            \"SELECT GCD(-9223372036854775808, -9223372036854775808)\",\n            Err(EvaluateError::GcdLcmOverflow(i64::MIN).into()),\n        ),\n        (\n            \"SELECT LCM(0, 0) as test\",\n            Ok(select_with_null!(test; I64(0))),\n        ),\n        (\n            \"VALUES(\n                LCM(-3, -5),\n                LCM(-13, 0),\n                LCM(-12, 2)\n            )\n            \",\n            Ok(select_with_null!(\n                column1 | column2 | column3;\n                I64(15)   I64(0)    I64(12)\n            )),\n        ),\n        (\n            // check i64::MIN overflow error\n            \"SELECT LCM(-9223372036854775808, -9223372036854775808)\",\n            Err(EvaluateError::GcdLcmOverflow(i64::MIN).into()),\n        ),\n        (\n            // 10^10 + 19 and 10^10 + 33 are prime numbers\n            // LCM(10^10+19, 10^10+33) = (10^10+19)*(10^10+33)\n            // this result is out of i64 range.\n            \"SELECT LCM(10000000019, 10000000033)\",\n            Err(EvaluateError::LcmResultOutOfRange.into()),\n        ),\n        (\n            \"SELECT gcd(1.0, 1);\",\n            Err(EvaluateError::FunctionRequiresIntegerValue(\"GCD\".to_owned()).into()),\n        ),\n    ];\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","generate_uuid.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast::DataType, error::TranslateError},\n};\n\ntest_case!(generate_uuid, {\n    let g = get_tester!();\n\n    let test_cases = [(\n        \"SELECT generate_uuid(0) as uuid\",\n        Err(TranslateError::FunctionArgsLengthNotMatching {\n            name: \"GENERATE_UUID\".to_owned(),\n            expected: 0,\n            found: 1,\n        }\n        .into()),\n    )];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n\n    g.count(\"SELECT GENERATE_UUID()\", 1).await;\n    g.count(\"VALUES (GENERATE_UUID())\", 1).await;\n    g.type_match(\"SELECT GENERATE_UUID() as uuid\", \u0026[DataType::Uuid])\n        .await;\n    g.type_match(\"VALUES (GENERATE_UUID())\", \u0026[DataType::Uuid])\n        .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","geometry","calc_distance.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(calc_distance, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Foo (geo1 Point, geo2 Point, bar Float)\",\n            Ok(Payload::Create),\n        ),\n        (\n            r#\"INSERT INTO Foo VALUES (POINT(0.3134, 3.156), POINT(1.415, 3.231), 3)\"#,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            r#\"SELECT CALC_DISTANCE(geo1, geo2) AS georesult FROM Foo\"#,\n            Ok(select!(\n                georesult\n                F64;\n                1.104150152832485_f64\n\n            )),\n        ),\n        (\n            r#\"SELECT CALC_DISTANCE(geo1) AS georesult FROM Foo\"#,\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"CALC_DISTANCE\".to_owned(),\n                expected: 2,\n                found: 1,\n            }\n            .into()),\n        ),\n        (\n            r#\"SELECT CALC_DISTANCE(geo1, bar) AS georesult FROM Foo\"#,\n            Err(EvaluateError::FunctionRequiresPointValue(\"CALC_DISTANCE\".to_owned()).into()),\n        ),\n        (\n            r#\"SELECT CALC_DISTANCE(geo1, NULL) AS georesult FROM Foo\"#,\n            Ok(select_with_null!(georesult; Null)),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","geometry","get_x.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::EvaluateError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(get_x, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE PointGroup (point_field POINT)\",\n            Ok(Payload::Create),\n        ),\n        (\n            r#\"INSERT INTO PointGroup VALUES (POINT(0.3134, 0.156))\"#,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            r#\"SELECT GET_X(point_field) AS point_field FROM PointGroup;\"#,\n            Ok(select!(\n                point_field\n                F64;\n                0.3134\n            )),\n        ),\n        (\n            r#\"SELECT GET_X(CAST('POINT(0.1 -0.2)' AS POINT)) AS ptx\"#,\n            Ok(select!(\n                ptx\n                F64;\n                0.1\n\n            )),\n        ),\n        (\n            r#\"SELECT GET_X(POINT(0.1, -0.2)) AS ptx\"#,\n            Ok(select!(\n                ptx\n                F64;\n                0.1\n            )),\n        ),\n        (\n            r#\"SELECT GET_X('cheese') AS ptx\"#,\n            Err(EvaluateError::FunctionRequiresPointValue(\"GET_X\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","geometry","get_y.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::EvaluateError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(get_y, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE PointGroup (point_field POINT)\",\n            Ok(Payload::Create),\n        ),\n        (\n            r#\"INSERT INTO PointGroup VALUES (POINT(0.3134, 0.156))\"#,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            r#\"SELECT GET_Y(point_field) AS point_field FROM PointGroup;\"#,\n            Ok(select!(\n                point_field\n                F64;\n                0.156\n            )),\n        ),\n        (\n            r#\"SELECT GET_Y(CAST('POINT(0.1 -0.2)' AS POINT)) AS ptx\"#,\n            Ok(select!(\n                ptx\n                F64;\n                -0.2\n            )),\n        ),\n        (\n            r#\"SELECT GET_Y(POINT(0.1, -0.2)) AS ptx\"#,\n            Ok(select!(\n                ptx\n                F64;\n                -0.2\n            )),\n        ),\n        (\n            r#\"SELECT GET_Y('cheese') AS ptx\"#,\n            Err(EvaluateError::FunctionRequiresPointValue(\"GET_Y\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","geometry.rs"],"content":"mod calc_distance;\nmod get_x;\nmod get_y;\n\npub use {calc_distance::calc_distance, get_x::get_x, get_y::get_y};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","greatest.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(greatest, {\n    let g = get_tester!();\n\n    g.test(\n        \"SELECT GREATEST(1,6,9,7,0,10) AS goat;\",\n        Ok(select!(\n            \"goat\"; I64; 10\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT GREATEST(1.2,6.8,9.6,7.4,0.1,10.5) AS goat;\",\n        Ok(select!(\n            \"goat\" ; F64; 10.5\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT GREATEST('bibibik', 'babamba', 'melona') AS goat;\",\n        Ok(select!(\n            \"goat\"; Str; \"melona\".to_owned()\n        )),\n    )\n    .await;\n\n    macro_rules! date {\n        ($date: expr) =\u003e {\n            $date.parse().unwrap()\n        };\n    }\n\n    g.test(\n        \"SELECT GREATEST(\n            DATE '2023-07-17', \n            DATE '2022-07-17', \n            DATE '2023-06-17', \n            DATE '2024-07-17',\n            DATE '2024-07-18') AS goat;\",\n        Ok(select!(\n            \"goat\"; Date; date!(\"2024-07-18\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT GREATEST() AS goat;\",\n        Err(TranslateError::FunctionArgsLengthNotMatchingMin {\n            name: \"GREATEST\".to_owned(),\n            expected_minimum: 2,\n            found: 0,\n        }\n        .into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT GREATEST(1, 2, 'bibibik') AS goat;\",\n        Err(EvaluateError::NonComparableArgumentError(\"GREATEST\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT GREATEST(NULL, 'bibibik', 'babamba', 'melona') AS goat;\",\n        Err(EvaluateError::NonComparableArgumentError(\"GREATEST\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT GREATEST(NULL, NULL, NULL) AS goat;\",\n        Err(EvaluateError::NonComparableArgumentError(\"GREATEST\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT GREATEST(true, false) AS goat;\",\n        Ok(select!(\n            \"goat\"; Bool; true\n        )),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","hex.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(hex, {\n    let g = get_tester!();\n\n    g.test(\n        \"VALUES(HEX('Hello World'))\",\n        Ok(select!(\n            column1\n            Str;\n            \"48656C6C6F20576F726C64\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"VALUES(HEX('ABC'))\",\n        Ok(select!(\n            column1\n            Str;\n            \"414243\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"VALUES(HEX(''))\",\n        Ok(select!(\n            column1\n            Str;\n            \"\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"VALUES(HEX('228'))\",\n        Ok(select!(\n            column1\n            Str;\n            \"323238\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"VALUES(HEX(228))\",\n        Ok(select!(\n            column1\n            Str;\n            \"E4\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"VALUES(HEX(0))\",\n        Ok(select!(\n            column1\n            Str;\n            \"0\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"VALUES(HEX(-123))\",\n        Ok(select!(\n            column1\n            Str;\n            \"FFFFFFFFFFFFFF85\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"VALUES(HEX(3.14))\",\n        Err(EvaluateError::FunctionRequiresIntegerOrStringValue(\"HEX\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(r#\"VALUES(HEX(NULL))\"#, Ok(select_with_null!(column1; Null)))\n        .await;\n\n    g.test(\n        r#\"VALUES(HEX())\"#,\n        Err(TranslateError::FunctionArgsLengthNotMatching {\n            name: \"HEX\".to_owned(),\n            expected: 1,\n            found: 0,\n        }\n        .into()),\n    )\n    .await;\n\n    g.test(\n        r#\"VALUES(HEX('test', 'extra'))\"#,\n        Err(TranslateError::FunctionArgsLengthNotMatching {\n            name: \"HEX\".to_owned(),\n            expected: 1,\n            found: 2,\n        }\n        .into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","ifnull.rs"],"content":"use {\n    crate::*,\n    chrono::{NaiveDate, NaiveTime},\n    gluesql_core::prelude::{Payload, Value::*},\n    rust_decimal::Decimal,\n};\n\ntest_case!(ifnull, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE SingleItem (id integer null, int8 int8 null, dec decimal null,\n                                        dt date null, mystring Text null,\n                                        mybool Boolean null, myfloat float null,\n                                        mytime time null, mytimestamp timestamp null)\",\n            Payload::Create,\n        ),\n        (\n            \"INSERT INTO SingleItem VALUES (0, 1, 2, '2022-05-23', 'this is a string', true, 3.15,\n                          '01:02:03', '1970-01-01 00:00:00 -00:00')\",\n            Payload::Insert(1),\n        ),\n        (\n            \"INSERT INTO SingleItem VALUES (null, null, null, null, null, null, null, null, null)\",\n            Payload::Insert(1),\n        ),\n        (\n            \"SELECT IFNULL(id, 1) AS myid, IFNULL(int8, 2) AS int8, IFNULL(dec, 3)\n            FROM SingleItem WHERE id IS NOT NULL\",\n            select!(\"myid\" | \"int8\" | \"IFNULL(dec, 3)\"; I64 | I8 | Decimal; 0 1 Decimal::from(2i8)),\n        ),\n        (\n            \"SELECT ifnull(id, 1) AS ID, IFNULL(int8, 2) AS INT8, IFNULL(dec, 3)\n            FROM SingleItem WHERE id IS NULL\",\n            select!(\"ID\" | \"INT8\" | \"IFNULL(dec, 3)\"; I64 | I64 | I64; 1  2 3),\n        ),\n        (\n            \"SELECT ifnull(dt, '2000-01-01') AS mydate, ifnull(mystring, 'blah') AS name\n            FROM SingleItem WHERE id IS NOT NULL\",\n            select!(\"mydate\" | \"name\"; Date | Str; NaiveDate::from_ymd_opt(2022,5,23).unwrap() \"this is a string\".to_owned()),\n        ),\n        (\n            \"SELECT IFNULL(dt, '2000-01-01') AS mydate, IFNULL(mystring, 'blah') AS name\n            FROM SingleItem where id is null\",\n            select!(\"mydate\" | \"name\"; Str | Str; \"2000-01-01\".to_owned() \"blah\".to_owned()),\n        ),\n        (\n            \"SELECT IFNULL(mybool, 'YES') AS mybool, IFNULL(myfloat, 'NO') AS myfloat\n            FROM SingleItem WHERE id IS NOT NULL\",\n            select!(\"mybool\" | \"myfloat\"; Bool | F64; true 3.15),\n        ),\n        (\n            \"SELECT IFNULL(mybool, 'YES') AS mybool, IFNULL(myfloat, 'NO') AS myfloat\n            FROM SingleItem WHERE id IS NULL\",\n            select!(\"mybool\" | \"myfloat\"; Str | Str; \"YES\".to_owned() \"NO\".to_owned()),\n        ),\n        (\n            \"SELECT\n                IFNULL(mytime, 'YES') AS mytime,\n                IFNULL(mytimestamp, 'NO') AS mytimestamp\n            FROM SingleItem\n            WHERE id IS NOT NULL\",\n            select!(\n                \"mytime\" | \"mytimestamp\";\n                 Time    |  Timestamp;\n                NaiveTime::from_hms_opt(1, 2, 3).unwrap()\n                NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_opt(0, 0, 0).unwrap()\n            ),\n        ),\n        (\n            \"SELECT IFNULL(mytime, 'YES') AS mytime, IFNULL(mytimestamp, 'NO') AS mytimestamp\n            FROM SingleItem WHERE id IS NULL\",\n            select!(\"mytime\" | \"mytimestamp\"; Str | Str; \"YES\".to_owned() \"NO\".to_owned()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","iif.rs"],"content":"use {\n    crate::*,\n    bigdecimal::BigDecimal,\n    gluesql_core::{data::Literal, error::EvaluateError, error::TranslateError, prelude::Value::*},\n    std::borrow::Cow,\n};\n\ntest_case!(iif, {\n    let g = get_tester!();\n\n    g.named_test(\n        \"IIF with TRUE should return THEN\",\n        \"SELECT IIF(TRUE, 'a', 'b') AS result\",\n        Ok(select!(result; Str; \"a\".to_owned())),\n    )\n    .await;\n\n    g.named_test(\n        \"IIF with FALSE should return ELSE\",\n        \"SELECT IIF(FALSE, 1, 2) AS result\",\n        Ok(select!(result; I64; 2)),\n    )\n    .await;\n\n    g.named_test(\n        \"IIF with boolean expression\",\n        \"SELECT IIF(1 \u003c 2, 10, 20) AS result\",\n        Ok(select!(result; I64; 10)),\n    )\n    .await;\n\n    g.named_test(\n        \"IIF with non-boolean condition should throw EvaluateError\",\n        \"SELECT IIF(1, 'a', 'b') AS result\",\n        Err(EvaluateError::BooleanTypeRequired(format!(\n            \"{:?}\",\n            Literal::Number(Cow::Owned(BigDecimal::from(1)))\n        ))\n        .into()),\n    )\n    .await;\n\n    g.named_test(\n        \"IIF with wrong arity (2 args) should throw TranslateError\",\n        \"SELECT IIF(1, 2) AS result\",\n        Err(TranslateError::FunctionArgsLengthNotMatching {\n            name: \"IIF\".to_owned(),\n            expected: 3,\n            found: 2,\n        }\n        .into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","initcap.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(initcap, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Item (\n                name TEXT DEFAULT 'abcd'\n            )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO Item VALUES\n            ('h/i jk'),\n            (NULL),\n            ('H/I JK')\",\n            Ok(Payload::Insert(3)),\n        ),\n        (\n            \"SELECT name FROM Item WHERE INITCAP(name) = 'H/I Jk';\",\n            Ok(select!(\n                name Str;\n                \"h/i jk\".to_owned();\n                \"H/I JK\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT INITCAP(name) FROM Item;\",\n            Ok(select_with_null!(\n                \"INITCAP(name)\";\n                Str(\"H/I Jk\".to_owned());\n                Null;\n                Str(\"H/I Jk\".to_owned())\n            )),\n        ),\n        (\n            \"SELECT INITCAP() FROM Item\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"INITCAP\".to_owned(),\n                expected: 1,\n                found: 0,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT INITCAP(1) FROM Item\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"INITCAP\".to_owned()).into()),\n        ),\n        (\n            \"SELECT INITCAP(a =\u003e 2) FROM Item\",\n            Err(TranslateError::NamedFunctionArgNotSupported.into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","is_empty.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::EvaluateError, prelude::Value::*},\n};\ntest_case!(is_empty, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE IsEmpty (\n            id INTEGER,\n            list_items LIST,\n            map_items MAP\n        );\",\n    )\n    .await;\n    g.run(\n        r#\"\n            INSERT INTO IsEmpty VALUES\n            (1, '[]', '{\"a\": {\"red\": \"cherry\", \"blue\": 2}, \"b\": 20}'),\n            (2, '[1, 2, 3]', '{\"a\": {\"red\": \"berry\", \"blue\": 3}, \"b\": 30, \"c\": true}'),\n            (3, '[]', '{}'),\n            (4, '[10]', '{}');\n        \"#,\n    )\n    .await;\n\n    g.named_test(\n        \"is_empty for list, return true\",\n        r#\"SELECT id FROM IsEmpty WHERE IS_EMPTY(list_items);\"#,\n        Ok(select!(id; I64; 1; 3)),\n    )\n    .await;\n    g.named_test(\n        \"is_empty for list, return false\",\n        r#\"SELECT IS_EMPTY(list_items) as result FROM IsEmpty WHERE id=2;\"#,\n        Ok(select!(result; Bool; false)),\n    )\n    .await;\n\n    g.named_test(\n        \"is_empty for map, return true\",\n        r#\"SELECT id FROM IsEmpty WHERE IS_EMPTY(map_items);\"#,\n        Ok(select!(id; I64; 3; 4)),\n    )\n    .await;\n    g.named_test(\n        \"is_empty for map, return false\",\n        r#\"SELECT IS_EMPTY(map_items) as result FROM IsEmpty WHERE id=1;\"#,\n        Ok(select!(result; Bool; false)),\n    )\n    .await;\n\n    g.named_test(\n        \"other argument types, return error\",\n        r#\"SELECT id FROM IsEmpty WHERE IS_EMPTY(id);\"#,\n        Err(EvaluateError::MapOrListTypeRequired.into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","keys.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::EvaluateError, prelude::Value},\n};\n\ntest_case!(keys, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE USER (id INTEGER, data MAP);\").await;\n    g.run(\n        r#\"\n            INSERT INTO USER VALUES \n            (1, '{\"id\": 1, \"name\": \"alice\", \"is_male\": false}'),\n            (2, '{\"name\": \"bob\"}'),\n            (3, '{}');\n        \"#,\n    )\n    .await;\n\n    g.named_test(\n         \"return all keys from map by ascending order\",\n        r#\"SELECT SORT(KEYS(data), 'ASC') as result FROM USER WHERE id=1\"#,\n        {\n            Ok(select!(result; Value::List; vec![Value::Str(\"id\".to_owned()), Value::Str(\"is_male\".to_owned()), Value::Str(\"name\".to_owned())]))\n        }\n    ).await;\n    g.named_test(\n        \"return one key from map\",\n        r#\"SELECT KEYS(data) as result FROM USER WHERE id=2\"#,\n        Ok(select!(result; Value::List; vec![Value::Str(\"name\".to_owned())])),\n    )\n    .await;\n    g.named_test(\n        \"return null from empty map\",\n        r#\"SELECT KEYS(data) as result FROM USER WHERE id=3\"#,\n        Ok(select!(result; Value::List; vec![])),\n    )\n    .await;\n    g.named_test(\n        \"return argument type error\",\n        r#\"SELECT KEYS(id) FROM USER WHERE id=1\"#,\n        Err(EvaluateError::MapTypeRequired.into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","last_day.rs"],"content":"use {\n    crate::*,\n    chrono::NaiveDate,\n    gluesql_core::{executor::EvaluateError, prelude::Value::*},\n};\n\ntest_case!(last_day, {\n    let g = get_tester!();\n\n    g.run(\n        \"CREATE TABLE LastDay (\n            id INTEGER,\n            date DATE,\n            timestamp TIMESTAMP\n        );\",\n    )\n    .await;\n\n    g.run(\"INSERT INTO LastDay (id, date) VALUES (1, LAST_DAY(DATE '2017-12-15'));\")\n        .await;\n    g.named_test(\n        \"Should insert the last day of the month that a given date belongs to\",\n        \"SELECT date FROM LastDay WHERE id = 1;\",\n        Ok(select!(\n            date;\n            Date;\n            NaiveDate::from_ymd_opt(2017, 12, 31).unwrap()\n        )),\n    )\n    .await;\n\n    g.run(\"INSERT INTO LastDay (id, date) VALUES (2, DATE '2017-01-01');\")\n        .await;\n    g.named_test(\n        \"Should return the last day of the month that a retrieved date belongs to\",\n        \"SELECT LAST_DAY(date) as date FROM LastDay WHERE id = 2;\",\n        Ok(select!(\n            date;\n            Date;\n            NaiveDate::from_ymd_opt(2017, 1, 31).unwrap()\n        )),\n    )\n    .await;\n\n    g.run(\"INSERT INTO LastDay (id, date) VALUES (3, LAST_DAY(TIMESTAMP '2017-12-15 12:12:20'));\")\n        .await;\n    g.named_test(\n        \"Should insert the last day of the month that a given timestamp belongs to\",\n        \"SELECT date FROM LastDay WHERE id = 3;\",\n        Ok(select!(\n            date;\n            Date;\n            NaiveDate::from_ymd_opt(2017, 12, 31).unwrap()\n        )),\n    )\n    .await;\n\n    g.run(\"INSERT INTO LastDay (id, timestamp) VALUES (4, TIMESTAMP '2017-01-01 12:12:20');\")\n        .await;\n    g.named_test(\n        \"Should return the last day of the month that a retrieved timestamp belongs to\",\n        \"SELECT LAST_DAY(timestamp) as date FROM LastDay WHERE id = 4;\",\n        Ok(select!(\n            date;\n            Date;\n            NaiveDate::from_ymd_opt(2017, 1, 31).unwrap()\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"Should only give date or timestamp value to LAST_DAY function\",\n        \"VALUES (LAST_DAY('dfafsdf3243252454325342'));\",\n        Err(EvaluateError::FunctionRequiresDateOrDateTimeValue(\"LAST_DAY\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","left_right.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(left_right, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Item (name TEXT DEFAULT LEFT('abc', 1))\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO Item VALUES ('Blop mc blee'), ('B'), ('Steven the \u0026long named$ folken!')\",\n            Ok(Payload::Insert(3)),\n        ),\n        (\"CREATE TABLE SingleItem (id INTEGER)\", Ok(Payload::Create)),\n        (\"INSERT INTO SingleItem VALUES (0)\", Ok(Payload::Insert(1))),\n        (\n            \"CREATE TABLE NullName (name TEXT NULL)\",\n            Ok(Payload::Create),\n        ),\n        (\"INSERT INTO NullName VALUES (NULL)\", Ok(Payload::Insert(1))),\n        (\n            \"CREATE TABLE NullNumber (number INTEGER NULL)\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO NullNumber VALUES (NULL)\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"CREATE TABLE NullableName (name TEXT NULL)\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO NullableName VALUES ('name')\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"SELECT LEFT(name, 3) AS test FROM Item\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"Blo\".to_owned();\n                \"B\".to_owned();\n                \"Ste\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT RIGHT(name, 10) AS test FROM Item\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"op mc blee\".to_owned();\n                \"B\".to_owned();\n                \"d$ folken!\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LEFT((name || 'bobbert'), 10) AS test FROM Item\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"Blop mc bl\".to_owned();\n                \"Bbobbert\".to_owned();\n                \"Steven the\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LEFT('blue', 10) AS test FROM SingleItem\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"blue\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LEFT('blunder', 3) AS test FROM SingleItem\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"blu\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LEFT(name, 3) AS test FROM NullName\",\n            Ok(select_with_null!(test; Null)),\n        ),\n        (\n            \"SELECT LEFT('Words', number) AS test FROM NullNumber\",\n            Ok(select_with_null!(test; Null)),\n        ),\n        (\n            \"SELECT LEFT(name, number) AS test FROM NullNumber INNER JOIN NullName ON 1 = 1\",\n            Ok(select_with_null!(test; Null)),\n        ),\n        (\n            \"SELECT LEFT(name, 1) AS test FROM NullableName\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"n\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT RIGHT(name, 10, 10) AS test FROM SingleItem\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"RIGHT\".to_owned(),\n                expected: 2,\n                found: 3,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT RIGHT(name) AS test FROM SingleItem\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"RIGHT\".to_owned(),\n                expected: 2,\n                found: 1,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT RIGHT() AS test FROM SingleItem\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"RIGHT\".to_owned(),\n                expected: 2,\n                found: 0,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT RIGHT(1, 1) AS test FROM SingleItem\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"RIGHT\".to_owned()).into()),\n        ),\n        (\n            \"SELECT RIGHT('Words', 1.1) AS test FROM SingleItem\",\n            Err(EvaluateError::FunctionRequiresIntegerValue(\"RIGHT\".to_owned()).into()),\n        ),\n        (\n            \"SELECT RIGHT('Words', -4) AS test FROM SingleItem\",\n            Err(EvaluateError::FunctionRequiresUSizeValue(\"RIGHT\".to_owned()).into()),\n        ),\n    ];\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","length.rs"],"content":"use {crate::*, gluesql_core::prelude::Value::*};\n\ntest_case!(length, {\n    let g = get_tester!();\n\n    g.named_test(\n        \"test length with string\",\n        \"SELECT LENGTH('Hello.');\",\n        Ok(select!(\n            \"LENGTH('Hello.')\"\n            U64;\n            6\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"test length with list\",\n        r#\"SELECT LENGTH(CAST('[1, 2, 3]' AS LIST))\"#,\n        Ok(select!(\n            \"LENGTH(CAST('[1, 2, 3]' AS LIST))\"\n            U64;\n            3\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"test length with map\",\n        r#\"SELECT LENGTH(CAST('{\"a\": 1, \"b\": 5, \"c\": 9, \"d\": 10}' AS MAP))\"#,\n        Ok(select!(\n            \"LENGTH(CAST('{\\\"a\\\": 1, \\\"b\\\": 5, \\\"c\\\": 9, \\\"d\\\": 10}' AS MAP))\"\n            U64;\n            4\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"test length string - wide chars 1\",\n        \"SELECT LENGTH('');\",\n        Ok(select!(\n            \"LENGTH('')\"\n            U64;\n            2\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"test length string - wide chars 2\",\n        \"SELECT LENGTH(' abc');\",\n        Ok(select!(\n            \"LENGTH(' abc')\"\n            U64;\n            6\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"test length string - wide chars 3\",\n        \"SELECT LENGTH('');\",\n        Ok(select!(\n            \"LENGTH('')\"\n            U64;\n            1\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"test length string - wide chars 4\",\n        \"SELECT LENGTH('');\",\n        Ok(select!(\n            \"LENGTH('')\"\n            U64;\n            1\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"test length string - wide chars 5\",\n        \"SELECT LENGTH('');\",\n        Ok(select!(\n            \"LENGTH('')\"\n            U64;\n            2\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"test length string - wide chars 6\",\n        \"SELECT LENGTH('');\",\n        Ok(select!(\n            \"LENGTH('')\"\n            U64;\n            3\n        )),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","lpad_rpad.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(lpad_rpad, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Item (name TEXT DEFAULT LPAD('a', 5) || LPAD('b', 3))\",\n            Ok(Payload::Create),\n        ),\n        (\"INSERT INTO Item VALUES ('hello')\", Ok(Payload::Insert(1))),\n        (\n            \"CREATE TABLE NullName (name TEXT NULL)\",\n            Ok(Payload::Create),\n        ),\n        (\"INSERT INTO NullName VALUES (NULL)\", Ok(Payload::Insert(1))),\n        (\n            \"CREATE TABLE NullNumber (number INTEGER NULL)\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO NullNumber VALUES (NULL)\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"SELECT LPAD(name, 10), RPAD(name, 10) FROM Item\",\n            Ok(select!(\n                \"LPAD(name, 10)\"         | \"RPAD(name, 10)\"\n                Str                      | Str;\n                \"     hello\".to_owned()    \"hello     \".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LPAD(name, 10, 'ab'), RPAD(name, 10, 'ab') FROM Item\",\n            Ok(select!(\n                \"LPAD(name, 10, 'ab')\"   | \"RPAD(name, 10, 'ab')\"\n                Str                      | Str;\n                \"ababahello\".to_owned()    \"helloababa\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LPAD(name, 3), RPAD(name, 3) FROM Item\",\n            Ok(select!(\n                \"LPAD(name, 3)\"   | \"RPAD(name, 3)\"\n                Str               | Str;\n                \"hel\".to_owned()    \"hel\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LPAD(name, 3, 'ab'), RPAD(name, 3, 'ab') FROM Item\",\n            Ok(select!(\n                \"LPAD(name, 3, 'ab')\"   | \"RPAD(name, 3, 'ab')\"\n                Str                     | Str;\n                \"hel\".to_owned()          \"hel\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LPAD(name, 10, 'ab') AS lpad FROM NullName\",\n            Ok(select_with_null!(lpad; Null)),\n        ),\n        (\n            \"SELECT RPAD(name, 10, 'ab') AS rpad FROM NullName\",\n            Ok(select_with_null!(rpad; Null)),\n        ),\n        (\n            \"SELECT LPAD('hello', number, 'ab') AS lpad FROM NullNumber\",\n            Ok(select_with_null!(lpad; Null)),\n        ),\n        (\n            \"SELECT RPAD('hello', number, 'ab') AS rpad FROM NullNumber\",\n            Ok(select_with_null!(rpad; Null)),\n        ),\n        (\n            \"SELECT LPAD('hello', 10, name) AS lpad FROM NullName\",\n            Ok(select_with_null!(lpad; Null)),\n        ),\n        (\n            \"SELECT RPAD('hello', 10, name) AS rpad FROM NullName\",\n            Ok(select_with_null!(rpad; Null)),\n        ),\n        (\n            \"SELECT LPAD(name) FROM Item\",\n            Err(TranslateError::FunctionArgsLengthNotWithinRange {\n                name: \"LPAD\".to_owned(),\n                expected_minimum: 2,\n                expected_maximum: 3,\n                found: 1,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT RPAD(name) FROM Item\",\n            Err(TranslateError::FunctionArgsLengthNotWithinRange {\n                name: \"RPAD\".to_owned(),\n                expected_minimum: 2,\n                expected_maximum: 3,\n                found: 1,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT LPAD(name, 10, 'ab', 'cd') FROM Item\",\n            Err(TranslateError::FunctionArgsLengthNotWithinRange {\n                name: \"LPAD\".to_owned(),\n                expected_minimum: 2,\n                expected_maximum: 3,\n                found: 4,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT RPAD(name, 10, 'ab', 'cd') FROM Item\",\n            Err(TranslateError::FunctionArgsLengthNotWithinRange {\n                name: \"RPAD\".to_owned(),\n                expected_minimum: 2,\n                expected_maximum: 3,\n                found: 4,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT LPAD(1, 10, 'ab') FROM Item\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"LPAD\".to_owned()).into()),\n        ),\n        (\n            \"SELECT RPAD(1, 10, 'ab') FROM Item\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"RPAD\".to_owned()).into()),\n        ),\n        (\n            \"SELECT LPAD(name, -10, 'ab') FROM Item\",\n            Err(EvaluateError::FunctionRequiresUSizeValue(\"LPAD\".to_owned()).into()),\n        ),\n        (\n            \"SELECT RPAD(name, -10, 'ab') FROM Item\",\n            Err(EvaluateError::FunctionRequiresUSizeValue(\"RPAD\".to_owned()).into()),\n        ),\n        (\n            \"SELECT LPAD(name, 10.1, 'ab') FROM Item\",\n            Err(EvaluateError::FunctionRequiresIntegerValue(\"LPAD\".to_owned()).into()),\n        ),\n        (\n            \"SELECT RPAD(name, 10.1, 'ab') FROM Item\",\n            Err(EvaluateError::FunctionRequiresIntegerValue(\"RPAD\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","ltrim_rtrim.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::EvaluateError,\n        prelude::{\n            Payload,\n            Value::{self, *},\n        },\n    },\n};\n\ntest_case!(ltrim_rtrim, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Item (name TEXT DEFAULT RTRIM(LTRIM('   abc   ')))\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO Item VALUES (' zzzytest'), ('testxxzx ')\",\n            Ok(Payload::Insert(2)),\n        ),\n        (\n            \"SELECT LTRIM('x', 'xyz') AS test from Item;\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"\".to_owned();\n                \"\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LTRIM('txu', 'xyz') AS test from Item;\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"txu\".to_owned();\n                \"txu\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LTRIM(name) AS test FROM Item\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"zzzytest\".to_owned();\n                \"testxxzx \".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LTRIM(RTRIM('GlueSQLABC', 'ABC')) AS test FROM Item;\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"GlueSQL\".to_owned();\n                \"GlueSQL\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LTRIM(name, ' xyz') AS test FROM Item\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"test\".to_owned();\n                \"testxxzx \".to_owned()\n            )),\n        ),\n        (\n            \"SELECT RTRIM(name) AS test FROM Item\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \" zzzytest\".to_owned();\n                \"testxxzx\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT RTRIM(name, 'xyz ') AS test FROM Item\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \" zzzytest\".to_owned();\n                \"test\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT RTRIM('x', 'xyz') AS test from Item;\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"\".to_owned();\n                \"\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT RTRIM('tuv', 'xyz') AS test from Item;\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"tuv\".to_owned();\n                \"tuv\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT RTRIM('txu', 'xyz') AS test from Item;\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"txu\".to_owned();\n                \"txu\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT RTRIM('xux', 'xyz') AS test from Item;\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"xu\".to_owned();\n                \"xu\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LTRIM(1) AS test FROM Item\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"LTRIM\".to_owned()).into()),\n        ),\n        (\n            \"SELECT LTRIM(name, 1) AS test FROM Item\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"LTRIM\".to_owned()).into()),\n        ),\n        (\n            \"SELECT RTRIM(1) AS test FROM Item\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"RTRIM\".to_owned()).into()),\n        ),\n        (\n            \"SELECT RTRIM(name, 1) AS test FROM Item\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"RTRIM\".to_owned()).into()),\n        ),\n        (\n            \"CREATE TABLE NullTest (name TEXT null)\",\n            Ok(Payload::Create),\n        ),\n        (\"INSERT INTO NullTest VALUES (null)\", Ok(Payload::Insert(1))),\n        (\n            \"SELECT LTRIM('name', NULL) AS test FROM NullTest\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n        (\n            \"SELECT LTRIM(name) AS test FROM NullTest\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n        (\n            \"SELECT RTRIM(name) AS test FROM NullTest\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n        (\n            \"SELECT RTRIM('name', NULL) AS test FROM NullTest\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n        (\n            \"SELECT LTRIM(NULL, '123') AS test FROM NullTest\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n        (\n            \"SELECT LTRIM(name, NULL) AS test FROM NullTest\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n        (\n            \"SELECT RTRIM(NULL, '123') AS test FROM NullTest\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n        (\n            \"SELECT RTRIM(name, NULL) AS test FROM NullTest\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n    ];\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","math_function.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::{\n            Payload,\n            Value::{self, *},\n        },\n    },\n};\n\ntest_case!(sin, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT SIN(0.5) AS sin1, SIN(1) AS sin2\",\n            Ok(select!(\n                \"sin1\"          | \"sin2\"\n                F64             | F64;\n                0.5_f64.sin()     1.0_f64.sin()\n            )),\n        ),\n        (\n            \"SELECT SIN(null) AS sin\",\n            Ok(select_with_null!(sin; Value::Null)),\n        ),\n        (\n            \"SELECT SIN(true) AS sin\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"SIN\".to_owned()).into()),\n        ),\n        (\n            \"SELECT SIN(false) AS sin\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"SIN\".to_owned()).into()),\n        ),\n        (\n            \"SELECT SIN('string') AS sin\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"SIN\".to_owned()).into()),\n        ),\n        (\n            \"SELECT SIN() AS sin\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"SIN\".to_owned(),\n                expected: 1,\n                found: 0,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT SIN(1.0, 2.0) AS sin\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"SIN\".to_owned(),\n                expected: 1,\n                found: 2,\n            }\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(cos, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT COS(0.5) AS cos1, COS(1) AS cos2\",\n            Ok(select!(\n                \"cos1\"        | \"cos2\"\n                F64           | F64;\n                0.5_f64.cos()   1.0_f64.cos()\n            )),\n        ),\n        (\n            \"SELECT COS(null) AS cos\",\n            Ok(select_with_null!(cos; Value::Null)),\n        ),\n        (\n            \"SELECT COS(true) AS cos\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"COS\".to_owned()).into()),\n        ),\n        (\n            \"SELECT COS(false) AS cos\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"COS\".to_owned()).into()),\n        ),\n        (\n            \"SELECT COS('string') AS cos\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"COS\".to_owned()).into()),\n        ),\n        (\n            \"SELECT COS() AS cos\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"COS\".to_owned(),\n                expected: 1,\n                found: 0,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT COS(1.0, 2.0) AS cos\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"COS\".to_owned(),\n                expected: 1,\n                found: 2,\n            }\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(tan, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT TAN(0.5) AS tan1, TAN(1) AS tan2\",\n            Ok(select!(\n                \"tan1\"        | \"tan2\"\n                F64           | F64;\n                0.5_f64.tan()   1.0_f64.tan()\n            )),\n        ),\n        (\n            \"SELECT TAN(null) AS tan\",\n            Ok(select_with_null!(tan; Value::Null)),\n        ),\n        (\n            \"SELECT TAN(true) AS tan\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"TAN\".to_owned()).into()),\n        ),\n        (\n            \"SELECT TAN(false) AS tan\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"TAN\".to_owned()).into()),\n        ),\n        (\n            \"SELECT TAN('string') AS tan\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"TAN\".to_owned()).into()),\n        ),\n        (\n            \"SELECT TAN() AS tan\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"TAN\".to_owned(),\n                expected: 1,\n                found: 0,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT TAN(1.0, 2.0) AS tan\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"TAN\".to_owned(),\n                expected: 1,\n                found: 2,\n            }\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(asin, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT ASIN(0.5) AS asin1, ASIN(1) AS asin2\",\n            Ok(select!(\n                \"asin1\"        | \"asin2\"\n                F64            | F64;\n                0.5_f64.asin()   1.0_f64.asin()\n            )),\n        ),\n        (\n            \"SELECT ASIN('string') AS asin\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"ASIN\".to_owned()).into()),\n        ),\n        (\n            \"SELECT ASIN(null) AS asin\",\n            Ok(select_with_null!(asin; Null)),\n        ),\n        (\n            \"SELECT ASIN() AS asin\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"ASIN\".to_owned(),\n                expected: 1,\n                found: 0,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT ASIN(1.0, 2.0) AS sin\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"ASIN\".to_owned(),\n                expected: 1,\n                found: 2,\n            }\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(acos, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT ACOS(0.5) AS acos1, ACOS(1) AS acos2\",\n            Ok(select!(\n                \"acos1\"        | \"acos2\";\n                F64            | F64 ;\n                0.5_f64.acos()   1.0_f64.acos()\n            )),\n        ),\n        (\n            \"SELECT ACOS('string') AS acos\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"ACOS\".to_owned()).into()),\n        ),\n        (\n            \"SELECT ACOS(null) AS acos\",\n            Ok(select_with_null!(acos; Null)),\n        ),\n        (\n            \"SELECT ACOS(true) AS acos\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"ACOS\".to_owned()).into()),\n        ),\n        (\n            \"SELECT ACOS() AS acos\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"ACOS\".to_owned(),\n                expected: 1,\n                found: 0,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT ACOS(1.0, 2.0) AS acos\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"ACOS\".to_owned(),\n                expected: 1,\n                found: 2,\n            }\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(atan, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE SingleItem (id INTEGER DEFAULT ATAN(3.14))\",\n            Ok(Payload::Create),\n        ),\n        (\n            r#\"INSERT INTO SingleItem VALUES (0)\"#,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"SELECT ATAN(0.5) AS atan1, ATAN(1) AS atan2\",\n            Ok(select!(\n                \"atan1\"        | \"atan2\";\n                F64            | F64 ;\n                0.5_f64.atan()   1.0_f64.atan()\n            )),\n        ),\n        (\n            \"SELECT ATAN('string') AS atan\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"ATAN\".to_owned()).into()),\n        ),\n        (\n            \"SELECT ATAN(null) AS atan\",\n            Ok(select_with_null!(atan; Null)),\n        ),\n        (\n            \"SELECT ATAN(true) AS atan\",\n            Err(EvaluateError::FunctionRequiresFloatValue(\"ATAN\".to_owned()).into()),\n        ),\n        (\n            \"SELECT ATAN() AS atan\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"ATAN\".to_owned(),\n                expected: 1,\n                found: 0,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT ATAN(1.0, 2.0) AS atan\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"ATAN\".to_owned(),\n                expected: 1,\n                found: 2,\n            }\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","md5.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::TranslateError, prelude::Value::*},\n};\n\ntest_case!(md5, {\n    let g = get_tester!();\n\n    g.test(\n        \"VALUES(MD5('GlueSQL'))\",\n        Ok(select!(\n            column1\n            Str;\n            \"4274ecec96f3ee59b51b168dc6137231\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\n        \"VALUES(MD5('GlueSQL Hi'))\",\n        Ok(select!(\n            column1\n            Str;\n            \"eab30259ac1a92b66794f301a6ac3ff3\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(r#\"VALUES(MD5(NULL))\"#, Ok(select_with_null!(column1; Null)))\n        .await;\n\n    g.test(\n        r#\"VALUES(MD5())\"#,\n        Err(TranslateError::FunctionArgsLengthNotMatching {\n            name: \"MD5\".to_owned(),\n            expected: 1,\n            found: 0,\n        }\n        .into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","now.rs"],"content":"use {\n    crate::*,\n    gluesql_core::prelude::{Payload, Value::*},\n};\n\ntest_case!(now, {\n    let g = get_tester!();\n\n    macro_rules! t {\n        ($timestamp: expr) =\u003e {\n            $timestamp.parse().unwrap()\n        };\n    }\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Item (time TIMESTAMP DEFAULT NOW())\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO Item VALUES\n                ('2021-10-13T06:42:40.364832862'),\n                ('9999-12-31T23:59:40.364832862');\",\n            Ok(Payload::Insert(2)),\n        ),\n        (\n            \"SELECT time FROM Item WHERE time \u003e NOW();\",\n            Ok(select!(\"time\" Timestamp; t!(\"9999-12-31T23:59:40.364832862\"))),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","nullif.rs"],"content":"use {\n    crate::*,\n    chrono::NaiveDate,\n    gluesql_core::{error::TranslateError, prelude::Value::*},\n};\n\ntest_case!(nullif, {\n    let g = get_tester!();\n\n    g.named_test(\n        \"NULLIF with equal integers should return NULL\",\n        \"SELECT NULLIF(0, 0) AS result\",\n        Ok(select_with_null!(\"result\"; Null)),\n    )\n    .await;\n\n    g.named_test(\n        \"NULLIF with different integers should return first arguments\",\n        \"SELECT NULLIF(1, 0) AS result\",\n        Ok(select_with_null!(\"result\"; I64(1))),\n    )\n    .await;\n\n    g.named_test(\n        \"NULLIF with equal strings should return NULL\",\n        \"SELECT NULLIF('hello', 'hello') AS result\",\n        Ok(select_with_null!(\"result\"; Null)),\n    )\n    .await;\n\n    g.named_test(\n        \"NULLIF with different strings should return first arguments\",\n        \"SELECT NULLIF('hello', 'helle') AS result\",\n        Ok(select_with_null!(\"result\"; Str(\"hello\".to_owned()))),\n    )\n    .await;\n\n    g.named_test(\n        \"NULLIF with equal date should return NULL\",\n        \"SELECT NULLIF(TO_DATE('2025-01-01', '%Y-%m-%d'), TO_DATE('2025-01-01', '%Y-%m-%d')) AS result\",\n        Ok(select_with_null!(\"result\"; Null)),\n    ).await;\n\n    g.named_test(\n        \"NULLIF with different date should return first arguments\",\n        \"SELECT NULLIF(TO_DATE('2025-01-01', '%Y-%m-%d'), TO_DATE('2025-01-02', '%Y-%m-%d')) AS result\",\n        Ok(select!(result; Date; NaiveDate::from_ymd_opt(2025, 1, 1).unwrap())),\n    ).await;\n\n    g.named_test(\n        \"NULLIF with zero argument should throw EvaluateError\",\n        \"SELECT NULLIF() AS result\",\n        Err(TranslateError::FunctionArgsLengthNotMatching {\n            name: \"NULLIF\".to_owned(),\n            expected: 2,\n            found: 0,\n        }\n        .into()),\n    )\n    .await;\n\n    g.named_test(\n        \"NULLIF with one argument should throw EvaluateError\",\n        \"SELECT NULLIF(1) AS result\",\n        Err(TranslateError::FunctionArgsLengthNotMatching {\n            name: \"NULLIF\".to_owned(),\n            expected: 2,\n            found: 1,\n        }\n        .into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","pi.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::TranslateError, prelude::Value::*},\n};\n\ntest_case!(pi, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT PI() AS pi\",\n            Ok(select!(\n                pi\n                F64;\n                std::f64::consts::PI\n            )),\n        ),\n        (\n            \"SELECT PI(0) AS pi\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"PI\".to_owned(),\n                expected: 0,\n                found: 1,\n            }\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","position.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::ValueError,\n        prelude::{\n            Payload,\n            Value::{self, *},\n        },\n    },\n};\n\ntest_case!(position, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\"CREATE TABLE Food (name Text null)\", Ok(Payload::Create)),\n        (\"INSERT INTO Food VALUES ('pork')\", Ok(Payload::Insert(1))),\n        (\"INSERT INTO Food VALUES ('burger')\", Ok(Payload::Insert(1))),\n        (\n            \"SELECT POSITION('e' IN name) AS test FROM Food\",\n            Ok(select!(test; I64; 0; 5)),\n        ),\n        (\n            \"SELECT POSITION('s' IN 'cheese') AS test\",\n            Ok(select!(test; I64; 5)),\n        ),\n        (\n            \"SELECT POSITION(NULL IN 'cheese') AS test\",\n            Ok(select_with_null!(test; Null)),\n        ),\n        (\n            \"SELECT POSITION(1 IN 'cheese') AS test\",\n            Err(ValueError::NonStringParameterInPosition {\n                from: Value::Str(\"cheese\".to_owned()),\n                sub: Value::I64(1),\n            }\n            .into()),\n        ),\n    ];\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","prepend.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::EvaluateError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(prepend, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Prepend (\n            id INTEGER,\n            items LIST,\n            element INTEGER,\n            element2 TEXT\n        );\n    \",\n    )\n    .await;\n    g.run(\n        r#\"\n            INSERT INTO Prepend VALUES\n            (1, '[1, 2, 3]',0, 'Foo');\n        \"#,\n    )\n    .await;\n    g.test(\n        r#\"select prepend(items, element) as myprepend from Prepend;\"#,\n        Ok(select!(\n           myprepend\n           List;\n           vec![I64(0), I64(1), I64(2), I64(3)]\n        )),\n    )\n    .await;\n    g.test(\n        r#\"select prepend(items, element2) as myprepend from Prepend;\"#,\n        Ok(select!(\n           myprepend\n           List;\n           vec![Str(\"Foo\".into()), I64(1), I64(2), I64(3)]\n        )),\n    )\n    .await;\n\n    g.test(\n        r#\"select prepend(element, element2) as myprepend from Prepend\"#,\n        Err(EvaluateError::ListTypeRequired.into()),\n    )\n    .await;\n\n    g.test(\n        r#\"CREATE TABLE Foo (\n                elements LIST\n            );\"#,\n        Ok(Payload::Create),\n    )\n    .await;\n\n    g.run(\n        r#\"\n            INSERT INTO Foo VALUES (PREPEND(CAST('[1, 2, 3]' AS LIST), 0));\n        \"#,\n    )\n    .await;\n    g.test(\n        r#\"select elements as myprepend from Foo;\"#,\n        Ok(select!(\n           myprepend\n           List;\n           vec![I64(0), I64(1), I64(2), I64(3)]\n        )),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","radians.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(radians, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT\n                RADIANS(180.0) as radians_1,\n                RADIANS(360.0) as radians_2\n            ;\",\n            Ok(select!(\n                radians_1              | radians_2;\n                F64                    | F64;\n                180.0_f64.to_radians()   360.0_f64.to_radians()\n            )),\n        ),\n        (\n            \"SELECT RADIANS(90) as radians_with_int\",\n            Ok(select!(\n                radians_with_int\n                F64;\n                f64::from(90).to_radians()\n            )),\n        ),\n        (\n            \"SELECT RADIANS(0) as radians_with_zero\",\n            Ok(select!(\n                radians_with_zero\n                F64;\n                f64::from(0).to_radians()\n            )),\n        ),\n        (\n            \"SELECT RADIANS(-900) as radians_with_zero\",\n            Ok(select!(\n                radians_with_zero\n                F64;\n                f64::from(-900).to_radians()\n            )),\n        ),\n        (\n            \"SELECT RADIANS(900) as radians_with_zero\",\n            Ok(select!(\n                radians_with_zero\n                F64;\n                f64::from(900).to_radians()\n            )),\n        ),\n        (\n            \"SELECT RADIANS(DEGREES(90)) as degrees_to_radians\",\n            Ok(select!(\n                degrees_to_radians\n                F64;\n                f64::from(90).to_degrees().to_radians()\n            )),\n        ),\n        (\n            \"SELECT RADIANS(0, 0) as radians_arg2\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"RADIANS\".to_owned(),\n                expected: 1,\n                found: 2,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT RADIANS() as radians_arg0\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"RADIANS\".to_owned(),\n                expected: 1,\n                found: 0,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT RADIANS('string') AS radians\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"RADIANS\")).into()),\n        ),\n        (\n            \"SELECT RADIANS(NULL) AS radians\",\n            Ok(select_with_null!(radians; Null)),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","rand.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(rand, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE SingleItem (qty Float DEFAULT ROUND(RAND()*100))\",\n            Ok(Payload::Create),\n        ),\n        (\n            r#\"INSERT INTO SingleItem VALUES (ROUND(RAND(1)*100))\"#,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"SELECT RAND(123) AS rand1, RAND(789.0) AS rand2\",\n            Ok(select!(\n                rand1               | rand2\n                F64                 | F64;\n                0.17325464426155657   0.9635218234007941\n            )),\n        ),\n        (\n            \"SELECT RAND('string') AS rand\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"RAND\")).into()),\n        ),\n        (\n            \"SELECT RAND(NULL) AS rand\",\n            Ok(select_with_null!(rand; Null)),\n        ),\n        (\n            \"SELECT RAND(TRUE) AS rand\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"RAND\")).into()),\n        ),\n        (\n            \"SELECT RAND(FALSE) AS rand\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"RAND\")).into()),\n        ),\n        (\n            \"SELECT RAND('string', 'string2') AS rand\",\n            Err(TranslateError::FunctionArgsLengthNotWithinRange {\n                name: \"RAND\".to_owned(),\n                expected_minimum: 0,\n                expected_maximum: 1,\n                found: 2,\n            }\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","repeat.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::{Payload, Value},\n    },\n};\n\ntest_case!(repeat, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Item (name TEXT DEFAULT REPEAT('hello', 2))\",\n            Ok(Payload::Create),\n        ),\n        (\"INSERT INTO Item VALUES ('hello')\", Ok(Payload::Insert(1))),\n        (\n            \"SELECT REPEAT(name, 2) AS test FROM Item\",\n            Ok(select!(\n                \"test\"\n                Value::Str;\n                \"hellohello\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT REPEAT('abcd') AS test FROM Item\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"REPEAT\".to_owned(),\n                expected: 2,\n                found: 1,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT REPEAT('abcd', 2, 2) AS test FROM Item\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"REPEAT\".to_owned(),\n                expected: 2,\n                found: 3,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT REPEAT(1, 1) AS test FROM Item\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"REPEAT\".to_owned()).into()),\n        ),\n        (\n            \"SELECT REPEAT(name, null) AS test FROM Item\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n        (\n            \"CREATE TABLE NullTest (name TEXT null)\",\n            Ok(Payload::Create),\n        ),\n        (\"INSERT INTO NullTest VALUES (null)\", Ok(Payload::Insert(1))),\n        (\n            \"SELECT REPEAT(name, 2) AS test FROM NullTest\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","replace.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::{Payload, Value},\n    },\n};\n\ntest_case!(replace, {\n    let g = get_tester!();\n\n    g.named_test(\n        \"test replace function works while creating a table simultaneously\",\n        \"CREATE TABLE Item (name TEXT DEFAULT REPLACE('SQL Tutorial', 'T', 'M'))\",\n        Ok(Payload::Create),\n    )\n    .await;\n    g.named_test(\n        \"test if the sample string gets inserted to table\",\n        \"INSERT INTO Item VALUES ('Tticky GlueTQL')\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n    g.named_test(\n        \"check id the replace function works with the previously inserted string\",\n        \"SELECT REPLACE(name,'T','S') AS test FROM Item;\",\n        Ok(select!(\n            \"test\"\n            Value::Str;\n            \"Sticky GlueSQL\".to_owned()\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test when one argument was given\",\n        \"SELECT REPLACE('GlueSQL') AS test FROM Item\",\n        Err(TranslateError::FunctionArgsLengthNotMatching {\n            name: \"REPLACE\".to_owned(),\n            expected: 3,\n            found: 1,\n        }\n        .into()),\n    )\n    .await;\n    g.named_test(\n        \"test when two arguments were given\",\n        \"SELECT REPLACE('GlueSQL','G') AS test FROM Item\",\n        Err(TranslateError::FunctionArgsLengthNotMatching {\n            name: \"REPLACE\".to_owned(),\n            expected: 3,\n            found: 2,\n        }\n        .into()),\n    )\n    .await;\n    g.named_test(\n        \"test when integers were given as arguments instead of string values\",\n        \"SELECT REPLACE(1,1,1) AS test FROM Item\",\n        Err(EvaluateError::FunctionRequiresStringValue(\"REPLACE\".to_owned()).into()),\n    )\n    .await;\n    g.named_test(\n        \"test when null was given as argument\",\n        \"SELECT REPLACE(name, null,null) AS test FROM Item\",\n        Ok(select_with_null!(test; Value::Null)),\n    )\n    .await;\n    g.named_test(\n        \"test if the table can be created will null value\",\n        \"CREATE TABLE NullTest (name TEXT null)\",\n        Ok(Payload::Create),\n    )\n    .await;\n    g.named_test(\n        \"test if null can be inserted\",\n        \"INSERT INTO NullTest VALUES (null)\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n    g.named_test(\n        \"test if replace works in null value\",\n        \"SELECT REPLACE(name, 'G','T') AS test FROM NullTest\",\n        Ok(select_with_null!(test; Value::Null)),\n    )\n    .await;\n    g.run(\"DELETE FROM Item\").await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","reverse.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::EvaluateError,\n        prelude::{Payload, Value},\n    },\n};\n\ntest_case!(reverse, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Item (name TEXT DEFAULT REVERSE('world'))\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO Item VALUES ('Let''s meet')\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"SELECT REVERSE(name) AS test FROM Item;\",\n            Ok(select!(\n                \"test\"\n                Value::Str;\n                \"teem s'teL\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT REVERSE(1) AS test FROM Item\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"REVERSE\".to_owned()).into()),\n        ),\n        (\n            \"CREATE TABLE NullTest (name TEXT null)\",\n            Ok(Payload::Create),\n        ),\n        (\"INSERT INTO NullTest VALUES (null)\", Ok(Payload::Insert(1))),\n        (\n            \"SELECT REVERSE(name) AS test FROM NullTest\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n    ];\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","round.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(round, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT\n                ROUND(0.3) AS round1,\n                ROUND(-0.8) AS round2,\n                ROUND(10) AS round3,\n                ROUND(6.87421) AS round4\n            ;\",\n            Ok(select!(\n                round1 | round2          | round3 | round4\n                F64    | F64             | F64    | F64;\n                0.0      f64::from(-1)   10.0     7.0\n            )),\n        ),\n        (\n            \"SELECT ROUND('string') AS round\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"ROUND\")).into()),\n        ),\n        (\n            \"SELECT ROUND(NULL) AS round\",\n            Ok(select_with_null!(round; Null)),\n        ),\n        (\n            \"SELECT ROUND(TRUE) AS round\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"ROUND\")).into()),\n        ),\n        (\n            \"SELECT ROUND(FALSE) AS round\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"ROUND\")).into()),\n        ),\n        (\n            \"SELECT ROUND('string', 'string2') AS round\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"ROUND\".to_owned(),\n                expected: 1,\n                found: 2,\n            }\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","sign.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(sign, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT\n                SIGN(2) AS SIGN1, \n                SIGN(-2) AS SIGN2, \n                SIGN(+2) AS SIGN3 \n            ;\",\n            Ok(select!(\n                \"SIGN1\" | \"SIGN2\"                 | \"SIGN3\";\n                I8      | I8                      | I8;\n                1_i8      f64::signum(-2.0) as i8    1_i8\n            )),\n        ),\n        (\n            \"SELECT\n                SIGN(2.0) AS SIGN1, \n                SIGN(-2.0) AS SIGN2, \n                SIGN(+2.0) AS SIGN3 \n            ;\",\n            Ok(select!(\n                \"SIGN1\" | \"SIGN2\"                 | \"SIGN3\";\n                I8      | I8                      | I8;\n                1_i8      f64::signum(-2.0) as i8   1_i8\n            )),\n        ),\n        (\n            \"SELECT\n                SIGN(0.0) AS SIGN1, \n                SIGN(-0.0) AS SIGN2, \n                SIGN(+0.0) AS SIGN3 \n            ;\",\n            Ok(select!(\n                \"SIGN1\" | \"SIGN2\" | \"SIGN3\";\n                I8      | I8      | I8;\n                0_i8      0_i8      0_i8\n            )),\n        ),\n        (\n            \"SELECT\n                SIGN(0) AS SIGN1, \n                SIGN(-0) AS SIGN2, \n                SIGN(+0) AS SIGN3 \n            ;\",\n            Ok(select!(\n                \"SIGN1\" | \"SIGN2\" | \"SIGN3\";\n                I8      | I8      | I8;\n                0_i8      0_i8      0_i8\n            )),\n        ),\n        (\n            \"SELECT SIGN('string') AS SIGN\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"SIGN\")).into()),\n        ),\n        (\n            \"SELECT SIGN(NULL) AS sign\",\n            Ok(select_with_null!(sign; Null)),\n        ),\n        (\n            \"SELECT SIGN(TRUE) AS sign\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"SIGN\")).into()),\n        ),\n        (\n            \"SELECT SIGN(FALSE) AS sign\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"SIGN\")).into()),\n        ),\n        (\n            \"SELECT SIGN('string', 'string2') AS SIGN\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"SIGN\".to_owned(),\n                expected: 1,\n                found: 2,\n            }\n            .into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","skip.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{executor::EvaluateError, prelude::Value::*},\n};\n\ntest_case!(skip, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n            CREATE TABLE Test (\n            id INTEGER,\n            list LIST\n            )\",\n    )\n    .await;\n    g.run(\"INSERT INTO Test (id, list) VALUES (1,'[1,2,3,4,5]')\")\n        .await;\n\n    g.named_test(\n        \"skip function with normal usage\",\n        \"SELECT SKIP(list, 2) as col1 FROM Test\",\n        Ok(select!(\n            col1\n            List;\n            vec![I64(3), I64(4), I64(5)]\n        )),\n    )\n    .await;\n    g.named_test(\n        \"skip function with out of range index\",\n        \"SELECT SKIP(list, 6) as col1 FROM Test\",\n        Ok(select!(\n            col1\n            List;\n            [].to_vec()\n        )),\n    )\n    .await;\n    g.named_test(\n        \"skip function with null list\",\n        \"SELECT SKIP(NULL, 2) as col1 FROM Test\",\n        Ok(select_with_null!(col1; Null)),\n    )\n    .await;\n    g.named_test(\n        \"skip function with null size\",\n        \"SELECT SKIP(list, NULL) as col1 FROM Test\",\n        Ok(select_with_null!(col1; Null)),\n    )\n    .await;\n    g.named_test(\n        \"skip function with non integer parameter\",\n        \"SELECT SKIP(list, 'd') as col1 FROM Test\",\n        Err(EvaluateError::FunctionRequiresIntegerValue(\"SKIP\".to_owned()).into()),\n    )\n    .await;\n    g.named_test(\n        \"skip function with non list\",\n        \"SELECT SKIP(id, 2) as col1 FROM Test\",\n        Err(EvaluateError::ListTypeRequired.into()),\n    )\n    .await;\n    g.named_test(\n        \"skip function with negative size\",\n        \"SELECT SKIP(id, -2) as col1 FROM Test\",\n        Err(EvaluateError::FunctionRequiresUSizeValue(\"SKIP\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","slice.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::EvaluateError, prelude::Value::*},\n};\n\ntest_case!(slice, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE Test (list LIST)\").await;\n\n    g.run(\"INSERT INTO Test VALUES ('[1,2,3,4]')\").await;\n\n    g.named_test(\n        \"slice start in index 0\",\n        \"SELECT SLICE(list, 0, 2) AS value FROM Test;\",\n        Ok(select!(\n            \"value\"\n            List;\n            vec![I64(1),I64(2)]\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"slice with size\",\n        \"SELECT SLICE(list, 0, 4) AS value FROM Test;\",\n        Ok(select!(\n            \"value\"\n            List;\n            vec![I64(1), I64(2),I64(3), I64(4)]\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"slice with size that pass over array size\",\n        \"SELECT SLICE(list, 2, 5) AS value FROM Test;\",\n        Ok(select!(\n            \"value\"\n            List;\n            vec![I64(3), I64(4)]\n        )),\n    )\n    .await;\n    g.named_test(\n        \"slice that over array size\",\n        \"SELECT SLICE(list, 100, 5) AS value FROM Test;\",\n        Ok(select!(\n            \"value\"\n            List;\n            vec![]\n        )),\n    )\n    .await;\n\n    g.named_test(\n        \"list value should be List Value\",\n        \"SELECT SLICE(1, 2, 2) AS value FROM Test;\",\n        Err(EvaluateError::ListTypeRequired.into()),\n    )\n    .await;\n    g.named_test(\n        \"start value should be Integer Value\",\n        \"SELECT SLICE(list, 'b', 5) AS value FROM Test;\",\n        Err(EvaluateError::FunctionRequiresIntegerValue(\"SLICE\".to_owned()).into()),\n    )\n    .await;\n    g.named_test(\n        \"start value should be Positive USIZE Value\",\n        \"SELECT SLICE(list, -1, 1) AS value FROM Test;\",\n        Ok(select!(\n            \"value\"\n            List;\n            vec![I64(4)]\n        )),\n    )\n    .await;\n    g.named_test(\n        \"start value should be Positive USIZE Value\",\n        \"SELECT SLICE(list, -2, 4) AS value FROM Test;\",\n        Ok(select!(\n            \"value\"\n            List;\n            vec![I64(3), I64(4)]\n        )),\n    )\n    .await;\n    g.named_test(\n        \"start value should be Positive USIZE Value\",\n        \"SELECT SLICE(list, 9999, 4) AS value FROM Test;\",\n        Ok(select!(\n            \"value\"\n            List;\n            vec![]\n        )),\n    )\n    .await;\n    g.named_test(\n        \"start value should be Positive USIZE Value\",\n        \"SELECT SLICE(list, 0, 1234) AS value FROM Test;\",\n        Ok(select!(\n            \"value\"\n            List;\n            vec![I64(1), I64(2),I64(3), I64(4)]\n        )),\n    )\n    .await;\n    g.named_test(\n        \"if absoulte value of negative index over length of list, covert to index 0\",\n        \"SELECT SLICE(list, -234, 4) AS value FROM Test;\",\n        Ok(select!(\n            \"value\"\n            List;\n            vec![I64(1), I64(2),I64(3), I64(4)]\n        )),\n    )\n    .await;\n    g.named_test(\n        \"length value should be Integer Value\",\n        \"SELECT SLICE(list, 2, 'a') AS value FROM Test;\",\n        Err(EvaluateError::FunctionRequiresIntegerValue(\"SLICE\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","sort.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::EvaluateError, prelude::Value::*},\n};\n\ntest_case!(sort, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE Test1 (list LIST)\").await;\n    g.run(\"INSERT INTO Test1 (list) VALUES ('[2, 1, 4, 3]')\")\n        .await;\n\n    g.named_test(\n        \"sort the list by default order\",\n        \"SELECT SORT(list) AS list FROM Test1\",\n        Ok(select!(list List; vec![I64(1), I64(2), I64(3), I64(4)])),\n    )\n    .await;\n\n    g.named_test(\n        \"sort the list by ascending order\",\n        \"SELECT SORT(list, 'ASC') AS list FROM Test1\",\n        Ok(select!(list List; vec![I64(1), I64(2), I64(3), I64(4)])),\n    )\n    .await;\n\n    g.named_test(\n        \"sort the list by descending order\",\n        \"SELECT SORT(list, 'DESC') AS list FROM Test1\",\n        Ok(select!(list List; vec![I64(4), I64(3), I64(2), I64(1)])),\n    )\n    .await;\n\n    g.named_test(\n        \"sort the list by wrong order\",\n        \"SELECT SORT(list, 'WRONG') AS list FROM Test1\",\n        Err(EvaluateError::InvalidSortOrder.into()),\n    )\n    .await;\n\n    g.named_test(\n        \"sort the list with not String typed order\",\n        \"SELECT SORT(list, 1) AS list FROM Test1\",\n        Err(EvaluateError::InvalidSortOrder.into()),\n    )\n    .await;\n\n    g.run(\"CREATE TABLE Test2 (id INTEGER, list LIST)\").await;\n    g.run(\"INSERT INTO Test2 (id, list) VALUES (1, '[2, \\\"1\\\", [\\\"a\\\", \\\"b\\\"], 3]')\")\n        .await;\n\n    g.named_test(\n        \"sort non-LIST items\",\n        \"SELECT SORT(id) AS list FROM Test2\",\n        Err(EvaluateError::ListTypeRequired.into()),\n    )\n    .await;\n\n    g.named_test(\n        \"sort the list with not comparable types\",\n        \"SELECT SORT(list) AS list FROM Test2\",\n        Err(EvaluateError::InvalidSortType.into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","splice.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{executor::EvaluateError, prelude::Value::*},\n};\n\ntest_case!(splice, {\n    let g = get_tester!();\n    g.run(\n        \"\n        CREATE TABLE ListTable (\n            id INTEGER,\n            items LIST\n        );\n        \",\n    )\n    .await;\n\n    g.run(\n        r#\"\n        INSERT INTO ListTable VALUES\n            (1, '[1, 2, 3]'),\n            (2, '[\"1\", \"2\", \"3\"]'),\n            (3, '[\"1\", 2, 3]')\n        \"#,\n    )\n    .await;\n\n    g.named_test(\n        \"SPLICE(CAST('[1, 2, 3, 4, 5]' AS List), 1, 3) should return '[1, 4, 5]'\",\n        \"SELECT SPLICE(CAST('[1, 2, 3, 4, 5]' AS List), 1, 3) AS actual\",\n        Ok(select!(actual List; vec![I64(1), I64(4), I64(5)])),\n    )\n    .await;\n\n    g.named_test(\n        \"SPLICE(CAST('[1, 2, 3, 4, 5]' AS List), 1, 3, CAST('[100, 99]' AS List)) should return '[1, 100, 99, 4, 5]'\",\n        \"SELECT SPLICE(CAST('[1, 2, 3, 4, 5]' AS List), 1, 3, CAST('[100, 99]' AS List)) AS actual\",\n        Ok(select!(actual List; vec![I64(1), I64(100), I64(99), I64(4), I64(5)]))\n    ).await;\n\n    g.named_test(\n        \"SPLICE(CAST('[1, 2, 3]' AS List), -1, 2, CAST('[100, 99]' AS List)) should return '[100, 99, 3]'\",\n        \"SELECT SPLICE(CAST('[1, 2, 3]' AS List), -1, 2, CAST('[100, 99]' AS List)) AS actual\",\n        Ok(select!(actual List; vec![I64(100), I64(99), I64(3)]))\n    ).await;\n\n    g.named_test(\n        \"SPLICE(CAST('[1, 2, 3]' AS List), 1, 100, CAST('[100, 99]' AS List)) should return '[1, 100, 99]')\",\n        \"SELECT SPLICE(CAST('[1, 2, 3]' AS List), 1, 100, CAST('[100, 99]' AS List)) AS actual\",\n        Ok(select!(actual List; vec!(I64(1), I64(100), I64(99))))\n    ).await;\n\n    g.named_test(\n        \"SPLICE(3, 1, 2) sholud return EvaluateError::ListTypeRequired\",\n        \"SELECT SPLICE(1, 2, 3) AS actual\",\n        Err(EvaluateError::ListTypeRequired.into()),\n    )\n    .await;\n\n    g.named_test(\n        \"SPLICE(CAST('[1, 2, 3]' AS List), 2, 4, 9) should return EvaluateError::ListTypeRequired\",\n        \"SELECT SPLICE(CAST('[1, 2, 3]' AS List), 2, 4, 9), AS actual\",\n        Err(EvaluateError::ListTypeRequired.into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","sqrt_power.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, ValueError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(sqrt, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT\n                SQRT(4.0) as sqrt_1,\n                SQRT(0.07) as sqrt_2\n            ;\",\n            Ok(select!(\n                sqrt_1 | sqrt_2;\n                F64    | F64;\n                2.0      0.07_f64.sqrt()\n            )),\n        ),\n        (\n            \"SELECT SQRT(64) as sqrt_with_int\",\n            Ok(select!(\n                sqrt_with_int\n                F64;\n                8.0\n            )),\n        ),\n        (\n            \"SELECT SQRT(0) as sqrt_with_zero\",\n            Ok(select!(\n                sqrt_with_zero\n                F64;\n                0.0\n            )),\n        ),\n        (\n            \"SELECT SQRT('string') AS sqrt\",\n            Err(ValueError::SqrtOnNonNumeric(Str(\"string\".to_owned())).into()),\n        ),\n        (\n            \"SELECT SQRT(NULL) AS sqrt\",\n            Ok(select_with_null!(sqrt; Null)),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(power, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"SELECT\n                POWER(2.0,4) as power_1,\n                POWER(0.07,3) as power_2\n            ;\",\n            Ok(select!(\n                power_1 | power_2;\n                F64     | F64;\n                16.0      0.07_f64.powf(3.0)\n            )),\n        ),\n        (\n            \"SELECT\n                POWER(0,4) as power_with_zero,\n                POWER(3,0) as power_to_zero\n            ;\",\n            Ok(select!(\n                power_with_zero | power_to_zero;\n                F64             | F64;\n                0.0               1.0\n            )),\n        ),\n        (\n            \"SELECT POWER(32,3.0) as power_with_float\",\n            Ok(select!(\n                power_with_float\n                F64;\n                f64::from(32).powf(3.0)\n            )),\n        ),\n        (\n            \"SELECT POWER('string','string') AS power\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"POWER\")).into()),\n        ),\n        (\n            \"SELECT POWER(2.0,'string') AS power\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"POWER\")).into()),\n        ),\n        (\n            \"SELECT POWER('string',2.0) AS power\",\n            Err(EvaluateError::FunctionRequiresFloatValue(String::from(\"POWER\")).into()),\n        ),\n        (\n            \"SELECT POWER(NULL,NULL) AS power\",\n            Ok(select_with_null!(power; Null)),\n        ),\n        (\n            \"SELECT POWER(2.0,NULL) AS power\",\n            Ok(select_with_null!(power; Null)),\n        ),\n        (\n            \"SELECT POWER(NULL,2.0) AS power\",\n            Ok(select_with_null!(power; Null)),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","substr.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast::BinaryOperator,\n        error::EvaluateError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(substr, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Item (name TEXT DEFAULT SUBSTR('abc', 0, 2))\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO Item VALUES ('Blop mc blee'), ('B'), ('Steven the \u0026long named$ folken!')\",\n            Ok(Payload::Insert(3)),\n        ),\n        (\"CREATE TABLE SingleItem (food TEXT)\", Ok(Payload::Create)),\n        (\n            \"INSERT INTO SingleItem VALUES (SUBSTR('LobSter',1))\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"CREATE TABLE NullName (name TEXT NULL)\",\n            Ok(Payload::Create),\n        ),\n        (\n            r#\"INSERT INTO NullName VALUES (NULL)\"#,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"CREATE TABLE NullNumber (number INTEGER NULL)\",\n            Ok(Payload::Create),\n        ),\n        (\n            r#\"INSERT INTO NullNumber VALUES (NULL)\"#,\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            r#\"SELECT SUBSTR(SUBSTR(name, 1), 1) AS test FROM Item\"#,\n            Ok(select!(\n                \"test\"\n                Str;\n                \"Blop mc blee\".to_owned();\n                \"B\".to_owned();\n                \"Steven the \u0026long named$ folken!\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT * FROM Item WHERE name = SUBSTR('ABC', 2, 1)\",\n            Ok(select!(\n                \"name\"\n                Str;\n                \"B\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT * FROM Item WHERE SUBSTR(name, 1, 1) = 'B'\",\n            Ok(select!(\n                \"name\"\n                Str;\n                \"Blop mc blee\".to_owned();\n                \"B\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT * FROM Item WHERE 'B' = SUBSTR(name, 1, 1)\",\n            Ok(select!(\n                \"name\"\n                Str;\n                \"Blop mc blee\".to_owned();\n                \"B\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT * FROM Item WHERE SUBSTR(name, 1, 1) = UPPER('b')\",\n            Ok(select!(\n                \"name\"\n                Str;\n                \"Blop mc blee\".to_owned();\n                \"B\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT * FROM Item WHERE SUBSTR(name, 1, 4) = SUBSTR('Blop', 1)\",\n            Ok(select!(\n                \"name\"\n                Str;\n                \"Blop mc blee\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT * FROM Item WHERE SUBSTR(name, 1, 4) \u003e SUBSTR('Blop', 1)\",\n            Ok(select!(\n                \"name\"\n                Str;\n                \"Steven the \u0026long named$ folken!\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT * FROM Item WHERE SUBSTR(name, 1, 4) \u003e 'B'\",\n            Ok(select!(\n                \"name\"\n                Str;\n                \"Blop mc blee\".to_owned();\n                \"Steven the \u0026long named$ folken!\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT * FROM Item WHERE 'B' \u003c SUBSTR(name, 1, 4)\",\n            Ok(select!(\n                \"name\"\n                Str;\n                \"Blop mc blee\".to_owned();\n                \"Steven the \u0026long named$ folken!\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT * FROM Item WHERE SUBSTR(name, 1, 4) \u003e UPPER('b')\",\n            Ok(select!(\n                \"name\"\n                Str;\n                \"Blop mc blee\".to_owned();\n                \"Steven the \u0026long named$ folken!\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT * FROM Item WHERE UPPER('b') \u003c SUBSTR(name, 1, 4)\",\n            Ok(select!(\n                \"name\"\n                Str;\n                \"Blop mc blee\".to_owned();\n                \"Steven the \u0026long named$ folken!\".to_owned()\n            )),\n        ),\n        (\n            r#\"SELECT SUBSTR(name, 2) AS test FROM Item\"#,\n            Ok(select!(\n                \"test\"\n                Str;\n                \"lop mc blee\".to_owned();\n                \"\".to_owned();\n                \"teven the \u0026long named$ folken!\".to_owned()\n            )),\n        ),\n        (\n            r#\"SELECT SUBSTR(name, 999) AS test FROM Item\"#,\n            Ok(select!(\n                \"test\"\n                Str;\n                \"\".to_owned();\n                \"\".to_owned();\n                \"\".to_owned()\n            )),\n        ),\n        (\n            r#\"SELECT SUBSTR('ABC', -3, 0) AS test FROM SingleItem\"#,\n            Ok(select!(\n                \"test\"\n                Str;\n                \"\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT SUBSTR('ABC', 0, 3) AS test FROM SingleItem\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"AB\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT SUBSTR('ABC', 1, 3) AS test FROM SingleItem\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"ABC\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT SUBSTR('ABC', 1, 999) AS test FROM SingleItem\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"ABC\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT SUBSTR('ABC', -1000, 1003) AS test FROM SingleItem\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"AB\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT SUBSTR('ABC', -1, 3) AS test FROM SingleItem\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"A\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT SUBSTR('ABC', -1, 4) AS test FROM SingleItem\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"AB\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT SUBSTR(SUBSTR('ABC', 2, 3), 1, 1) AS test FROM SingleItem\",\n            Ok(select!(\n                \"test\"\n                Str;\n                \"B\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT SUBSTR('ABC', -1, NULL) AS test FROM SingleItem\",\n            Ok(select_with_null!(test; Null)),\n        ),\n        (\n            r#\"SELECT SUBSTR(name, 3) AS test FROM NullName\"#,\n            Ok(select_with_null!(test; Null)),\n        ),\n        (\n            r#\"SELECT SUBSTR('Words', number) AS test FROM NullNumber\"#,\n            Ok(select_with_null!(test; Null)),\n        ),\n        (\n            \"SELECT * FROM SingleItem WHERE TRUE AND SUBSTR('wine',2,3)\",\n            Err(EvaluateError::BooleanTypeRequired(\"ine\".to_owned()).into()),\n        ),\n        (\n            r#\"SELECT SUBSTR(1, 1) AS test FROM SingleItem\"#,\n            Err(EvaluateError::FunctionRequiresStringValue(\"SUBSTR\".to_owned()).into()),\n        ),\n        (\n            r#\"SELECT SUBSTR('Words', 1.1) AS test FROM SingleItem\"#,\n            Err(EvaluateError::FunctionRequiresIntegerValue(\"SUBSTR\".to_owned()).into()),\n        ),\n        (\n            r#\"SELECT SUBSTR('Words', 1, -4) AS test FROM SingleItem\"#,\n            Err(EvaluateError::NegativeSubstrLenNotAllowed.into()),\n        ),\n        (\n            r#\"SELECT SUBSTR('123', 2, 3) - '3' AS test FROM SingleItem\"#,\n            Err(EvaluateError::UnsupportedBinaryOperation {\n                left: \"StrSlice { source: \\\"123\\\", range: 1..3 }\".to_owned(),\n                op: BinaryOperator::Minus,\n                right: \"Literal(Text(\\\"3\\\"))\".to_owned(),\n            }\n            .into()),\n        ),\n        (\n            r#\"SELECT +SUBSTR('123', 2, 3) AS test FROM SingleItem\"#,\n            Err(EvaluateError::UnsupportedUnaryPlus(\"23\".to_owned()).into()),\n        ),\n        (\n            r#\"SELECT -SUBSTR('123', 2, 3) AS test FROM SingleItem\"#,\n            Err(EvaluateError::UnsupportedUnaryMinus(\"23\".to_owned()).into()),\n        ),\n        (\n            r#\"SELECT SUBSTR('123', 2, 3)! AS test FROM SingleItem\"#,\n            Err(EvaluateError::UnsupportedUnaryFactorial(\"23\".to_owned()).into()),\n        ),\n        (\n            r#\"SELECT ~SUBSTR('123', 2, 3) AS test FROM SingleItem\"#,\n            Err(EvaluateError::IncompatibleUnaryBitwiseNotOperation(\"23\".to_owned()).into()),\n        ),\n    ];\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","take.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{executor::EvaluateError, prelude::Value::*},\n};\n\ntest_case!(take, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Take (\n            items LIST\n        );\n        \",\n    )\n    .await;\n    g.run(\n        r#\"\n            INSERT INTO Take VALUES\n            (TAKE(CAST('[1, 2, 3, 4, 5]' AS LIST), 5));\n        \"#,\n    )\n    .await;\n    g.test(\n        r#\"select take(items, 0) as mygoodtake from Take;\"#,\n        Ok(select!(\n            mygoodtake\n            List;\n            vec![]\n        )),\n    )\n    .await;\n    g.test(\n        r#\"select take(items, 3) as mygoodtake from Take;\"#,\n        Ok(select!(\n            mygoodtake\n            List;\n            vec![I64(1), I64(2), I64(3)]\n        )),\n    )\n    .await;\n    g.test(\n        r#\"select take(items, 5) as mygoodtake from Take;\"#,\n        Ok(select!(\n            mygoodtake\n            List;\n            vec![I64(1), I64(2), I64(3), I64(4), I64(5)]\n        )),\n    )\n    .await;\n    g.test(\n        r#\"select take(items, 10) as mygoodtake from Take;\"#,\n        Ok(select!(\n            mygoodtake\n            List;\n            vec![I64(1), I64(2), I64(3), I64(4), I64(5)]\n        )),\n    )\n    .await;\n    g.test(\n        r#\"select take(NULL, 3) as mynulltake from Take;\"#,\n        Ok(select_with_null!(mynulltake; Null)),\n    )\n    .await;\n    g.test(\n        r#\"select take(items, NULL) as mynulltake from Take;\"#,\n        Ok(select_with_null!(mynulltake; Null)),\n    )\n    .await;\n\n    g.test(\n        r#\"select take(items, -5) as mymistake from Take;\"#,\n        Err(EvaluateError::FunctionRequiresUSizeValue(\"TAKE\".to_owned()).into()),\n    )\n    .await;\n    g.test(\n        r#\"select take(items, 'TEST') as mymistake from Take;\"#,\n        Err(EvaluateError::FunctionRequiresIntegerValue(\"TAKE\".to_owned()).into()),\n    )\n    .await;\n    g.test(\n        r#\"select take(0, 3) as mymistake from Take;\"#,\n        Err(EvaluateError::ListTypeRequired.into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","to_date.rs"],"content":"use {\n    crate::*,\n    chrono::{NaiveDate, NaiveTime, format::ParseErrorKind},\n    gluesql_core::{\n        error::EvaluateError,\n        prelude::{Error, Value::*},\n    },\n};\n\ntest_case!(to_date, {\n    let g = get_tester!();\n\n    fn assert_chrono_error_kind_eq(error: Error, kind: ParseErrorKind) {\n        match error {\n            Error::Evaluate(EvaluateError::FormatParseError(err)) =\u003e {\n                assert_eq!(err.kind(), kind)\n            }\n            _ =\u003e panic!(\"invalid error: {error}\"),\n        }\n    }\n\n    let test_cases = vec![\n        (\n            \"VALUES(TO_DATE('2017-06-15', '%Y-%m-%d'))\",\n            Ok(select!(\n                column1\n                Date;\n                NaiveDate::from_ymd_opt(2017, 6, 15).unwrap()\n            )),\n        ),\n        (\n            \"VALUES(TO_TIMESTAMP('2015-09-05 23:56:04', '%Y-%m-%d %H:%M:%S'))\",\n            Ok(select!(\n                column1\n                Timestamp;\n                NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap()\n            )),\n        ),\n        (\n            \"VALUES(TO_TIME('23:56:04', '%H:%M:%S'))\",\n            Ok(select!(\n                column1\n                Time;\n                NaiveTime::from_hms_opt(23, 56, 4).unwrap()\n            )),\n        ),\n        (\n            \"SELECT TO_DATE('2017-06-15','%Y-%m-%d') AS date\",\n            Ok(select!(\n                date\n                Date;\n                NaiveDate::from_ymd_opt(2017, 6, 15).unwrap()\n            )),\n        ),\n        (\n            \"SELECT TO_DATE('2017-jun-15','%Y-%b-%d') AS date\",\n            Ok(select!(\n                date\n                Date;\n                NaiveDate::from_ymd_opt(2017, 6, 15).unwrap()\n            )),\n        ),\n        (\n            \"SELECT TO_TIME('23:56:04','%H:%M:%S') AS time\",\n            Ok(select!(\n                time\n                Time;\n                NaiveTime::from_hms_opt(23, 56, 4).unwrap()\n            )),\n        ),\n        (\n            \"SELECT TO_TIMESTAMP('2015-09-05 23:56:04', '%Y-%m-%d %H:%M:%S') AS timestamp\",\n            Ok(select!(\n                timestamp\n                Timestamp;\n                NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap()\n            )),\n        ),\n        (\n            \"SELECT TO_DATE(DATE '2017-06-15','%Y-%m-%d') AS date\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"TO_DATE\".to_owned()).into()),\n        ),\n        (\n            \"SELECT TO_TIMESTAMP(TIMESTAMP '2015-09-05 23:56:04','%Y-%m-%d') AS date\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"TO_TIMESTAMP\".to_owned()).into()),\n        ),\n        (\n            \"SELECT TO_TIME(TIME '23:56:04','%H:%M:%S') AS date\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"TO_TIME\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n\n    let error_cases = [\n        (\n            g.run_err(\"SELECT TO_DATE('2015-09-05', '%Y-%m') AS date\")\n                .await,\n            chrono::format::ParseErrorKind::TooLong,\n        ),\n        (\n            g.run_err(\"SELECT TO_TIME('23:56', '%H:%M:%S') AS time\")\n                .await,\n            chrono::format::ParseErrorKind::TooShort,\n        ),\n        (\n            g.run_err(\"SELECT TO_TIMESTAMP('2015-05 23', '%Y-%d %H') AS timestamp\")\n                .await,\n            chrono::format::ParseErrorKind::NotEnough,\n        ),\n        (\n            g.run_err(\n                \"SELECT TO_TIMESTAMP('2015-14-05 23:56:12','%Y-%m-%d %H:%M:%S') AS timestamp\",\n            )\n            .await,\n            chrono::format::ParseErrorKind::OutOfRange,\n        ),\n        (\n            g.run_err(\n                \"SELECT TO_TIMESTAMP('2015-14-05 23:56:12','%Y-%m-%d %H:%M:%S') AS timestamp\",\n            )\n            .await,\n            chrono::format::ParseErrorKind::OutOfRange,\n        ),\n        (\n            g.run_err(\n                \"SELECT TO_TIMESTAMP('2015-14-05 23:56:12','%Y-%m-%d %H:%M:%%S') AS timestamp;\",\n            )\n            .await,\n            chrono::format::ParseErrorKind::OutOfRange,\n        ),\n        (\n            g.run_err(\n                \"SELECT TO_TIMESTAMP('2015-09-05 23:56:04', '%Y-%m-%d %H:%M:%M') AS timestamp\",\n            )\n            .await,\n            chrono::format::ParseErrorKind::Impossible,\n        ),\n        (\n            g.run_err(\n                \"SELECT TO_TIMESTAMP('2015-09-05 23:56:04', '%Y-%m-%d %H:%M:%') AS timestamp\",\n            )\n            .await,\n            chrono::format::ParseErrorKind::BadFormat,\n        ),\n    ];\n\n    for (error, kind) in error_cases {\n        assert_chrono_error_kind_eq(error, kind);\n    }\n});\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","trim.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::EvaluateError,\n        prelude::{Payload, Value},\n    },\n};\n\ntest_case!(trim, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Item (\n                name TEXT DEFAULT TRIM(LEADING 'a' FROM 'aabc') || TRIM('   good  ')\n            )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO Item VALUES\n                ('      Left blank'),\n                ('Right blank     '),\n                ('     Blank!     '),\n                ('Not Blank');\",\n            Ok(Payload::Insert(4)),\n        ),\n        (\n            \"SELECT TRIM(name) FROM Item;\",\n            Ok(select!(\n                \"TRIM(name)\"\n                Value::Str;\n                \"Left blank\".to_owned();\n                \"Right blank\".to_owned();\n                \"Blank!\".to_owned();\n                \"Not Blank\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT TRIM(1) FROM Item;\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"TRIM\".to_owned()).into()),\n        ),\n        (\n            \"CREATE TABLE NullName (name TEXT NULL)\",\n            Ok(Payload::Create),\n        ),\n        (\"INSERT INTO NullName VALUES (NULL)\", Ok(Payload::Insert(1))),\n        (\n            \"SELECT TRIM(name) AS test FROM NullName;\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n        (\n            r#\"SELECT TRIM(BOTH NULL FROM name) FROM NullName;\"#,\n            Ok(select_with_null!(\n                \"TRIM(BOTH NULL FROM name)\";\n                Value::Null\n            )),\n        ),\n        (\n            \"SELECT TRIM(BOTH NULL FROM 'name') AS test\",\n            Ok(select_with_null!(test; Value::Null)),\n        ),\n        (\n            \"SELECT TRIM(TRAILING NULL FROM name) FROM NullName;\",\n            Ok(select_with_null!(\n                \"TRIM(TRAILING NULL FROM name)\";\n                Value::Null\n            )),\n        ),\n        (\n            \"SELECT TRIM(LEADING NULL FROM name) FROM NullName;\",\n            Ok(select_with_null!(\n                \"TRIM(LEADING NULL FROM name)\";\n                Value::Null\n            )),\n        ),\n        (\"CREATE TABLE Test (name TEXT)\", Ok(Payload::Create)),\n        (\n            \"INSERT INTO Test VALUES\n                    ('     blank     '), \n                    ('xxxyzblankxyzxx'), \n                    ('xxxyzblank     '),\n                    ('     blankxyzxx'),\n                    ('  xyzblankxyzxx'),\n                    ('xxxyzblankxyz  ');\",\n            Ok(Payload::Insert(6)),\n        ),\n        (\n            \"SELECT TRIM(BOTH 'xyz' FROM name) FROM Test;\",\n            Ok(select!(\n                \"TRIM(BOTH 'xyz' FROM name)\"\n                Value::Str;\n                \"     blank     \".to_owned();\n                \"blank\".to_owned();\n                \"blank     \".to_owned();\n                \"     blank\".to_owned();\n                \"  xyzblank\".to_owned();\n                \"blankxyz  \".to_owned()\n            )),\n        ),\n        (\n            \"SELECT TRIM(LEADING 'xyz' FROM name) FROM Test;\",\n            Ok(select!(\n                \"TRIM(LEADING 'xyz' FROM name)\"\n                Value::Str;\n                \"     blank     \".to_owned();\n                \"blankxyzxx\".to_owned();\n                \"blank     \".to_owned();\n                \"     blankxyzxx\".to_owned();\n                \"  xyzblankxyzxx\".to_owned();\n                \"blankxyz  \".to_owned()\n            )),\n        ),\n        (\n            r#\"SELECT TRIM(TRAILING 'xyz' FROM name) FROM Test;\"#,\n            Ok(select!(\n                \"TRIM(TRAILING 'xyz' FROM name)\"\n                Value::Str;\n                \"     blank     \".to_owned();\n                \"xxxyzblank\".to_owned();\n                \"xxxyzblank     \".to_owned();\n                \"     blank\".to_owned();\n                \"  xyzblank\".to_owned();\n                \"xxxyzblankxyz  \".to_owned()\n            )),\n        ),\n        (\n            \"SELECT\n                TRIM(BOTH '  hello  ') AS both,\n                TRIM(LEADING '  hello  ') AS leading,\n                TRIM(TRAILING '  hello  ') AS trailing\n            \",\n            Ok(select!(\n                both               | leading              | trailing\n                Value::Str         | Value::Str           | Value::Str;\n                \"hello\".to_owned()   \"hello  \".to_owned()   \"  hello\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT\n                TRIM(BOTH TRIM(BOTH ' potato ')) AS Case1,\n                TRIM('xyz' FROM 'x') AS Case2,\n                TRIM(TRAILING 'xyz' FROM 'xx') AS Case3\n            \",\n            Ok(select!(\n                Case1               | Case2         | Case3\n                Value::Str          | Value::Str    | Value::Str;\n                \"potato\".to_owned()   \"\".to_owned()   \"\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT TRIM('1' FROM 1) AS test FROM Test\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"TRIM\".to_owned()).into()),\n        ),\n        (\n            \"SELECT TRIM(1 FROM TRIM('t' FROM 'tartare')) AS test FROM Test\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"TRIM\".to_owned()).into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","upper_lower.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(upper_lower, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Item (\n                name TEXT DEFAULT UPPER('abc'),\n                opt_name TEXT NULL DEFAULT LOWER('ABC')\n            )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO Item VALUES ('abcd', 'efgi'), ('Abcd', NULL), ('ABCD', 'EfGi')\",\n            Ok(Payload::Insert(3)),\n        ),\n        (\n            \"SELECT name FROM Item WHERE LOWER(name) = 'abcd';\",\n            Ok(select!(\n                name Str;\n                \"abcd\".to_owned();\n                \"Abcd\".to_owned();\n                \"ABCD\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LOWER(name), UPPER(name) FROM Item;\",\n            Ok(select!(\n                \"LOWER(name)\"      | \"UPPER(name)\"\n                Str                | Str;\n                \"abcd\".to_owned()    \"ABCD\".to_owned();\n                \"abcd\".to_owned()    \"ABCD\".to_owned();\n                \"abcd\".to_owned()    \"ABCD\".to_owned()\n            )),\n        ),\n        (\n            \"\n            SELECT\n                LOWER('Abcd') as lower,\n                UPPER('abCd') as upper\n            FROM Item LIMIT 1;\n            \",\n            Ok(select!(\n                lower             | upper\n                Str               | Str;\n                \"abcd\".to_owned()   \"ABCD\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT LOWER(opt_name), UPPER(opt_name) FROM Item;\",\n            Ok(select_with_null!(\n                \"LOWER(opt_name)\"      | \"UPPER(opt_name)\";\n                Str(\"efgi\".to_owned())   Str(\"EFGI\".to_owned());\n                Null                     Null;\n                Str(\"efgi\".to_owned())   Str(\"EFGI\".to_owned())\n            )),\n        ),\n        (\n            \"SELECT LOWER() FROM Item\",\n            Err(TranslateError::FunctionArgsLengthNotMatching {\n                name: \"LOWER\".to_owned(),\n                expected: 1,\n                found: 0,\n            }\n            .into()),\n        ),\n        (\n            \"SELECT LOWER(1) FROM Item\",\n            Err(EvaluateError::FunctionRequiresStringValue(\"LOWER\".to_owned()).into()),\n        ),\n        (\n            \"SELECT LOWER(a =\u003e 2) FROM Item\",\n            Err(TranslateError::NamedFunctionArgNotSupported.into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function","values.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::EvaluateError, prelude::Value},\n};\n\ntest_case!(values, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE USER (id INTEGER, data MAP);\").await;\n    g.run(\n        r#\"\n            INSERT INTO USER VALUES \n            (1, '{\"id\": 1, \"name\": \"alice\", \"is_male\": false}'),\n            (2, '{\"name\": \"bob\"}'),\n            (3, '{}');\n        \"#,\n    )\n    .await;\n\n    g.named_test(\n         \"return all values from map by descending order\",\n        r#\"SELECT SORT(VALUES(data), 'DESC') as result FROM USER WHERE id=1\"#,\n        {\n            Ok(select!(result; Value::List; vec![Value::I64(1), Value::Bool(false), Value::Str(\"alice\".to_owned())]))\n        }\n    ).await;\n    g.named_test(\n         \"return all values from map by ascending order\",\n        r#\"SELECT SORT(VALUES(data), 'ASC') as result FROM USER WHERE id=1\"#,\n        {\n            Ok(select!(result; Value::List; vec![Value::Str(\"alice\".to_owned()), Value::Bool(false), Value::I64(1)]))\n        }\n    ).await;\n    g.named_test(\n        \"return all values from map\",\n        r#\"SELECT VALUES(data) as result FROM USER WHERE id=2\"#,\n        Ok(select!(result; Value::List; vec![Value::Str(\"bob\".to_owned())])),\n    )\n    .await;\n    g.named_test(\n        \"return null from empty map\",\n        r#\"SELECT VALUES(data) as result FROM USER WHERE id=3\"#,\n        Ok(select!(result; Value::List; vec![])),\n    )\n    .await;\n    g.named_test(\n        \"return argument type error\",\n        r#\"SELECT VALUES(id) FROM USER WHERE id=1\"#,\n        Err(EvaluateError::MapTypeRequired.into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","function.rs"],"content":"pub mod abs;\npub mod add_month;\npub mod append;\npub mod ascii;\npub mod cast;\npub mod ceil;\npub mod chr;\npub mod coalesce;\npub mod concat;\npub mod concat_ws;\npub mod current_date;\npub mod current_time;\npub mod current_timestamp;\npub mod dedup;\npub mod degrees;\npub mod div_mod;\npub mod entries;\npub mod exp_log;\npub mod extract;\npub mod find_idx;\npub mod floor;\npub mod format;\npub mod gcd_lcm;\npub mod generate_uuid;\npub mod geometry;\npub mod greatest;\npub mod hex;\npub mod ifnull;\npub mod iif;\npub mod initcap;\npub mod is_empty;\npub mod keys;\npub mod last_day;\npub mod left_right;\npub mod length;\npub mod lpad_rpad;\npub mod ltrim_rtrim;\npub mod math_function;\npub mod md5;\npub mod now;\npub mod nullif;\npub mod pi;\npub mod position;\npub mod prepend;\npub mod radians;\npub mod rand;\npub mod repeat;\npub mod replace;\npub mod reverse;\npub mod round;\npub mod sign;\npub mod skip;\npub mod slice;\npub mod sort;\npub mod splice;\npub mod sqrt_power;\npub mod substr;\npub mod take;\npub mod to_date;\npub mod trim;\npub mod upper_lower;\npub mod values;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","index","and.rs"],"content":"use {\n    crate::*,\n    Value::*,\n    gluesql_core::{ast::IndexOperator::*, prelude::*},\n};\n\ntest_case!(and, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE NullIdx (\n    id INTEGER,\n    date DATE,\n    flag BOOLEAN\n)\",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO NullIdx\n            (id, date, flag)\n        VALUES\n            (1, '2020-03-20', True),\n            (2, '2021-01-01', True),\n            (3, '1989-02-01', False),\n            (4, '2002-06-11', True),\n            (5, '2030-03-01', False);\n    \",\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_id ON NullIdx (id)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n    g.test(\n        \"CREATE INDEX idx_date ON NullIdx (date)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n\n    macro_rules! date {\n        ($date: expr) =\u003e {\n            $date.parse().unwrap()\n        };\n    }\n\n    g.test_idx(\n        \"\n        SELECT id, date, flag FROM NullIdx\n        WHERE\n            date \u003c DATE '2040-12-24'\n            AND flag = false\n        \",\n        Ok(select!(\n            id  | date                | flag\n            I64 | Date                | Bool;\n            3     date!(\"1989-02-01\")   false;\n            5     date!(\"2030-03-01\")   false\n        )),\n        idx!(idx_date, Lt, \"DATE '2040-12-24'\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"\n        SELECT * FROM NullIdx\n        WHERE\n            flag = False\n            AND date \u003c DATE '2020-12-24'\n        \",\n        Ok(select!(\n            id  | date                | flag\n            I64 | Date                | Bool;\n            3     date!(\"1989-02-01\")   false\n        )),\n        idx!(idx_date, Lt, \"DATE '2020-12-24'\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"\n        SELECT * FROM NullIdx\n        WHERE\n            flag = False\n            AND DATE '2030-11-24' \u003e date\n            AND id \u003e 1\n        \",\n        Ok(select!(\n            id  | date                | flag\n            I64 | Date                | Bool;\n            3     date!(\"1989-02-01\")   false;\n            5     date!(\"2030-03-01\")   false\n        )),\n        idx!(idx_date, Lt, \"DATE '2030-11-24'\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"\n        SELECT * FROM NullIdx\n        WHERE\n            flag = False\n            AND id \u003e 1\n            AND DATE '2030-11-24' \u003e date\n        \",\n        Ok(select!(\n            id  | date                | flag\n            I64 | Date                | Bool;\n            3     date!(\"1989-02-01\")   false;\n            5     date!(\"2030-03-01\")   false\n        )),\n        idx!(idx_id, Gt, \"1\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"\n        SELECT * FROM NullIdx\n        WHERE\n            flag = False\n            AND id * 2 \u003e 6\n        \",\n        Ok(select!(\n            id  | date                | flag\n            I64 | Date                | Bool;\n            5     date!(\"2030-03-01\")   false\n        )),\n        idx!(),\n    )\n    .await;\n\n    g.test_idx(\n        \"\n        SELECT * FROM NullIdx\n        WHERE\n            flag = False\n            AND id * 2 \u003e 6\n            AND (date = DATE '2030-03-01' AND flag != True);\n        \",\n        Ok(select!(\n            id  | date                | flag\n            I64 | Date                | Bool;\n            5     date!(\"2030-03-01\")   false\n        )),\n        idx!(idx_date, Eq, \"DATE '2030-03-01'\"),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","index","basic.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast::IndexOperator::*,\n        error::{AlterError, IndexError, TranslateError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(basic, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Test (\n            id INTEGER,\n            num INTEGER,\n            name TEXT\n        )\n    \",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO Test\n            (id, num, name)\n        VALUES\n            (1, 2, 'Hello'),\n            (1, 17, 'World'),\n            (11, 7, 'Great'),\n            (4, 7, 'Job');\n    \",\n    )\n    .await;\n\n    g.test(\"CREATE INDEX idx_id ON Test (id)\", Ok(Payload::CreateIndex))\n        .await;\n    g.test(\n        \"CREATE INDEX idx_name ON Test (name)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n    g.test(\n        \"CREATE INDEX idx_id2 ON Test (id + num)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned();\n            1     17    \"World\".to_owned();\n            11    7     \"Great\".to_owned();\n            4     7     \"Job\".to_owned()\n        )),\n        idx!(),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id \u003c 20\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned();\n            1     17    \"World\".to_owned();\n            4     7     \"Job\".to_owned();\n            11    7     \"Great\".to_owned()\n        )),\n        idx!(idx_id, Lt, \"20\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE 20 \u003e id\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned();\n            1     17    \"World\".to_owned();\n            4     7     \"Job\".to_owned();\n            11    7     \"Great\".to_owned()\n        )),\n        idx!(idx_id, Lt, \"20\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id \u003c= 4\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned();\n            1     17    \"World\".to_owned();\n            4     7     \"Job\".to_owned()\n        )),\n        idx!(idx_id, LtEq, \"4\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE 4 \u003e= id\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned();\n            1     17    \"World\".to_owned();\n            4     7     \"Job\".to_owned()\n        )),\n        idx!(idx_id, LtEq, \"4\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id \u003e= 4\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            4     7     \"Job\".to_owned();\n            11    7     \"Great\".to_owned()\n        )),\n        idx!(idx_id, GtEq, \"4\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE 4 \u003c= id\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            4     7     \"Job\".to_owned();\n            11    7     \"Great\".to_owned()\n        )),\n        idx!(idx_id, GtEq, \"4\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id \u003e 0\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned();\n            1     17    \"World\".to_owned();\n            4     7     \"Job\".to_owned();\n            11    7     \"Great\".to_owned()\n        )),\n        idx!(idx_id, Gt, \"0\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE 4 \u003c id\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            11    7     \"Great\".to_owned()\n        )),\n        idx!(idx_id, Gt, \"4\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id = 1\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned();\n            1     17    \"World\".to_owned()\n        )),\n        idx!(idx_id, Eq, \"1\"),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO Test (id, num, name) VALUES (1, 30, 'New one')\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE 1 = id\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned();\n            1     17    \"World\".to_owned();\n            1     30    \"New one\".to_owned()\n        )),\n        idx!(idx_id, Eq, \"1\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE name = 'New one'\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     30    \"New one\".to_owned()\n        )),\n        idx!(idx_name, Eq, \"'New one'\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id + num = 10\",\n        Ok(Payload::Select {\n            labels: vec![\"id\".to_owned(), \"num\".to_owned(), \"name\".to_owned()],\n            rows: vec![],\n        }),\n        idx!(idx_id2, Eq, \"10\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id + num \u003c 11\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_id2, Lt, \"11\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE 11 \u003e id + num\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_id2, Lt, \"11\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id + num = 18\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     17    \"World\".to_owned();\n            11    7     \"Great\".to_owned()\n        )),\n        idx!(idx_id2, Eq, \"18\"),\n    )\n    .await;\n\n    g.test(\"DELETE FROM Test WHERE id = 11\", Ok(Payload::Delete(1)))\n        .await;\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id + num = 3\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_id2, Eq, \"3\"),\n    )\n    .await;\n\n    g.test(\n        \"UPDATE Test SET id = id + 1 WHERE id = 1;\",\n        Ok(Payload::Update(3)),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM Test WHERE 19 = id + num\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            2     17    \"World\".to_owned()\n        )),\n        idx!(idx_id2, Eq, \"19\"),\n    )\n    .await;\n\n    g.test(\"DROP INDEX Test.idx_id2;\", Ok(Payload::DropIndex))\n        .await;\n    g.test_idx(\n        \"SELECT * FROM Test WHERE id + num = 19\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            2     17    \"World\".to_owned()\n        )),\n        idx!(),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id FROM Test WHERE id + num = id\",\n        Ok(Payload::Select {\n            labels: vec![\"id\".to_owned()],\n            rows: vec![],\n        }),\n        idx!(),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id \u003c 20\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            2     2     \"Hello\".to_owned();\n            2     17    \"World\".to_owned();\n            2     30    \"New one\".to_owned();\n            4     7     \"Job\".to_owned()\n        )),\n        idx!(idx_id, Lt, \"20\"),\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_com ON Test (id, num)\",\n        Err(TranslateError::CompositeIndexNotSupported.into()),\n    )\n    .await;\n\n    g.test(\n        \"DROP INDEX Test.idx_id, Test.idx_id2\",\n        Err(TranslateError::TooManyParamsInDropIndex.into()),\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_wow On Test (a.b)\",\n        Err(AlterError::UnsupportedIndexExpr(expr(\"a.b\")).into()),\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_wow ON Abc (name)\",\n        Err(AlterError::TableNotFound(\"Abc\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"DROP INDEX NoNameTable.idx_id\",\n        Err(IndexError::TableNotFound(\"NoNameTable\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_name ON Test (name || id)\",\n        Err(IndexError::IndexNameAlreadyExists(\"idx_name\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"DROP INDEX Test.idx_aaa\",\n        Err(IndexError::IndexNameDoesNotExist(\"idx_aaa\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","index","expr.rs"],"content":"use {\n    crate::{expr as parse_expr, *},\n    gluesql_core::{\n        ast::IndexOperator::*,\n        error::AlterError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(expr, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Test (\n            id INTEGER,\n            num INTEGER,\n            name TEXT\n        )\n    \",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO Test\n            (id, num, name)\n        VALUES\n            (1, 2, 'Hello');\n    \",\n    )\n    .await;\n\n    g.test(\"CREATE INDEX idx_id ON Test (id)\", Ok(Payload::CreateIndex))\n        .await;\n\n    g.test(\n        \"CREATE INDEX idx_typed_string ON Test ((id))\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_binary_op ON Test (num || name);\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_unary_op ON Test (-num);\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_cast ON Test (CAST(id AS TEXT));\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_literal ON Test (100)\",\n        Err(AlterError::IdentifierNotFound(parse_expr(\"100\")).into()),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO Test VALUES (4, 7, 'Well');\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, num, name FROM Test\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned();\n            4     7     \"Well\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id \u003c= 1\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_id, LtEq, \"1\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE id \u003c= (1)\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_id, LtEq, \"(1)\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE num || name = '2Hello'\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_binary_op, Eq, \"'2Hello'\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE (num || name) = '2Hello'\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_binary_op, Eq, \"'2Hello'\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE '7Well' = (num || name)\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            4     7     \"Well\".to_owned()\n        )),\n        idx!(idx_binary_op, Eq, \"'7Well'\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE -num \u003c -2\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            4     7     \"Well\".to_owned()\n        )),\n        idx!(idx_unary_op, Lt, \"-2\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, num, name FROM Test WHERE CAST(id AS TEXT) = '4'\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            4     7     \"Well\".to_owned()\n        )),\n        idx!(idx_cast, Eq, \"'4'\"),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","index","nested.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast::IndexOperator::*,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(nested, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE User (\n    id INTEGER,\n    num INTEGER,\n    name TEXT\n)\",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO User\n            (id, num, name)\n        VALUES\n            (1, 2, 'Hello'),\n            (2, 4, 'World'),\n            (3, 9, 'Office'),\n            (4, 1, 'Origin'),\n            (5, 2, 'Builder');\n    \",\n    )\n    .await;\n\n    g.test(\"CREATE INDEX idx_id ON User (id)\", Ok(Payload::CreateIndex))\n        .await;\n\n    g.test_idx(\n        \"\n        SELECT * FROM User u1\n        WHERE (\n            SELECT u1.id = id FROM User\n            WHERE id = 1\n            LIMIT 1\n        )\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_id, Eq, \"1\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"\n        SELECT * FROM User u1\n        WHERE EXISTS(\n            SELECT * FROM User\n            WHERE id = 1 AND u1.id = id\n        )\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_id, Eq, \"1\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"\n        SELECT * FROM User u1\n        WHERE id IN (\n            SELECT * FROM User WHERE id = 1\n        )\",\n        Ok(select!(\n            id  | num | name\n            I64 | I64 | Str;\n            1     2     \"Hello\".to_owned()\n        )),\n        idx!(idx_id, Eq, \"1\"),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","index","null.rs"],"content":"use {\n    crate::*,\n    Value::*,\n    gluesql_core::{ast::IndexOperator::*, prelude::*},\n};\n\ntest_case!(null, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE NullIdx (\n    id INTEGER NULL,\n    date DATE NULL,\n    flag BOOLEAN NULL\n)\",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO NullIdx\n            (id, date, flag)\n        VALUES\n            (NULL, NULL,         True),\n            (1,    '2020-03-20', True),\n            (2,    NULL,         NULL),\n            (3,    '1989-02-01', False),\n            (4,    NULL,         True);\n    \",\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_id ON NullIdx (id)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n    g.test(\n        \"CREATE INDEX idx_date ON NullIdx (date)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n    g.test(\n        \"CREATE INDEX idx_flag ON NullIdx (flag)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n\n    macro_rules! date {\n        ($date: expr) =\u003e {\n            $date.parse().unwrap()\n        };\n    }\n\n    g.test_idx(\n        \"SELECT id, date, flag FROM NullIdx WHERE date \u003c DATE '2040-12-24'\",\n        Ok(select!(\n            id  | date                | flag\n            I64 | Date                | Bool;\n            3     date!(\"1989-02-01\")   false;\n            1     date!(\"2020-03-20\")   true\n        )),\n        idx!(idx_date, Lt, \"DATE '2040-12-24'\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, date, flag FROM NullIdx WHERE date \u003e= DATE '2040-12-24'\",\n        Ok(select_with_null!(\n            id     | date | flag;\n            Null     Null   Bool(true);\n            I64(2)   Null   Null;\n            I64(4)   Null   Bool(true)\n        )),\n        idx!(idx_date, GtEq, \"DATE '2040-12-24'\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM NullIdx WHERE flag = True\",\n        Ok(select_with_null!(\n            id     | date                      | flag;\n            Null     Null                        Bool(true);\n            I64(1)   Date(date!(\"2020-03-20\"))   Bool(true);\n            I64(4)   Null                        Bool(true)\n        )),\n        idx!(idx_flag, Eq, \"True\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM NullIdx WHERE id \u003e 2\",\n        Ok(select_with_null!(\n            id     | date                      | flag;\n            I64(3)   Date(date!(\"1989-02-01\"))   Bool(false);\n            I64(4)   Null                        Bool(true);\n            Null     Null                        Bool(true)\n        )),\n        idx!(idx_id, Gt, \"2\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM NullIdx WHERE id IS NULL\",\n        Ok(select_with_null!(\n            id   | date | flag;\n            Null   Null   Bool(true)\n        )),\n        idx!(idx_id, Eq, \"NULL\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT id, date, flag FROM NullIdx WHERE date IS NOT NULL\",\n        Ok(select!(\n            id     | date | flag\n            I64 | Date                | Bool;\n            3     date!(\"1989-02-01\")   false;\n            1     date!(\"2020-03-20\")   true\n        )),\n        idx!(idx_date, Lt, \"NULL\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM NullIdx WHERE id = NULL\",\n        Ok(Payload::Select {\n            labels: vec![\"id\".to_owned(), \"date\".to_owned(), \"flag\".to_owned()],\n            rows: vec![],\n        }),\n        idx!(),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","index","order_by.rs"],"content":"use {crate::*, Value::*, gluesql_core::prelude::*};\n\ntest_case!(order_by, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE Test (\n    id INTEGER,\n    num INTEGER NULL,\n    name TEXT\n)\",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Test (id, num, name)\n        VALUES\n            (1, 2,    'Hello'),\n            (1, 9,    'Wild'),\n            (3, NULL, 'World'),\n            (4, 7,    'Monday');\n   \",\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_name ON Test (name)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n    g.test(\n        \"CREATE INDEX idx_id_num_asc ON Test (id + num ASC)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n    g.test(\n        \"CREATE INDEX idx_num_desc ON Test (num DESC)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n\n    macro_rules! s {\n        ($v: literal) =\u003e {\n            Str($v.to_owned())\n        };\n    }\n\n    g.test_idx(\n        \"SELECT * FROM Test ORDER BY name\",\n        Ok(select_with_null!(\n            id     | num    | name;\n            I64(1)   I64(2)   s!(\"Hello\");\n            I64(4)   I64(7)   s!(\"Monday\");\n            I64(1)   I64(9)   s!(\"Wild\");\n            I64(3)   Null     s!(\"World\")\n        )),\n        idx!(idx_name),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM Test ORDER BY id + num\",\n        Ok(select_with_null!(\n            id     | num    | name;\n            I64(1)   I64(2)   s!(\"Hello\");\n            I64(1)   I64(9)   s!(\"Wild\");\n            I64(4)   I64(7)   s!(\"Monday\");\n            I64(3)   Null     s!(\"World\")\n        )),\n        idx!(idx_id_num_asc),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM Test ORDER BY id + num ASC\",\n        Ok(select_with_null!(\n            id     | num    | name;\n            I64(1)   I64(2)   s!(\"Hello\");\n            I64(1)   I64(9)   s!(\"Wild\");\n            I64(4)   I64(7)   s!(\"Monday\");\n            I64(3)   Null     s!(\"World\")\n        )),\n        idx!(idx_id_num_asc, ASC),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM Test where id \u003c 4 ORDER BY num DESC\",\n        Ok(select_with_null!(\n            id     | num    | name;\n            I64(3)   Null     s!(\"World\");\n            I64(1)   I64(9)   s!(\"Wild\");\n            I64(1)   I64(2)   s!(\"Hello\")\n        )),\n        idx!(idx_num_desc, DESC),\n    )\n    .await;\n});\n\ntest_case!(order_by_multi, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE Multi (\n    id INTEGER,\n    num INTEGER\n)\",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO Multi VALUES\n            (3, 50), (3, 10), (3, 40), (3, 30), (3, 20),\n            (4, 10), (4, 30), (4, 20), (4, 40), (4, 50),\n            (2, 20), (2, 10), (2, 30), (2, 40), (2, 50),\n            (5, 40), (5, 50), (5, 10), (5, 20), (5, 30),\n            (1, 30), (1, 40), (1, 20), (1, 50), (1, 10);\n    \",\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_id_num ON Multi (id + num DESC)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM Multi ORDER BY id ASC, num ASC\",\n        Ok(select!(id | num I64 | I64;\n            1 10; 1 20; 1 30; 1 40; 1 50;\n            2 10; 2 20; 2 30; 2 40; 2 50;\n            3 10; 3 20; 3 30; 3 40; 3 50;\n            4 10; 4 20; 4 30; 4 40; 4 50;\n            5 10; 5 20; 5 30; 5 40; 5 50\n        )),\n        idx!(),\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_num ON Multi (num ASC)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM Multi ORDER BY id ASC, num ASC\",\n        Ok(select!(id | num I64 | I64;\n            1 10; 1 20; 1 30; 1 40; 1 50;\n            2 10; 2 20; 2 30; 2 40; 2 50;\n            3 10; 3 20; 3 30; 3 40; 3 50;\n            4 10; 4 20; 4 30; 4 40; 4 50;\n            5 10; 5 20; 5 30; 5 40; 5 50\n        )),\n        idx!(idx_num, ASC),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM Multi ORDER BY num ASC, id ASC\",\n        Ok(select!(id | num I64 | I64;\n            1 10; 2 10; 3 10; 4 10; 5 10;\n            1 20; 2 20; 3 20; 4 20; 5 20;\n            1 30; 2 30; 3 30; 4 30; 5 30;\n            1 40; 2 40; 3 40; 4 40; 5 40;\n            1 50; 2 50; 3 50; 4 50; 5 50\n        )),\n        idx!(),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM Multi ORDER BY id DESC, id + num DESC\",\n        Ok(select!(id | num I64 | I64;\n            5 50; 5 40; 5 30; 5 20; 5 10;\n            4 50; 4 40; 4 30; 4 20; 4 10;\n            3 50; 3 40; 3 30; 3 20; 3 10;\n            2 50; 2 40; 2 30; 2 20; 2 10;\n            1 50; 1 40; 1 30; 1 20; 1 10\n        )),\n        idx!(idx_id_num, DESC),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM Multi ORDER BY id ASC, id + num DESC\",\n        Ok(select!(id | num I64 | I64;\n            1 50; 1 40; 1 30; 1 20; 1 10;\n            2 50; 2 40; 2 30; 2 20; 2 10;\n            3 50; 3 40; 3 30; 3 20; 3 10;\n            4 50; 4 40; 4 30; 4 20; 4 10;\n            5 50; 5 40; 5 30; 5 20; 5 10\n        )),\n        idx!(idx_id_num, DESC),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","index","showindexes.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::ExecuteError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(showindexes, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE Test (\n    id INTEGER,\n    num INTEGER,\n    name TEXT\n)\",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO Test\n            (id, num, name)\n        VALUES\n            (1, 2, 'Hello'),\n            (1, 17, 'World'),\n            (11, 7, 'Great'),\n            (4, 7, 'Job');\n    \",\n    )\n    .await;\n\n    g.test(\"CREATE INDEX idx_id ON Test (id)\", Ok(Payload::CreateIndex))\n        .await;\n    g.test(\n        \"CREATE INDEX idx_name ON Test (name)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n    g.test(\n        \"CREATE INDEX idx_id2 ON Test (id + num)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n    g.test(\n        \"show indexes from Test\",\n        Ok(select!(\n            TABLE_NAME        | INDEX_NAME            | ORDER             | EXPRESSION            | UNIQUENESS;\n            Str               | Str                   | Str               | Str                   | Bool;\n            \"Test\".to_owned()   \"idx_id\".to_owned()     \"BOTH\".to_owned()   \"id\".to_owned()         false;\n            \"Test\".to_owned()   \"idx_name\".to_owned()   \"BOTH\".to_owned()   \"name\".to_owned()       false;\n            \"Test\".to_owned()   \"idx_id2\".to_owned()    \"BOTH\".to_owned()   \"id + num\".to_owned()   false\n        ))\n    ).await;\n    g.test(\n        \"show indexes from NoTable\",\n        Err(ExecuteError::TableNotFound(\"NoTable\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","index","value.rs"],"content":"use {\n    crate::*,\n    Value::*,\n    chrono::NaiveTime,\n    gluesql_core::{ast::IndexOperator::*, prelude::*},\n};\n\ntest_case!(value, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE IdxValue (\n    id INTEGER NULL,\n    time TIME NULL,\n    flag BOOLEAN\n)\",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO IdxValue\n        VALUES\n            (NULL, '01:30 PM', True),\n            (1,    '12:10 AM', False),\n            (2,    NULL,       True);\n    \",\n    )\n    .await;\n\n    g.test(\n        \"CREATE INDEX idx_id ON IdxValue (id)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n    g.test(\n        \"CREATE INDEX idx_time ON IdxValue (time)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n    g.test(\n        \"CREATE INDEX idx_flag ON IdxValue (flag)\",\n        Ok(Payload::CreateIndex),\n    )\n    .await;\n\n    let t = |h, m| NaiveTime::from_hms_opt(h, m, 0).unwrap();\n\n    g.test_idx(\n        \"SELECT * FROM IdxValue WHERE id = 1\",\n        Ok(select!(\n            id  | time     | flag\n            I64 | Time     | Bool;\n            1     t(0, 10)    false\n        )),\n        idx!(idx_id, Eq, \"1\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM IdxValue WHERE time \u003c= TIME '13:30:00'\",\n        Ok(select_with_null!(\n            id     | time            | flag;\n            I64(1)   Time(t(0, 10))    Bool(false);\n            Null     Time(t(13, 30))   Bool(true)\n        )),\n        idx!(idx_time, LtEq, \"TIME '13:30:00'\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM IdxValue WHERE flag = ('ABC' IS NULL)\",\n        Ok(select_with_null!(\n            id     | time           | flag;\n            I64(1)   Time(t(0, 10))   Bool(false)\n        )),\n        idx!(idx_flag, Eq, \"('ABC' IS NULL)\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM IdxValue WHERE flag = (100 IS NOT NULL)\",\n        Ok(select_with_null!(\n            id     | time            | flag;\n            Null     Time(t(13, 30))   Bool(true);\n            I64(2)   Null              Bool(true)\n        )),\n        idx!(idx_flag, Eq, \"(100 IS NOT NULL)\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM IdxValue WHERE id = +1\",\n        Ok(select!(\n            id  | time     | flag\n            I64 | Time     | Bool;\n            1     t(0, 10)   false\n        )),\n        idx!(idx_id, Eq, \"+1\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM IdxValue WHERE id = CAST('1' AS INTEGER)\",\n        Ok(select!(\n            id  | time      | flag\n            I64 | Time      | Bool;\n            1     t(0, 10)    false\n        )),\n        idx!(idx_id, Eq, \"CAST('1' AS INTEGER)\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM IdxValue WHERE id = (1)\",\n        Ok(select!(\n            id  | time      | flag\n            I64 | Time      | Bool;\n            1     t(0, 10)    false\n        )),\n        idx!(idx_id, Eq, \"(1)\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM IdxValue WHERE id = 1 + 1 * 5 / 5\",\n        Ok(select_with_null!(\n            id     | time | flag;\n            I64(2)   Null   Bool(true)\n        )),\n        idx!(idx_id, Eq, \"1 + 1 * 5 / 5\"),\n    )\n    .await;\n\n    g.test_idx(\n        \"SELECT * FROM IdxValue WHERE flag = (True AND False)\",\n        Ok(select!(\n            id  | time     | flag\n            I64 | Time     | Bool;\n            1     t(0, 10)   false\n        )),\n        idx!(idx_flag, Eq, \"(True AND False)\"),\n    )\n    .await;\n});\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","index.rs"],"content":"mod and;\nmod basic;\nmod expr;\nmod nested;\nmod null;\nmod order_by;\nmod showindexes;\nmod value;\n\npub use {\n    and::and,\n    basic::basic,\n    expr::expr,\n    nested::nested,\n    null::null,\n    order_by::{order_by, order_by_multi},\n    showindexes::showindexes,\n    value::value,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","inline_view.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, TranslateError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(inline_view, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE InnerTable (\n                id INTEGER,\n                name TEXT \n            )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"CREATE TABLE OuterTable (\n                id INTEGER,\n                name TEXT \n            )\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO InnerTable VALUES (1, 'GLUE'), (2, 'SQL'), (3, 'SQL')\",\n            Ok(Payload::Insert(3)),\n        ),\n        (\n            \"INSERT INTO OuterTable VALUES (1, 'WORKS!'), (2, 'EXTRA')\",\n            Ok(Payload::Insert(2)),\n        ),\n        (\n            \"SELECT * FROM InnerTable\",\n            Ok(select!(\n                    id  | name\n                    I64 | Str;\n                    1     \"GLUE\".to_owned();\n                    2     \"SQL\".to_owned();\n                    3     \"SQL\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT *\n            FROM (\n                SELECT COUNT(*) AS cnt FROM InnerTable\n            ) AS InlineView\",\n            Ok(select!(cnt;I64;3)),\n        ),\n        (\n            // inline view with WHERE clause\n            \"SELECT *\n            FROM (\n                SELECT COUNT(*) AS cnt\n                FROM InnerTable\n                WHERE id \u003e 1\n            ) AS InlineView\",\n            Ok(select!(cnt;I64;2)),\n        ),\n        (\n            // inline view without column alias\n            \"SELECT *\n            FROM (\n                SELECT COUNT(*) FROM InnerTable\n            ) AS InlineView\",\n            Ok(select!(\"COUNT(*)\";I64;3)),\n        ),\n        (\n            // cannot use inline view without table alias\n            \"SELECT *\n            FROM (\n                SELECT COUNT(*) AS cnt FROM InnerTable\n            )\",\n            Err(TranslateError::LackOfAlias.into()),\n        ),\n        (\n            // inline view more than twice\n            \"SELECT *\n            FROM (\n                SELECT *\n                FROM (\n                    SELECT COUNT(*) AS cnt FROM InnerTable\n                ) AS InlineView\n            ) AS InlineView2\",\n            Ok(select!(cnt;I64;3)),\n        ),\n        (\n            // join - Expr\n            \"SELECT *\n            FROM OuterTable\n            JOIN (\n                SELECT id, name FROM InnerTable\n            ) AS InlineView ON OuterTable.id = InlineView.id\",\n            Ok(select!(\n                id  | name                | id  | name\n                I64 | Str                 | I64 | Str;\n                1     \"WORKS!\".to_owned()   1     \"GLUE\".to_owned();\n                2     \"EXTRA\".to_owned()    2     \"SQL\".to_owned()\n            )),\n        ),\n        (\n            // join - Expr should include join column\n            \"SELECT *\n            FROM OuterTable JOIN (\n                SELECT name FROM InnerTable\n            ) AS InlineView ON OuterTable.id = InlineView.id\",\n            Err(EvaluateError::CompoundIdentifierNotFound {\n                table_alias: \"InlineView\".to_owned(),\n                column_name: \"id\".to_owned(),\n            }\n            .into()),\n        ),\n        (\n            // join - Expr with WHERE clause\n            \"SELECT *\n            FROM OuterTable\n            JOIN (\n                SELECT id, name\n                FROM InnerTable\n                WHERE id = 1 \n            ) AS InlineView ON OuterTable.id = InlineView.id\",\n            Ok(select!(\n                id  | name                | id  | name\n                I64 | Str                 | I64 | Str;\n                1     \"WORKS!\".to_owned()   1     \"GLUE\".to_owned()\n            )),\n        ),\n        (\n            // join - Wildcard\n            \"SELECT *\n            FROM OuterTable JOIN (\n                SELECT * FROM InnerTable\n            ) AS InlineView ON OuterTable.id = InlineView.id\",\n            Ok(select!(\n                id  | name                | id  | name\n                I64 | Str                 | I64 | Str;\n                1     \"WORKS!\".to_owned()   1     \"GLUE\".to_owned();\n                2     \"EXTRA\".to_owned()    2     \"SQL\".to_owned()\n            )),\n        ),\n        (\n            // join - QualifiedWildcard at inner projection\n            \"SELECT * \n            FROM OuterTable JOIN (\n                SELECT InnerTable.* FROM InnerTable\n            ) AS InlineView ON OuterTable.id = InlineView.id\",\n            Ok(select!(\n                id  | name                | id  | name\n                I64 | Str                 | I64 | Str;\n                1     \"WORKS!\".to_owned()   1     \"GLUE\".to_owned();\n                2     \"EXTRA\".to_owned()    2     \"SQL\".to_owned()\n            )),\n        ),\n        (\n            // join - QualifiedWildcard at outer projection\n            \"SELECT InlineView.*\n            FROM OuterTable JOIN (\n                SELECT InnerTable.*, 'once' AS literal FROM InnerTable\n            ) AS InlineView ON OuterTable.id = InlineView.id\",\n            Ok(select!(\n                id  | name               | literal\n                I64 | Str                | Str;\n                1     \"GLUE\".to_owned()    \"once\".to_owned();\n                2     \"SQL\".to_owned()     \"once\".to_owned()\n            )),\n        ),\n        (\n            // join - inline view more than twice\n            \"SELECT * \n            FROM OuterTable\n            JOIN (\n                SELECT OuterTable.id, OuterTable.name \n                FROM OuterTable \n                JOIN (\n                    SELECT * FROM InnerTable\n                ) AS InlineView ON OuterTable.id = InlineView.id\n            ) AS InlineView2 ON OuterTable.id = InlineView2.id\",\n            Ok(select!(\n                id  | name                | id  | name\n                I64 | Str                 | I64 | Str;\n                1     \"WORKS!\".to_owned()   1     \"WORKS!\".to_owned();\n                2     \"EXTRA\".to_owned()   2     \"EXTRA\".to_owned()\n            )),\n        ),\n        (\n            // group by\n            \"SELECT *\n            FROM (\n                SELECT name, count(*) as cnt\n                FROM InnerTable\n                GROUP BY name\n             ) AS InlineView\",\n            Ok(select!(\n                name             | cnt\n                Str              | I64;\n                \"GLUE\".to_owned()  1;\n                \"SQL\".to_owned()   2\n            )),\n        ),\n        (\n            // limit\n            \"SELECT * FROM (\n                SELECT *\n                FROM InnerTable\n                LIMIT 1\n             ) AS InlineView\",\n            Ok(select!(\n                id  | name\n                I64 | Str;\n                1    \"GLUE\".to_owned()\n            )),\n        ),\n        (\n            // offset\n            \"SELECT * FROM (\n                SELECT *\n                FROM InnerTable\n                OFFSET 2\n             ) AS InlineView\",\n            Ok(select!(\n                id  | name\n                I64 | Str;\n                3    \"SQL\".to_owned()\n            )),\n        ),\n        (\n            // order by: can return error by different plan in the future\n            \"SELECT * FROM (\n                SELECT *\n                FROM InnerTable\n                ORDER BY id desc\n             ) AS InlineView\",\n            Ok(select!(\n                id  | name\n                I64 | Str;\n                3    \"SQL\".to_owned();\n                2    \"SQL\".to_owned();\n                1    \"GLUE\".to_owned()\n            )),\n        ),\n        (\n            // unsupported implicit join\n            \"SELECT *\n            FROM OuterTable, (\n                    SELECT id\n                    FROM InnerTable\n                    WHERE InnerTable.id = OuterTable.id\n                ) AS InlineView\",\n            Err(TranslateError::TooManyTables.into()),\n        ),\n        (\n            // unsupported select distinct\n            \"SELECT DISTINCT id FROM OuterTable\",\n            Err(TranslateError::SelectDistinctNotSupported.into()),\n        ),\n        (\n            // inline view subquery + join with inline view\n            \"SELECT *\n            FROM (\n                SELECT *\n                FROM InnerTable \n            ) AS InlineView\n            Join OuterTable ON InlineView.id = OuterTable.id\",\n            Ok(select!(\n                id  | name                | id  | name\n                I64 | Str                 | I64 | Str;\n                1     \"GLUE\".to_owned()   1     \"WORKS!\".to_owned();\n                2     \"SQL\".to_owned()    2     \"EXTRA\".to_owned()\n            )),\n        ),\n    ];\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","insert.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::InsertError,\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(insert, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE Test (\n    id INTEGER DEFAULT 1,\n    num INTEGER NULL,\n    name TEXT NOT NULL\n);\",\n    )\n    .await;\n\n    g.named_test(\n        \"basic insert - single item\",\n        \"INSERT INTO Test (id, num, name) VALUES (1, 2, 'Hi boo');\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n\n    g.named_test(\n        \"insert multiple rows\",\n        \"\n            INSERT INTO Test (id, num, name)\n            VALUES\n                (3, 9, 'Kitty!'),\n                (2, 7, 'Monsters');\n        \",\n        Ok(Payload::Insert(2)),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO Test VALUES(17, 30, 'Sullivan');\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO Test (num, name) VALUES (28, 'Wazowski');\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO Test (name) VALUES ('The end');\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n\n    g.test(\n        \"INSERT INTO Test (id, num) VALUES (1, 10);\",\n        Err(InsertError::LackOfRequiredColumn(\"name\".to_owned()).into()),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM Test;\",\n        Ok(select_with_null!(\n            id     | num     | name;\n            I64(1)   I64(2)    Str(\"Hi boo\".to_owned());\n            I64(3)   I64(9)    Str(\"Kitty!\".to_owned());\n            I64(2)   I64(7)    Str(\"Monsters\".to_owned());\n            I64(17)  I64(30)   Str(\"Sullivan\".to_owned());\n            I64(1)   I64(28)   Str(\"Wazowski\".to_owned());\n            I64(1)   Null      Str(\"The end\".to_owned())\n        )),\n    )\n    .await;\n\n    g.run(\"CREATE TABLE Target AS SELECT * FROM Test WHERE 1 = 0;\")\n        .await;\n\n    g.named_test(\n        \"insert into target from source\",\n        \"INSERT INTO Target SELECT * FROM Test;\",\n        Ok(Payload::Insert(6)),\n    )\n    .await;\n\n    g.named_test(\n        \"target rows are equivalent to source rows\",\n        \"SELECT * FROM Target;\",\n        Ok(select_with_null!(\n            id     | num     | name;\n            I64(1)   I64(2)    Str(\"Hi boo\".to_owned());\n            I64(3)   I64(9)    Str(\"Kitty!\".to_owned());\n            I64(2)   I64(7)    Str(\"Monsters\".to_owned());\n            I64(17)  I64(30)   Str(\"Sullivan\".to_owned());\n            I64(1)   I64(28)   Str(\"Wazowski\".to_owned());\n            I64(1)   Null      Str(\"The end\".to_owned())\n        )),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","join.rs"],"content":"use {\n    crate::*,\n    Value::*,\n    gluesql_core::{\n        error::{PlanError, TranslateError},\n        prelude::*,\n    },\n};\n\ntest_case!(join, {\n    let g = get_tester!();\n\n    let create_sqls: [\u0026str; 2] = [\n        \"\n        CREATE TABLE Player (\n            id INTEGER,\n            name TEXT\n        );\n    \",\n        \"\n        CREATE TABLE Item (\n            id INTEGER,\n            quantity INTEGER,\n            player_id INTEGER\n        );\n    \",\n    ];\n\n    for sql in create_sqls {\n        g.run(sql).await;\n    }\n\n    let delete_sqls = [\"DELETE FROM Player\", \"DELETE FROM Item\"];\n\n    for sql in delete_sqls {\n        g.run(sql).await;\n    }\n\n    let insert_sqls = [\n        \"\n        INSERT INTO Player (id, name) VALUES\n            (1, 'Taehoon'),\n            (2,    'Mike'),\n            (3,   'Jorno'),\n            (4,   'Berry'),\n            (5,    'Hwan');\n        \",\n        \"\n        INSERT INTO Item (id, quantity, player_id) VALUES\n            (101, 1, 1),\n            (102, 4, 2),\n            (103, 9, 3),\n            (104, 2, 3),\n            (105, 1, 3),\n            (106, 5, 1),\n            (107, 2, 1),\n            (108, 1, 5),\n            (109, 1, 5),\n            (110, 3, 3),\n            (111, 4, 2),\n            (112, 8, 1),\n            (113, 7, 1),\n            (114, 1, 1),\n            (115, 2, 1);\n        \",\n    ];\n\n    for insert_sql in insert_sqls {\n        g.run(insert_sql).await;\n    }\n\n    let select_sqls = [\n        (75, \"SELECT * FROM Item JOIN Player\"),\n        (\n            15,\n            \"SELECT * FROM Item LEFT JOIN Player ON Player.id = Item.player_id;\",\n        ),\n        (\n            5,\n            \"SELECT * FROM Item LEFT JOIN Player ON Player.id = Item.player_id WHERE quantity = 1;\",\n        ),\n        (\n            7,\n            \"SELECT * FROM Item LEFT JOIN Player ON Player.id = Item.player_id WHERE Player.id = 1;\",\n        ),\n        (\n            7,\n            \"SELECT * FROM Item INNER JOIN Player ON Player.id = Item.player_id WHERE Player.id = 1;\",\n        ),\n        (\n            7,\n            \"SELECT * FROM Item\n            LEFT JOIN Player ON Player.id = Item.player_id\n            LEFT JOIN Player p1 ON p1.id = Item.player_id\n            LEFT JOIN Player p2 ON p2.id = Item.player_id\n            LEFT JOIN Player p3 ON p3.id = Item.player_id\n            LEFT JOIN Player p4 ON p4.id = Item.player_id\n            LEFT JOIN Player p5 ON p5.id = Item.player_id\n            LEFT JOIN Player p6 ON p6.id = Item.player_id\n            LEFT JOIN Player p7 ON p7.id = Item.player_id\n            LEFT JOIN Player p8 ON p8.id = Item.player_id\n            LEFT JOIN Player p9 ON p9.id = Item.player_id\n            WHERE Player.id = 1;\",\n        ),\n        (\n            6,\n            \"SELECT * FROM Item\n            LEFT JOIN Player ON Player.id = Item.player_id\n            LEFT JOIN Player p1 ON p1.id = Item.player_id\n            LEFT JOIN Player p2 ON p2.id = Item.player_id\n            LEFT JOIN Player p3 ON p3.id = Item.player_id\n            LEFT JOIN Player p4 ON p4.id = Item.player_id\n            LEFT JOIN Player p5 ON p5.id = Item.player_id\n            LEFT JOIN Player p6 ON p6.id = Item.player_id\n            LEFT JOIN Player p7 ON p7.id = Item.player_id\n            LEFT JOIN Player p8 ON p8.id = Item.player_id\n            INNER JOIN Player p9 ON p9.id = Item.player_id AND Item.id \u003e 101\n            WHERE Player.id = 1;\",\n        ),\n        (\n            5,\n            \"SELECT * FROM Item LEFT JOIN Player ON Player.id = Item.player_id WHERE Item.quantity = 1;\",\n        ),\n        (\n            5,\n            \"SELECT * FROM Item i LEFT JOIN Player p ON p.id = i.player_id WHERE i.quantity = 1;\",\n        ),\n        (\n            15,\n            \"SELECT * FROM Item i LEFT JOIN Player p ON p.id = i.player_id AND p.id = 1;\",\n        ),\n        (\n            15,\n            \"SELECT * FROM Item i LEFT JOIN Player p ON p.id = i.player_id AND i.quantity = 1;\",\n        ),\n        (\n            15,\n            \"SELECT * FROM Item LEFT JOIN Player ON Player.id = Item.player_id AND Item.quantity = 1;\",\n        ),\n        (\n            7,\n            \"SELECT * FROM Item i JOIN Player p ON p.id = i.player_id AND p.id = 1;\",\n        ),\n        (\n            7,\n            \"SELECT * FROM Item i INNER JOIN Player p ON p.id = i.player_id AND p.id = 1;\",\n        ),\n        (\n            5,\n            \"SELECT * FROM Item i JOIN Player p ON p.id = i.player_id AND i.quantity = 1;\",\n        ),\n        (\n            0,\n            \"SELECT * FROM Player\n            INNER JOIN Item ON 1 = 2\n            INNER JOIN Item i2 ON 1 = 2\n        \",\n        ),\n        (\n            7,\n            \"SELECT * FROM Item\n            LEFT JOIN Player ON Player.id = Item.player_id\n            WHERE Player.id = (SELECT id FROM Player LIMIT 1 OFFSET 0);\",\n        ),\n        (\n            0,\n            \"SELECT * FROM Item i1\n            LEFT JOIN Player ON Player.id = i1.player_id\n            WHERE Player.id = (SELECT id FROM Item i2 WHERE i2.id = i1.id)\",\n        ),\n        (\n            0,\n            \"SELECT * FROM Item i1\n            LEFT JOIN Player ON Player.id = i1.player_id\n            WHERE Player.id =\n                (SELECT i2.id FROM Item i2\n                 JOIN Item i3 ON i3.id = i2.id\n                 WHERE\n                     i2.id = i1.id AND\n                     i3.id = i2.id AND\n                     i1.id = i3.id);\",\n        ),\n        (\n            4,\n            \"SELECT * FROM Item i1\n            LEFT JOIN Player ON Player.id = i1.player_id\n            WHERE Player.id IN\n                (SELECT i2.player_id FROM Item i2\n                 JOIN Item i3 ON i3.id = i2.id\n                 WHERE Player.name = 'Jorno');\",\n        ),\n        // cartesian product tests\n        (\n            15,\n            \"SELECT * FROM Player INNER JOIN Item ON Player.id = Item.player_id;\",\n        ),\n        (25, \"SELECT * FROM Player p1 LEFT JOIN Player p2 ON 1 = 1\"),\n        (\n            30,\n            \"SELECT * FROM Item INNER JOIN Item i2 ON i2.id IN (101, 103);\",\n        ),\n    ];\n\n    for (num, sql) in select_sqls {\n        g.count(sql, num).await;\n    }\n\n    for sql in delete_sqls {\n        g.run(sql).await;\n    }\n});\n\ntest_case!(project, {\n    let g = get_tester!();\n\n    let create_sqls: [\u0026str; 2] = [\n        \"\n        CREATE TABLE Player (\n            id INTEGER,\n            name TEXT\n        );\n    \",\n        \"\n        CREATE TABLE Item (\n            id INTEGER,\n            quantity INTEGER,\n            player_id INTEGER\n        );\n    \",\n    ];\n\n    for sql in create_sqls {\n        g.run(sql).await;\n    }\n\n    let insert_sqls = [\n        \"\n        INSERT INTO Player (id, name) VALUES\n            (1, 'Taehoon'),\n            (2,    'Mike'),\n            (3,   'Jorno'),\n            (4,   'Berry'),\n            (5,    'Hwan');\n        \",\n        \"\n        INSERT INTO Item (id, quantity, player_id) VALUES\n            (101, 1, 1),\n            (102, 4, 2),\n            (103, 9, 4);\n        \",\n    ];\n\n    for insert_sql in insert_sqls {\n        g.run(insert_sql).await;\n    }\n\n    let sql = \"\n        SELECT p.id, i.id\n        FROM Player p\n        LEFT JOIN Item i\n        ON p.id = i.player_id\n    \";\n    let expected = select_with_null!(\n        id     | id;\n        I64(1)   I64(101);\n        I64(2)   I64(102);\n        I64(3)   Null;\n        I64(4)   I64(103);\n        I64(5)   Null\n    );\n    g.test(sql, Ok(expected)).await;\n\n    let sql = \"\n        SELECT p.id, player_id\n        FROM Player p\n        LEFT JOIN Item\n        ON p.id = player_id\n    \";\n    let expected = select_with_null!(\n        id     | player_id;\n        I64(1)   I64(1);\n        I64(2)   I64(2);\n        I64(3)   Null;\n        I64(4)   I64(4);\n        I64(5)   Null\n    );\n    g.test(sql, Ok(expected)).await;\n\n    let sql = \"\n        SELECT Item.*\n        FROM Player p\n        LEFT JOIN Item\n        ON p.id = player_id\n    \";\n    let expected = select_with_null!(\n        id       | quantity | player_id;\n        I64(101)   I64(1)     I64(1);\n        I64(102)   I64(4)     I64(2);\n        Null       Null       Null;\n        I64(103)   I64(9)     I64(4);\n        Null       Null       Null\n    );\n    g.test(sql, Ok(expected)).await;\n\n    let sql = \"\n        SELECT *\n        FROM Player p\n        LEFT JOIN Item\n        ON p.id = player_id\n    \";\n    let expected = select_with_null!(\n        id     | name                      | id       | quantity | player_id;\n        I64(1)   Str(\"Taehoon\".to_owned())   I64(101)   I64(1)     I64(1);\n        I64(2)   Str(\"Mike\".to_owned())      I64(102)   I64(4)     I64(2);\n        I64(3)   Str(\"Jorno\".to_owned())     Null       Null       Null;\n        I64(4)   Str(\"Berry\".to_owned())     I64(103)   I64(9)     I64(4);\n        I64(5)   Str(\"Hwan\".to_owned())      Null       Null       Null\n    );\n    g.test(sql, Ok(expected)).await;\n\n    // To test `PlanError` while using `JOIN`\n    g.run(\"CREATE TABLE Users (id INTEGER, name TEXT);\").await;\n    g.run(\"INSERT INTO Users (id, name) VALUES (1, 'Harry');\")\n        .await;\n    g.run(\"CREATE TABLE Testers (id INTEGER, nickname TEXT);\")\n        .await;\n    g.run(\"INSERT INTO Testers (id, nickname) VALUES (1, 'Ron');\")\n        .await;\n\n    let error_cases = [\n        (\n            \"SELECT * FROM TableA JOIN TableA USING (id);\",\n            TranslateError::UnsupportedJoinConstraint(\"USING\".to_owned()).into(),\n        ),\n        (\n            \"SELECT * FROM TableA CROSS JOIN TableA as A;\",\n            TranslateError::UnsupportedJoinOperator(\"CrossJoin\".to_owned()).into(),\n        ),\n        (\n            \"SELECT id FROM Users JOIN Testers ON Users.id = Testers.id;\",\n            PlanError::ColumnReferenceAmbiguous(\"id\".to_owned()).into(),\n        ),\n        (\n            // Ambiguous column should return error even with identical table join\n            \"SELECT id FROM Users A JOIN Users B on A.id = B.id\",\n            PlanError::ColumnReferenceAmbiguous(\"id\".to_owned()).into(),\n        ),\n        (\n            \"INSERT INTO Users SELECT id FROM Users A JOIN Users B on A.id = B.id\",\n            PlanError::ColumnReferenceAmbiguous(\"id\".to_owned()).into(),\n        ),\n        (\n            \"CREATE TABLE Ids AS SELECT id FROM Users A JOIN Users B on A.id = B.id\",\n            PlanError::ColumnReferenceAmbiguous(\"id\".to_owned()).into(),\n        ),\n        (\n            \"SELECT * FROM ProjectUser, ProjectItem\",\n            TranslateError::TooManyTables.into(),\n        ),\n    ];\n\n    for (sql, error) in error_cases {\n        g.test(sql, Err(error)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","lib.rs"],"content":"#![deny(clippy::str_to_string)]\n\npub mod aggregate;\npub mod alter;\npub mod arithmetic;\npub mod array;\npub mod ast_builder;\npub mod basic;\npub mod bitwise_and;\npub mod bitwise_shift_left;\npub mod bitwise_shift_right;\npub mod case;\npub mod column_alias;\npub mod concat;\npub mod custom_function;\npub mod data_type;\npub mod default;\npub mod delete;\npub mod dictionary;\npub mod dictionary_index;\npub mod filter;\npub mod foreign_key;\npub mod function;\npub mod index;\npub mod inline_view;\npub mod insert;\npub mod join;\npub mod like_ilike;\npub mod limit;\npub mod metadata;\npub mod migrate;\npub mod nested_select;\npub mod nullable;\npub mod order_by;\npub mod ordering;\npub mod primary_key;\npub mod project;\npub mod schemaless;\npub mod series;\npub mod show_columns;\npub mod store;\npub mod synthesize;\npub mod transaction;\npub mod type_match;\npub mod unary_operator;\npub mod update;\npub mod validate;\npub mod values;\n\npub mod tester;\n\npub use tester::*;\n\n#[macro_export]\nmacro_rules! declare_test_fn {\n    ($test: meta, $storage: ident, $title: ident, $func: path) =\u003e {\n        #[$test]\n        async fn $title() {\n            let path = stringify!($title);\n            let storage = $storage::new(path).await;\n\n            $func(storage).await;\n        }\n    };\n}\n\n#[macro_export]\nmacro_rules! generate_store_tests {\n    ($test: meta, $storage: ident) =\u003e {\n        macro_rules! glue {\n            ($title: ident, $func: path) =\u003e {\n                declare_test_fn!($test, $storage, $title, $func);\n            };\n        }\n        glue!(update, update::update);\n        glue!(insert, insert::insert);\n        glue!(delete, delete::delete);\n        glue!(basic, basic::basic);\n        glue!(array, array::array);\n        glue!(bitwise_and, bitwise_and::bitwise_and);\n        glue!(aggregate_avg, aggregate::avg::avg);\n        glue!(aggregate_count, aggregate::count::count);\n        glue!(aggregate_group_by, aggregate::group_by::group_by);\n        glue!(aggregate_max, aggregate::max::max);\n        glue!(aggregate_min, aggregate::min::min);\n        glue!(aggregate_stdev, aggregate::stdev::stdev);\n        glue!(aggregate_sum, aggregate::sum::sum);\n        glue!(aggregate_variance, aggregate::variance::variance);\n        glue!(aggregate_error, aggregate::error::error);\n        glue!(arithmetic_error, arithmetic::error::error);\n        glue!(arithmetic_project, arithmetic::project::project);\n        glue!(arithmetic_on_where, arithmetic::on_where::on_where);\n        glue!(concat, concat::concat);\n        glue!(project, project::project);\n        glue!(bitwise_shift_left, bitwise_shift_left::bitwise_shift_left);\n        glue!(\n            bitwise_shift_right,\n            bitwise_shift_right::bitwise_shift_right\n        );\n        glue!(create_table, alter::create_table);\n        glue!(drop_table, alter::drop_table);\n        glue!(default, default::default);\n        glue!(limit, limit::limit);\n        glue!(like_ilike, like_ilike::like_ilike);\n        glue!(filter, filter::filter);\n        glue!(inline_view, inline_view::inline_view);\n        glue!(values, values::values);\n        glue!(unary_operator, unary_operator::unary_operator);\n        glue!(function_upper_lower, function::upper_lower::upper_lower);\n        glue!(function_initcap, function::initcap::initcap);\n        glue!(function_gcd_lcm, function::gcd_lcm::gcd_lcm);\n        glue!(function_left_right, function::left_right::left_right);\n        glue!(function_sqrt, function::sqrt_power::sqrt);\n        glue!(function_power, function::sqrt_power::power);\n        glue!(function_lpad_rpad, function::lpad_rpad::lpad_rpad);\n        glue!(function_trim, function::trim::trim);\n        glue!(function_div_mod, function::div_mod::div_mod);\n        glue!(function_ltrim_rtrim, function::ltrim_rtrim::ltrim_rtrim);\n        glue!(function_cast_literal, function::cast::cast_literal);\n        glue!(function_cast_value, function::cast::cast_value);\n        glue!(function_coalesce, function::coalesce::coalesce);\n        glue!(function_concat, function::concat::concat);\n        glue!(function_concat_ws, function::concat_ws::concat_ws);\n        glue!(function_ifnull, function::ifnull::ifnull);\n        glue!(function_iif, function::iif::iif);\n        glue!(function_is_empty, function::is_empty::is_empty);\n        glue!(function_math_function_asin, function::math_function::asin);\n        glue!(function_math_function_acos, function::math_function::acos);\n        glue!(function_math_function_atan, function::math_function::atan);\n        glue!(function_math_function_sin, function::math_function::sin);\n        glue!(function_math_function_cos, function::math_function::cos);\n        glue!(function_math_function_tan, function::math_function::tan);\n        glue!(function_abs, function::abs::abs);\n        glue!(function_ceil, function::ceil::ceil);\n        glue!(function_round, function::round::round);\n        glue!(function_rand, function::rand::rand);\n        glue!(function_floor, function::floor::floor);\n        glue!(function_format, function::format::format);\n        glue!(function_last_day, function::last_day::last_day);\n        glue!(function_ln, function::exp_log::ln);\n        glue!(function_log, function::exp_log::log);\n        glue!(function_log2, function::exp_log::log2);\n        glue!(function_log10, function::exp_log::log10);\n        glue!(function_exp, function::exp_log::exp);\n        glue!(function_now, function::now::now);\n        glue!(function_current_date, function::current_date::current_date);\n        glue!(function_current_time, function::current_time::current_time);\n        glue!(\n            function_current_timestamp,\n            function::current_timestamp::current_timestamp\n        );\n        glue!(function_sign, function::sign::sign);\n        glue!(function_skip, function::skip::skip);\n        glue!(function_to_date, function::to_date::to_date);\n        glue!(function_ascii, function::ascii::ascii);\n        glue!(function_chr, function::chr::chr);\n        glue!(function_mod, function::md5::md5);\n        glue!(function_replace, function::replace::replace);\n        glue!(function_length, function::length::length);\n        glue!(function_position, function::position::position);\n        glue!(function_find_idx, function::find_idx::find_idx);\n        glue!(function_geometry_get_x, function::geometry::get_x);\n        glue!(function_geometry_get_y, function::geometry::get_y);\n        glue!(\n            function_geometry_calc_distance,\n            function::geometry::calc_distance\n        );\n        glue!(function_add_month, function::add_month::add_month);\n        glue!(function_slice, function::slice::slice);\n        glue!(function_entries, function::entries::entries);\n        glue!(function_keys, function::keys::keys);\n        glue!(function_values, function::values::values);\n        glue!(function_nullif, function::nullif::nullif);\n        glue!(function_hex, function::hex::hex);\n        glue!(join, join::join);\n        glue!(join_project, join::project);\n        glue!(migrate, migrate::migrate);\n        glue!(nested_select, nested_select::nested_select);\n        glue!(primary_key, primary_key::primary_key);\n        glue!(foreign_key, foreign_key::foreign_key);\n        glue!(series, series::series);\n        glue!(nullable, nullable::nullable);\n        glue!(nullable_text, nullable::nullable_text);\n        glue!(nullable_implicit_insert, nullable::nullable_implicit_insert);\n        glue!(ordering, ordering::ordering);\n        glue!(order_by, order_by::order_by);\n        glue!(sql_types, data_type::sql_types::sql_types);\n        glue!(show_columns, show_columns::show_columns);\n        glue!(int8, data_type::int8::int8);\n        glue!(int16, data_type::int16::int16);\n        glue!(int32, data_type::int32::int32);\n        glue!(int64, data_type::int64::int64);\n        glue!(int128, data_type::int128::int128);\n        glue!(float32, data_type::float32::float32);\n        glue!(uint16, data_type::uint16::uint16);\n        glue!(uint8, data_type::uint8::uint8);\n        glue!(uint64, data_type::uint64::uint64);\n        glue!(uint32, data_type::uint32::uint32);\n        glue!(uint128, data_type::uint128::uint128);\n        glue!(date, data_type::date::date);\n        glue!(timestamp, data_type::timestamp::timestamp);\n        glue!(time, data_type::time::time);\n        glue!(interval, data_type::interval::interval);\n        glue!(list, data_type::list::list);\n        glue!(map, data_type::map::map);\n        glue!(bytea, data_type::bytea::bytea);\n        glue!(inet, data_type::inet::inet);\n        glue!(point, data_type::point::point);\n        glue!(synthesize, synthesize::synthesize);\n        glue!(validate_unique, validate::unique::unique);\n        glue!(validate_types, validate::types::types);\n        glue!(function_extract, function::extract::extract);\n        glue!(function_radians, function::radians::radians);\n        glue!(function_degrees, function::degrees::degrees);\n        glue!(function_pi, function::pi::pi);\n        glue!(function_reverse, function::reverse::reverse);\n        glue!(function_repeat, function::repeat::repeat);\n        glue!(case, case::case);\n        glue!(function_substr, function::substr::substr);\n        glue!(uuid, data_type::uuid::uuid);\n        glue!(decimal, data_type::decimal::decimal);\n        glue!(\n            function_generate_uuid,\n            function::generate_uuid::generate_uuid\n        );\n        glue!(function_greatest, function::greatest::greatest);\n        glue!(type_match, type_match::type_match);\n        glue!(dictionary, dictionary::dictionary);\n        glue!(function_append, function::append::append);\n        glue!(function_prepend, function::prepend::prepend);\n        glue!(function_sort, function::sort::sort);\n        glue!(function_take, function::take::take);\n        glue!(column_alias, column_alias::column_alias);\n        glue!(function_splice, function::splice::splice);\n        glue!(function_dedup, function::dedup::dedup);\n\n        // ast-builder\n        glue!(ast_builder_basic, ast_builder::basic::basic);\n        glue!(\n            ast_builder_statements_queryinng_data_aggregation,\n            ast_builder::statements::querying::data_aggregation\n        );\n        glue!(\n            ast_builder_statements_queryinng_data_selection_and_projection,\n            ast_builder::statements::querying::data_selection_and_projection\n        );\n        glue!(\n            ast_builder_function_math_rounding,\n            ast_builder::function::math::rounding\n        );\n        glue!(\n            ast_builder_expr_pattern_matching,\n            ast_builder::expr::pattern_matching::pattern_matching\n        );\n        glue!(ast_builder_select, ast_builder::select::select);\n        glue!(ast_builder_values, ast_builder::values::values);\n        glue!(ast_builder_insert, ast_builder::insert::insert);\n        glue!(ast_builder_update, ast_builder::update::update);\n        glue!(ast_builder_delete, ast_builder::delete::delete);\n        glue!(ast_builder_alias_as, ast_builder::alias_as::alias_as);\n        glue!(\n            ast_builder_function_text_case_conversion,\n            ast_builder::function::text::case_conversion\n        );\n        glue!(\n            ast_builder_function_text_character_conversion,\n            ast_builder::function::text::character_conversion\n        );\n        glue!(\n            ast_builder_function_text_padding,\n            ast_builder::function::text::padding\n        );\n        glue!(\n            ast_builder_function_other_coalesce,\n            ast_builder::function::other::coalesce::coalesce\n        );\n        glue!(\n            ast_builder_function_other_ifnull,\n            ast_builder::function::other::ifnull::ifnull\n        );\n        glue!(\n            ast_builder_function_datetime_conversion,\n            ast_builder::function::datetime::conversion\n        );\n        glue!(\n            ast_builder_function_math_basic_arithmetic,\n            ast_builder::function::math::basic_arithmetic\n        );\n        glue!(\n            ast_builder_function_math_conversion,\n            ast_builder::function::math::conversion\n        );\n        glue!(\n            ast_builder_function_datetime_formatting,\n            ast_builder::function::datetime::formatting\n        );\n        glue!(\n            ast_builder_function_text_trimming,\n            ast_builder::function::text::trimming\n        );\n        glue!(\n            ast_builder_function_datetime_current_date_and_time,\n            ast_builder::function::datetime::current_date_and_time\n        );\n        glue!(\n            ast_builder_function_text_position_and_indexing,\n            ast_builder::function::text::position_and_indexing\n        );\n        glue!(ast_builder_index_by, ast_builder::index_by::index_by);\n        glue!(\n            ast_builder_schemaless_basic,\n            ast_builder::schemaless::basic::basic\n        );\n\n        // schemaless data support\n        glue!(schemaless_basic, schemaless::basic);\n        glue!(schemaless_error, schemaless::error);\n\n        glue!(store_insert_schema, store::insert_schema::insert_schema);\n    };\n}\n\n#[macro_export]\nmacro_rules! generate_alter_table_tests {\n    ($test: meta, $storage: ident) =\u003e {\n        macro_rules! glue {\n            ($title: ident, $func: path) =\u003e {\n                declare_test_fn!($test, $storage, $title, $func);\n            };\n        }\n\n        glue!(alter_table_rename, alter::alter_table_rename);\n        glue!(alter_table_add_drop, alter::alter_table_add_drop);\n    };\n}\n\n#[macro_export]\nmacro_rules! generate_custom_function_tests {\n    ($test: meta, $storage: ident) =\u003e {\n        macro_rules! glue {\n            ($title: ident, $func: path) =\u003e {\n                declare_test_fn!($test, $storage, $title, $func);\n            };\n        }\n\n        glue!(function_custom, custom_function::custom);\n    };\n}\n\n#[macro_export]\nmacro_rules! generate_index_tests {\n    ($test: meta, $storage: ident) =\u003e {\n        macro_rules! glue {\n            ($title: ident, $func: path) =\u003e {\n                declare_test_fn!($test, $storage, $title, $func);\n            };\n        }\n\n        glue!(index_basic, index::basic);\n        glue!(index_and, index::and);\n        glue!(index_nested, index::nested);\n        glue!(index_null, index::null);\n        glue!(index_expr, index::expr);\n        glue!(index_value, index::value);\n        glue!(index_order_by, index::order_by);\n        glue!(index_order_by_multi, index::order_by_multi);\n        glue!(showindexes, index::showindexes);\n        glue!(dictionary_index, dictionary_index::ditionary_index);\n    };\n}\n\n#[macro_export]\nmacro_rules! generate_transaction_tests {\n    ($test: meta, $storage: ident) =\u003e {\n        macro_rules! glue {\n            ($title: ident, $func: path) =\u003e {\n                declare_test_fn!($test, $storage, $title, $func);\n            };\n        }\n\n        glue!(transaction_basic, transaction::basic);\n        glue!(\n            transaction_create_drop_table,\n            transaction::create_drop_table\n        );\n        glue!(transaction_dictionary, transaction::dictionary);\n        glue!(transaction_ast_builder, transaction::ast_builder);\n    };\n}\n\n#[macro_export]\nmacro_rules! generate_alter_table_index_tests {\n    ($test: meta, $storage: ident) =\u003e {\n        macro_rules! glue {\n            ($title: ident, $func: path) =\u003e {\n                declare_test_fn!($test, $storage, $title, $func);\n            };\n        }\n\n        glue!(alter_table_drop_indexed_table, alter::drop_indexed_table);\n        glue!(alter_table_drop_indexed_column, alter::drop_indexed_column);\n    };\n}\n\n#[macro_export]\nmacro_rules! generate_transaction_alter_table_tests {\n    ($test: meta, $storage: ident) =\u003e {\n        macro_rules! glue {\n            ($title: ident, $func: path) =\u003e {\n                declare_test_fn!($test, $storage, $title, $func);\n            };\n        }\n\n        glue!(\n            transaction_alter_table_rename_table,\n            transaction::alter_table_rename_table\n        );\n        glue!(\n            transaction_alter_table_rename_column,\n            transaction::alter_table_rename_column\n        );\n        glue!(\n            transaction_alter_table_add_column,\n            transaction::alter_table_add_column\n        );\n        glue!(\n            transaction_alter_table_drop_column,\n            transaction::alter_table_drop_column\n        );\n    };\n}\n\n#[macro_export]\nmacro_rules! generate_transaction_index_tests {\n    ($test: meta, $storage: ident) =\u003e {\n        macro_rules! glue {\n            ($title: ident, $func: path) =\u003e {\n                declare_test_fn!($test, $storage, $title, $func);\n            };\n        }\n\n        glue!(transaction_index_create, transaction::index_create);\n        glue!(transaction_index_drop, transaction::index_drop);\n    };\n}\n\n#[macro_export]\nmacro_rules! generate_metadata_table_tests {\n    ($test: meta, $storage: ident) =\u003e {\n        macro_rules! glue {\n            ($title: ident, $func: path) =\u003e {\n                declare_test_fn!($test, $storage, $title, $func);\n            };\n        }\n\n        glue!(metadata_table, metadata::table::table);\n    };\n}\n\n#[macro_export]\nmacro_rules! generate_metadata_index_tests {\n    ($test: meta, $storage: ident) =\u003e {\n        macro_rules! glue {\n            ($title: ident, $func: path) =\u003e {\n                declare_test_fn!($test, $storage, $title, $func);\n            };\n        }\n\n        glue!(metadata_index, metadata::index::index);\n    };\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","like_ilike.rs"],"content":"use {\n    crate::*,\n    bigdecimal::BigDecimal,\n    gluesql_core::{\n        data::Literal,\n        error::{LiteralError, ValueError},\n        prelude::Value::{self, Bool},\n    },\n    std::{borrow::Cow, str::FromStr},\n};\n\ntest_case!(like_ilike, {\n    let g = get_tester!();\n\n    g.named_test(\n        \"basic usage - LIKE and ILIKE\",\n        \"\n            VALUES\n                ('abc' LIKE '%c'),\n                ('abc' NOT LIKE '_c'),\n                ('abc' LIKE '_b_'),\n                ('HELLO' ILIKE '%el%'),\n                ('HELLO' NOT ILIKE '_ELLE');\n        \",\n        Ok(select!(column1 Bool; true; true; true; true; true)),\n    )\n    .await;\n\n    g.run(\n        \"\n        CREATE TABLE Item (\n            id INTEGER,\n            name TEXT\n        );\n    \",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Item (id, name) VALUES\n            (1,    'Amelia'),\n            (2,      'Doll'),\n            (3, 'Gascoigne'),\n            (4,   'Gehrman'),\n            (5,     'Maria');\n    \",\n    )\n    .await;\n\n    let test_cases = [\n        (2, \"SELECT name FROM Item WHERE name LIKE '_a%'\"),\n        (2, \"SELECT name FROM Item WHERE name LIKE '%r%'\"),\n        (2, \"SELECT name FROM Item WHERE SUBSTR(name, 1) LIKE '%a'\"),\n        (0, \"SELECT name FROM Item WHERE 'name' LIKE SUBSTR('%a', 1)\"),\n        (\n            2,\n            \"SELECT name FROM Item WHERE SUBSTR(name, 1) LIKE SUBSTR('%a', 1)\",\n        ),\n        (\n            2,\n            \"SELECT name FROM Item WHERE SUBSTR(name, 1) LIKE SUBSTR('%a', 1)\",\n        ),\n        (\n            2,\n            \"SELECT name FROM Item WHERE LOWER(name) LIKE SUBSTR('%a', 1)\",\n        ),\n        (\n            2,\n            \"SELECT name FROM Item WHERE SUBSTR(name, 1) LIKE '%' || LOWER('A')\",\n        ),\n        (5, \"SELECT name FROM Item WHERE name LIKE '%%'\"),\n        (0, \"SELECT name FROM Item WHERE name LIKE 'g%'\"),\n        (2, \"SELECT name FROM Item WHERE name ILIKE '_A%'\"),\n        (2, \"SELECT name FROM Item WHERE name ILIKE 'g%'\"),\n        (5, \"SELECT name FROM Item WHERE name ILIKE '%%'\"),\n        (1, \"SELECT name FROM Item WHERE name NOT LIKE '%a%'\"),\n        (1, \"SELECT name FROM Item WHERE name NOT ILIKE '%A%'\"),\n        (5, \"SELECT name FROM Item WHERE 'ABC' LIKE '_B_'\"),\n        (5, \"SELECT name FROM Item WHERE 'abc' ILIKE '_B_'\"),\n        (5, \"SELECT name FROM Item WHERE 'ABC' ILIKE '_B_'\"),\n    ];\n\n    for (num, sql) in test_cases {\n        g.count(sql, num).await;\n    }\n\n    let error_sqls = [\n        (\n            \"SELECT name FROM Item WHERE 'ABC' LIKE 10\",\n            LiteralError::LikeOnNonString {\n                base: format!(\"{:?}\", Literal::Text(Cow::Owned(\"ABC\".to_owned()))),\n                pattern: format!(\n                    \"{:?}\",\n                    Literal::Number(Cow::Owned(BigDecimal::from_str(\"10\").unwrap()))\n                ),\n                case_sensitive: true,\n            }\n            .into(),\n        ),\n        (\n            \"SELECT name FROM Item WHERE True ILIKE '_B_'\",\n            LiteralError::LikeOnNonString {\n                base: format!(\"{:?}\", Literal::Boolean(true)),\n                pattern: format!(\"{:?}\", Literal::Text(Cow::Owned(\"_B_\".to_owned()))),\n                case_sensitive: false,\n            }\n            .into(),\n        ),\n        (\n            \"SELECT name FROM Item WHERE name = 'Amelia' AND name LIKE 10\",\n            ValueError::LikeOnNonString {\n                base: Value::Str(\"Amelia\".to_owned()),\n                pattern: Value::I64(10),\n                case_sensitive: true,\n            }\n            .into(),\n        ),\n        (\n            \"SELECT name FROM Item WHERE name = 'Amelia' AND name ILIKE 10\",\n            ValueError::LikeOnNonString {\n                base: Value::Str(\"Amelia\".to_owned()),\n                pattern: Value::I64(10),\n                case_sensitive: false,\n            }\n            .into(),\n        ),\n    ];\n\n    for (sql, error) in error_sqls {\n        g.test(sql, Err(error)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","limit.rs"],"content":"use {crate::*, Value::*, gluesql_core::prelude::*};\n\ntest_case!(limit, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Test (\n                id INTEGER\n            )\",\n            Payload::Create,\n        ),\n        (\n            \"INSERT INTO Test VALUES (1), (2), (3), (4), (5), (6), (7), (8);\",\n            Payload::Insert(8),\n        ),\n        (\n            \"SELECT * FROM Test LIMIT 10;\",\n            select!(id; I64; 1; 2; 3; 4; 5; 6; 7; 8),\n        ),\n        (\n            \"SELECT * FROM Test LIMIT 10 OFFSET 1;\",\n            select!(id; I64; 2; 3; 4; 5; 6; 7; 8),\n        ),\n        (\n            \"SELECT * FROM Test OFFSET 2;\",\n            select!(id; I64; 3; 4; 5; 6; 7; 8),\n        ),\n        (\n            \"SELECT * FROM Test OFFSET 10;\",\n            Payload::Select {\n                labels: vec![\"id\".to_owned()],\n                rows: vec![],\n            },\n        ),\n        (r#\"SELECT * FROM Test LIMIT 3;\"#, select!(id; I64; 1; 2; 3)),\n        (\n            r#\"SELECT * FROM Test LIMIT 4 OFFSET 3;\"#,\n            select!(id; I64; 4; 5; 6; 7),\n        ),\n        (\n            \"SELECT * FROM Test ORDER BY id DESC LIMIT 3\",\n            select!(id; I64; 8; 7; 6),\n        ),\n        (\n            \"SELECT id, COUNT(*) as c FROM Test GROUP BY id LIMIT 3 OFFSET 2\",\n            select!(\n                id  | c;\n                I64 | I64;\n                3     1;\n                4     1;\n                5     1\n            ),\n        ),\n        (\n            \"CREATE TABLE InsertTest (\n                case_no INTEGER,\n                id INTEGER\n            )\",\n            Payload::Create,\n        ),\n        (\n            \"INSERT INTO InsertTest SELECT 1, id FROM Test OFFSET 1;\",\n            Payload::Insert(7),\n        ),\n        (\n            \"SELECT id FROM InsertTest WHERE case_no = 1\",\n            select!(id; I64; 2; 3; 4; 5; 6; 7; 8),\n        ),\n        (\n            \"INSERT INTO InsertTest SELECT 2, id FROM Test LIMIT 1;\",\n            Payload::Insert(1),\n        ),\n        (\n            \"SELECT id FROM InsertTest WHERE case_no = 2\",\n            select!(id; I64; 1),\n        ),\n        (\n            \"INSERT INTO InsertTest SELECT 3, id FROM Test ORDER BY id LIMIT 1 OFFSET 1;\",\n            Payload::Insert(1),\n        ),\n        (\n            \"SELECT id FROM InsertTest WHERE case_no = 3\",\n            select!(id; I64; 2),\n        ),\n        (\n            \"INSERT INTO InsertTest VALUES (4, 1), (4, 2), (4, 3), (4, 4) LIMIT 1;\",\n            Payload::Insert(1),\n        ),\n        (\n            \"SELECT id FROM InsertTest WHERE case_no = 4\",\n            select!(id; I64; 1),\n        ),\n        (\n            \"INSERT INTO InsertTest VALUES (5, 1), (5, 2), (5, 3), (5, 4) OFFSET 1;\",\n            Payload::Insert(3),\n        ),\n        (\n            \"SELECT id FROM InsertTest WHERE case_no = 5\",\n            select!(id; I64; 2; 3; 4),\n        ),\n        (\n            \"INSERT INTO InsertTest VALUES (6, 1), (6, 2), (6, 3), (6, 4) LIMIT 3 OFFSET 2;\",\n            Payload::Insert(2),\n        ),\n        (\n            \"SELECT id FROM InsertTest WHERE case_no = 6\",\n            select!(id; I64; 3; 4),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","metadata","index.rs"],"content":"use {\n    crate::{concat_with, row, select, stringify_label, test_case},\n    gluesql_core::prelude::{Payload, Value::Str},\n};\n\ntest_case!(index, {\n    let g = get_tester!();\n\n    let cases = vec![\n        (\"CREATE TABLE Meta (id INT, name TEXT)\", Ok(Payload::Create)),\n        (\n            \"CREATE INDEX Meta_id ON Meta (id)\",\n            Ok(Payload::CreateIndex),\n        ),\n        (\n            \"CREATE INDEX Meta_name ON Meta (name)\",\n            Ok(Payload::CreateIndex),\n        ),\n        (\n            \"SELECT OBJECT_NAME, OBJECT_TYPE FROM GLUE_OBJECTS\",\n            Ok(select!(\n                OBJECT_NAME            | OBJECT_TYPE       ;\n                Str                    | Str               ;\n                \"Meta\".to_owned()        \"TABLE\".to_owned();\n                \"Meta_id\".to_owned()     \"INDEX\".to_owned();\n                \"Meta_name\".to_owned()   \"INDEX\".to_owned()\n            )),\n        ),\n    ];\n\n    for (actual, expected) in cases {\n        g.test(actual, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","metadata","table.rs"],"content":"use {\n    crate::{row, select, stringify_label, test_case},\n    gluesql_core::prelude::{Payload, Value::Str},\n};\n\ntest_case!(table, {\n    let g = get_tester!();\n\n    let cases = vec![\n        (\"CREATE TABLE Meta (id INT, name TEXT)\", Ok(Payload::Create)),\n        (\n            \"SELECT OBJECT_NAME, OBJECT_TYPE\n                     FROM GLUE_OBJECTS\n                     WHERE CREATED \u003e NOW() - INTERVAL 1 MINUTE\",\n            Ok(select!(\n                OBJECT_NAME       | OBJECT_TYPE       ;\n                Str               | Str               ;\n                \"Meta\".to_owned()   \"TABLE\".to_owned()\n            )),\n        ),\n        (\"DROP TABLE Meta\", Ok(Payload::DropTable(1))),\n        (\n            \"SELECT COUNT(*)\n                     FROM GLUE_OBJECTS\n                     WHERE CREATED \u003e NOW() - INTERVAL 1 MINUTE\",\n            Ok(Payload::Select {\n                labels: vec![\"COUNT(*)\".to_owned()],\n                rows: Vec::new(),\n            }),\n        ),\n    ];\n\n    for (actual, expected) in cases {\n        g.test(actual, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","metadata.rs"],"content":"pub mod index;\npub mod table;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","migrate.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast::Expr,\n        error::{EvaluateError, FetchError, TranslateError, ValueError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(migrate, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Test (\n            id INT,\n            num INT,\n            name TEXT\n        );\n    \",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Test (id, num, name) VALUES\n            (1,     2,     'Hello'),\n            (-(-1), 9,     'World'),\n            (+3,    2 * 2, 'Great');\n        \",\n    )\n    .await;\n\n    let error_cases = [\n        (\n            \"INSERT INTO Test (id, num, name) VALUES (1.1, 1, 'good');\",\n            ValueError::FailedToParseNumber.into(),\n        ),\n        (\n            \"INSERT INTO Test (id, num, name) VALUES (1, 1, a.b);\",\n            EvaluateError::ContextRequiredForIdentEvaluation(Expr::CompoundIdentifier {\n                alias: \"a\".to_owned(),\n                ident: \"b\".to_owned(),\n            })\n            .into(),\n        ),\n        (\n            \"SELECT * FROM Test WHERE Here.User.id = 1\",\n            TranslateError::UnsupportedExpr(\"Here.User.id\".to_owned()).into(),\n        ),\n        (\n            \"SELECT * FROM Test NATURAL JOIN Test\",\n            TranslateError::UnsupportedJoinConstraint(\"NATURAL\".to_owned()).into(),\n        ),\n        (\n            \"SELECT 1 ^ 2 FROM Test;\",\n            TranslateError::UnsupportedBinaryOperator(\"^\".to_owned()).into(),\n        ),\n        (\n            \"SELECT * FROM Test UNION SELECT * FROM Test;\",\n            TranslateError::UnsupportedQuerySetExpr(\n                \"SELECT * FROM Test UNION SELECT * FROM Test\".to_owned(),\n            )\n            .into(),\n        ),\n        (\n            \"SELECT * FROM Test WHERE noname = 1;\",\n            EvaluateError::IdentifierNotFound(\"noname\".to_owned()).into(),\n        ),\n        (\n            \"SELECT * FROM Nothing;\",\n            FetchError::TableNotFound(\"Nothing\".to_owned()).into(),\n        ),\n        (\n            \"TRUNCATE TABLE ProjectUser;\",\n            TranslateError::UnsupportedStatement(\"TRUNCATE TABLE ProjectUser\".to_owned()).into(),\n        ),\n    ];\n\n    for (sql, error) in error_cases {\n        g.test(sql, Err(error)).await;\n    }\n\n    let found = \"SELECT id, num, name FROM Test\";\n    let expected = select!(\n        id  | num | name\n        I64 | I64 | Str;\n        1     2     \"Hello\".to_owned();\n        1     9     \"World\".to_owned();\n        3     4     \"Great\".to_owned()\n    );\n    g.test(found, Ok(expected)).await;\n\n    let found = \"SELECT id, num, name FROM Test WHERE id = 1\";\n    let expected = select!(\n        id  | num | name\n        I64 | I64 | Str;\n        1     2     \"Hello\".to_owned();\n        1     9     \"World\".to_owned()\n    );\n    g.test(found, Ok(expected)).await;\n\n    g.run(\"UPDATE Test SET id = 2\").await;\n\n    let found = \"SELECT id, num, name FROM Test\";\n    let expected = select!(\n        id  | num | name;\n        I64 | I64 | Str;\n        2     2     \"Hello\".to_owned();\n        2     9     \"World\".to_owned();\n        2     4     \"Great\".to_owned()\n    );\n    g.test(found, Ok(expected)).await;\n\n    let found = \"SELECT id FROM Test\";\n    let expected = select!(id; I64; 2; 2; 2);\n    g.test(found, Ok(expected)).await;\n\n    let found = \"SELECT id, num FROM Test\";\n    let expected = select!(id | num; I64 | I64; 2 2; 2 9; 2 4);\n    g.test(found, Ok(expected)).await;\n\n    let found = \"SELECT id, num FROM Test LIMIT 1 OFFSET 1\";\n    let expected = select!(id | num; I64 | I64; 2 9);\n    g.test(found, Ok(expected)).await;\n\n    let found = \"SELECT id, num FROM Test LIMIT 1 OFFSET 1\";\n    let expected = select!(id | num; I64 | I64; 2 9);\n    g.test(found, Ok(expected)).await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","nested_select.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{executor::Payload, prelude::Value},\n};\n\ntest_case!(nested_select, {\n    let g = get_tester!();\n\n    let create_sqls: [\u0026str; 2] = [\n        \"\n        CREATE TABLE Player (\n            id INTEGER,\n            name TEXT\n        );\n    \",\n        \"\n        CREATE TABLE Request (\n            id INTEGER,\n            quantity INTEGER,\n            user_id INTEGER\n        );\n    \",\n    ];\n\n    for sql in create_sqls {\n        g.run(sql).await;\n    }\n\n    let insert_sqls = [\n        \"\n        INSERT INTO Player (id, name) VALUES\n            (1, 'Taehoon'),\n            (2,    'Mike'),\n            (3,   'Jorno'),\n            (4,   'Berry'),\n            (5,    'Hwan');\n        \",\n        \"\n        INSERT INTO Request (id, quantity, user_id) VALUES\n            (101, 1, 1),\n            (102, 4, 2),\n            (103, 9, 3),\n            (104, 2, 3),\n            (105, 1, 3),\n            (106, 5, 1),\n            (107, 2, 1),\n            (108, 1, 5),\n            (109, 1, 5),\n            (110, 3, 3),\n            (111, 4, 2),\n            (112, 8, 1),\n            (113, 7, 1),\n            (114, 1, 1),\n            (115, 2, 1);\n        \",\n    ];\n\n    for insert_sql in insert_sqls {\n        g.run(insert_sql).await;\n    }\n\n    let select_sqls = [\n        (6, \"SELECT * FROM Request WHERE quantity IN (5, 1);\"),\n        (9, \"SELECT * FROM Request WHERE quantity NOT IN (5, 1);\"),\n        (\n            4,\n            \"SELECT * FROM Request WHERE user_id IN (SELECT id FROM Player WHERE id = 3);\",\n        ),\n        (\n            4,\n            \"SELECT * FROM Player WHERE id IN (SELECT user_id FROM Request);\",\n        ),\n        (\n            4,\n            \"SELECT * FROM Player WHERE id IN (SELECT user_id FROM Request WHERE user_id = Player.id);\",\n        ),\n        (\n            4,\n            \"SELECT * FROM Player WHERE id IN (SELECT user_id FROM Request WHERE user_id IN (Player.id));\",\n        ),\n        (\n            2,\n            \"SELECT * FROM Player WHERE id IN (SELECT user_id FROM Request WHERE quantity IN (6, 7, 8, 9));\",\n        ),\n        (\n            9,\n            \"SELECT * FROM Request WHERE user_id IN (SELECT id FROM Player WHERE name IN ('Taehoon', 'Hwan'));\",\n        ),\n    ];\n    for (num, sql) in select_sqls {\n        g.count(sql, num).await;\n    }\n\n    let test_cases = [\n        (\n            \"SELECT * FROM Player WHERE id = (SELECT id FROM Player WHERE id = 9)\",\n            Ok(Payload::Select {\n                labels: vec![\"id\".to_owned(), \"name\".to_owned()],\n                rows: vec![],\n            }),\n        ),\n        (\n            \"SELECT (SELECT N FROM SERIES(3) WHERE N = 4) N\",\n            Ok(select_with_null!(\n                N;\n                Value::Null\n            )),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","nullable.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::ValueError, prelude::Value::*},\n};\n\ntest_case!(nullable, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Test (\n            id INTEGER NULL,\n            num INTEGER NOT NULL,\n            name TEXT\n        )\n        \",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Test (id, num, name) VALUES\n            (NULL, 2, 'Hello'),\n            (   1, 9, 'World'),\n            (   3, 4, 'Great');\n        \",\n    )\n    .await;\n\n    let test_cases = [\n        (\n            \"SELECT id, num, name FROM Test\",\n            select_with_null!(\n                id     | num    | name;\n                Null     I64(2)   Str(\"Hello\".to_owned());\n                I64(1)   I64(9)   Str(\"World\".to_owned());\n                I64(3)   I64(4)   Str(\"Great\".to_owned())\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE id IS NULL AND name = 'Hello'\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE id IS NULL\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2)\n            ),\n        ),\n        (\n            \"SELECT name FROM Test WHERE SUBSTR(name, 1) IS NULL\",\n            select!(\n                name;\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE id IS NOT NULL\",\n            select_with_null!(\n                id     | num;\n                I64(1)   I64(9);\n                I64(3)   I64(4)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE id + 1 IS NULL\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE id + 1 IS NOT NULL\",\n            select_with_null!(\n                id     | num;\n                I64(1)   I64(9);\n                I64(3)   I64(4)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE 100 IS NULL\",\n            select!(id | num),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE 100 IS NOT NULL\",\n            select_with_null!(\n                id     | num;\n                Null     I64(2);\n                I64(1)   I64(9);\n                I64(3)   I64(4)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE 8 + 3 IS NULL\",\n            select!(id | num),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE 8 + 3 IS NOT NULL\",\n            select_with_null!(\n                id     | num;\n                Null     I64(2);\n                I64(1)   I64(9);\n                I64(3)   I64(4)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE NULL IS NULL\",\n            select_with_null!(\n                id     | num;\n                Null     I64(2);\n                I64(1)   I64(9);\n                I64(3)   I64(4)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE NULL IS NOT NULL\",\n            select!(id | num),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE (NULL + id) IS NULL;\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2);\n                I64(1)   I64(9);\n                I64(3)   I64(4)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE (NULL + NULL) IS NULL;\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2);\n                I64(1)   I64(9);\n                I64(3)   I64(4)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE 'NULL' IS NULL\",\n            select!(id | num),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE 'NULL' IS NOT NULL\",\n            select_with_null!(\n                id     | num;\n                Null     I64(2);\n                I64(1)   I64(9);\n                I64(3)   I64(4)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE (NULL + id) IS NULL;\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2);\n                I64(1)   I64(9);\n                I64(3)   I64(4)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE id + 1 IS NULL;\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE 1 + id IS NULL;\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE id - 1 IS NULL;\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE 1 - id IS NULL;\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE id * 1 IS NULL;\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE 1 * id IS NULL;\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE id / 1 IS NULL;\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2)\n            ),\n        ),\n        (\n            \"SELECT id, num FROM Test WHERE 1 / id IS NULL;\",\n            select_with_null!(\n                id   | num;\n                Null   I64(2)\n            ),\n        ),\n        (\n            \"SELECT id + 1, 1 + id, id - 1, 1 - id, id * 1, 1 * id, id / 1, 1 / id FROM Test WHERE id IS NULL;\",\n            select_with_null!(\n                \"id + 1\" | \"1 + id\" | \"id - 1\" | \"1 - id\" | \"id * 1\" | \"1 * id\" | \"id / 1\" | \"1 / id\";\n                Null       Null       Null       Null       Null       Null       Null       Null\n            ),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n\n    g.run(\"UPDATE Test SET id = 2\").await;\n\n    let test_cases = [\n        (\"SELECT id FROM Test\", Ok(select!(id I64; 2; 2; 2))),\n        (\n            \"SELECT id, num FROM Test\",\n            Ok(select!(\n                id  | num\n                I64 | I64;\n                2     2;\n                2     9;\n                2     4\n            )),\n        ),\n        (\n            \"INSERT INTO Test VALUES (1, NULL, 'ok')\",\n            Err(ValueError::NullValueOnNotNullField.into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n\ntest_case!(nullable_text, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Foo (\n            id INTEGER,\n            name TEXT NULL\n        );\n    \",\n    )\n    .await;\n\n    g.run(\"INSERT INTO Foo (id, name) VALUES (1, 'Hello'), (2, Null);\")\n        .await;\n});\n\ntest_case!(nullable_implicit_insert, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Foo (\n            id INTEGER,\n            name TEXT NULL\n        );\n    \",\n    )\n    .await;\n\n    g.run(\"INSERT INTO Foo (id) VALUES (1)\").await;\n    g.test(\n        \"SELECT id, name FROM Foo\",\n        Ok(select_with_null!(\n            id   | name;\n            I64(1)  Null\n        )),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","order_by.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{SortError, TranslateError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(order_by, {\n    let g = get_tester!();\n\n    g.run(\n        \"\nCREATE TABLE Test (\n    id INTEGER,\n    num INTEGER,\n    name TEXT NULL,\n    rate FLOAT NULL\n)\",\n    )\n    .await;\n    g.run(\n        \"\n        INSERT INTO Test (id, num, name, rate)\n        VALUES\n            (1, 2, 'Hello',    3.0),\n            (1, 9, NULL,       NULL),\n            (3, 4, 'World',    1.0),\n            (4, 7, 'Thursday', NULL);\n    \",\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, num FROM Test\",\n        Ok(select!(\n            id  | num\n            I64 | I64;\n            1     2;\n            1     9;\n            3     4;\n            4     7\n        )),\n    )\n    .await;\n\n    macro_rules! s {\n        ($v: literal) =\u003e {\n            Str($v.to_owned())\n        };\n    }\n\n    g.test(\n        \"SELECT id, num, name FROM Test ORDER BY id + num ASC\",\n        Ok(select_with_null!(\n            id     | num    | name;\n            I64(1)   I64(2)   s!(\"Hello\");\n            I64(3)   I64(4)   s!(\"World\");\n            I64(1)   I64(9)   Null;\n            I64(4)   I64(7)   s!(\"Thursday\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, num, name FROM Test ORDER BY num DESC\",\n        Ok(select_with_null!(\n            id     | num    | name;\n            I64(1)   I64(9)   Null;\n            I64(4)   I64(7)   s!(\"Thursday\");\n            I64(3)   I64(4)   s!(\"World\");\n            I64(1)   I64(2)   s!(\"Hello\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, num, name FROM Test ORDER BY name\",\n        Ok(select_with_null!(\n            id     | num    | name;\n            I64(1)   I64(2)   s!(\"Hello\");\n            I64(4)   I64(7)   s!(\"Thursday\");\n            I64(3)   I64(4)   s!(\"World\");\n            I64(1)   I64(9)   Null\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, num, name FROM Test ORDER BY name DESC\",\n        Ok(select_with_null!(\n            id     | num    | name;\n            I64(1)   I64(9)   Null;\n            I64(3)   I64(4)   s!(\"World\");\n            I64(4)   I64(7)   s!(\"Thursday\");\n            I64(1)   I64(2)   s!(\"Hello\")\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, num, name, rate FROM Test ORDER BY rate DESC, id DESC\",\n        Ok(select_with_null!(\n            id     | num    | name           | rate;\n            I64(4)   I64(7)   s!(\"Thursday\")   Null;\n            I64(1)   I64(9)   Null             Null;\n            I64(1)   I64(2)   s!(\"Hello\")      F64(3.0);\n            I64(3)   I64(4)   s!(\"World\")      F64(1.0)\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, num FROM Test ORDER BY id ASC, num DESC\",\n        Ok(select!(\n            id  | num\n            I64 | I64;\n            1     9;\n            1     2;\n            3     4;\n            4     7\n        )),\n    )\n    .await;\n\n    g.test(\n        \"\n        SELECT id, num FROM Test\n        ORDER BY\n            (SELECT id FROM Test t2 WHERE Test.id = t2.id LIMIT 1) ASC,\n            num DESC\n        \",\n        Ok(select!(\n            id  | num\n            I64 | I64;\n            1     9;\n            1     2;\n            3     4;\n            4     7\n        )),\n    )\n    .await;\n\n    g.test(\n        \"\n        SELECT id, num FROM Test\n        ORDER BY\n            (SELECT t2.id FROM Test t2\n                WHERE Test.id = t2.id\n                ORDER BY (Test.id + t2.id) LIMIT 1\n            ) ASC,\n            num DESC;\n        \",\n        Ok(select!(\n            id  | num\n            I64 | I64;\n            1     9;\n            1     2;\n            3     4;\n            4     7\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM Test ORDER BY id NULLS FIRST\",\n        Err(TranslateError::OrderByNullsFirstOrLastNotSupported.into()),\n    )\n    .await;\n    g.named_test(\n        \"ORDER BY aliases\",\n        \"SELECT id AS C1, num AS C2 FROM Test ORDER BY C1 ASC, C2 DESC\",\n        Ok(select!(\n            C1  | C2\n            I64 | I64;\n            1     9;\n            1     2;\n            3     4;\n            4     7\n        )),\n    )\n    .await;\n    g.named_test(\n        \"original column_names still work even if aliases were used at SELECT clause\",\n        \"SELECT id AS C1, num AS C2 FROM Test ORDER BY id ASC, num DESC\",\n        Ok(select!(\n            C1  | C2\n            I64 | I64;\n            1     9;\n            1     2;\n            3     4;\n            4     7\n        )),\n    )\n    .await;\n    g.named_test(\n        \"ORDER BY I64 and UnaryOperator::PLUS work as COLUMN_INDEX\",\n        \"SELECT id, num FROM Test ORDER BY 1 ASC, +2 DESC\",\n        Ok(select!(\n            id  | num\n            I64 | I64;\n            1     9;\n            1     2;\n            3     4;\n            4     7\n        )),\n    )\n    .await;\n    g.named_test(\n        \"ORDER BY UnaryOperator::MINUS works as a normal integer\",\n        \"SELECT id, num FROM Test ORDER BY -1\",\n        Ok(select!(\n            id  | num\n            I64 | I64;\n            1     2;\n            1     9;\n            3     4;\n            4     7\n        )),\n    )\n    .await;\n    g.named_test(\n        \"ORDER BY COLUMN_INDEX should be larger than 0\",\n        \"SELECT id, num FROM Test ORDER BY 0\",\n        Err(SortError::ColumnIndexOutOfRange(0).into()),\n    )\n    .await;\n    g.named_test(\n        \"ORDER BY COLUMN_INDEX should be less than the number of columns\",\n        \"SELECT id, num FROM Test ORDER BY 3\",\n        Err(SortError::ColumnIndexOutOfRange(3).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","ordering.rs"],"content":"use {crate::*, gluesql_core::prelude::Value::Bool};\n\ntest_case!(ordering, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Operator (\n            id INTEGER,\n            name TEXT\n        );\n    \",\n    )\n    .await;\n    g.run(\"DELETE FROM Operator\").await;\n    g.run(\n        \"\n        INSERT INTO Operator (id, name) VALUES\n            (1, 'Abstract'),\n            (2,    'Azzzz'),\n            (3,     'July'),\n            (4,    'Romeo'),\n            (5,    'Trade');\n    \",\n    )\n    .await;\n\n    let test_cases = [\n        (1, \"SELECT * FROM Operator WHERE id \u003c 2;\"),\n        (2, \"SELECT * FROM Operator WHERE id \u003c= 2;\"),\n        (3, \"SELECT * FROM Operator WHERE id \u003e 2;\"),\n        (4, \"SELECT * FROM Operator WHERE id \u003e= 2;\"),\n        (1, \"SELECT * FROM Operator WHERE 2 \u003e id;\"),\n        (2, \"SELECT * FROM Operator WHERE 2 \u003e= id;\"),\n        (3, \"SELECT * FROM Operator WHERE 2 \u003c id;\"),\n        (4, \"SELECT * FROM Operator WHERE 2 \u003c= id;\"),\n        (5, \"SELECT * FROM Operator WHERE 1 \u003c 3;\"),\n        (5, \"SELECT * FROM Operator WHERE 3 \u003e= 3;\"),\n        (0, \"SELECT * FROM Operator WHERE 3 \u003e 3;\"),\n        (\n            5,\n            \"SELECT * FROM Operator o1 WHERE 3 \u003e (SELECT MIN(id) FROM Operator WHERE o1.id \u003c 100);\",\n        ),\n        (2, \"SELECT * FROM Operator WHERE name \u003c 'Azzzzzzzzzz';\"),\n        (1, \"SELECT * FROM Operator WHERE name \u003c 'Az';\"),\n        (5, \"SELECT * FROM Operator WHERE name \u003c 'zz';\"),\n        (5, \"SELECT * FROM Operator WHERE 'aa' \u003c 'zz';\"),\n        (4, \"SELECT * FROM Operator WHERE 'Romeo' \u003e= name;\"),\n        (\n            1,\n            \"SELECT * FROM Operator WHERE (SELECT name FROM Operator LIMIT 1) \u003e= name\",\n        ),\n        (\n            1,\n            \"SELECT * FROM Operator WHERE name \u003c= (SELECT name FROM Operator LIMIT 1)\",\n        ),\n        (\n            5,\n            \"SELECT * FROM Operator WHERE 'zz' \u003e (SELECT name FROM Operator LIMIT 1)\",\n        ),\n        (\n            5,\n            \"SELECT * FROM Operator WHERE (SELECT name FROM Operator LIMIT 1) \u003c 'zz'\",\n        ),\n        (5, \"SELECT * FROM Operator WHERE NOT (1 != 1);\"),\n    ];\n\n    for (num, sql) in test_cases {\n        g.count(sql, num).await;\n    }\n\n    // Literal comparison with BinaryOperator\n    g.test(\"select 1 \u003c 'a' as test\", Ok(select!(test Bool; false)))\n        .await;\n    g.test(\"select 1 \u003e= 'a' as test\", Ok(select!(test Bool; false)))\n        .await;\n    g.test(\"select 1 = 'a' as test\", Ok(select!(test Bool; false)))\n        .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","primary_key.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        data::Value::*,\n        error::{UpdateError, ValidateError, ValueError},\n        prelude::{Key, Payload},\n    },\n};\n\ntest_case!(primary_key, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE Allegro (\n            id INTEGER PRIMARY KEY,\n            name TEXT\n        );\n    \",\n    )\n    .await;\n    g.test(\n        \"INSERT INTO Allegro VALUES (1, 'hello'), (3, 'world');\",\n        Ok(Payload::Insert(2)),\n    )\n    .await;\n\n    g.test(\n        \"SELECT id, name FROM Allegro\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"hello\".to_owned();\n            3     \"world\".to_owned()\n        )),\n    )\n    .await;\n    g.test(\n        \"SELECT id, name FROM Allegro WHERE id = 1\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"hello\".to_owned()\n        )),\n    )\n    .await;\n    g.test(\n        \"SELECT id, name FROM Allegro WHERE id \u003c 2\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"hello\".to_owned()\n        )),\n    )\n    .await;\n    g.test(\n        \"\n            SELECT a.id\n            FROM Allegro a\n            JOIN Allegro a2\n            WHERE a.id = a2.id;\n        \",\n        Ok(select!(id I64; 1; 3)),\n    )\n    .await;\n    g.test(\n        \"\n            SELECT id FROM Allegro WHERE id IN (\n                SELECT id FROM Allegro WHERE id = id\n            );\n        \",\n        Ok(select!(id I64; 1; 3)),\n    )\n    .await;\n\n    g.run(\"INSERT INTO Allegro VALUES (5, 'neon'), (2, 'foo'), (4, 'bar');\")\n        .await;\n\n    g.test(\n        \"SELECT id, name FROM Allegro\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"hello\".to_owned();\n            2     \"foo\".to_owned();\n            3     \"world\".to_owned();\n            4     \"bar\".to_owned();\n            5     \"neon\".to_owned()\n        )),\n    )\n    .await;\n    g.test(\n        \"SELECT id, name FROM Allegro WHERE id % 2 = 0\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            2     \"foo\".to_owned();\n            4     \"bar\".to_owned()\n        )),\n    )\n    .await;\n    g.test(\n        \"SELECT id, name FROM Allegro WHERE id = 4\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            4     \"bar\".to_owned()\n        )),\n    )\n    .await;\n\n    g.run(\"DELETE FROM Allegro WHERE id \u003e 3\").await;\n    g.test(\n        \"SELECT id, name FROM Allegro\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"hello\".to_owned();\n            2     \"foo\".to_owned();\n            3     \"world\".to_owned()\n        )),\n    )\n    .await;\n    g.run(\n        \"\n        CREATE TABLE Strslice (\n            name TEXT PRIMARY KEY\n        );\n        \",\n    )\n    .await;\n    g.run(\"INSERT INTO Strslice VALUES (SUBSTR(SUBSTR('foo', 1), 1));\")\n        .await;\n\n    g.named_test(\n        \"PRIMARY KEY includes UNIQUE constraint\",\n        \"INSERT INTO Allegro VALUES (1, 'another hello');\",\n        Err(ValidateError::DuplicateEntryOnPrimaryKeyField(Key::I64(1)).into()),\n    )\n    .await;\n\n    g.named_test(\n        \"PRIMARY KEY includes NOT NULL constraint\",\n        \"INSERT INTO Allegro VALUES (NULL, 'hello');\",\n        Err(ValueError::NullValueOnNotNullField.into()),\n    )\n    .await;\n\n    g.named_test(\n        \"UPDATE is not allowed for PRIMARY KEY applied column\",\n        \"UPDATE Allegro SET id = 100 WHERE id = 1\",\n        Err(UpdateError::UpdateOnPrimaryKeyNotSupported(\"id\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","project.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{EvaluateError, FetchError},\n        prelude::Value::*,\n    },\n};\n\ntest_case!(project, {\n    let g = get_tester!();\n\n    let create_sqls: [\u0026str; 2] = [\n        \"\n        CREATE TABLE ProjectUser (\n            id INTEGER,\n            name TEXT\n        );\n    \",\n        \"\n        CREATE TABLE ProjectItem (\n            id INTEGER,\n            player_id INTEGER,\n            quantity INTEGER\n        );\n    \",\n    ];\n\n    for sql in create_sqls {\n        g.run(sql).await;\n    }\n\n    let delete_sqls = [\"DELETE FROM ProjectUser\", \"DELETE FROM ProjectItem\"];\n\n    for sql in delete_sqls {\n        g.run(sql).await;\n    }\n\n    let insert_sqls = [\n        \"\n        INSERT INTO ProjectUser (id, name) VALUES\n            (1, 'Taehoon'),\n            (2,    'Mike'),\n            (3,   'Jorno');\n        \",\n        \"\n        INSERT INTO ProjectItem (id, player_id, quantity) VALUES\n            (101, 1, 1),\n            (102, 2, 4),\n            (103, 2, 9),\n            (104, 3, 2),\n            (105, 3, 1);\n        \",\n    ];\n\n    for insert_sql in insert_sqls {\n        g.run(insert_sql).await;\n    }\n\n    let test_cases = [\n        (\"SELECT 1 FROM ProjectUser\", select!(\"1\"; I64; 1; 1; 1)),\n        (\n            \"SELECT id, name FROM ProjectUser\",\n            select!(\n                id  | name\n                I64 | Str;\n                1     \"Taehoon\".to_owned();\n                2     \"Mike\".to_owned();\n                3     \"Jorno\".to_owned()\n            ),\n        ),\n        (\n            \"SELECT player_id, quantity FROM ProjectItem\",\n            select!(player_id | quantity; I64 | I64; 1 1; 2 4; 2 9; 3 2; 3 1),\n        ),\n        (\n            \"SELECT player_id, player_id FROM ProjectItem\",\n            select!(player_id | player_id; I64 | I64; 1 1; 2 2; 2 2; 3 3; 3 3),\n        ),\n        (\n            \"\n            SELECT u.id, i.id, player_id\n            FROM ProjectUser u\n            JOIN ProjectItem i ON u.id = 1 AND u.id = i.player_id\n            \",\n            select!(id | id | player_id; I64 | I64 | I64; 1 101 1),\n        ),\n        (\n            \"\n            SELECT i.*, u.name\n            FROM ProjectUser u\n            JOIN ProjectItem i ON u.id = 2 AND u.id = i.player_id\n            \",\n            select!(\n                id  | player_id | quantity | name\n                I64 | I64       | I64      | Str;\n                102   2           4          \"Mike\".to_owned();\n                103   2           9          \"Mike\".to_owned()\n            ),\n        ),\n        (\n            \"\n            SELECT u.*, i.*\n            FROM ProjectUser u\n            JOIN ProjectItem i ON u.id = i.player_id\n            \",\n            select!(\n                id  | name                 | id  | player_id | quantity\n                I64 | Str                  | I64 | I64       | I64;\n                1     \"Taehoon\".to_owned()   101   1           1;\n                2     \"Mike\".to_owned()      102   2           4;\n                2     \"Mike\".to_owned()      103   2           9;\n                3     \"Jorno\".to_owned()     104   3           2;\n                3     \"Jorno\".to_owned()     105   3           1\n            ),\n        ),\n        (\n            \"SELECT id as Ident, name FROM ProjectUser\",\n            select!(\n                Ident | name\n                I64   | Str;\n                1       \"Taehoon\".to_owned();\n                2       \"Mike\".to_owned();\n                3       \"Jorno\".to_owned()\n            ),\n        ),\n        (\n            \"SELECT (1 + 2) as foo, 2+id+2*100-1 as Ident, name FROM ProjectUser\",\n            select!(\n                foo | Ident | name\n                I64 | I64   | Str;\n                3     202     \"Taehoon\".to_owned();\n                3     203     \"Mike\".to_owned();\n                3     204     \"Jorno\".to_owned()\n            ),\n        ),\n        (\n            \"\n            SELECT id FROM ProjectUser\n            WHERE id IN (\n                SELECT ProjectUser.id FROM ProjectItem\n                WHERE quantity \u003e 5 AND ProjectUser.id = player_id\n            );\",\n            select!(id; I64; 2),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n\n    let error_cases = [\n        (\n            \"SELECT Whatever.* FROM ProjectUser\",\n            FetchError::TableAliasNotFound(\"Whatever\".to_owned()).into(),\n        ),\n        (\n            \"SELECT noname FROM ProjectUser\",\n            EvaluateError::IdentifierNotFound(\"noname\".to_owned()).into(),\n        ),\n        (\n            \"SELECT (SELECT id FROM ProjectItem) as id FROM ProjectItem\",\n            EvaluateError::MoreThanOneRowReturned.into(),\n        ),\n        (\n            \"SELECT (SELECT 1,2)\",\n            EvaluateError::MoreThanOneColumnReturned.into(),\n        ),\n    ];\n\n    for (sql, error) in error_cases {\n        g.test(sql, Err(error)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","schemaless","basic.rs"],"content":"use {\n    crate::*,\n    gluesql_core::prelude::Value::{self, *},\n    serde_json::json,\n};\n\ntest_case!(basic, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE Player\").await;\n    g.run(\n        format!(\n            \"INSERT INTO Player VALUES ('{}'), ('{}');\",\n            json!({ \"id\": 1001, \"name\": \"Beam\", \"flag\": 1 }),\n            json!({ \"id\": 1002, \"name\": \"Seo\" }),\n        )\n        .as_str(),\n    )\n    .await;\n\n    g.run(\"CREATE TABLE Item\").await;\n    g.run(\n        format!(\n            \"INSERT INTO Item VALUES ('{}'), ('{}');\",\n            json!({\n                \"id\": 100,\n                \"name\": \"Test 001\",\n                \"dex\": 324,\n                \"rare\": false,\n                \"obj\": {\n                    \"cost\": 3000\n                }\n            }),\n            json!({\n                \"id\": 200\n            })\n        )\n        .as_str(),\n    )\n    .await;\n\n    g.test(\n        \"SELECT name, dex, rare FROM Item WHERE id = 100\",\n        Ok(select!(\n            name                  | dex | rare\n            Str                   | I64 | Bool;\n            \"Test 001\".to_owned()   324   false\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT name, dex, rare FROM Item\",\n        Ok(select_with_null!(\n            name                       | dex      | rare;\n            Str(\"Test 001\".to_owned())   I64(324)   Bool(false);\n            Null                         Null       Null\n        )),\n    )\n    .await;\n\n    g.test(\n        \"SELECT * FROM Item\",\n        Ok(select_map![\n            json!({\n                \"id\": 100,\n                \"name\": \"Test 001\",\n                \"dex\": 324,\n                \"rare\": false,\n                \"obj\": {\n                    \"cost\": 3000\n                }\n            }),\n            json!({\n                \"id\": 200\n            })\n        ]),\n    )\n    .await;\n\n    g.run(\"DELETE FROM Item WHERE id \u003e 100\").await;\n    g.run(\n        \"\n        UPDATE Item\n        SET\n            id = id + 1,\n            rare = NOT rare\n    \",\n    )\n    .await;\n    g.test(\n        \"SELECT id, name, dex, rare FROM Item\",\n        Ok(select!(\n            id  | name                  | dex | rare\n            I64 | Str                   | I64 | Bool;\n            101   \"Test 001\".to_owned()   324   true\n        )),\n    )\n    .await;\n\n    // add new field to existing row\n    g.run(\"UPDATE Item SET new_field = 'Hello'\").await;\n    g.test(\n        r#\"SELECT new_field, obj['cost'] AS cost FROM Item\"#,\n        Ok(select!(\n            new_field          | cost\n            Str                | I64;\n            \"Hello\".to_owned()   3000\n        )),\n    )\n    .await;\n\n    // join\n    g.test(\n        \"SELECT\n            Player.id AS player_id,\n            Player.name AS player_name,\n            Item.obj['cost'] AS item_cost\n        FROM Item\n        JOIN Player\n        WHERE flag IS NOT NULL;\n        \",\n        Ok(select!(\n            player_id | player_name       | item_cost\n            I64       | Str               | I64;\n            1001        \"Beam\".to_owned()   3000\n        )),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","schemaless","error.rs"],"content":"use {\n    crate::*,\n    gluesql_core::error::{EvaluateError, InsertError, ValueError},\n    serde_json::json,\n};\n\ntest_case!(error, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE Item\").await;\n    g.run(\n        format!(\n            \"INSERT INTO Item VALUES ('{}');\",\n            json!({\n                \"id\": 100,\n                \"name\": \"Test 001\",\n                \"dex\": 324,\n                \"rare\": false,\n                \"obj\": {\n                    \"cost\": 3000\n                }\n            })\n        )\n        .as_str(),\n    )\n    .await;\n\n    g.run(\"CREATE TABLE Player\").await;\n    g.run(\n        format!(\n            \"INSERT INTO Player VALUES ('{}'), ('{}');\",\n            json!({ \"id\": 1001, \"name\": \"Beam\", \"flag\": 1 }),\n            json!({ \"id\": 1002, \"name\": \"Seo\" }),\n        )\n        .as_str(),\n    )\n    .await;\n\n    g.run(\"CREATE TABLE Food\").await;\n    g.run(\n        format!(\n            \"INSERT INTO Food VALUES (SUBSTR(SUBSTR(' hi{}', 4), 1));\",\n            json!({ \"id\": 1, \"name\": \"meat\", \"weight\": 10 }),\n        )\n        .as_str(),\n    )\n    .await;\n\n    g.test(\n        r#\"\n            INSERT INTO Item\n            VALUES (\n                '{ \"a\": 10 }',\n                '{ \"b\": true }'\n            );\n        \"#,\n        Err(InsertError::OnlySingleValueAcceptedForSchemalessRow.into()),\n    )\n    .await;\n    g.test(\n        \"INSERT INTO Item SELECT id, name FROM Item LIMIT 1\",\n        Err(InsertError::OnlySingleValueAcceptedForSchemalessRow.into()),\n    )\n    .await;\n    g.test(\n        \"INSERT INTO Item VALUES ('[1, 2, 3]');\",\n        Err(ValueError::JsonObjectTypeRequired.into()),\n    )\n    .await;\n    g.test(\n        \"INSERT INTO Item VALUES (true);\",\n        Err(EvaluateError::TextLiteralRequired(\"Boolean(true)\".to_owned()).into()),\n    )\n    .await;\n    g.test(\n        \"INSERT INTO Item VALUES (CAST(1 AS INTEGER) + 4)\",\n        Err(EvaluateError::MapOrStringValueRequired(\"5\".to_owned()).into()),\n    )\n    .await;\n    g.test(\n        \"INSERT INTO Item SELECT id FROM Item LIMIT 1\",\n        Err(InsertError::MapTypeValueRequired(\"100\".to_owned()).into()),\n    )\n    .await;\n    g.test(\n        \"SELECT id FROM Item WHERE id IN (SELECT * FROM Item)\",\n        Err(EvaluateError::SchemalessProjectionForInSubQuery.into()),\n    )\n    .await;\n    g.test(\n        \"SELECT id FROM Item WHERE id = (SELECT * FROM Item LIMIT 1)\",\n        Err(EvaluateError::SchemalessProjectionForSubQuery.into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","schemaless.rs"],"content":"mod basic;\nmod error;\n\npub use {basic::basic, error::error};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","series.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{FetchError, TranslateError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(series, {\n    let g = get_tester!();\n\n    let test_cases = vec![\n        (\n            // SERIES(N) has intenal column `N`\n            \"SELECT * FROM SERIES(3)\",\n            Ok(select!(\n                N\n                I64;\n                1;\n                2;\n                3\n            )),\n        ),\n        (\n            // SERIES(N) with lowercase works\n            \"SELECT * FROM sErIeS(3)\",\n            Ok(select!(\n                N\n                I64;\n                1;\n                2;\n                3\n            )),\n        ),\n        (\n            // SERIES(N) with table alias\n            \"SELECT S.* FROM SERIES(3) as S\",\n            Ok(select!(\n                N\n                I64;\n                1;\n                2;\n                3\n            )),\n        ),\n        (\n            // SERIES with unary plus is allowed\n            \"SELECT * FROM SERIES(+3)\",\n            Ok(select!(\n                N\n                I64;\n                1;\n                2;\n                3\n            )),\n        ),\n        (\n            // CTAS with SERIES(N)\n            \"CREATE TABLE SeriesTable AS SELECT * FROM SERIES(3)\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"SELECT * FROM SeriesTable\",\n            Ok(select!(\n                N\n                I64;\n                1;\n                2;\n                3\n            )),\n        ),\n        (\n            // SERIES with size 0 is allowed\n            \"SELECT * FROM SERIES(0)\",\n            Ok(Payload::Select {\n                labels: vec![\"N\".into()],\n                rows: Vec::new(),\n            }),\n        ),\n        (\n            // SERIES without parentheses is a normal table name\n            \"SELECT * FROM SERIES\",\n            Err(FetchError::TableNotFound(\"SERIES\".into()).into()),\n        ),\n        (\n            // SERIES without size is not allowed\n            \"SELECT * FROM SERIES()\",\n            Err(TranslateError::LackOfArgs.into()),\n        ),\n        (\n            // SERIES with unary minus is not allowed\n            \"SELECT * FROM SERIES(-1)\",\n            Err(FetchError::SeriesSizeWrong(-1).into()),\n        ),\n        (\n            // SELECT without Table\n            \"SELECT 1, 'a', true, 1 + 2, 'a' || 'b'\",\n            Ok(select!(\n                \"1\"   | \"'a'\"      | \"true\" | \"1 + 2\" | \"'a' || 'b'\"\n                I64   | Str        | Bool   | I64     | Str;\n                1       \"a\".into()   true     3         \"ab\".into()\n            )),\n        ),\n        (\n            // SELECT without Table in Scalar subquery\n            \"SELECT (SELECT 'Hello')\",\n            Ok(select!(\n                \"(SELECT 'Hello')\"\n                Str;\n                \"Hello\".to_owned()\n            )),\n        ),\n        (\n            // SELECT without Table with Column aliases\n            \"SELECT 1 AS id, (SELECT MAX(N) FROM SERIES(3)) AS max\",\n            Ok(select!(\n                id  | max\n                I64 | I64;\n                1     3\n            )),\n        ),\n        (\n            // SELECT without Table in Drived\n            \"SELECT * FROM (SELECT 1) AS Drived\",\n            Ok(select!(\n                \"1\"\n                I64;\n                1\n            )),\n        ),\n        (\n            // `SELECT *` fetches column `N` for now\n            \"SELECT *\",\n            Ok(select!(\n                N\n                I64;\n                1\n            )),\n        ),\n        (\n            // CTAS without Table\n            \"CREATE TABLE TargetTable AS SELECT 1\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"SELECT * FROM TargetTable\",\n            Ok(select!(\n                N\n                I64;\n                1\n            )),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","show_columns.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast::DataType, error::ExecuteError, executor::Payload},\n};\n\ntest_case!(show_columns, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE mytable (\n            id8 INT8,\n            id INTEGER,\n            rate FLOAT,\n            dec  decimal,\n            flag BOOLEAN,\n            text TEXT,\n            DOB  Date,\n            Tm   Time,\n            ival Interval,\n            tstamp Timestamp,\n            uid    Uuid,\n            hash   Map,\n            glist  List\n        );\n    \",\n    )\n    .await;\n\n    g.test(\n        r#\"Show columns from mytable\"#,\n        Ok(Payload::ShowColumns(vec![\n            (\"id8\".to_owned(), DataType::Int8),\n            (\"id\".to_owned(), DataType::Int),\n            (\"rate\".to_owned(), DataType::Float),\n            (\"dec\".to_owned(), DataType::Decimal),\n            (\"flag\".to_owned(), DataType::Boolean),\n            (\"text\".to_owned(), DataType::Text),\n            (\"DOB\".to_owned(), DataType::Date),\n            (\"Tm\".to_owned(), DataType::Time),\n            (\"ival\".to_owned(), DataType::Interval),\n            (\"tstamp\".to_owned(), DataType::Timestamp),\n            (\"uid\".to_owned(), DataType::Uuid),\n            (\"hash\".to_owned(), DataType::Map),\n            (\"glist\".to_owned(), DataType::List),\n        ])),\n    )\n    .await;\n\n    g.test(\n        r#\"Show columns from mytable1\"#,\n        Err(ExecuteError::TableNotFound(\"mytable1\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","store","insert_schema.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        ast::{AstLiteral, ColumnDef, DataType, Expr},\n        data::Schema,\n    },\n};\n\ntest_case!(insert_schema, {\n    let storage = \u0026mut get_glue!().storage;\n    let column_defs = Some(vec![ColumnDef {\n        name: \"id\".to_owned(),\n        data_type: DataType::Int,\n        nullable: false,\n        default: Some(Expr::Literal(AstLiteral::Number(11.into()))),\n        unique: None,\n        comment: Some(\"default value is lucky eleven\".to_owned()),\n    }]);\n\n    let mut schema = Schema {\n        table_name: \"MutableTable\".to_owned(),\n        column_defs,\n        indexes: Vec::new(),\n        engine: None,\n        foreign_keys: Vec::new(),\n        comment: Some(\"this is comment for table\".to_owned()),\n    };\n\n    storage.begin(true).await.unwrap();\n    storage.insert_schema(\u0026schema).await.unwrap();\n\n    schema.column_defs = schema.column_defs.map(|mut column_defs| {\n        column_defs.push(ColumnDef {\n            name: \"name\".to_owned(),\n            data_type: DataType::Text,\n            nullable: false,\n            default: None,\n            unique: None,\n            comment: Some(\"this is comment for name column\".to_owned()),\n        });\n\n        column_defs\n    });\n\n    storage.insert_schema(\u0026schema).await.unwrap();\n\n    let actual = storage.fetch_schema(\"MutableTable\").await.unwrap().unwrap();\n    assert_eq!(\n        actual.column_defs, schema.column_defs,\n        \"Consecutive insert_schema failed\"\n    );\n    assert_eq!(actual.comment, schema.comment, \"Storing comment failed\");\n\n    let schema = Schema {\n        table_name: \"SchemalessTable\".to_owned(),\n        column_defs: None,\n        indexes: Vec::new(),\n        engine: None,\n        foreign_keys: Vec::new(),\n        comment: Some(\"this is comment for schemaless table\".to_owned()),\n    };\n    storage.insert_schema(\u0026schema).await.unwrap();\n\n    let actual = storage\n        .fetch_schema(\"SchemalessTable\")\n        .await\n        .unwrap()\n        .unwrap();\n    assert_eq!(\n        actual.comment, schema.comment,\n        \"Storing comment to schemaless table failed\"\n    );\n\n    let _ = storage.commit().await;\n});\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","store.rs"],"content":"pub mod insert_schema;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","synthesize.rs"],"content":"use {crate::*, Value::*, gluesql_core::prelude::*};\n\ntest_case!(synthesize, {\n    let g = get_tester!();\n\n    let create_sql = \"\n        CREATE TABLE TableA (\n            id INTEGER,\n            test INTEGER,\n            target_id INTEGER\n        );\n    \";\n\n    g.run(create_sql).await;\n\n    let insert_sqls = [\n        \"\n        INSERT INTO TableA (id, test, target_id) VALUES\n            (1, 100, 2),\n            (2, 100, 1),\n            (3, 300, 5);\n        \",\n        \"INSERT INTO TableA (target_id, id, test) VALUES (5, 3, 400);\",\n        \"INSERT INTO TableA (test, id, target_id) VALUES (500, 3, 4);\",\n        \"INSERT INTO TableA VALUES (4, 500, 3);\",\n    ];\n\n    for insert_sql in insert_sqls {\n        g.run(insert_sql).await;\n    }\n\n    let test_cases = [\n        (6, \"SELECT * FROM TableA;\"),\n        (3, \"SELECT * FROM TableA WHERE id = 3;\"),\n        (\n            3,\n            \"SELECT * FROM TableA WHERE id = (SELECT id FROM TableA WHERE id = 3 LIMIT 1)\",\n        ),\n        (3, \"SELECT * FROM TableA WHERE id IN (1, 2, 4)\"),\n        (3, \"SELECT * FROM TableA WHERE test IN (500, 300)\"),\n        (\n            2,\n            \"SELECT * FROM TableA WHERE id IN (SELECT target_id FROM TableA LIMIT 3)\",\n        ),\n        (1, \"SELECT * FROM TableA WHERE id = 3 AND test = 500;\"),\n        (5, \"SELECT * FROM TableA WHERE id = 3 OR test = 100;\"),\n        (1, \"SELECT * FROM TableA WHERE id != 3 AND test != 100;\"),\n        (2, \"SELECT * FROM TableA WHERE id = 3 LIMIT 2;\"),\n        (4, \"SELECT * FROM TableA LIMIT 10 OFFSET 2;\"),\n        (\n            1,\n            \"SELECT * FROM TableA WHERE (id = 3 OR test = 100) AND test = 300;\",\n        ),\n        (\n            4,\n            \"SELECT * FROM TableA a WHERE target_id = (SELECT id FROM TableA b WHERE b.target_id = a.id LIMIT 1);\",\n        ),\n        (\n            4,\n            \"SELECT * FROM TableA a WHERE target_id = (SELECT id FROM TableA WHERE target_id = a.id LIMIT 1);\",\n        ),\n        (3, \"SELECT * FROM TableA WHERE NOT (id = 3);\"),\n        (2, \"UPDATE TableA SET test = 200 WHERE test = 100;\"),\n        (0, \"SELECT * FROM TableA WHERE test = 100;\"),\n        (2, \"SELECT * FROM TableA WHERE (test = 200);\"),\n        (3, \"DELETE FROM TableA WHERE id != 3;\"),\n        (3, \"SELECT * FROM TableA;\"),\n        (3, \"DELETE FROM TableA;\"),\n    ];\n\n    for (num, sql) in test_cases {\n        g.count(sql, num).await;\n    }\n\n    for insert_sql in insert_sqls {\n        g.run(insert_sql).await;\n    }\n\n    let test_cases = [\n        (\n            \"SELECT id, test FROM TableA LIMIT 1;\",\n            select!(id | test; I64 | I64; 1 100),\n        ),\n        (\"SELECT id FROM TableA LIMIT 1;\", select!(id; I64; 1)),\n        (\n            \"SELECT * FROM TableA LIMIT 1;\",\n            select!(id | test | target_id; I64 | I64 | I64; 1 100 2),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, Ok(expected)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","tester","macros.rs"],"content":"#[macro_export]\nmacro_rules! row {\n    ( $( $p:path )* ; $( $v:expr )* ) =\u003e (\n        vec![$( $p($v) ),*]\n    )\n}\n\n#[macro_export]\nmacro_rules! idx {\n    () =\u003e {\n        vec![]\n    };\n    ($name: path, $op: path, $sql_expr: literal) =\u003e {\n        vec![gluesql_core::ast::IndexItem::NonClustered {\n            name: stringify_label!($name).to_owned(),\n            asc: None,\n            cmp_expr: Some((\n                $op,\n                gluesql_core::translate::translate_expr(\n                    \u0026gluesql_core::parse_sql::parse_expr($sql_expr).unwrap(),\n                )\n                .unwrap(),\n            )),\n        }]\n    };\n    ($name: path) =\u003e {\n        vec![gluesql_core::ast::IndexItem::NonClustered {\n            name: stringify_label!($name).to_owned(),\n            asc: None,\n            cmp_expr: None,\n        }]\n    };\n    ($name: path, ASC) =\u003e {\n        vec![gluesql_core::ast::IndexItem::NonClustered {\n            name: stringify_label!($name).to_owned(),\n            asc: Some(true),\n            cmp_expr: None,\n        }]\n    };\n    ($name: path, DESC) =\u003e {\n        vec![gluesql_core::ast::IndexItem::NonClustered {\n            name: stringify_label!($name).to_owned(),\n            asc: Some(false),\n            cmp_expr: None,\n        }]\n    };\n}\n\n#[macro_export]\nmacro_rules! select {\n    ( $( $c: tt )|+ $( ; )? $( $t: path )|+ ; $( $v: expr )+ ; $( $( $v2: expr )+ );+) =\u003e ({\n        let mut rows = vec![\n            row!($( $t )+ ; $( $v )+),\n        ];\n\n        gluesql_core::executor::Payload::Select {\n            labels: vec![$( stringify_label!($c).to_owned()),+],\n            rows: concat_with!(rows ; $( $t )+ ; $( $( $v2 )+ );+)\n        }\n    });\n    ( $( $c: tt )|+ $( ; )? $( $t: path )|+ ; $( $v: expr )+ ) =\u003e (\n        gluesql_core::executor::Payload::Select {\n            labels: vec![$( stringify_label!($c).to_owned()),+],\n            rows: vec![row!($( $t )+ ; $( $v )+ )],\n        }\n    );\n    ( $( $c: tt )|+ $( ; )?) =\u003e (\n        gluesql_core::executor::Payload::Select {\n            labels: vec![$( stringify_label!($c).to_owned()),+],\n            rows: vec![],\n        }\n    );\n}\n\n#[macro_export]\nmacro_rules! concat_with {\n    ( $rows: ident ; $( $t:path )* ; $( $v: expr )* ) =\u003e ({\n        $rows.push(row!($( $t )* ; $( $v )*));\n\n        $rows\n    });\n    ( $rows: ident ; $( $t:path )* ; $( $v: expr )* ; $( $( $v2: expr )* );* ) =\u003e ({\n        $rows.push(row!($( $t )* ; $( $v )*));\n\n        concat_with!($rows ; $( $t )* ; $( $( $v2 )* );* )\n    });\n}\n\n#[macro_export]\nmacro_rules! stringify_label {\n    ($label: literal) =\u003e {\n        $label\n    };\n    ($label: tt) =\u003e {\n        stringify!($label)\n    };\n}\n\n#[macro_export]\nmacro_rules! select_with_null {\n    ( $( $c: tt )|* ; $( $v: expr )* ) =\u003e (\n        gluesql_core::executor::Payload::Select {\n            labels: vec![$( stringify_label!($c).to_owned()),+],\n            rows: vec![vec![$( $v ),*]],\n        }\n    );\n    ( $( $c: tt )|* ; $( $v: expr )* ; $( $( $v2: expr )* );*) =\u003e ({\n        let mut rows = vec![vec![$( $v ),*]];\n\n        gluesql_core::executor::Payload::Select {\n            labels: vec![$( stringify_label!($c).to_owned()),+],\n            rows: concat_with_null!(rows ; $( $( $v2 )* );*),\n        }\n    });\n}\n\n#[macro_export]\nmacro_rules! concat_with_null {\n    ( $rows: ident ; $( $v: expr )* ) =\u003e ({\n        $rows.push(vec![$( $v ),*]);\n\n        $rows\n    });\n    ( $rows: ident ; $( $v: expr )* ; $( $( $v2: expr )* );* ) =\u003e ({\n        $rows.push(vec![$( $v ),*]);\n\n        concat_with_null!($rows ; $( $( $v2 )* );* )\n    });\n}\n\n#[macro_export]\nmacro_rules! select_map {\n    ( $( $row: expr ),* ) =\u003e (\n        gluesql_core::executor::Payload::SelectMap(vec![\n            $(\n                match gluesql_core::data::Value::try_from($row).unwrap() {\n                    Value::Map(v) =\u003e v,\n                    _ =\u003e panic!(\"select_map! - Value::Map type required\"),\n                }\n            ),*\n        ])\n    )\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","tester.rs"],"content":"use {\n    async_trait::async_trait,\n    gluesql_core::{\n        ast::*,\n        parse_sql::parse_expr,\n        prelude::*,\n        store::{GStore, GStoreMut},\n        translate::translate_expr,\n    },\n    pretty_assertions::assert_eq,\n};\n\npub mod macros;\n\npub fn expr(sql: \u0026str) -\u003e Expr {\n    let parsed = parse_expr(sql).unwrap();\n\n    translate_expr(\u0026parsed).unwrap()\n}\n\npub async fn run\u003cT: GStore + GStoreMut\u003e(\n    sql: \u0026str,\n    glue: \u0026mut Glue\u003cT\u003e,\n    indexes: Option\u003cVec\u003cIndexItem\u003e\u003e,\n) -\u003e Result\u003cPayload\u003e {\n    println!(\"[SQL] {}\", sql);\n    let parsed = parse(sql)?;\n    let statement = translate(\u0026parsed[0])?;\n    let statement = plan(\u0026glue.storage, statement).await?;\n\n    test_indexes(\u0026statement, indexes);\n\n    glue.execute_stmt(\u0026statement).await\n}\n\npub fn test_indexes(statement: \u0026Statement, indexes: Option\u003cVec\u003cIndexItem\u003e\u003e) {\n    if let Some(expected) = indexes {\n        let found = find_indexes(statement);\n\n        if expected.len() != found.len() {\n            panic!(\n                \"num of indexes does not match: found({}) != expected({})\",\n                found.len(),\n                expected.len(),\n            );\n        }\n\n        for expected_index in expected {\n            if !found.contains(\u0026(\u0026expected_index)) {\n                panic!(\"index does not exist: {:#?}\", expected_index)\n            }\n        }\n    }\n}\n\nfn find_indexes(statement: \u0026Statement) -\u003e Vec\u003c\u0026IndexItem\u003e {\n    fn find_expr_indexes(expr: \u0026Expr) -\u003e Vec\u003c\u0026IndexItem\u003e {\n        match expr {\n            Expr::Subquery(query)\n            | Expr::Exists {\n                subquery: query, ..\n            }\n            | Expr::InSubquery {\n                subquery: query, ..\n            } =\u003e find_query_indexes(query),\n            _ =\u003e vec![],\n        }\n    }\n\n    fn find_query_indexes(query: \u0026Query) -\u003e Vec\u003c\u0026IndexItem\u003e {\n        let select = match \u0026query.body {\n            SetExpr::Select(select) =\u003e select,\n            _ =\u003e {\n                return vec![];\n            }\n        };\n\n        let selection_indexes = select\n            .selection\n            .as_ref()\n            .map(find_expr_indexes)\n            .unwrap_or_default();\n\n        let table_indexes = match \u0026select.from.relation {\n            TableFactor::Table {\n                index: Some(index), ..\n            } =\u003e vec![index],\n            _ =\u003e vec![],\n        };\n\n        [selection_indexes, table_indexes].concat()\n    }\n\n    match statement {\n        Statement::Query(query) =\u003e find_query_indexes(query),\n        _ =\u003e vec![],\n    }\n}\n\npub fn type_match(expected: \u0026[DataType], found: Result\u003cPayload\u003e) {\n    let rows = match found {\n        Ok(Payload::Select {\n            labels: _expected_labels,\n            rows,\n        }) =\u003e rows,\n        _ =\u003e panic!(\"type match is only for Select\"),\n    };\n\n    for (i, items) in rows.iter().enumerate() {\n        assert_eq!(\n            items.len(),\n            expected.len(),\n            \"\\n[err: size of row] row index: {}\\n found: {:?}\\n expected: {:?}\",\n            i,\n            items.len(),\n            expected.len()\n        );\n\n        items\n            .iter()\n            .zip(expected.iter())\n            .for_each(|(value, data_type)| match value.validate_type(data_type) {\n                Ok(_) =\u003e {}\n                Err(_) =\u003e panic!(\n                    \"[err: type match failed]\\n found {:?}\\n expected {:?}\\n\",\n                    value, data_type\n                ),\n            })\n    }\n}\n\n/// If you want to make your custom storage and want to run integrate tests,\n/// you should implement this `Tester` trait.\n///\n/// To see how to use it,\n/// * [tests/memory_storage.rs](https://github.com/gluesql/gluesql/blob/main/storages/memory-storage/tests/memory_storage.rs)\n/// * [tests/sled_storage.rs](https://github.com/gluesql/gluesql/blob/main/storages/sled-storage/tests/sled_storage.rs)\n///\n/// Actual test cases are in [test-suite/src/](https://github.com/gluesql/gluesql/blob/main/test-suite/src/),\n/// not in `/tests/`.\n#[async_trait(?Send)]\npub trait Tester\u003cT: GStore + GStoreMut\u003e {\n    async fn new(namespace: \u0026str) -\u003e Self;\n\n    fn get_glue(\u0026mut self) -\u003e \u0026mut Glue\u003cT\u003e;\n\n    async fn run_inner(\u0026mut self, sql: \u0026str) -\u003e Result\u003cPayload\u003e {\n        let glue = self.get_glue();\n\n        println!(\"[RUN] {}\", sql);\n        let parsed = parse(sql)?;\n        let statement = translate(\u0026parsed[0])?;\n        let statement = plan(\u0026glue.storage, statement).await?;\n\n        glue.execute_stmt(\u0026statement).await\n    }\n\n    async fn run(\u0026mut self, sql: \u0026str) -\u003e Payload {\n        self.run_inner(sql).await.unwrap()\n    }\n\n    async fn run_err(\u0026mut self, sql: \u0026str) -\u003e Error {\n        self.run_inner(sql).await.unwrap_err()\n    }\n\n    async fn count(\u0026mut self, sql: \u0026str, expected: usize) {\n        let actual = match self.run_inner(sql).await.unwrap() {\n            Payload::Select { rows, .. } =\u003e rows.len(),\n            Payload::Delete(num) | Payload::Update(num) =\u003e num,\n            _ =\u003e panic!(\"compare is only for Select, Delete and Update\"),\n        };\n\n        assert_eq!(actual, expected, \"[COUNT] {sql}\");\n    }\n\n    async fn type_match(\u0026mut self, sql: \u0026str, expected: \u0026[DataType]) {\n        let actual = self.run_inner(sql).await.unwrap();\n\n        type_match(expected, Ok(actual));\n    }\n\n    async fn test(\u0026mut self, sql: \u0026str, expected: Result\u003cPayload\u003e) {\n        let actual = self.run_inner(sql).await;\n\n        assert_eq!(actual, expected, \"[TEST] {sql}\");\n    }\n\n    async fn named_test(\u0026mut self, name: \u0026str, sql: \u0026str, expected: Result\u003cPayload\u003e) {\n        let actual = self.run_inner(sql).await;\n\n        assert_eq!(actual, expected, \"[TEST] {name}\");\n    }\n\n    async fn test_idx(\u0026mut self, sql: \u0026str, expected: Result\u003cPayload\u003e, indexes: Vec\u003cIndexItem\u003e) {\n        let glue = self.get_glue();\n\n        let parsed = parse(sql).unwrap();\n        let statement = translate(\u0026parsed[0]).unwrap();\n        let statement = plan(\u0026glue.storage, statement).await.unwrap();\n\n        test_indexes(\u0026statement, Some(indexes));\n\n        let actual = glue.execute_stmt(\u0026statement).await;\n\n        assert_eq!(actual, expected, \"[TEST IDX] {sql}\");\n    }\n}\n\n#[macro_export]\nmacro_rules! test_case {\n    ($name: ident, $content: expr) =\u003e {\n        pub async fn $name\u003cT\u003e(mut tester: impl $crate::Tester\u003cT\u003e)\n        where\n            T: gluesql_core::store::GStore + gluesql_core::store::GStoreMut,\n        {\n            #[allow(unused_variables)]\n            let glue = tester.get_glue();\n\n            #[allow(unused_macros)]\n            macro_rules! get_glue {\n                () =\u003e {\n                    glue\n                };\n            }\n\n            #[allow(unused_macros)]\n            macro_rules! get_tester {\n                () =\u003e {\n                    \u0026mut tester\n                };\n            }\n\n            async {\n                $content;\n\n                gluesql_core::prelude::Result::\u003c()\u003e::Ok(())\n            }\n            .await\n            .unwrap()\n        }\n    };\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":106},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","transaction","alter_table.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::FetchError, prelude::Value::*},\n};\n\ntest_case!(alter_table_rename_table, {\n    let g = get_tester!();\n\n    for query in [\n        \"CREATE TABLE RenameTable (id INTEGER);\",\n        \"INSERT INTO RenameTable VALUES (1);\",\n        \"BEGIN;\",\n        \"ALTER TABLE RenameTable RENAME TO NewName;\",\n    ] {\n        g.run(query).await;\n    }\n\n    g.test(\n        \"SELECT * FROM RenameTable\",\n        Err(FetchError::TableNotFound(\"RenameTable\".to_owned()).into()),\n    )\n    .await;\n    g.test(\"SELECT * FROM NewName\", Ok(select!(id I64; 1)))\n        .await;\n\n    g.run(\"ROLLBACK;\").await;\n\n    g.test(\n        \"SELECT * FROM NewName\",\n        Err(FetchError::TableNotFound(\"NewName\".to_owned()).into()),\n    )\n    .await;\n    g.test(\"SELECT * FROM RenameTable\", Ok(select!(id I64; 1)))\n        .await;\n});\n\ntest_case!(alter_table_rename_column, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE RenameCol (id INTEGER);\").await;\n    g.run(\"INSERT INTO RenameCol VALUES (1);\").await;\n\n    // ROLLBACK\n    g.run(\"BEGIN;\").await;\n    g.run(\"ALTER TABLE RenameCol RENAME COLUMN id TO new_id;\")\n        .await;\n    g.test(\"SELECT * FROM RenameCol\", Ok(select!(new_id I64; 1)))\n        .await;\n    g.run(\"ROLLBACK;\").await;\n    g.test(\"SELECT * FROM RenameCol\", Ok(select!(id I64; 1)))\n        .await;\n\n    // COMMIT\n    g.run(\"BEGIN;\").await;\n    g.run(\"ALTER TABLE RenameCol RENAME COLUMN id TO new_id;\")\n        .await;\n    g.run(\"COMMIT;\").await;\n    g.test(\"SELECT * FROM RenameCol\", Ok(select!(new_id I64; 1)))\n        .await;\n});\n\ntest_case!(alter_table_add_column, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE AddCol (id INTEGER);\").await;\n    g.run(\"INSERT INTO AddCol VALUES (1);\").await;\n\n    // ROLLBACK\n    g.run(\"BEGIN;\").await;\n    g.run(\"ALTER TABLE AddCol ADD COLUMN new_col INTEGER DEFAULT 3;\")\n        .await;\n    g.test(\n        \"SELECT * FROM AddCol\",\n        Ok(select!(\n            id  | new_col\n            I64 | I64;\n            1     3\n        )),\n    )\n    .await;\n    g.run(\"ROLLBACK;\").await;\n    g.test(\"SELECT * FROM AddCol\", Ok(select!(id I64; 1))).await;\n\n    // COMMIT\n    g.run(\"BEGIN;\").await;\n    g.run(\"ALTER TABLE AddCol ADD COLUMN new_col INTEGER DEFAULT 3;\")\n        .await;\n    g.run(\"COMMIT;\").await;\n    g.test(\n        \"SELECT * FROM AddCol\",\n        Ok(select!(\n            id  | new_col\n            I64 | I64;\n            1     3\n        )),\n    )\n    .await;\n});\n\ntest_case!(alter_table_drop_column, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE DropCol (id INTEGER, num INTEGER);\")\n        .await;\n    g.run(\"INSERT INTO DropCol VALUES (1, 2);\").await;\n\n    // ROLLBACK\n    g.run(\"BEGIN;\").await;\n    g.run(\"ALTER TABLE DropCol DROP COLUMN num;\").await;\n    g.test(\"SELECT * FROM DropCol\", Ok(select!(id I64; 1)))\n        .await;\n    g.run(\"ROLLBACK;\").await;\n    g.test(\n        \"SELECT * FROM DropCol\",\n        Ok(select!(\n            id  | num\n            I64 | I64;\n            1     2\n        )),\n    )\n    .await;\n\n    // COMMIT\n    g.run(\"BEGIN;\").await;\n    g.run(\"ALTER TABLE DropCol DROP COLUMN num;\").await;\n    g.run(\"COMMIT;\").await;\n    g.test(\"SELECT * FROM DropCol\", Ok(select!(id I64; 1)))\n        .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","transaction","ast_builder.rs"],"content":"use {\n    crate::*,\n    Value::*,\n    gluesql_core::{ast_builder::*, prelude::*},\n};\n\ntest_case!(ast_builder, {\n    let glue = get_glue!();\n\n    let actual = table(\"TxTest\")\n        .create_table()\n        .add_column(\"id INTEGER\")\n        .add_column(\"name TEXT\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Create);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .insert()\n        .columns(\"id, name\")\n        .values(vec![\n            vec![num(1), text(\"Friday\")],\n            vec![num(2), text(\"Phone\")],\n        ])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(2));\n    assert_eq!(actual, expected);\n\n    let actual = begin().execute(glue).await;\n    let expected = Ok(Payload::StartTransaction);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .insert()\n        .columns(\"id, name\")\n        .values(vec![vec![num(3), text(\"Vienna\")]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected);\n\n    let actual = rollback().execute(glue).await;\n    let expected = Ok(Payload::Rollback);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Friday\".to_owned();\n        2     \"Phone\".to_owned()\n    ));\n    assert_eq!(actual, expected);\n\n    let actual = begin().execute(glue).await;\n    let expected = Ok(Payload::StartTransaction);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .insert()\n        .columns(\"id, name\")\n        .values(vec![vec![num(3), text(\"Vienna\")]])\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Insert(1));\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Friday\".to_owned();\n        2     \"Phone\".to_owned();\n        3     \"Vienna\".to_owned()\n    ));\n    assert_eq!(actual, expected);\n\n    let actual = commit().execute(glue).await;\n    let expected = Ok(Payload::Commit);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Friday\".to_owned();\n        2     \"Phone\".to_owned();\n        3     \"Vienna\".to_owned()\n    ));\n    assert_eq!(actual, expected);\n\n    // DELETE\n    let actual = begin().execute(glue).await;\n    let expected = Ok(Payload::StartTransaction);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .delete()\n        .filter(\"id = 3\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Delete(1));\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Friday\".to_owned();\n        2     \"Phone\".to_owned()\n    ));\n    assert_eq!(actual, expected);\n\n    let actual = rollback().execute(glue).await;\n    let expected = Ok(Payload::Rollback);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Friday\".to_owned();\n        2     \"Phone\".to_owned();\n        3     \"Vienna\".to_owned()\n    ));\n    assert_eq!(actual, expected);\n\n    let actual = begin().execute(glue).await;\n    let expected = Ok(Payload::StartTransaction);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .delete()\n        .filter(\"id = 3\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Delete(1));\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Friday\".to_owned();\n        2     \"Phone\".to_owned()\n    ));\n    assert_eq!(actual, expected);\n\n    let actual = commit().execute(glue).await;\n    let expected = Ok(Payload::Commit);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Friday\".to_owned();\n        2     \"Phone\".to_owned()\n    ));\n    assert_eq!(actual, expected);\n\n    // UPDATE\n    let actual = begin().execute(glue).await;\n    let expected = Ok(Payload::StartTransaction);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .update()\n        .filter(\"id = 1\")\n        .set(\"name\", \"'Sunday'\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Update(1));\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Sunday\".to_owned();\n        2     \"Phone\".to_owned()\n    ));\n    assert_eq!(actual, expected);\n\n    let actual = rollback().execute(glue).await;\n    let expected = Ok(Payload::Rollback);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Friday\".to_owned();\n        2     \"Phone\".to_owned()\n    ));\n    assert_eq!(actual, expected);\n\n    let actual = begin().execute(glue).await;\n    let expected = Ok(Payload::StartTransaction);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .update()\n        .filter(\"id = 1\")\n        .set(\"name\", \"'Sunday'\")\n        .execute(glue)\n        .await;\n    let expected = Ok(Payload::Update(1));\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Sunday\".to_owned();\n        2     \"Phone\".to_owned()\n    ));\n    assert_eq!(actual, expected);\n\n    let actual = commit().execute(glue).await;\n    let expected = Ok(Payload::Commit);\n    assert_eq!(actual, expected);\n\n    let actual = table(\"TxTest\")\n        .select()\n        .project(\"id, name\")\n        .execute(glue)\n        .await;\n    let expected = Ok(select!(\n        id  | name\n        I64 | Str;\n        1     \"Sunday\".to_owned();\n        2     \"Phone\".to_owned()\n    ));\n    assert_eq!(actual, expected);\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","transaction","basic.rs"],"content":"use {crate::*, Value::*, gluesql_core::prelude::*};\n\ntest_case!(basic, {\n    let g = get_tester!();\n\n    for query in [\n        \"\n        CREATE TABLE TxTest (\n            id INTEGER,\n            name TEXT\n        );\n    \",\n        \"\n        INSERT INTO TxTest VALUES\n            (1, 'Friday'),\n            (2, 'Phone');\n    \",\n    ] {\n        g.run(query).await;\n    }\n\n    g.test(\"BEGIN;\", Ok(Payload::StartTransaction)).await;\n    g.test(\n        \"INSERT INTO TxTest VALUES (3, 'New one');\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n    g.test(\"ROLLBACK;\", Ok(Payload::Rollback)).await;\n    g.test(\n        \"SELECT id, name FROM TxTest\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"Friday\".to_owned();\n            2     \"Phone\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\"BEGIN;\", Ok(Payload::StartTransaction)).await;\n    g.test(\n        \"INSERT INTO TxTest VALUES (3, 'Vienna');\",\n        Ok(Payload::Insert(1)),\n    )\n    .await;\n    g.test(\n        \"SELECT id, name FROM TxTest\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"Friday\".to_owned();\n            2     \"Phone\".to_owned();\n            3     \"Vienna\".to_owned()\n        )),\n    )\n    .await;\n\n    g.test(\"COMMIT;\", Ok(Payload::Commit)).await;\n    g.test(\n        \"SELECT id, name FROM TxTest\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"Friday\".to_owned();\n            2     \"Phone\".to_owned();\n            3     \"Vienna\".to_owned()\n        )),\n    )\n    .await;\n\n    // DELETE\n    g.test(\"BEGIN;\", Ok(Payload::StartTransaction)).await;\n    g.test(\"DELETE FROM TxTest WHERE id = 3;\", Ok(Payload::Delete(1)))\n        .await;\n    g.test(\n        \"SELECT id, name FROM TxTest\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"Friday\".to_owned();\n            2     \"Phone\".to_owned()\n        )),\n    )\n    .await;\n    g.test(\"ROLLBACK;\", Ok(Payload::Rollback)).await;\n    g.test(\n        \"SELECT id, name FROM TxTest\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"Friday\".to_owned();\n            2     \"Phone\".to_owned();\n            3     \"Vienna\".to_owned()\n        )),\n    )\n    .await;\n    g.test(\"BEGIN;\", Ok(Payload::StartTransaction)).await;\n    g.test(\"DELETE FROM TxTest WHERE id = 3;\", Ok(Payload::Delete(1)))\n        .await;\n    g.test(\n        \"SELECT id, name FROM TxTest\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"Friday\".to_owned();\n            2     \"Phone\".to_owned()\n        )),\n    )\n    .await;\n    g.test(\"COMMIT;\", Ok(Payload::Commit)).await;\n    g.test(\n        \"SELECT id, name FROM TxTest\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"Friday\".to_owned();\n            2     \"Phone\".to_owned()\n        )),\n    )\n    .await;\n\n    // UPDATE\n    g.test(\"BEGIN;\", Ok(Payload::StartTransaction)).await;\n    g.test(\n        \"UPDATE TxTest SET name = 'Sunday' WHERE id = 1;\",\n        Ok(Payload::Update(1)),\n    )\n    .await;\n    g.test(\n        \"SELECT id, name FROM TxTest\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"Sunday\".to_owned();\n            2     \"Phone\".to_owned()\n        )),\n    )\n    .await;\n    g.test(\"ROLLBACK;\", Ok(Payload::Rollback)).await;\n    g.test(\n        \"SELECT id, name FROM TxTest\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"Friday\".to_owned();\n            2     \"Phone\".to_owned()\n        )),\n    )\n    .await;\n    g.test(\"BEGIN;\", Ok(Payload::StartTransaction)).await;\n    g.test(\n        \"UPDATE TxTest SET name = 'Sunday' WHERE id = 1;\",\n        Ok(Payload::Update(1)),\n    )\n    .await;\n    g.test(\n        \"SELECT id, name FROM TxTest\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"Sunday\".to_owned();\n            2     \"Phone\".to_owned()\n        )),\n    )\n    .await;\n    g.test(\"COMMIT;\", Ok(Payload::Commit)).await;\n    g.test(\n        \"SELECT id, name FROM TxTest\",\n        Ok(select!(\n            id  | name\n            I64 | Str;\n            1     \"Sunday\".to_owned();\n            2     \"Phone\".to_owned()\n        )),\n    )\n    .await;\n\n    for query in [\n        \"BEGIN;\",\n        \"SELECT * FROM TxTest;\",\n        \"ROLLBACK;\",\n        \"BEGIN;\",\n        \"SELECT * FROM TxTest;\",\n        \"COMMIT;\",\n        \"BEGIN;\",\n        \"COMMIT;\",\n    ] {\n        g.run(query).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","transaction","dictionary.rs"],"content":"use {crate::*, gluesql_core::prelude::*};\n\ntest_case!(dictionary, {\n    let g = get_tester!();\n\n    let tables = |v: Vec\u003c\u0026str\u003e| {\n        Ok(Payload::ShowVariable(PayloadVariable::Tables(\n            v.into_iter().map(ToOwned::to_owned).collect(),\n        )))\n    };\n\n    g.run(\"CREATE TABLE Garlic (id INTEGER);\").await;\n    g.test(\"SHOW TABLES;\", tables(vec![\"Garlic\"])).await;\n\n    g.run(\"BEGIN;\").await;\n    g.test(\"SHOW TABLES;\", tables(vec![\"Garlic\"])).await;\n\n    g.run(\"CREATE TABLE Noodle (id INTEGER);\").await;\n    g.test(\"SHOW TABLES;\", tables(vec![\"Garlic\", \"Noodle\"]))\n        .await;\n\n    g.run(\"ROLLBACK;\").await;\n    g.test(\"SHOW TABLES;\", tables(vec![\"Garlic\"])).await;\n\n    g.run(\"BEGIN;\").await;\n    g.run(\"CREATE TABLE Apple (id INTEGER);\").await;\n    g.run(\"CREATE TABLE Rice (id INTEGER);\").await;\n    g.test(\"SHOW TABLES;\", tables(vec![\"Apple\", \"Garlic\", \"Rice\"]))\n        .await;\n\n    g.run(\"COMMIT;\").await;\n    g.test(\"SHOW TABLES;\", tables(vec![\"Apple\", \"Garlic\", \"Rice\"]))\n        .await;\n});\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","transaction","index.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast::IndexOperator::*, prelude::Value::*},\n};\n\ntest_case!(index_create, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE IdxCreate (id INTEGER);\").await;\n    g.run(\"INSERT INTO IdxCreate VALUES (1);\").await;\n\n    // ROLLBACK\n    g.run(\"BEGIN;\").await;\n    g.run(\"CREATE INDEX idx_id ON IdxCreate (id);\").await;\n    g.test_idx(\n        \"SELECT id FROM IdxCreate WHERE id = 1\",\n        Ok(select!(id I64; 1)),\n        idx!(idx_id, Eq, \"1\"),\n    )\n    .await;\n    g.run(\"ROLLBACK;\").await;\n    g.test_idx(\n        \"SELECT id FROM IdxCreate WHERE id = 1\",\n        Ok(select!(id I64; 1)),\n        idx!(),\n    )\n    .await;\n\n    // COMMIT;\n    g.run(\"BEGIN;\").await;\n    g.run(\"CREATE INDEX idx_id ON IdxCreate (id);\").await;\n    g.test_idx(\n        \"SELECT id FROM IdxCreate WHERE id = 1\",\n        Ok(select!(id I64; 1)),\n        idx!(idx_id, Eq, \"1\"),\n    )\n    .await;\n    g.run(\"COMMIT;\").await;\n    g.test_idx(\n        \"SELECT id FROM IdxCreate WHERE id = 1\",\n        Ok(select!(id I64; 1)),\n        idx!(idx_id, Eq, \"1\"),\n    )\n    .await;\n\n    g.run(\"DELETE FROM IdxCreate;\").await;\n    g.run(\"INSERT INTO IdxCreate VALUES (3);\").await;\n\n    // CREATE MORE\n    g.run(\"BEGIN;\").await;\n    g.run(\"CREATE INDEX idx_id2 ON IdxCreate (id * 2);\").await;\n    g.test_idx(\n        \"SELECT id FROM IdxCreate WHERE id = 3\",\n        Ok(select!(id I64; 3)),\n        idx!(idx_id, Eq, \"3\"),\n    )\n    .await;\n    g.test_idx(\n        \"SELECT id FROM IdxCreate WHERE id * 2 = 6\",\n        Ok(select!(id I64; 3)),\n        idx!(idx_id2, Eq, \"6\"),\n    )\n    .await;\n    g.run(\"ROLLBACK;\").await;\n\n    g.test_idx(\n        \"SELECT id FROM IdxCreate WHERE id = 3\",\n        Ok(select!(id I64; 3)),\n        idx!(idx_id, Eq, \"3\"),\n    )\n    .await;\n    g.test_idx(\n        \"SELECT id FROM IdxCreate WHERE id * 2 = 6\",\n        Ok(select!(id I64; 3)),\n        idx!(),\n    )\n    .await;\n});\n\ntest_case!(index_drop, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE IdxDrop (id INTEGER);\").await;\n    g.run(\"INSERT INTO IdxDrop VALUES (1);\").await;\n    g.run(\"CREATE INDEX idx_id ON IdxDrop (id);\").await;\n\n    // ROLLBACK\n    g.run(\"BEGIN;\").await;\n    g.run(\"DROP INDEX IdxDrop.idx_id;\").await;\n    g.test_idx(\n        \"SELECT id FROM IdxDrop WHERE id = 1\",\n        Ok(select!(id I64; 1)),\n        idx!(),\n    )\n    .await;\n    g.run(\"ROLLBACK;\").await;\n    g.test_idx(\n        \"SELECT id FROM IdxDrop WHERE id = 1\",\n        Ok(select!(id I64; 1)),\n        idx!(idx_id, Eq, \"1\"),\n    )\n    .await;\n\n    // COMMIT;\n    g.run(\"BEGIN;\").await;\n    g.run(\"DROP INDEX IdxDrop.idx_id;\").await;\n    g.test_idx(\n        \"SELECT id FROM IdxDrop WHERE id = 1\",\n        Ok(select!(id I64; 1)),\n        idx!(),\n    )\n    .await;\n    g.run(\"COMMIT;\").await;\n    g.test_idx(\n        \"SELECT id FROM IdxDrop WHERE id = 1\",\n        Ok(select!(id I64; 1)),\n        idx!(),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","transaction","table.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::FetchError, prelude::Value::*},\n};\n\ntest_case!(create_drop_table, {\n    let g = get_tester!();\n\n    // CREATE \u0026\u0026 ROLLBACK\n    g.run(\"BEGIN;\").await;\n    g.run(\"CREATE TABLE Test (id INTEGER);\").await;\n    g.run(\"INSERT INTO Test VALUES (1);\").await;\n    g.test(\"SELECT * FROM Test;\", Ok(select!(id I64; 1))).await;\n    g.run(\"ROLLBACK;\").await;\n    g.test(\n        \"SELECT * FROM Test;\",\n        Err(FetchError::TableNotFound(\"Test\".to_owned()).into()),\n    )\n    .await;\n\n    // CREATE \u0026\u0026 COMMIT\n    g.run(\"BEGIN;\").await;\n    g.run(\"CREATE TABLE Test (id INTEGER);\").await;\n    g.run(\"INSERT INTO Test VALUES (3);\").await;\n    g.run(\"COMMIT;\").await;\n    g.test(\"SELECT * FROM Test;\", Ok(select!(id I64; 3))).await;\n\n    // DROP \u0026\u0026 ROLLBACK\n    g.run(\"BEGIN;\").await;\n    g.run(\"DROP TABLE Test;\").await;\n    g.test(\n        \"SELECT * FROM Test;\",\n        Err(FetchError::TableNotFound(\"Test\".to_owned()).into()),\n    )\n    .await;\n    g.run(\"ROLLBACK;\").await;\n    g.test(\"SELECT * FROM Test;\", Ok(select!(id I64; 3))).await;\n\n    // DROP \u0026\u0026 COMMIT\n    g.run(\"BEGIN;\").await;\n    g.run(\"DROP TABLE Test;\").await;\n    g.run(\"COMMIT;\").await;\n    g.test(\n        \"SELECT * FROM Test;\",\n        Err(FetchError::TableNotFound(\"Test\".to_owned()).into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","transaction.rs"],"content":"mod alter_table;\nmod ast_builder;\nmod basic;\nmod dictionary;\nmod index;\nmod table;\n\npub use {\n    alter_table::*, ast_builder::*, basic::basic, dictionary::dictionary, index::*, table::*,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","type_match.rs"],"content":"use {crate::*, gluesql_core::ast::DataType};\n\ntest_case!(type_match, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE TypeMatch (uuid_value UUID, float_value FLOAT, int_value INT, bool_value BOOLEAN)\").await;\n    g.run(\"INSERT INTO TypeMatch values(GENERATE_UUID(), 1.0, 1, true)\")\n        .await;\n    g.type_match(\n        \"SELECT * FROM TypeMatch\",\n        \u0026[\n            DataType::Uuid,\n            DataType::Float,\n            DataType::Int,\n            DataType::Boolean,\n        ],\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","unary_operator.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{\n        error::{LiteralError, ValueError},\n        prelude::{Payload, Value::*},\n    },\n};\n\ntest_case!(unary_operator, {\n    let g = get_tester!();\n\n    let test_cases = [\n        (\n            \"CREATE TABLE Test (v1 INT, v2 FLOAT, v3 TEXT, v4 INT, v5 INT, v6 INT8)\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"INSERT INTO Test VALUES (10, 10.5, 'hello', -5, 1000, 20)\",\n            Ok(Payload::Insert(1)),\n        ),\n        (\n            \"SELECT -v1 as v1, -v2 as v2, v3, -v4 as v4, -v6 as v6 FROM Test\",\n            Ok(select_with_null!(\n                v1      |   v2          |   v3                      |   v4      |  v6;\n                I64(-10)    F64(-10.5)      Str(\"hello\".to_owned())     I64(5)     I8(-20)\n            )),\n        ),\n        (\n            \"SELECT -(-10) as v1, -(-10) as v2 FROM Test\",\n            Ok(select!(\n                v1  |   v2\n                I64 |   I64;\n                10      10\n            )),\n        ),\n        (\n            \"SELECT -v3 as v3 FROM Test\",\n            Err(ValueError::UnaryMinusOnNonNumeric.into()),\n        ),\n        (\n            \"SELECT -'errrr' as v1 FROM Test\",\n            Err(LiteralError::UnaryOperationOnNonNumeric.into()),\n        ),\n        (\n            \"SELECT +10 as v1, +(+10) as v2 FROM Test\",\n            Ok(select!(\n                v1  |   v2\n                I64 |   I64;\n                10      10\n            )),\n        ),\n        (\n            \"SELECT +v3 as v3 FROM Test\",\n            Err(ValueError::UnaryPlusOnNonNumeric.into()),\n        ),\n        (\n            \"SELECT +'errrr' as v1 FROM Test\",\n            Err(LiteralError::UnaryOperationOnNonNumeric.into()),\n        ),\n        (\n            \"SELECT v1! as v1 FROM Test\",\n            Ok(select!(\n                v1\n                I128;\n                3628800\n            )),\n        ),\n        (\n            \"SELECT 4! as v1 FROM Test\",\n            Ok(select!(\n                v1\n                I128;\n                24\n            )),\n        ),\n        (\n            \"SELECT v2! as v1 FROM Test\",\n            Err(ValueError::FactorialOnNonInteger.into()),\n        ),\n        (\n            \"SELECT v3! as v1 FROM Test\",\n            Err(ValueError::FactorialOnNonNumeric.into()),\n        ),\n        (\n            \"SELECT v4! as v4 FROM Test\",\n            Err(ValueError::FactorialOnNegativeNumeric.into()),\n        ),\n        (\n            \"SELECT v5! as v5 FROM Test\",\n            Err(ValueError::FactorialOverflow.into()),\n        ),\n        (\n            \"SELECT (-v6)! as v6 FROM Test\",\n            Err(ValueError::FactorialOnNegativeNumeric.into()),\n        ),\n        (\n            \"SELECT (v6 * 2)! as v6 FROM Test\",\n            Err(ValueError::FactorialOverflow.into()),\n        ),\n        (\n            \"SELECT (-5)! as v4 FROM Test\",\n            Err(ValueError::FactorialOnNegativeNumeric.into()),\n        ),\n        (\n            \"SELECT (5.5)! as v4 FROM Test\",\n            Err(ValueError::FactorialOnNonInteger.into()),\n        ),\n        (\n            \"SELECT 'errrr'! as v1 FROM Test\",\n            Err(ValueError::FactorialOnNonNumeric.into()),\n        ),\n        (\n            \"SELECT 1000! as v4 FROM Test\",\n            Err(ValueError::FactorialOverflow.into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n\n    g.named_test(\n        \"test bitwise-not operator with UINT8 type\",\n        \"SELECT ~(CAST(1 AS UINT8)) as v1 FROM Test\",\n        Ok(select!(\n            v1\n            U8;\n            254\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with UINT16 type\",\n        \"SELECT ~(CAST(1 AS UINT16)) as v1 FROM Test\",\n        Ok(select!(\n            v1\n            U16;\n            65534\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with UINT32 type\",\n        \"SELECT ~(CAST(1 AS UINT32)) as v1 FROM Test\",\n        Ok(select!(\n            v1\n            U32;\n            4294967294\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with UINT64 type\",\n        \"SELECT ~(CAST(1 AS UINT64)) as v1 FROM Test\",\n        Ok(select!(\n            v1\n            U64;\n            18446744073709551614\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with UINT128 type\",\n        \"SELECT ~(CAST(1 AS UINT128)) as v1 FROM Test\",\n        Ok(select!(\n            v1\n            U128;\n            340282366920938463463374607431768211454\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with INT8 type\",\n        \"SELECT ~(CAST(1 AS INT8)) as v1 FROM Test\",\n        Ok(select!(\n            v1\n            I8;\n            -2\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with INT16 type\",\n        \"SELECT ~(CAST(1 AS INT16)) as v1 FROM Test\",\n        Ok(select!(\n            v1\n            I16;\n            -2\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with INT32 type\",\n        \"SELECT ~(CAST(1 AS INT32)) as v1 FROM Test\",\n        Ok(select!(\n            v1\n            I32;\n            -2\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with INT64 type\",\n        \"SELECT ~1 as v1 FROM Test\",\n        Ok(select!(\n            v1\n            I64;\n            -2\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with INT128 type\",\n        \"SELECT ~(CAST(1 AS INT128)) as v1 FROM Test\",\n        Ok(select!(\n            v1\n            I128;\n            -2\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with Null\",\n        \"SELECT ~Null as v1 FROM Test\",\n        Ok(select_with_null!(\n            v1;\n            Null\n        )),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with FLOAT64 type\",\n        \"SELECT ~(5.5) as v4 FROM Test\",\n        Err(ValueError::UnaryBitwiseNotOnNonInteger.into()),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with FLOAT32 type\",\n        \"SELECT ~(CAST(5.5 AS FLOAT32)) as v4 FROM Test\",\n        Err(ValueError::UnaryBitwiseNotOnNonInteger.into()),\n    )\n    .await;\n    g.named_test(\n        \"test bitwise-not operator with string type\",\n        \"SELECT ~'error' as v1 FROM Test\",\n        Err(ValueError::UnaryBitwiseNotOnNonNumeric.into()),\n    )\n    .await;\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","update.rs"],"content":"use {\n    crate::*,\n    Value::*,\n    gluesql_core::{\n        error::{ExecuteError, TranslateError, UpdateError},\n        prelude::*,\n    },\n};\n\ntest_case!(update, {\n    let g = get_tester!();\n\n    g.run(\n        \"\n        CREATE TABLE TableA (\n            id INTEGER,\n            num INTEGER,\n            num2 INTEGER,\n            name TEXT\n        )\",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO TableA (id, num, num2, name)\n        VALUES\n            (1, 2, 4, 'Hello'),\n            (1, 9, 5, 'World'),\n            (3, 4, 7, 'Great'),\n            (4, 7, 10, 'Job');\n        \",\n    )\n    .await;\n\n    g.run(\n        \"\n        CREATE TABLE TableB (\n            id INTEGER,\n            num INTEGER,\n            rank INTEGER\n        )\",\n    )\n    .await;\n\n    g.run(\n        \"\n        INSERT INTO TableB (id, num, rank)\n        VALUES\n            (1, 2, 1),\n            (1, 9, 2),\n            (3, 4, 3),\n            (4, 7, 4);\n        \",\n    )\n    .await;\n\n    let test_cases = [\n        (\"UPDATE TableA SET id = 2\", Ok(Payload::Update(4))),\n        (\n            \"SELECT id, num FROM TableA\",\n            Ok(select!(id | num; I64 | I64; 2 2; 2 9; 2 4; 2 7)),\n        ),\n        (\n            \"UPDATE TableA SET id = 4 WHERE num = 9\",\n            Ok(Payload::Update(1)),\n        ),\n        (\n            \"UPDATE TableA SET name = SUBSTR('John', 1) WHERE num = 9\",\n            Ok(Payload::Update(1)),\n        ),\n        (\n            \"SELECT id, num FROM TableA\",\n            Ok(select!(id | num; I64 | I64; 2 2; 4 9; 2 4; 2 7)),\n        ),\n        (\n            \"UPDATE TableA SET num2 = (SELECT num FROM TableA WHERE num = 9 LIMIT 1) WHERE num = 9\",\n            Ok(Payload::Update(1)),\n        ),\n        (\n            \"SELECT id, num, num2 FROM TableA\",\n            Ok(select!(id | num | num2; I64 | I64 | I64; 2 2 4; 4 9 9; 2 4 7; 2 7 10)),\n        ),\n        (\n            \"UPDATE TableA SET num2 = (SELECT rank FROM TableB WHERE num = TableA.num) WHERE num = 7\",\n            Ok(Payload::Update(1)),\n        ),\n        (\n            \"SELECT id, num, num2 FROM TableA\",\n            Ok(select!(id | num | num2; I64 | I64 | I64; 2 2 4; 4 9 9; 2 4 7; 2 7 4)),\n        ),\n        (\n            \"UPDATE TableA SET num2 = (SELECT rank FROM TableB WHERE num = TableA.num) WHERE num = (SELECT MIN(num) FROM TableA)\",\n            Ok(Payload::Update(1)),\n        ),\n        (\n            \"SELECT id, num, num2 FROM TableA\",\n            Ok(select!(id | num | num2; I64 | I64 | I64; 2 2 1; 4 9 9; 2 4 7; 2 7 4)),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n\n    // Test Error cases for UPDATE\n    g.run(\"CREATE TABLE ErrTestTable (id INTEGER);\").await;\n    g.run(\"INSERT INTO ErrTestTable (id) VALUES (1),(9);\").await;\n\n    let error_cases = [\n        (\n            \"UPDATE TableA INNER JOIN ErrTestTable ON 1 = 1 SET id = 1\",\n            Err(TranslateError::JoinOnUpdateNotSupported.into()),\n        ),\n        (\n            \"UPDATE (SELECT * FROM ErrTestTable) SET id = 1\",\n            Err(\n                TranslateError::UnsupportedTableFactor(\"(SELECT * FROM ErrTestTable)\".to_owned())\n                    .into(),\n            ),\n        ),\n        (\n            \"UPDATE ErrTestTable SET ErrTestTable.id = 1 WHERE id = 1\",\n            Err(TranslateError::CompoundIdentOnUpdateNotSupported(\n                \"ErrTestTable.id = 1\".to_owned(),\n            )\n            .into()),\n        ),\n        (\n            \"UPDATE Nothing SET a = 1;\",\n            Err(ExecuteError::TableNotFound(\"Nothing\".to_owned()).into()),\n        ),\n        (\n            \"UPDATE TableA SET Foo = 1;\",\n            Err(UpdateError::ColumnNotFound(\"Foo\".to_owned()).into()),\n        ),\n    ];\n    for (sql, expected) in error_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","validate","types.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{ast::DataType, data::Literal, error::ValueError, prelude::Value},\n    std::borrow::Cow,\n};\n\ntest_case!(types, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE TableB (id BOOLEAN);\").await;\n    g.run(\"CREATE TABLE TableC (uid INTEGER NOT NULL, null_val INTEGER NULL);\")\n        .await;\n    g.run(\"INSERT INTO TableB VALUES (FALSE);\").await;\n    g.run(\"INSERT INTO TableC VALUES (1, NULL);\").await;\n\n    let test_cases = [\n        (\n            \"INSERT INTO TableB SELECT uid FROM TableC;\",\n            Err(ValueError::IncompatibleDataType {\n                data_type: DataType::Boolean,\n                value: Value::I64(1),\n            }\n            .into()),\n        ),\n        (\n            \"INSERT INTO TableC (uid) VALUES ('A')\",\n            Err(ValueError::IncompatibleLiteralForDataType {\n                data_type: DataType::Int,\n                literal: format!(\"{:?}\", Literal::Text(Cow::Owned(\"A\".to_owned()))),\n            }\n            .into()),\n        ),\n        (\n            \"INSERT INTO TableC VALUES (NULL, 30);\",\n            Err(ValueError::NullValueOnNotNullField.into()),\n        ),\n        (\n            \"INSERT INTO TableC SELECT null_val FROM TableC;\",\n            Err(ValueError::NullValueOnNotNullField.into()),\n        ),\n        (\n            \"UPDATE TableC SET uid = TRUE;\",\n            Err(ValueError::IncompatibleLiteralForDataType {\n                data_type: DataType::Int,\n                literal: format!(\"{:?}\", Literal::Boolean(true)),\n            }\n            .into()),\n        ),\n        (\n            \"UPDATE TableC SET uid = (SELECT id FROM TableB LIMIT 1) WHERE uid = 1\",\n            Err(ValueError::IncompatibleDataType {\n                data_type: DataType::Int,\n                value: Value::Bool(false),\n            }\n            .into()),\n        ),\n        (\n            \"UPDATE TableC SET uid = NULL;\",\n            Err(ValueError::NullValueOnNotNullField.into()),\n        ),\n        (\n            \"UPDATE TableC SET uid = (SELECT null_val FROM TableC);\",\n            Err(ValueError::NullValueOnNotNullField.into()),\n        ),\n    ];\n\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","validate","unique.rs"],"content":"use {\n    crate::*,\n    gluesql_core::{error::ValidateError, prelude::Value},\n};\n\ntest_case!(unique, {\n    let g = get_tester!();\n\n    let queries = [\n        r#\"\n        CREATE TABLE TestA (\n            id INTEGER UNIQUE,\n            num INT\n        )\n        \"#,\n        r#\"\n        CREATE TABLE TestB (\n            id INTEGER UNIQUE,\n            num INT UNIQUE\n        )\n        \"#,\n        r#\"\n        CREATE TABLE TestC (\n            id INTEGER NULL UNIQUE,\n            num INT\n        )\n        \"#,\n        \"INSERT INTO TestA VALUES (1, 1)\",\n        \"INSERT INTO TestA VALUES (2, 1), (3, 1)\",\n        \"INSERT INTO TestB VALUES (1, 1)\",\n        \"INSERT INTO TestB VALUES (2, 2), (3, 3)\",\n        \"INSERT INTO TestC VALUES (NULL, 1)\",\n        \"INSERT INTO TestC VALUES (2, 2), (NULL, 3)\",\n        \"UPDATE TestC SET id = 1 WHERE num = 1\",\n        \"UPDATE TestC SET id = NULL WHERE num = 1\",\n    ];\n\n    for query in queries {\n        g.run(query).await;\n    }\n\n    let error_cases = [\n        (\n            \"INSERT INTO TestA VALUES (2, 2)\",\n            ValidateError::DuplicateEntryOnUniqueField(Value::I64(2), \"id\".to_owned()).into(),\n        ),\n        (\n            \"INSERT INTO TestA VALUES (4, 4), (4, 5)\",\n            ValidateError::DuplicateEntryOnUniqueField(Value::I64(4), \"id\".to_owned()).into(),\n        ),\n        (\n            \"UPDATE TestA SET id = 2 WHERE id = 1\",\n            ValidateError::DuplicateEntryOnUniqueField(Value::I64(2), \"id\".to_owned()).into(),\n        ),\n        (\n            \"INSERT INTO TestB VALUES (1, 3)\",\n            ValidateError::DuplicateEntryOnUniqueField(Value::I64(1), \"id\".to_owned()).into(),\n        ),\n        (\n            \"INSERT INTO TestB VALUES (4, 2)\",\n            ValidateError::DuplicateEntryOnUniqueField(Value::I64(2), \"num\".to_owned()).into(),\n        ),\n        (\n            \"INSERT INTO TestB VALUES (5, 5), (6, 5)\",\n            ValidateError::DuplicateEntryOnUniqueField(Value::I64(5), \"num\".to_owned()).into(),\n        ),\n        (\n            \"UPDATE TestB SET num = 2 WHERE id = 1\",\n            ValidateError::DuplicateEntryOnUniqueField(Value::I64(2), \"num\".to_owned()).into(),\n        ),\n        (\n            \"INSERT INTO TestC VALUES (2, 4)\",\n            ValidateError::DuplicateEntryOnUniqueField(Value::I64(2), \"id\".to_owned()).into(),\n        ),\n        (\n            \"INSERT INTO TestC VALUES (NULL, 5), (3, 5), (3, 6)\",\n            ValidateError::DuplicateEntryOnUniqueField(Value::I64(3), \"id\".to_owned()).into(),\n        ),\n        (\n            \"UPDATE TestC SET id = 1\",\n            ValidateError::DuplicateEntryOnUniqueField(Value::I64(1), \"id\".to_owned()).into(),\n        ),\n    ];\n\n    for (sql, error) in error_cases {\n        g.test(sql, Err(error)).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","validate.rs"],"content":"pub mod types;\npub mod unique;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","test-suite","src","values.rs"],"content":"use {\n    crate::*,\n    bigdecimal::BigDecimal,\n    gluesql_core::{\n        ast::DataType::{Boolean, Int, Text},\n        data::Literal,\n        error::{InsertError, SelectError, ValueError},\n        prelude::{DataType, Payload, Value::*},\n    },\n    std::borrow::Cow,\n};\n\ntest_case!(values, {\n    let g = get_tester!();\n\n    g.run(\"CREATE TABLE Items (id INTEGER NOT NULL, name TEXT, status TEXT DEFAULT 'ACTIVE' NOT NULL);\").await;\n\n    let test_cases = [\n        (\n            \"VALUES (1), (2), (3)\",\n            Ok(select!(\n                column1;\n                I64;\n                1;\n                2;\n                3\n            )),\n        ),\n        (\n            \"VALUES (1, 'a'), (2, 'b')\",\n            Ok(select!(\n                column1 | column2;\n                I64     | Str;\n                1         \"a\".to_owned();\n                2         \"b\".to_owned()\n            )),\n        ),\n        (\n            \"VALUES (1, 'a'), (2, 'b') ORDER BY column1 DESC\",\n            Ok(select!(\n                column1 | column2;\n                I64     | Str;\n                2         \"b\".to_owned();\n                1         \"a\".to_owned()\n            )),\n        ),\n        (\n            \"VALUES (1), (2) limit 1\",\n            Ok(select!(\n                column1;\n                I64;\n                1\n            )),\n        ),\n        (\n            \"VALUES (1), (2) offset 1\",\n            Ok(select!(\n                column1;\n                I64;\n                2\n            )),\n        ),\n        (\n            \"VALUES (1, NULL), (2, NULL)\",\n            Ok(select_with_null!(\n                column1 | column2;\n                I64(1)    Null;\n                I64(2)    Null\n            )),\n        ),\n        (\n            \"VALUES (1), (2, 'b')\",\n            Err(SelectError::NumberOfValuesDifferent.into()),\n        ),\n        (\n            \"VALUES (1, 'a'), (2)\",\n            Err(SelectError::NumberOfValuesDifferent.into()),\n        ),\n        (\n            \"VALUES (1, 'a'), (2, 3)\",\n            Err(ValueError::IncompatibleLiteralForDataType {\n                data_type: DataType::Text,\n                literal: format!(\"{:?}\", Literal::Number(Cow::Owned(BigDecimal::from(3)))),\n            }\n            .into()),\n        ),\n        (\n            \"VALUES (1, 'a'), ('b', 'c')\",\n            Err(ValueError::IncompatibleLiteralForDataType {\n                data_type: DataType::Int,\n                literal: format!(\"{:?}\", Literal::Text(Cow::Owned(\"b\".to_owned()))),\n            }\n            .into()),\n        ),\n        (\n            \"VALUES (1, NULL), (2, 'a'), (3, 4)\",\n            Err(ValueError::IncompatibleLiteralForDataType {\n                data_type: DataType::Text,\n                literal: format!(\"{:?}\", Literal::Number(Cow::Owned(BigDecimal::from(4)))),\n            }\n            .into()),\n        ),\n        (\n            \"CREATE TABLE TableFromValues AS VALUES (1, 'a', True, Null, Null), (2, 'b', False, 3, Null)\",\n            Ok(Payload::Create),\n        ),\n        (\n            \"SELECT * FROM TableFromValues\",\n            Ok(select_with_null!(\n                column1 | column2         | column3    | column4 | column5;\n                I64(1)    Str(\"a\".into())   Bool(true)   Null      Null   ;\n                I64(2)    Str(\"b\".into())   Bool(false)  I64(3)    Null\n            )),\n        ),\n        (\n            \"SHOW COLUMNS FROM TableFromValues\",\n            Ok(Payload::ShowColumns(vec![\n                (\"column1\".into(), Int),\n                (\"column2\".into(), Text),\n                (\"column3\".into(), Boolean),\n                (\"column4\".into(), Int),\n                (\"column5\".into(), Text),\n            ])),\n        ),\n        (\n            \"SELECT * FROM (VALUES (1, 'a'), (2, 'b')) AS Derived\",\n            Ok(select!(\n                column1 | column2;\n                I64     | Str;\n                1         \"a\".to_owned();\n                2         \"b\".to_owned()\n            )),\n        ),\n        (\n            \"SELECT column1 AS id, column2 AS name FROM (VALUES (1, 'a'), (2, 'b')) AS Derived\",\n            Ok(select!(\n                id      | name;\n                I64     | Str;\n                1         \"a\".to_owned();\n                2         \"b\".to_owned()\n            )),\n        ),\n        (\"INSERT INTO Items (id) VALUES (1);\", Ok(Payload::Insert(1))),\n        (\n            \"INSERT INTO Items (id2) VALUES (1);\",\n            Err(InsertError::WrongColumnName(\"id2\".to_owned()).into()),\n        ),\n        (\n            \"INSERT INTO Items (name) VALUES ('glue');\",\n            Err(InsertError::LackOfRequiredColumn(\"id\".to_owned()).into()),\n        ),\n        (\n            \"INSERT INTO Items (id) VALUES (3, 'sql')\",\n            Err(InsertError::ColumnAndValuesNotMatched.into()),\n        ),\n        (\n            \"INSERT INTO Items VALUES (100, 'a', 'b', 1);\",\n            Err(InsertError::TooManyValues.into()),\n        ),\n        (\n            \"INSERT INTO Nothing VALUES (1);\",\n            Err(InsertError::TableNotFound(\"Nothing\".to_owned()).into()),\n        ),\n    ];\n    for (sql, expected) in test_cases {\n        g.test(sql, expected).await;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","utils","src","hashmap.rs"],"content":"use std::{collections::HashMap, hash::Hash};\n\npub trait HashMapExt\u003cK, V, I\u003e {\n    fn concat(self, entries: I) -\u003e Self;\n}\n\nimpl\u003cK, V, I\u003e HashMapExt\u003cK, V, I\u003e for HashMap\u003cK, V\u003e\nwhere\n    K: Hash + Eq,\n    I: Iterator\u003cItem = (K, V)\u003e,\n{\n    fn concat(mut self, entries: I) -\u003e Self {\n        for (key, value) in entries {\n            self.insert(key, value);\n        }\n\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {super::HashMapExt, std::collections::HashMap};\n\n    #[test]\n    fn concat() {\n        let values: HashMap\u003c\u0026str, i64\u003e = [(\"a\", 10), (\"b\", 20)].into();\n        let new_items = [(\"c\", 30), (\"d\", 40), (\"e\", 50)];\n\n        let actual = values.concat(new_items.into_iter());\n        let expected = [(\"a\", 10), (\"b\", 20), (\"c\", 30), (\"d\", 40), (\"e\", 50)].into();\n\n        assert_eq!(actual, expected);\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","utils","src","indexmap.rs"],"content":"use {\n    indexmap::map::{IntoIter, Keys},\n    std::{cmp::Eq, hash::Hash},\n};\n\n/// HashMap which provides\n/// 1. Immutable APIs\n/// 2. Preserving insertion order\npub struct IndexMap\u003cK, V\u003e(indexmap::IndexMap\u003cK, V\u003e);\n\nimpl\u003cK: Hash + Eq, V\u003e IndexMap\u003cK, V\u003e {\n    pub fn new() -\u003e Self {\n        Self(indexmap::IndexMap::new())\n    }\n\n    pub fn insert(mut self, key: K, value: V) -\u003e (Self, Option\u003cV\u003e) {\n        let existing = self.0.insert(key, value);\n\n        (self, existing)\n    }\n\n    pub fn get(\u0026self, key: \u0026K) -\u003e Option\u003c\u0026V\u003e {\n        self.0.get(key)\n    }\n\n    pub fn keys(\u0026self) -\u003e Keys\u003cK, V\u003e {\n        self.0.keys()\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.0.len()\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.0.is_empty()\n    }\n}\n\nimpl\u003cK: Hash + Eq, V\u003e Default for IndexMap\u003cK, V\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cK: Hash + Eq, V\u003e IntoIterator for IndexMap\u003cK, V\u003e {\n    type Item = (K, V);\n    type IntoIter = IntoIter\u003cK, V\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","utils","src","lib.rs"],"content":"#![deny(clippy::str_to_string)]\n\nmod hashmap;\nmod indexmap;\nmod or_stream;\nmod vector;\n\npub use {self::indexmap::IndexMap, hashmap::HashMapExt, or_stream::OrStream, vector::Vector};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","utils","src","or_stream.rs"],"content":"use {\n    core::{cmp::max, pin::Pin},\n    futures::{\n        ready,\n        stream::Stream,\n        task::{Context, Poll},\n    },\n    pin_project::pin_project,\n};\n\n#[derive(Debug)]\nenum State {\n    Initial,\n    St1,\n    St2,\n}\n\n#[pin_project]\n#[derive(Debug)]\n#[must_use = \"streams do nothing unless polled\"]\npub struct OrStream\u003cSt1, St2\u003e {\n    #[pin]\n    stream1: St1,\n    #[pin]\n    stream2: St2,\n    state: State,\n}\n\nuse State::{Initial, St1, St2};\n\nimpl\u003cSt1, St2\u003e OrStream\u003cSt1, St2\u003e\nwhere\n    St1: Stream,\n    St2: Stream\u003cItem = St1::Item\u003e,\n{\n    pub fn new(stream1: St1, stream2: St2) -\u003e Self {\n        Self {\n            stream1,\n            stream2,\n            state: Initial,\n        }\n    }\n}\n\nimpl\u003cSt1, St2\u003e Stream for OrStream\u003cSt1, St2\u003e\nwhere\n    St1: Stream,\n    St2: Stream\u003cItem = St1::Item\u003e,\n{\n    type Item = St1::Item;\n\n    fn poll_next(self: Pin\u003c\u0026mut Self\u003e, cx: \u0026mut Context\u003c'_\u003e) -\u003e Poll\u003cOption\u003cSelf::Item\u003e\u003e {\n        let this = self.project();\n\n        match this.state {\n            Initial =\u003e match ready!(this.stream1.poll_next(cx)) {\n                item @ Some(_) =\u003e {\n                    *this.state = St1;\n\n                    Poll::Ready(item)\n                }\n                None =\u003e {\n                    *this.state = St2;\n\n                    this.stream2.poll_next(cx)\n                }\n            },\n            St1 =\u003e this.stream1.poll_next(cx),\n            St2 =\u003e this.stream2.poll_next(cx),\n        }\n    }\n\n    fn size_hint(\u0026self) -\u003e (usize, Option\u003cusize\u003e) {\n        match self.state {\n            Initial =\u003e {\n                let (s1_low, s1_high) = self.stream1.size_hint();\n                let (s2_low, s2_high) = self.stream2.size_hint();\n\n                if s1_high == Some(0) {\n                    (s2_low, s2_high)\n                } else if s1_low \u003e 0 {\n                    (s1_low, s1_high)\n                } else {\n                    let low = if s2_low \u003e 0 { 1 } else { 0 };\n                    let high = match (s1_high, s2_high) {\n                        (Some(h1), Some(h2)) =\u003e Some(max(h1, h2)),\n                        _ =\u003e None,\n                    };\n                    (low, high)\n                }\n            }\n            St1 =\u003e self.stream1.size_hint(),\n            St2 =\u003e self.stream2.size_hint(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use {\n        super::OrStream,\n        futures::{\n            Stream,\n            executor::block_on,\n            pin_mut,\n            stream::{StreamExt, empty, iter, once, poll_fn},\n        },\n        std::task::Poll,\n    };\n\n    #[test]\n    fn basic() {\n        block_on(async move {\n            let s1 = once(async { 1 });\n            let s2 = once(async { 3 });\n            let v = OrStream::new(s1, s2).collect::\u003cVec\u003ci32\u003e\u003e().await;\n            assert_eq!(vec![1], v);\n\n            let s1 = empty();\n            let s2 = once(async { 3 });\n            let v = OrStream::new(s1, s2).collect::\u003cVec\u003ci32\u003e\u003e().await;\n            assert_eq!(vec![3], v);\n\n            let s1 = once(async { 3 });\n            let s2 = empty();\n            let v = OrStream::new(s1, s2).collect::\u003cVec\u003ci32\u003e\u003e().await;\n            assert_eq!(vec![3], v);\n        });\n    }\n\n    #[test]\n    fn size_hint_initial_branches() {\n        // stream1 high is Some(0)\n        let s1 = empty();\n        let s2 = once(async { 1 });\n        let or = OrStream::new(s1, s2);\n        assert_eq!(or.size_hint(), (1, Some(1)));\n\n        // stream1 low \u003e 0\n        let s1 = once(async { 1 });\n        let s2 = empty();\n        let or = OrStream::new(s1, s2);\n        assert_eq!(or.size_hint(), (1, Some(1)));\n\n        // else branch with s2_low \u003e 0\n        let s1 = poll_fn(|_| Poll::\u003cOption\u003ci32\u003e\u003e::Pending);\n        let s2 = once(async { 1 });\n        let or = OrStream::new(s1, s2);\n        assert_eq!(or.size_hint(), (1, None));\n\n        // else branch with s2_low == 0\n        let s1 = poll_fn(|_| Poll::\u003cOption\u003ci32\u003e\u003e::Pending);\n        let s2 = empty();\n        let or = OrStream::new(s1, s2);\n        assert_eq!(or.size_hint(), (0, None));\n\n        // both highs defined triggers max branch\n        let s1 = iter([1, 2, 3]).filter(|_| async { true });\n        let s2 = iter([1, 2]);\n        let or = OrStream::new(s1, s2);\n        assert_eq!(or.size_hint(), (1, Some(3)));\n    }\n\n    #[test]\n    fn size_hint_state_changes() {\n        block_on(async {\n            // move to St1 after first item from stream1\n            let or = OrStream::new(once(async { 1 }), once(async { 2 }));\n            pin_mut!(or);\n            assert_eq!(or.next().await, Some(1));\n            assert_eq!(or.size_hint(), (0, Some(0)));\n\n            // move to St2 when stream1 is empty\n            let or = OrStream::new(empty(), once(async { 2 }));\n            pin_mut!(or);\n            assert_eq!(or.next().await, Some(2));\n            assert_eq!(or.size_hint(), (0, Some(0)));\n        });\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","Users","hvunrnin","4-2","gluesql_oss","gluesql","utils","src","vector.rs"],"content":"use std::{convert::From, vec::IntoIter};\n\npub struct Vector\u003cT\u003e(Vec\u003cT\u003e);\n\nimpl\u003cT\u003e Vector\u003cT\u003e {\n    pub fn new() -\u003e Self {\n        Self(vec![])\n    }\n\n    pub fn push(mut self, value: T) -\u003e Self {\n        self.0.push(value);\n\n        self\n    }\n\n    pub fn update(mut self, i: usize, value: T) -\u003e Self {\n        self.0[i] = value;\n\n        self\n    }\n\n    pub fn remove(mut self, i: usize) -\u003e Self {\n        self.0.remove(i);\n\n        self\n    }\n\n    pub fn reverse(mut self) -\u003e Self {\n        self.0.reverse();\n\n        self\n    }\n\n    pub fn sort(mut self) -\u003e Self\n    where\n        T: std::cmp::Ord,\n    {\n        self.0.sort();\n\n        self\n    }\n\n    pub fn sort_by\u003cF\u003e(mut self, compare: F) -\u003e Self\n    where\n        F: FnMut(\u0026T, \u0026T) -\u003e std::cmp::Ordering,\n    {\n        self.0.sort_by(compare);\n\n        self\n    }\n\n    pub fn pop(mut self) -\u003e (Self, Option\u003cT\u003e) {\n        let v = self.0.pop();\n\n        (self, v)\n    }\n\n    pub fn get(\u0026self, i: usize) -\u003e Option\u003c\u0026T\u003e {\n        self.0.get(i)\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.0.is_empty()\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.0.len()\n    }\n}\n\nimpl\u003cT\u003e Default for Vector\u003cT\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cT\u003e IntoIterator for Vector\u003cT\u003e {\n    type Item = T;\n    type IntoIter = IntoIter\u003cSelf::Item\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\nimpl\u003cT\u003e FromIterator\u003cT\u003e for Vector\u003cT\u003e {\n    fn from_iter\u003cI\u003e(iter: I) -\u003e Self\n    where\n        I: IntoIterator\u003cItem = T\u003e,\n    {\n        Self(iter.into_iter().collect())\n    }\n}\n\nimpl\u003cT\u003e From\u003cVec\u003cT\u003e\u003e for Vector\u003cT\u003e {\n    fn from(vector: Vec\u003cT\u003e) -\u003e Self {\n        Self(vector)\n    }\n}\n\nimpl\u003cT\u003e From\u003cVector\u003cT\u003e\u003e for Vec\u003cT\u003e {\n    fn from(vector: Vector\u003cT\u003e) -\u003e Self {\n        vector.0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Vector;\n\n    #[test]\n    fn test_len() {\n        let mut vector = Vector::new();\n        assert_eq!(vector.len(), 0);\n\n        vector = vector.push(1);\n        assert_eq!(vector.len(), 1);\n\n        vector = vector.push(2);\n        assert_eq!(vector.len(), 2);\n    }\n\n    #[test]\n    fn test_is_empty() {\n        let mut vector = Vector::new();\n        assert!(vector.is_empty());\n\n        vector = vector.push(1);\n        assert!(!vector.is_empty());\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":39}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>