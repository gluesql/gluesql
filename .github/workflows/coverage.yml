name: Coverage

on:
  push:
    branches: [main, release-*]
    paths-ignore:
      - "docs/**"
  pull_request:
    branches: [main]
    paths-ignore:
      - "docs/**"

env:
  CARGO_TERM_COLOR: always

jobs:
  coverage:
    runs-on: ubuntu-latest
    env:
      COMMIT_SHA: ${{ github.event.pull_request.head.sha || github.sha }}
    services:
      redis:
        image: redis
        ports:
          - 6379:6379
      mongo:
        image: mongo
        ports:
          - 27017:27017
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Free disk space (pre-build)
        continue-on-error: true
        run: |
          echo "Freeing disk space..."
          echo "Disk before:"
          df -h
          sudo rm -rf /usr/local/lib/android || true
          sudo rm -rf /usr/share/dotnet || true
          sudo rm -rf /opt/ghc || true
          if command -v docker >/dev/null 2>&1; then
            timeout 60 docker image prune -af || true
          fi
          echo "Disk after:"
          df -h
      - name: Configure git user
        run: |
          git config --global user.email "ci@example.com"
          git config --global user.name "CI"
      - run: rustup component add llvm-tools-preview
      - name: Install grcov (prebuilt)
        uses: taiki-e/install-action@v2
        with:
          tool: grcov@0.10.5
      - name: Prepare coverage dirs
        run: |
          mkdir -p coverage/profraw
      - name: test
        env:
          RUSTFLAGS: -Cinstrument-coverage
          LLVM_PROFILE_FILE: coverage/profraw/%p-%m.profraw
          GIT_REMOTE: https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}
        run: GIT_REMOTE=$GIT_REMOTE cargo test --all-features --verbose
      - name: Merge coverage profiles and free space
        run: |
          echo "Merging coverage profiles..."
          LLVM_BIN=$(rustc --print sysroot)/lib/rustlib/$(rustc -vV | sed -n 's|host: ||p')/bin
          "$LLVM_BIN/llvm-profdata" merge -sparse coverage/profraw/*.profraw -o coverage/merged.profdata
          echo "Removing incremental build artifacts to free space..."
          rm -rf target/debug/incremental || true
          echo "Removing Cargo registry/git caches to free space..."
          rm -rf ~/.cargo/registry ~/.cargo/git || true
      - name: Run grcov
        run: |
          grcov . \
            --binary-path ./target/debug/ \
            -s . \
            -t lcov \
            --branch \
            --ignore-not-existing \
            --ignore "/*" \
            --ignore "pkg/rust/examples/*.rs" \
            --ignore "cli/src/{cli,helper,lib,main}.rs" \
            --excl-line "(#\\[derive\\()|(^\s*.await[;,]?$)|(^test_case\!\([\d\w]+,)" \
            -o ./coverage/lcov.info
      - name: Build patch coverage summary
        if: github.event_name == 'pull_request'
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');

          const baseSha = process.env.BASE_SHA;
          const headSha = process.env.HEAD_SHA;
          const repoRoot = process.cwd();
          const lcovPath = path.join(repoRoot, 'coverage', 'lcov.info');

          const normalizePath = (filePath) => {
            const normalized = filePath.replaceAll('\\', '/').replace(/^\.\/+/, '');
            const rootPrefix = `${repoRoot.replaceAll('\\', '/')}/`;

            if (normalized.startsWith(rootPrefix)) {
              return normalized.slice(rootPrefix.length);
            }

            return normalized;
          };

          const parseLcov = () => {
            const coverageByFile = new Map();
            const lines = fs.readFileSync(lcovPath, 'utf8').split('\n');
            let currentFile = null;

            for (const line of lines) {
              if (line.startsWith('SF:')) {
                currentFile = normalizePath(line.slice(3).trim());
                coverageByFile.set(currentFile, new Map());
                continue;
              }

              if (line === 'end_of_record') {
                currentFile = null;
                continue;
              }

              if (!currentFile || !line.startsWith('DA:')) {
                continue;
              }

              const payload = line.slice(3);
              const parts = payload.split(',');
              const lineNo = Number(parts[0]);
              const hit = Number(parts[1]);

              if (Number.isNaN(lineNo) || Number.isNaN(hit)) {
                continue;
              }

              coverageByFile.get(currentFile).set(lineNo, hit);
            }

            return coverageByFile;
          };

          const parseChangedAddedLines = () => {
            const diffOutput = execSync(
              `git diff --unified=0 --no-color --find-renames "${baseSha}" "${headSha}"`,
              { encoding: 'utf8' },
            );
            const changedByFile = new Map();
            let currentFile = null;

            for (const line of diffOutput.split('\n')) {
              if (line.startsWith('+++ ')) {
                const rawPath = line.slice(4).trim();
                if (rawPath === '/dev/null') {
                  currentFile = null;
                  continue;
                }

                currentFile = normalizePath(rawPath.replace(/^b\//, ''));
                if (!changedByFile.has(currentFile)) {
                  changedByFile.set(currentFile, new Set());
                }
                continue;
              }

              if (!currentFile || !line.startsWith('@@ ')) {
                continue;
              }

              const match = line.match(/\+(\d+)(?:,(\d+))?/);
              if (!match) {
                continue;
              }

              const start = Number(match[1]);
              const count = Number(match[2] || '1');

              if (Number.isNaN(start) || Number.isNaN(count) || count <= 0) {
                continue;
              }

              const added = changedByFile.get(currentFile);
              for (let lineNo = start; lineNo < start + count; lineNo += 1) {
                added.add(lineNo);
              }
            }

            return changedByFile;
          };

          const coverageByFile = parseLcov();
          const changedByFile = parseChangedAddedLines();

          let totalExecutableLines = 0;
          let totalCoveredLines = 0;
          for (const lines of coverageByFile.values()) {
            totalExecutableLines += lines.size;
            for (const hit of lines.values()) {
              if (hit > 0) {
                totalCoveredLines += 1;
              }
            }
          }

          let addedLines = 0;
          let addedExecutableLines = 0;
          let coveredAddedExecutableLines = 0;
          let missedAddedExecutableLines = 0;
          const perFileStats = [];

          const changedLinesJson = {};
          for (const [file, addedSet] of changedByFile.entries()) {
            const sorted = Array.from(addedSet).sort((a, b) => a - b);
            changedLinesJson[file] = sorted;
            addedLines += sorted.length;
            let fileAddedExecutableLines = 0;
            let fileCoveredAddedExecutableLines = 0;
            let fileMissedAddedExecutableLines = 0;

            const coverageLines = coverageByFile.get(file);
            if (!coverageLines) {
              perFileStats.push({
                file,
                added_lines: sorted.length,
                added_executable_lines: fileAddedExecutableLines,
                covered_added_executable_lines: fileCoveredAddedExecutableLines,
                missed_added_executable_lines: fileMissedAddedExecutableLines,
                patch_coverage_percent: null,
              });
              continue;
            }

            for (const lineNo of sorted) {
              const hit = coverageLines.get(lineNo);
              if (typeof hit !== 'number') {
                continue;
              }

              addedExecutableLines += 1;
              fileAddedExecutableLines += 1;
              if (hit > 0) {
                coveredAddedExecutableLines += 1;
                fileCoveredAddedExecutableLines += 1;
              } else {
                missedAddedExecutableLines += 1;
                fileMissedAddedExecutableLines += 1;
              }
            }

            perFileStats.push({
              file,
              added_lines: sorted.length,
              added_executable_lines: fileAddedExecutableLines,
              covered_added_executable_lines: fileCoveredAddedExecutableLines,
              missed_added_executable_lines: fileMissedAddedExecutableLines,
              patch_coverage_percent:
                fileAddedExecutableLines > 0
                  ? (fileCoveredAddedExecutableLines / fileAddedExecutableLines) * 100
                  : null,
            });
          }

          const topChangedFiles = perFileStats
            .slice()
            .sort((left, right) => {
              if (right.added_lines !== left.added_lines) {
                return right.added_lines - left.added_lines;
              }

              if (right.added_executable_lines !== left.added_executable_lines) {
                return right.added_executable_lines - left.added_executable_lines;
              }

              return left.file.localeCompare(right.file);
            })
            .slice(0, 10);

          const summary = {
            base_sha: baseSha,
            head_sha: headSha,
            total_files_with_changes: Object.keys(changedLinesJson).length,
            added_lines: addedLines,
            added_executable_lines: addedExecutableLines,
            covered_added_executable_lines: coveredAddedExecutableLines,
            missed_added_executable_lines: missedAddedExecutableLines,
            total_executable_lines: totalExecutableLines,
            covered_executable_lines: totalCoveredLines,
            overall_coverage_percent:
              totalExecutableLines > 0 ? (totalCoveredLines / totalExecutableLines) * 100 : null,
            patch_coverage_percent:
              addedExecutableLines > 0
                ? (coveredAddedExecutableLines / addedExecutableLines) * 100
                : null,
            top_changed_files: topChangedFiles,
          };

          fs.writeFileSync(
            path.join(repoRoot, 'coverage', 'changed-lines.json'),
            JSON.stringify(changedLinesJson),
          );
          fs.writeFileSync(
            path.join(repoRoot, 'coverage', 'patch-summary.json'),
            JSON.stringify(summary, null, 2),
          );
          NODE
      - name: Cleanup raw and merged profiles
        if: always()
        run: |
          rm -f coverage/profraw/*.profraw || true
          rm -f coverage/merged.profdata || true
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage/lcov.info
          token: ${{ secrets.CODECOV_TOKEN }}
          flags: rust
          fail_ci_if_error: true
      - name: Coveralls
        continue-on-error: true
        uses: coverallsapp/github-action@master
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Compress coverage report
        run: |
          xz -T0 -9e -c coverage/lcov.info > coverage/lcov.info.xz
          rm -f coverage/lcov.info
      - name: Compress changed lines
        if: github.event_name == 'pull_request'
        run: |
          xz -T0 -9e -c coverage/changed-lines.json > coverage/changed-lines.json.xz
          rm -f coverage/changed-lines.json
      - name: Record PR number
        if: github.event_name == 'pull_request'
        run: echo "${{ github.event.pull_request.number }}" > coverage/pr-number
      - name: Set timestamp
        run: echo "TIMESTAMP=$(date -u +'%Y-%m-%dT%H%M%SZ')" >> $GITHUB_ENV
      - name: Create GitHub App token
        if: github.repository == 'gluesql/gluesql' && github.event_name == 'push' && github.ref == 'refs/heads/main'
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.COVERAGE_APP_ID }}
          installation-id: ${{ secrets.COVERAGE_APP_INSTALLATION_ID }}
          private-key: ${{ secrets.COVERAGE_APP_PRIVATE_KEY }}
          owner: gluesql
          repositories: gluesql, gluesql.github.io
      - name: Publish coverage to gluesql.github.io
        if: github.repository == 'gluesql/gluesql' && github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          git clone https://github.com/gluesql/gluesql.github.io.git
          cd gluesql.github.io
          git checkout gh-pages
          mkdir -p coverage/main
          cp ../coverage/lcov.info.xz coverage/main/${TIMESTAMP}.${COMMIT_SHA}.lcov.info.xz
          git add coverage/main/${TIMESTAMP}.${COMMIT_SHA}.lcov.info.xz
          git commit -m "Coverage: main@${COMMIT_SHA}"
          git push https://x-access-token:${{ steps.app-token.outputs.token }}@github.com/gluesql/gluesql.github.io.git
      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage
          path: coverage
